# 1 "src/core/Application.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 439 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "src/core/Application.cpp" 2
# 1 "src/core/Application.h" 1



# 1 "src/core/WindowManager.h" 1



# 1 "/opt/homebrew/include/GLFW/glfw3.h" 1
# 33 "/opt/homebrew/include/GLFW/glfw3.h"
extern "C" {
# 103 "/opt/homebrew/include/GLFW/glfw3.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__config" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__config" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__config_site" 1 3
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__config_site" 3
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wmacro-redefined"






#pragma clang diagnostic pop
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__config" 2 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__config" 3
# 646 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__config" 3
typedef __char16_t char16_t;
typedef __char32_t char32_t;
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 2 3



# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 1 3
# 78 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_header_macro.h" 1 3
# 79 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3



# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_ptrdiff_t.h" 1 3
# 18 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_ptrdiff_t.h" 3
typedef long int ptrdiff_t;
# 83 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3




# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_size_t.h" 1 3
# 18 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_size_t.h" 3
typedef long unsigned int size_t;
# 88 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3
# 97 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_wchar_t.h" 1 3
# 98 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3




# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_null.h" 1 3
# 103 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3




# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_nullptr_t.h" 1 3
# 108 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3
# 122 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_offsetof.h" 1 3
# 123 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 2 3
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 3



typedef __decltype(__nullptr) nullptr_t;
# 104 "/opt/homebrew/include/GLFW/glfw3.h" 2




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdint.h" 1 3
# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdint.h" 3
# 124 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdint.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stdint.h" 1 3
# 52 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stdint.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 1 3 4
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int8_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int8_t.h" 3 4
typedef signed char int8_t;
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int16_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int16_t.h" 3 4
typedef short int16_t;
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int32_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int32_t.h" 3 4
typedef int int32_t;
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int64_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_int64_t.h" 3 4
typedef long long int64_t;
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint8_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint8_t.h" 3 4
typedef unsigned char uint8_t;
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint16_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint16_t.h" 3 4
typedef unsigned short uint16_t;
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint32_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint32_t.h" 3 4
typedef unsigned int uint32_t;
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint64_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uint64_t.h" 3 4
typedef unsigned long long uint64_t;
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4


typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;



typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 1 3 4
# 782 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_symbol_aliasing.h" 1 3 4
# 783 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 2 3 4
# 848 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_posix_availability.h" 1 3 4
# 849 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 2 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_types.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_types.h" 1 3 4
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_types.h" 3 4
typedef signed char __int8_t;



typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_types.h" 3 4
typedef int __darwin_ct_rune_t;





typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t;




typedef long int __darwin_ptrdiff_t;
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_types.h" 3 4
typedef long unsigned int __darwin_size_t;







typedef __builtin_va_list __darwin_va_list;







typedef int __darwin_wchar_t;




typedef __darwin_wchar_t __darwin_rune_t;


typedef int __darwin_wint_t;




typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_types.h" 2 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 2 3 4
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 3 4
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;

typedef __darwin_ino64_t __darwin_ino_t;



typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_types.h" 1 3 4
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_types.h" 3 4
struct __darwin_pthread_handler_rec {
 void (*__routine)(void *);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};

struct _opaque_pthread_attr_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_cond_t {
 long __sig;
 char __opaque[40];
};

struct _opaque_pthread_condattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_mutex_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_mutexattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_once_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_rwlock_t {
 long __sig;
 char __opaque[192];
};

struct _opaque_pthread_rwlockattr_t {
 long __sig;
 char __opaque[16];
};

struct _opaque_pthread_t {
 long __sig;
 struct __darwin_pthread_handler_rec *__cleanup_stack;
 char __opaque[8176];
};

typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t *__darwin_pthread_t;
# 95 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 2 3 4
# 53 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_intptr_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_intptr_t.h" 3 4
typedef __darwin_intptr_t intptr_t;
# 54 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_uintptr_t.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_uintptr_t.h" 3 4
typedef unsigned long uintptr_t;
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_intmax_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_intmax_t.h" 3 4
typedef long int intmax_t;
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uintmax_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_uintmax_t.h" 3 4
typedef long unsigned int uintmax_t;
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 53 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stdint.h" 2 3
# 125 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdint.h" 2 3
# 109 "/opt/homebrew/include/GLFW/glfw3.h" 2
# 237 "/opt/homebrew/include/GLFW/glfw3.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 1 3
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks/OpenGL.framework/Headers/gltypes.h" 1 3








typedef uint32_t GLbitfield;
typedef uint8_t GLboolean;
typedef int8_t GLbyte;
typedef float GLclampf;
typedef uint32_t GLenum;
typedef float GLfloat;
typedef int32_t GLint;
typedef int16_t GLshort;
typedef int32_t GLsizei;
typedef uint8_t GLubyte;
typedef uint32_t GLuint;
typedef uint16_t GLushort;
typedef void GLvoid;


typedef char GLchar;


typedef char GLcharARB;
typedef void *GLhandleARB;

typedef double GLdouble;
typedef double GLclampd;

typedef int32_t GLfixed;


typedef uint16_t GLhalf;


typedef uint16_t GLhalfARB;


typedef int64_t GLint64;
typedef struct __GLsync *GLsync;
typedef uint64_t GLuint64;


typedef int64_t GLint64EXT;
typedef uint64_t GLuint64EXT;


typedef intptr_t GLintptr;
typedef intptr_t GLsizeiptr;


typedef intptr_t GLintptrARB;
typedef intptr_t GLsizeiptrARB;
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 2 3




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks/OpenGL.framework/Headers/OpenGLAvailability.h" 1 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/os/availability.h" 1 3 4
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/os/availability.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityInternal.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityInternal.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityVersions.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityInternal.h" 2 3 4
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/os/availability.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/AvailabilityInternalLegacy.h" 1 3 4
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/os/availability.h" 2 3 4
# 5 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks/OpenGL.framework/Headers/OpenGLAvailability.h" 2 3
# 47 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 2 3



extern "C" {
# 2381 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 3
extern void glAccum (GLenum op, GLfloat value) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glAlphaFunc (GLenum func, GLclampf ref) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLboolean glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glArrayElement (GLint i) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glBegin (GLenum mode) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glBindTexture (GLenum target, GLuint texture) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glBlendColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glBlendEquation (GLenum mode) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glBlendEquationSeparate (GLenum modeRGB, GLenum modeAlpha) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glBlendFunc (GLenum sfactor, GLenum dfactor) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glCallList (GLuint list) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glCallLists (GLsizei n, GLenum type, const GLvoid *lists) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glClear (GLbitfield mask) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glClearDepth (GLclampd depth) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glClearIndex (GLfloat c) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glClearStencil (GLint s) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glClipPlane (GLenum plane, const GLdouble *equation) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor3b (GLbyte red, GLbyte green, GLbyte blue) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor3bv (const GLbyte *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor3d (GLdouble red, GLdouble green, GLdouble blue) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor3dv (const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor3f (GLfloat red, GLfloat green, GLfloat blue) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor3fv (const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor3i (GLint red, GLint green, GLint blue) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor3iv (const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor3s (GLshort red, GLshort green, GLshort blue) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor3sv (const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor3ub (GLubyte red, GLubyte green, GLubyte blue) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor3ubv (const GLubyte *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor3ui (GLuint red, GLuint green, GLuint blue) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor3uiv (const GLuint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor3us (GLushort red, GLushort green, GLushort blue) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor3usv (const GLushort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor4bv (const GLbyte *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor4dv (const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor4fv (const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor4i (GLint red, GLint green, GLint blue, GLint alpha) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor4iv (const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor4sv (const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor4ubv (const GLubyte *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor4uiv (const GLuint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColor4usv (const GLushort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColorMaterial (GLenum face, GLenum mode) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColorSubTable (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColorTable (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColorTableParameterfv (GLenum target, GLenum pname, const GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glColorTableParameteriv (GLenum target, GLenum pname, const GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glConvolutionFilter1D (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glConvolutionFilter2D (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glConvolutionParameterf (GLenum target, GLenum pname, GLfloat params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glConvolutionParameterfv (GLenum target, GLenum pname, const GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glConvolutionParameteri (GLenum target, GLenum pname, GLint params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glConvolutionParameteriv (GLenum target, GLenum pname, const GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glCopyColorSubTable (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glCopyColorTable (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glCopyConvolutionFilter1D (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glCopyConvolutionFilter2D (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glCopyTexImage1D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glCopyTexImage2D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glCopyTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glCullFace (GLenum mode) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glDeleteLists (GLuint list, GLsizei range) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glDeleteTextures (GLsizei n, const GLuint *textures) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glDepthFunc (GLenum func) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glDepthMask (GLboolean flag) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glDepthRange (GLclampd zNear, GLclampd zFar) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glDisable (GLenum cap) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glDisableClientState (GLenum array) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glDrawArrays (GLenum mode, GLint first, GLsizei count) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glDrawBuffer (GLenum mode) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glDrawRangeElements (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEdgeFlag (GLboolean flag) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEdgeFlagPointer (GLsizei stride, const GLvoid *pointer) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEdgeFlagv (const GLboolean *flag) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEnable (GLenum cap) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEnableClientState (GLenum array) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEnd (void) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEndList (void) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEvalCoord1d (GLdouble u) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEvalCoord1dv (const GLdouble *u) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEvalCoord1f (GLfloat u) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEvalCoord1fv (const GLfloat *u) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEvalCoord2d (GLdouble u, GLdouble v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEvalCoord2dv (const GLdouble *u) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEvalCoord2f (GLfloat u, GLfloat v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEvalCoord2fv (const GLfloat *u) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEvalMesh1 (GLenum mode, GLint i1, GLint i2) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEvalPoint1 (GLint i) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEvalPoint2 (GLint i, GLint j) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glFinish (void) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glFlush (void) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glFogf (GLenum pname, GLfloat param) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glFogfv (GLenum pname, const GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glFogi (GLenum pname, GLint param) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glFogiv (GLenum pname, const GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glFrontFace (GLenum mode) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLuint glGenLists (GLsizei range) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGenTextures (GLsizei n, GLuint *textures) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetBooleanv (GLenum pname, GLboolean *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetClipPlane (GLenum plane, GLdouble *equation) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetColorTable (GLenum target, GLenum format, GLenum type, GLvoid *table) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetColorTableParameterfv (GLenum target, GLenum pname, GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetColorTableParameteriv (GLenum target, GLenum pname, GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetConvolutionFilter (GLenum target, GLenum format, GLenum type, GLvoid *image) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetConvolutionParameterfv (GLenum target, GLenum pname, GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetConvolutionParameteriv (GLenum target, GLenum pname, GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetDoublev (GLenum pname, GLdouble *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLenum glGetError (void) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetFloatv (GLenum pname, GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetHistogram (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetHistogramParameterfv (GLenum target, GLenum pname, GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetHistogramParameteriv (GLenum target, GLenum pname, GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetIntegerv (GLenum pname, GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetLightfv (GLenum light, GLenum pname, GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetLightiv (GLenum light, GLenum pname, GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetMapdv (GLenum target, GLenum query, GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetMapfv (GLenum target, GLenum query, GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetMapiv (GLenum target, GLenum query, GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetMaterialiv (GLenum face, GLenum pname, GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetMinmax (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetMinmaxParameterfv (GLenum target, GLenum pname, GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetMinmaxParameteriv (GLenum target, GLenum pname, GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetPixelMapfv (GLenum map, GLfloat *values) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetPixelMapuiv (GLenum map, GLuint *values) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetPixelMapusv (GLenum map, GLushort *values) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetPointerv (GLenum pname, GLvoid **params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetPolygonStipple (GLubyte *mask) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetSeparableFilter (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern const GLubyte *glGetString (GLenum name) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetTexEnviv (GLenum target, GLenum pname, GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetTexGeniv (GLenum coord, GLenum pname, GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetTexParameteriv (GLenum target, GLenum pname, GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glHint (GLenum target, GLenum mode) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glHistogram (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glIndexMask (GLuint mask) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glIndexPointer (GLenum type, GLsizei stride, const GLvoid *pointer) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glIndexd (GLdouble c) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glIndexdv (const GLdouble *c) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glIndexf (GLfloat c) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glIndexfv (const GLfloat *c) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glIndexi (GLint c) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glIndexiv (const GLint *c) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glIndexs (GLshort c) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glIndexsv (const GLshort *c) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glIndexub (GLubyte c) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glIndexubv (const GLubyte *c) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glInitNames (void) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLboolean glIsEnabled (GLenum cap) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLboolean glIsList (GLuint list) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLboolean glIsTexture (GLuint texture) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glLightModelf (GLenum pname, GLfloat param) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glLightModelfv (GLenum pname, const GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glLightModeli (GLenum pname, GLint param) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glLightModeliv (GLenum pname, const GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glLightf (GLenum light, GLenum pname, GLfloat param) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glLightfv (GLenum light, GLenum pname, const GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glLighti (GLenum light, GLenum pname, GLint param) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glLightiv (GLenum light, GLenum pname, const GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glLineStipple (GLint factor, GLushort pattern) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glLineWidth (GLfloat width) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glListBase (GLuint base) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glLoadIdentity (void) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glLoadMatrixd (const GLdouble *m) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glLoadMatrixf (const GLfloat *m) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glLoadName (GLuint name) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glLogicOp (GLenum opcode) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMapGrid1d (GLint un, GLdouble u1, GLdouble u2) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMapGrid1f (GLint un, GLfloat u1, GLfloat u2) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMaterialf (GLenum face, GLenum pname, GLfloat param) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMaterialfv (GLenum face, GLenum pname, const GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMateriali (GLenum face, GLenum pname, GLint param) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMaterialiv (GLenum face, GLenum pname, const GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMatrixMode (GLenum mode) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMinmax (GLenum target, GLenum internalformat, GLboolean sink) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultMatrixd (const GLdouble *m) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultMatrixf (const GLfloat *m) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glNewList (GLuint list, GLenum mode) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glNormal3bv (const GLbyte *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glNormal3dv (const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glNormal3fv (const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glNormal3i (GLint nx, GLint ny, GLint nz) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glNormal3iv (const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glNormal3s (GLshort nx, GLshort ny, GLshort nz) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glNormal3sv (const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPassThrough (GLfloat token) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPixelMapfv (GLenum map, GLint mapsize, const GLfloat *values) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPixelMapuiv (GLenum map, GLint mapsize, const GLuint *values) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPixelMapusv (GLenum map, GLint mapsize, const GLushort *values) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPixelStoref (GLenum pname, GLfloat param) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPixelStorei (GLenum pname, GLint param) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPixelTransferf (GLenum pname, GLfloat param) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPixelTransferi (GLenum pname, GLint param) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPixelZoom (GLfloat xfactor, GLfloat yfactor) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPointSize (GLfloat size) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPolygonMode (GLenum face, GLenum mode) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPolygonOffset (GLfloat factor, GLfloat units) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPolygonStipple (const GLubyte *mask) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPopAttrib (void) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPopClientAttrib (void) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPopMatrix (void) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPopName (void) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPushAttrib (GLbitfield mask) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPushClientAttrib (GLbitfield mask) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPushMatrix (void) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPushName (GLuint name) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos2d (GLdouble x, GLdouble y) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos2dv (const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos2f (GLfloat x, GLfloat y) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos2fv (const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos2i (GLint x, GLint y) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos2iv (const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos2s (GLshort x, GLshort y) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos2sv (const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos3d (GLdouble x, GLdouble y, GLdouble z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos3dv (const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos3f (GLfloat x, GLfloat y, GLfloat z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos3fv (const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos3i (GLint x, GLint y, GLint z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos3iv (const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos3s (GLshort x, GLshort y, GLshort z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos3sv (const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos4dv (const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos4fv (const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos4i (GLint x, GLint y, GLint z, GLint w) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos4iv (const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRasterPos4sv (const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glReadBuffer (GLenum mode) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRectdv (const GLdouble *v1, const GLdouble *v2) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRectfv (const GLfloat *v1, const GLfloat *v2) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRecti (GLint x1, GLint y1, GLint x2, GLint y2) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRectiv (const GLint *v1, const GLint *v2) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRectsv (const GLshort *v1, const GLshort *v2) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLint glRenderMode (GLenum mode) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glResetHistogram (GLenum target) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glResetMinmax (GLenum target) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glScaled (GLdouble x, GLdouble y, GLdouble z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glScalef (GLfloat x, GLfloat y, GLfloat z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glScissor (GLint x, GLint y, GLsizei width, GLsizei height) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glSelectBuffer (GLsizei size, GLuint *buffer) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glSeparableFilter2D (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glShadeModel (GLenum mode) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glStencilFunc (GLenum func, GLint ref, GLuint mask) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glStencilMask (GLuint mask) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glStencilOp (GLenum fail, GLenum zfail, GLenum zpass) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord1d (GLdouble s) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord1dv (const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord1f (GLfloat s) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord1fv (const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord1i (GLint s) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord1iv (const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord1s (GLshort s) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord1sv (const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord2d (GLdouble s, GLdouble t) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord2dv (const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord2f (GLfloat s, GLfloat t) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord2fv (const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord2i (GLint s, GLint t) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord2iv (const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord2s (GLshort s, GLshort t) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord2sv (const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord3d (GLdouble s, GLdouble t, GLdouble r) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord3dv (const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord3f (GLfloat s, GLfloat t, GLfloat r) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord3fv (const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord3i (GLint s, GLint t, GLint r) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord3iv (const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord3s (GLshort s, GLshort t, GLshort r) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord3sv (const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord4dv (const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord4fv (const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord4i (GLint s, GLint t, GLint r, GLint q) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord4iv (const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoord4sv (const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexEnvf (GLenum target, GLenum pname, GLfloat param) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexEnvi (GLenum target, GLenum pname, GLint param) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexEnviv (GLenum target, GLenum pname, const GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexGend (GLenum coord, GLenum pname, GLdouble param) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexGendv (GLenum coord, GLenum pname, const GLdouble *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexGenf (GLenum coord, GLenum pname, GLfloat param) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexGeni (GLenum coord, GLenum pname, GLint param) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexGeniv (GLenum coord, GLenum pname, const GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexImage3D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexParameterf (GLenum target, GLenum pname, GLfloat param) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexParameteri (GLenum target, GLenum pname, GLint param) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexParameteriv (GLenum target, GLenum pname, const GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTranslated (GLdouble x, GLdouble y, GLdouble z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glTranslatef (GLfloat x, GLfloat y, GLfloat z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex2d (GLdouble x, GLdouble y) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex2dv (const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex2f (GLfloat x, GLfloat y) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex2fv (const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex2i (GLint x, GLint y) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex2iv (const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex2s (GLshort x, GLshort y) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex2sv (const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex3d (GLdouble x, GLdouble y, GLdouble z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex3dv (const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex3f (GLfloat x, GLfloat y, GLfloat z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex3fv (const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex3i (GLint x, GLint y, GLint z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex3iv (const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex3s (GLshort x, GLshort y, GLshort z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex3sv (const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex4dv (const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex4fv (const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex4i (GLint x, GLint y, GLint z, GLint w) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex4iv (const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertex4sv (const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glViewport (GLint x, GLint y, GLsizei width, GLsizei height) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));

extern void glSampleCoverage (GLclampf value, GLboolean invert) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));

extern void glLoadTransposeMatrixf (const GLfloat *m) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glLoadTransposeMatrixd (const GLdouble *m) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultTransposeMatrixf (const GLfloat *m) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultTransposeMatrixd (const GLdouble *m) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));

extern void glCompressedTexImage3D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glCompressedTexImage1D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glCompressedTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glCompressedTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetCompressedTexImage (GLenum target, GLint lod, GLvoid *img) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));

extern void glActiveTexture (GLenum texture) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glClientActiveTexture (GLenum texture) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord1d (GLenum target, GLdouble s) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord1dv (GLenum target, const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord1f (GLenum target, GLfloat s) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord1fv (GLenum target, const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord1i (GLenum target, GLint s) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord1iv (GLenum target, const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord1s (GLenum target, GLshort s) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord1sv (GLenum target, const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord2d (GLenum target, GLdouble s, GLdouble t) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord2dv (GLenum target, const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord2f (GLenum target, GLfloat s, GLfloat t) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord2fv (GLenum target, const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord2i (GLenum target, GLint s, GLint t) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord2iv (GLenum target, const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord2s (GLenum target, GLshort s, GLshort t) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord2sv (GLenum target, const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord3d (GLenum target, GLdouble s, GLdouble t, GLdouble r) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord3dv (GLenum target, const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord3f (GLenum target, GLfloat s, GLfloat t, GLfloat r) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord3fv (GLenum target, const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord3i (GLenum target, GLint s, GLint t, GLint r) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord3iv (GLenum target, const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord3s (GLenum target, GLshort s, GLshort t, GLshort r) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord3sv (GLenum target, const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord4d (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord4dv (GLenum target, const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord4f (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord4fv (GLenum target, const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord4i (GLenum target, GLint s, GLint t, GLint r, GLint q) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord4iv (GLenum target, const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord4s (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiTexCoord4sv (GLenum target, const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));

extern void glFogCoordf (GLfloat coord) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glFogCoordfv (const GLfloat *coord); __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")))
extern void glFogCoordd (GLdouble coord) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glFogCoorddv (const GLdouble *coord); __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")))
extern void glFogCoordPointer (GLenum type, GLsizei stride, const GLvoid *pointer) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));

extern void glSecondaryColor3b (GLbyte red, GLbyte green, GLbyte blue) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glSecondaryColor3bv (const GLbyte *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glSecondaryColor3d (GLdouble red, GLdouble green, GLdouble blue) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glSecondaryColor3dv (const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glSecondaryColor3f (GLfloat red, GLfloat green, GLfloat blue) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glSecondaryColor3fv (const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glSecondaryColor3i (GLint red, GLint green, GLint blue) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glSecondaryColor3iv (const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glSecondaryColor3s (GLshort red, GLshort green, GLshort blue) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glSecondaryColor3sv (const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glSecondaryColor3ub (GLubyte red, GLubyte green, GLubyte blue) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glSecondaryColor3ubv (const GLubyte *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glSecondaryColor3ui (GLuint red, GLuint green, GLuint blue) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glSecondaryColor3uiv (const GLuint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glSecondaryColor3us (GLushort red, GLushort green, GLushort blue) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glSecondaryColor3usv (const GLushort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glSecondaryColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));

extern void glPointParameterf (GLenum pname, GLfloat param); __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")))
extern void glPointParameterfv (GLenum pname, const GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glPointParameteri (GLenum pname, GLint param); __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")))
extern void glPointParameteriv (GLenum pname, const GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));

extern void glBlendFuncSeparate (GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));

extern void glMultiDrawArrays (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glMultiDrawElements (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei primcount) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));

extern void glWindowPos2d (GLdouble x, GLdouble y) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glWindowPos2dv (const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glWindowPos2f (GLfloat x, GLfloat y) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glWindowPos2fv (const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glWindowPos2i (GLint x, GLint y); __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")))
extern void glWindowPos2iv (const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glWindowPos2s (GLshort x, GLshort y) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glWindowPos2sv (const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glWindowPos3d (GLdouble x, GLdouble y, GLdouble z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glWindowPos3dv (const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glWindowPos3f (GLfloat x, GLfloat y, GLfloat z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glWindowPos3fv (const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glWindowPos3i (GLint x, GLint y, GLint z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glWindowPos3iv (const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glWindowPos3s (GLshort x, GLshort y, GLshort z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glWindowPos3sv (const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));

extern void glGenQueries (GLsizei n, GLuint *ids) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glDeleteQueries (GLsizei n, const GLuint *ids) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLboolean glIsQuery (GLuint id) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glBeginQuery (GLenum target, GLuint id) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEndQuery (GLenum target) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetQueryiv (GLenum target, GLenum pname, GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetQueryObjectiv (GLuint id, GLenum pname, GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetQueryObjectuiv (GLuint id, GLenum pname, GLuint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));

extern void glBindBuffer (GLenum target, GLuint buffer) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glDeleteBuffers (GLsizei n, const GLuint *buffers) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGenBuffers (GLsizei n, GLuint *buffers) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLboolean glIsBuffer (GLuint buffer) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glBufferData (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLvoid *glMapBuffer (GLenum target, GLenum access) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLboolean glUnmapBuffer (GLenum target) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetBufferParameteriv (GLenum target, GLenum pname, GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetBufferPointerv (GLenum target, GLenum pname, GLvoid **params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));

extern void glDrawBuffers (GLsizei n, const GLenum *bufs) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib1d (GLuint index, GLdouble x) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib1dv (GLuint index, const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib1f (GLuint index, GLfloat x) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib1fv (GLuint index, const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib1s (GLuint index, GLshort x) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib1sv (GLuint index, const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib2d (GLuint index, GLdouble x, GLdouble y) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib2dv (GLuint index, const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib2f (GLuint index, GLfloat x, GLfloat y) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib2fv (GLuint index, const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib2s (GLuint index, GLshort x, GLshort y) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib2sv (GLuint index, const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib3d (GLuint index, GLdouble x, GLdouble y, GLdouble z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib3dv (GLuint index, const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib3f (GLuint index, GLfloat x, GLfloat y, GLfloat z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib3fv (GLuint index, const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib3s (GLuint index, GLshort x, GLshort y, GLshort z) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib3sv (GLuint index, const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib4Nbv (GLuint index, const GLbyte *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib4Niv (GLuint index, const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib4Nsv (GLuint index, const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib4Nub (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib4Nubv (GLuint index, const GLubyte *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib4Nuiv (GLuint index, const GLuint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib4Nusv (GLuint index, const GLushort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib4bv (GLuint index, const GLbyte *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib4d (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib4dv (GLuint index, const GLdouble *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib4f (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib4fv (GLuint index, const GLfloat *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib4iv (GLuint index, const GLint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib4s (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib4sv (GLuint index, const GLshort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib4ubv (GLuint index, const GLubyte *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib4uiv (GLuint index, const GLuint *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttrib4usv (GLuint index, const GLushort *v) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glVertexAttribPointer (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glEnableVertexAttribArray (GLuint index) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glDisableVertexAttribArray (GLuint index) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetVertexAttribdv (GLuint index, GLenum pname, GLdouble *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetVertexAttribfv (GLuint index, GLenum pname, GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetVertexAttribiv (GLuint index, GLenum pname, GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetVertexAttribPointerv (GLuint index, GLenum pname, GLvoid **pointer) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glDeleteShader (GLuint shader) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glDetachShader (GLuint program, GLuint shader) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLuint glCreateShader (GLenum type) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glShaderSource (GLuint shader, GLsizei count, const GLchar* const *string, const GLint *length) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glCompileShader (GLuint shader) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLuint glCreateProgram (void) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glAttachShader (GLuint program, GLuint shader) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glLinkProgram (GLuint program) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUseProgram (GLuint program) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glDeleteProgram (GLuint program) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glValidateProgram (GLuint program) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniform1f (GLint location, GLfloat v0) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniform2f (GLint location, GLfloat v0, GLfloat v1) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniform3f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniform4f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniform1i (GLint location, GLint v0) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniform2i (GLint location, GLint v0, GLint v1) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniform3i (GLint location, GLint v0, GLint v1, GLint v2) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniform4i (GLint location, GLint v0, GLint v1, GLint v2, GLint v3) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniform1fv (GLint location, GLsizei count, const GLfloat *value) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniform2fv (GLint location, GLsizei count, const GLfloat *value) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniform3fv (GLint location, GLsizei count, const GLfloat *value) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniform4fv (GLint location, GLsizei count, const GLfloat *value) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniform1iv (GLint location, GLsizei count, const GLint *value) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniform2iv (GLint location, GLsizei count, const GLint *value) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniform3iv (GLint location, GLsizei count, const GLint *value) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniform4iv (GLint location, GLsizei count, const GLint *value) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniformMatrix2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniformMatrix3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniformMatrix4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLboolean glIsShader (GLuint shader) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLboolean glIsProgram (GLuint program) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetShaderiv (GLuint shader, GLenum pname, GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetProgramiv (GLuint program, GLenum pname, GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetAttachedShaders (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetShaderInfoLog (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetProgramInfoLog (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLint glGetUniformLocation (GLuint program, const GLchar *name) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetActiveUniform (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetUniformfv (GLuint program, GLint location, GLfloat *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetUniformiv (GLuint program, GLint location, GLint *params) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetShaderSource (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glBindAttribLocation (GLuint program, GLuint index, const GLchar *name) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glGetActiveAttrib (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLint glGetAttribLocation (GLuint program, const GLchar *name) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glStencilFuncSeparate (GLenum face, GLenum func, GLint ref, GLuint mask) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glStencilOpSeparate (GLenum face, GLenum fail, GLenum zfail, GLenum zpass) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glStencilMaskSeparate (GLenum face, GLuint mask) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));

extern void glUniformMatrix2x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniformMatrix3x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniformMatrix2x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniformMatrix4x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniformMatrix3x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void glUniformMatrix4x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) __attribute__((availability(macos,introduced=10.0,deprecated=10.14,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));





}
# 238 "/opt/homebrew/include/GLFW/glfw3.h" 2
# 1365 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (*GLFWglproc)(void);
# 1379 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (*GLFWvkproc)(void);
# 1391 "/opt/homebrew/include/GLFW/glfw3.h"
typedef struct GLFWmonitor GLFWmonitor;
# 1403 "/opt/homebrew/include/GLFW/glfw3.h"
typedef struct GLFWwindow GLFWwindow;
# 1415 "/opt/homebrew/include/GLFW/glfw3.h"
typedef struct GLFWcursor GLFWcursor;
# 1468 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void* (* GLFWallocatefun)(size_t size, void* user);
# 1524 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void* (* GLFWreallocatefun)(void* block, size_t size, void* user);
# 1566 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWdeallocatefun)(void* block, void* user);
# 1590 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWerrorfun)(int error_code, const char* description);
# 1613 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWwindowposfun)(GLFWwindow* window, int xpos, int ypos);
# 1635 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWwindowsizefun)(GLFWwindow* window, int width, int height);
# 1655 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWwindowclosefun)(GLFWwindow* window);
# 1675 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWwindowrefreshfun)(GLFWwindow* window);
# 1696 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWwindowfocusfun)(GLFWwindow* window, int focused);
# 1717 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWwindowiconifyfun)(GLFWwindow* window, int iconified);
# 1738 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWwindowmaximizefun)(GLFWwindow* window, int maximized);
# 1759 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWframebuffersizefun)(GLFWwindow* window, int width, int height);
# 1780 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWwindowcontentscalefun)(GLFWwindow* window, float xscale, float yscale);
# 1806 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWmousebuttonfun)(GLFWwindow* window, int button, int action, int mods);
# 1829 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWcursorposfun)(GLFWwindow* window, double xpos, double ypos);
# 1850 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWcursorenterfun)(GLFWwindow* window, int entered);
# 1871 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWscrollfun)(GLFWwindow* window, double xoffset, double yoffset);
# 1897 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWkeyfun)(GLFWwindow* window, int key, int scancode, int action, int mods);
# 1918 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWcharfun)(GLFWwindow* window, unsigned int codepoint);
# 1945 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWcharmodsfun)(GLFWwindow* window, unsigned int codepoint, int mods);
# 1969 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWdropfun)(GLFWwindow* window, int path_count, const char* paths[]);
# 1990 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWmonitorfun)(GLFWmonitor* monitor, int event);
# 2011 "/opt/homebrew/include/GLFW/glfw3.h"
typedef void (* GLFWjoystickfun)(int jid, int event);
# 2026 "/opt/homebrew/include/GLFW/glfw3.h"
typedef struct GLFWvidmode
{


    int width;


    int height;


    int redBits;


    int greenBits;


    int blueBits;


    int refreshRate;
} GLFWvidmode;
# 2060 "/opt/homebrew/include/GLFW/glfw3.h"
typedef struct GLFWgammaramp
{


    unsigned short* red;


    unsigned short* green;


    unsigned short* blue;


    unsigned int size;
} GLFWgammaramp;
# 2089 "/opt/homebrew/include/GLFW/glfw3.h"
typedef struct GLFWimage
{


    int width;


    int height;


    unsigned char* pixels;
} GLFWimage;
# 2113 "/opt/homebrew/include/GLFW/glfw3.h"
typedef struct GLFWgamepadstate
{



    unsigned char buttons[15];



    float axes[6];
} GLFWgamepadstate;
# 2137 "/opt/homebrew/include/GLFW/glfw3.h"
typedef struct GLFWallocator
{



    GLFWallocatefun allocate;



    GLFWreallocatefun reallocate;



    GLFWdeallocatefun deallocate;



    void* user;
} GLFWallocator;
# 2220 "/opt/homebrew/include/GLFW/glfw3.h"
        int glfwInit(void);
# 2254 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwTerminate(void);
# 2286 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwInitHint(int hint, int value);
# 2317 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwInitAllocator(const GLFWallocator* allocator);
# 2392 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwGetVersion(int* major, int* minor, int* rev);
# 2426 "/opt/homebrew/include/GLFW/glfw3.h"
        const char* glfwGetVersionString(void);
# 2457 "/opt/homebrew/include/GLFW/glfw3.h"
        int glfwGetError(const char** description);
# 2503 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWerrorfun glfwSetErrorCallback(GLFWerrorfun callback);
# 2524 "/opt/homebrew/include/GLFW/glfw3.h"
        int glfwGetPlatform(void);
# 2548 "/opt/homebrew/include/GLFW/glfw3.h"
        int glfwPlatformSupported(int platform);
# 2577 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWmonitor** glfwGetMonitors(int* count);
# 2601 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWmonitor* glfwGetPrimaryMonitor(void);
# 2626 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwGetMonitorPos(GLFWmonitor* monitor, int* xpos, int* ypos);
# 2657 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwGetMonitorWorkarea(GLFWmonitor* monitor, int* xpos, int* ypos, int* width, int* height);
# 2692 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwGetMonitorPhysicalSize(GLFWmonitor* monitor, int* widthMM, int* heightMM);
# 2727 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwGetMonitorContentScale(GLFWmonitor* monitor, float* xscale, float* yscale);
# 2753 "/opt/homebrew/include/GLFW/glfw3.h"
        const char* glfwGetMonitorName(GLFWmonitor* monitor);
# 2779 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSetMonitorUserPointer(GLFWmonitor* monitor, void* pointer);
# 2803 "/opt/homebrew/include/GLFW/glfw3.h"
        void* glfwGetMonitorUserPointer(GLFWmonitor* monitor);
# 2833 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWmonitorfun glfwSetMonitorCallback(GLFWmonitorfun callback);
# 2867 "/opt/homebrew/include/GLFW/glfw3.h"
        const GLFWvidmode* glfwGetVideoModes(GLFWmonitor* monitor, int* count);
# 2895 "/opt/homebrew/include/GLFW/glfw3.h"
        const GLFWvidmode* glfwGetVideoMode(GLFWmonitor* monitor);
# 2928 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSetGamma(GLFWmonitor* monitor, float gamma);
# 2958 "/opt/homebrew/include/GLFW/glfw3.h"
        const GLFWgammaramp* glfwGetGammaRamp(GLFWmonitor* monitor);
# 2999 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSetGammaRamp(GLFWmonitor* monitor, const GLFWgammaramp* ramp);
# 3018 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwDefaultWindowHints(void);
# 3053 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwWindowHint(int hint, int value);
# 3091 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwWindowHintString(int hint, const char* value);
# 3235 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWwindow* glfwCreateWindow(int width, int height, const char* title, GLFWmonitor* monitor, GLFWwindow* share);
# 3264 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwDestroyWindow(GLFWwindow* window);
# 3284 "/opt/homebrew/include/GLFW/glfw3.h"
        int glfwWindowShouldClose(GLFWwindow* window);
# 3306 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSetWindowShouldClose(GLFWwindow* window, int value);
# 3338 "/opt/homebrew/include/GLFW/glfw3.h"
        const char* glfwGetWindowTitle(GLFWwindow* window);
# 3364 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSetWindowTitle(GLFWwindow* window, const char* title);
# 3413 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSetWindowIcon(GLFWwindow* window, int count, const GLFWimage* images);
# 3445 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwGetWindowPos(GLFWwindow* window, int* xpos, int* ypos);
# 3480 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSetWindowPos(GLFWwindow* window, int xpos, int ypos);
# 3510 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwGetWindowSize(GLFWwindow* window, int* width, int* height);
# 3553 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSetWindowSizeLimits(GLFWwindow* window, int minwidth, int minheight, int maxwidth, int maxheight);
# 3596 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSetWindowAspectRatio(GLFWwindow* window, int numer, int denom);
# 3634 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSetWindowSize(GLFWwindow* window, int width, int height);
# 3663 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwGetFramebufferSize(GLFWwindow* window, int* width, int* height);
# 3700 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwGetWindowFrameSize(GLFWwindow* window, int* left, int* top, int* right, int* bottom);
# 3733 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwGetWindowContentScale(GLFWwindow* window, float* xscale, float* yscale);
# 3760 "/opt/homebrew/include/GLFW/glfw3.h"
        float glfwGetWindowOpacity(GLFWwindow* window);
# 3792 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSetWindowOpacity(GLFWwindow* window, float opacity);
# 3824 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwIconifyWindow(GLFWwindow* window);
# 3851 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwRestoreWindow(GLFWwindow* window);
# 3876 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwMaximizeWindow(GLFWwindow* window);
# 3908 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwShowWindow(GLFWwindow* window);
# 3930 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwHideWindow(GLFWwindow* window);
# 3969 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwFocusWindow(GLFWwindow* window);
# 3996 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwRequestWindowAttention(GLFWwindow* window);
# 4018 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWmonitor* glfwGetWindowMonitor(GLFWwindow* window);
# 4074 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSetWindowMonitor(GLFWwindow* window, GLFWmonitor* monitor, int xpos, int ypos, int width, int height, int refreshRate);
# 4111 "/opt/homebrew/include/GLFW/glfw3.h"
        int glfwGetWindowAttrib(GLFWwindow* window, int attrib);
# 4153 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSetWindowAttrib(GLFWwindow* window, int attrib, int value);
# 4176 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSetWindowUserPointer(GLFWwindow* window, void* pointer);
# 4197 "/opt/homebrew/include/GLFW/glfw3.h"
        void* glfwGetWindowUserPointer(GLFWwindow* window);
# 4232 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWwindowposfun glfwSetWindowPosCallback(GLFWwindow* window, GLFWwindowposfun callback);
# 4264 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWwindowsizefun glfwSetWindowSizeCallback(GLFWwindow* window, GLFWwindowsizefun callback);
# 4304 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWwindowclosefun glfwSetWindowCloseCallback(GLFWwindow* window, GLFWwindowclosefun callback);
# 4340 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWwindowrefreshfun glfwSetWindowRefreshCallback(GLFWwindow* window, GLFWwindowrefreshfun callback);
# 4375 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWwindowfocusfun glfwSetWindowFocusCallback(GLFWwindow* window, GLFWwindowfocusfun callback);
# 4405 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWwindowiconifyfun glfwSetWindowIconifyCallback(GLFWwindow* window, GLFWwindowiconifyfun callback);
# 4435 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWwindowmaximizefun glfwSetWindowMaximizeCallback(GLFWwindow* window, GLFWwindowmaximizefun callback);
# 4465 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWframebuffersizefun glfwSetFramebufferSizeCallback(GLFWwindow* window, GLFWframebuffersizefun callback);
# 4496 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWwindowcontentscalefun glfwSetWindowContentScaleCallback(GLFWwindow* window, GLFWwindowcontentscalefun callback);
# 4534 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwPollEvents(void);
# 4579 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwWaitEvents(void);
# 4628 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwWaitEventsTimeout(double timeout);
# 4648 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwPostEmptyEvent(void);
# 4673 "/opt/homebrew/include/GLFW/glfw3.h"
        int glfwGetInputMode(GLFWwindow* window, int mode);
# 4738 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSetInputMode(GLFWwindow* window, int mode, int value);
# 4767 "/opt/homebrew/include/GLFW/glfw3.h"
        int glfwRawMouseMotionSupported(void);
# 4835 "/opt/homebrew/include/GLFW/glfw3.h"
        const char* glfwGetKeyName(int key, int scancode);
# 4862 "/opt/homebrew/include/GLFW/glfw3.h"
        int glfwGetKeyScancode(int key);
# 4901 "/opt/homebrew/include/GLFW/glfw3.h"
        int glfwGetKey(GLFWwindow* window, int key);
# 4930 "/opt/homebrew/include/GLFW/glfw3.h"
        int glfwGetMouseButton(GLFWwindow* window, int button);
# 4968 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwGetCursorPos(GLFWwindow* window, double* xpos, double* ypos);
# 5008 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSetCursorPos(GLFWwindow* window, double xpos, double ypos);
# 5046 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWcursor* glfwCreateCursor(const GLFWimage* image, int xhot, int yhot);
# 5094 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWcursor* glfwCreateStandardCursor(int shape);
# 5121 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwDestroyCursor(GLFWcursor* cursor);
# 5148 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSetCursor(GLFWwindow* window, GLFWcursor* cursor);
# 5198 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWkeyfun glfwSetKeyCallback(GLFWwindow* window, GLFWkeyfun callback);
# 5241 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWcharfun glfwSetCharCallback(GLFWwindow* window, GLFWcharfun callback);
# 5283 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWcharmodsfun glfwSetCharModsCallback(GLFWwindow* window, GLFWcharmodsfun callback);
# 5320 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWmousebuttonfun glfwSetMouseButtonCallback(GLFWwindow* window, GLFWmousebuttonfun callback);
# 5352 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWcursorposfun glfwSetCursorPosCallback(GLFWwindow* window, GLFWcursorposfun callback);
# 5383 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWcursorenterfun glfwSetCursorEnterCallback(GLFWwindow* window, GLFWcursorenterfun callback);
# 5417 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWscrollfun glfwSetScrollCallback(GLFWwindow* window, GLFWscrollfun callback);
# 5452 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWdropfun glfwSetDropCallback(GLFWwindow* window, GLFWdropfun callback);
# 5476 "/opt/homebrew/include/GLFW/glfw3.h"
        int glfwJoystickPresent(int jid);
# 5509 "/opt/homebrew/include/GLFW/glfw3.h"
        const float* glfwGetJoystickAxes(int jid, int* count);
# 5550 "/opt/homebrew/include/GLFW/glfw3.h"
        const unsigned char* glfwGetJoystickButtons(int jid, int* count);
# 5607 "/opt/homebrew/include/GLFW/glfw3.h"
        const unsigned char* glfwGetJoystickHats(int jid, int* count);
# 5638 "/opt/homebrew/include/GLFW/glfw3.h"
        const char* glfwGetJoystickName(int jid);
# 5679 "/opt/homebrew/include/GLFW/glfw3.h"
        const char* glfwGetJoystickGUID(int jid);
# 5705 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSetJoystickUserPointer(int jid, void* pointer);
# 5729 "/opt/homebrew/include/GLFW/glfw3.h"
        void* glfwGetJoystickUserPointer(int jid);
# 5757 "/opt/homebrew/include/GLFW/glfw3.h"
        int glfwJoystickIsGamepad(int jid);
# 5793 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWjoystickfun glfwSetJoystickCallback(GLFWjoystickfun callback);
# 5827 "/opt/homebrew/include/GLFW/glfw3.h"
        int glfwUpdateGamepadMappings(const char* string);
# 5859 "/opt/homebrew/include/GLFW/glfw3.h"
        const char* glfwGetGamepadName(int jid);
# 5897 "/opt/homebrew/include/GLFW/glfw3.h"
        int glfwGetGamepadState(int jid, GLFWgamepadstate* state);
# 5927 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSetClipboardString(GLFWwindow* window, const char* string);
# 5962 "/opt/homebrew/include/GLFW/glfw3.h"
        const char* glfwGetClipboardString(GLFWwindow* window);
# 5992 "/opt/homebrew/include/GLFW/glfw3.h"
        double glfwGetTime(void);
# 6022 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSetTime(double time);
# 6044 "/opt/homebrew/include/GLFW/glfw3.h"
        uint64_t glfwGetTimerValue(void);
# 6064 "/opt/homebrew/include/GLFW/glfw3.h"
        uint64_t glfwGetTimerFrequency(void);
# 6109 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwMakeContextCurrent(GLFWwindow* window);
# 6130 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWwindow* glfwGetCurrentContext(void);
# 6164 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSwapBuffers(GLFWwindow* window);
# 6210 "/opt/homebrew/include/GLFW/glfw3.h"
        void glfwSwapInterval(int interval);
# 6248 "/opt/homebrew/include/GLFW/glfw3.h"
        int glfwExtensionSupported(const char* extension);
# 6290 "/opt/homebrew/include/GLFW/glfw3.h"
        GLFWglproc glfwGetProcAddress(const char* procname);
# 6316 "/opt/homebrew/include/GLFW/glfw3.h"
        int glfwVulkanSupported(void);
# 6360 "/opt/homebrew/include/GLFW/glfw3.h"
        const char** glfwGetRequiredInstanceExtensions(uint32_t* count);
# 6543 "/opt/homebrew/include/GLFW/glfw3.h"
}
# 5 "src/core/WindowManager.h" 2
# 1 "/opt/homebrew/include/glm/glm.hpp" 1
# 104 "/opt/homebrew/include/glm/glm.hpp"
# 1 "/opt/homebrew/include/glm/detail/_fixes.hpp" 1
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 1 3
# 307 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__assert" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__assert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__assertion_handler" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__assertion_handler" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__verbose_abort" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__verbose_abort" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__availability" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__availability" 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__verbose_abort" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__verbose_abort" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



__attribute__((__noreturn__)) __attribute__((availability(macos,strict,introduced=16.0))) __attribute__((availability(ios,strict,introduced=17.0))) __attribute__((availability(tvos,strict,introduced=17.0))) __attribute__((availability(watchos,strict,introduced=10.0))) __attribute__((availability(driverkit,strict,introduced=23.0))) __attribute__((__visibility__("default")))
    __attribute__((__format__(__printf__, 1, 2))) void __libcpp_verbose_abort(const char* __format, ...);
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__verbose_abort" 3
void __use(const char*, ...);







}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__assertion_handler" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__assertion_handler" 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__assert" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__assert" 3
# 308 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/enable_if.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/enable_if.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <bool, class _Tp = void>
struct enable_if {};
template <class _Tp>
struct enable_if<true, _Tp> {
  typedef _Tp type;
};

template <bool _Bp, class _Tp = void>
using __enable_if_t __attribute__((__nodebug__)) = typename enable_if<_Bp, _Tp>::type;






}}
# 310 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_arithmetic.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_arithmetic.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/integral_constant.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/integral_constant.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, _Tp __v>
struct integral_constant {
  static const _Tp value = __v;
  typedef _Tp value_type;
  typedef integral_constant type;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) operator value_type() const throw() { return value; }



};

template <class _Tp, _Tp __v>
                  const _Tp integral_constant<_Tp, __v>::value;

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;

template <bool _Val>
using _BoolConstant __attribute__((__nodebug__)) = integral_constant<bool, _Val>;






}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_arithmetic.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_floating_point.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_floating_point.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_cv.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_cv.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_const.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_const.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
struct remove_const {
  using type __attribute__((__nodebug__)) = __remove_const(_Tp);
};

template <class _Tp>
using __remove_const_t = __remove_const(_Tp);
# 47 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_const.h" 3
}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_cv.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_volatile.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_volatile.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
struct remove_volatile {
  using type __attribute__((__nodebug__)) = __remove_volatile(_Tp);
};

template <class _Tp>
using __remove_volatile_t = __remove_volatile(_Tp);
# 47 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_volatile.h" 3
}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_cv.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_cv.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
struct remove_cv {
  using type __attribute__((__nodebug__)) = __remove_cv(_Tp);
};

template <class _Tp>
using __remove_cv_t = __remove_cv(_Tp);
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_cv.h" 3
}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_floating_point.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_floating_point.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <> struct __libcpp_is_floating_point<long double> : public true_type {};


template <class _Tp>
struct is_floating_point : public __libcpp_is_floating_point<__remove_cv_t<_Tp> > {};






}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_arithmetic.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_integral.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_integral.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp> struct __libcpp_is_integral { enum { value = 0 }; };
template <> struct __libcpp_is_integral<bool> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<char> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<signed char> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned char> { enum { value = 1 }; };

template <> struct __libcpp_is_integral<wchar_t> { enum { value = 1 }; };




template <> struct __libcpp_is_integral<char16_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<char32_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<short> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned short> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<int> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned int> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<long long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned long long> { enum { value = 1 }; };

template <> struct __libcpp_is_integral<__int128_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<__uint128_t> { enum { value = 1 }; };





template <class _Tp>
struct is_integral : _BoolConstant<__is_integral(_Tp)> {};
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_integral.h" 3
}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_arithmetic.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_arithmetic.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value || is_floating_point<_Tp>::value> {};






}}
# 311 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_constant_evaluated.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_constant_evaluated.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {







__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline bool __libcpp_is_constant_evaluated() throw() {
  return __builtin_is_constant_evaluated();
}

}}
# 312 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_same.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_same.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Up>
struct is_same : _BoolConstant<__is_same(_Tp, _Up)> {};
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_same.h" 3
template <class _Tp, class _Up>
using _IsSame = _BoolConstant<__is_same(_Tp, _Up)>;

template <class _Tp, class _Up>
using _IsNotSame = _BoolConstant<!__is_same(_Tp, _Up)>;

}}
# 314 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/promote.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/promote.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/declval.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/declval.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



#pragma GCC diagnostic push
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/declval.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/declval.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp>
_Tp&& __declval(int);
template <class _Tp>
_Tp __declval(long);
#pragma GCC diagnostic pop

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __decltype(std::__declval<_Tp>(0)) declval() throw() {
  _Static_assert(!__is_same(_Tp, _Tp), "std::declval can only be used in an unevaluated context. " "It's likely that your current usage is trying to extract a value from the function.");


}

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/promote.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/promote.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __numeric_type {
  static void __test(...);
  static float __test(float);
  static double __test(char);
  static double __test(int);
  static double __test(unsigned);
  static double __test(long);
  static double __test(unsigned long);
  static double __test(long long);
  static double __test(unsigned long long);

  static double __test(__int128_t);
  static double __test(__uint128_t);

  static double __test(double);
  static long double __test(long double);

  typedef __decltype(__test(std::declval<_Tp>())) type;
  static const bool value = _IsNotSame<type, void>::value;
};

template <>
struct __numeric_type<void> {
  static const bool value = true;
};

template <class _A1,
          class _A2 = void,
          class _A3 = void,
          bool = __numeric_type<_A1>::value && __numeric_type<_A2>::value && __numeric_type<_A3>::value>
class __promote_imp {
public:
  static const bool value = false;
};

template <class _A1, class _A2, class _A3>
class __promote_imp<_A1, _A2, _A3, true> {
private:
  typedef typename __promote_imp<_A1>::type __type1;
  typedef typename __promote_imp<_A2>::type __type2;
  typedef typename __promote_imp<_A3>::type __type3;

public:
  typedef __decltype(__type1() + __type2() + __type3()) type;
  static const bool value = true;
};

template <class _A1, class _A2>
class __promote_imp<_A1, _A2, void, true> {
private:
  typedef typename __promote_imp<_A1>::type __type1;
  typedef typename __promote_imp<_A2>::type __type2;

public:
  typedef __decltype(__type1() + __type2()) type;
  static const bool value = true;
};

template <class _A1>
class __promote_imp<_A1, void, void, true> {
public:
  typedef typename __numeric_type<_A1>::type type;
  static const bool value = true;
};

template <class _A1, class _A2 = void, class _A3 = void>
class __promote : public __promote_imp<_A1, _A2, _A3> {};

}}
# 315 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits" 1 3
# 108 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_signed.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_signed.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_signed : _BoolConstant<__is_signed(_Tp)> {};
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_signed.h" 3
}}
# 109 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits" 2 3
# 113 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 117 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/version" 1 3
# 253 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/version" 3
# 118 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

enum float_round_style {
  round_indeterminate = -1,
  round_toward_zero = 0,
  round_to_nearest = 1,
  round_toward_infinity = 2,
  round_toward_neg_infinity = 3
};

enum float_denorm_style {
  denorm_indeterminate = -1,
  denorm_absent = 0,
  denorm_present = 1
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits {
protected:
  typedef _Tp type;

  static const bool is_specialized = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type min() throw() { return type(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type max() throw() { return type(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type lowest() throw() { return type(); }

  static const int digits = 0;
  static const int digits10 = 0;
  static const int max_digits10 = 0;
  static const bool is_signed = false;
  static const bool is_integer = false;
  static const bool is_exact = false;
  static const int radix = 0;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type epsilon() throw() { return type(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type round_error() throw() { return type(); }

  static const int min_exponent = 0;
  static const int min_exponent10 = 0;
  static const int max_exponent = 0;
  static const int max_exponent10 = 0;

  static const bool has_infinity = false;
  static const bool has_quiet_NaN = false;
  static const bool has_signaling_NaN = false;
  static const float_denorm_style has_denorm = denorm_absent;
  static const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type infinity() throw() { return type(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type quiet_NaN() throw() { return type(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type signaling_NaN() throw() { return type(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type denorm_min() throw() { return type(); }

  static const bool is_iec559 = false;
  static const bool is_bounded = false;
  static const bool is_modulo = false;

  static const bool traps = false;
  static const bool tinyness_before = false;
  static const float_round_style round_style = round_toward_zero;
};

template <class _Tp, int __digits, bool _IsSigned>
struct __libcpp_compute_min {
  static const _Tp value = _Tp(_Tp(1) << __digits);
};

template <class _Tp, int __digits>
struct __libcpp_compute_min<_Tp, __digits, false> {
  static const _Tp value = _Tp(0);
};

template <class _Tp>
class __libcpp_numeric_limits<_Tp, true> {
protected:
  typedef _Tp type;

  static const bool is_specialized = true;

  static const bool is_signed = type(-1) < type(0);
  static const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
  static const int digits10 = digits * 3 / 10;
  static const int max_digits10 = 0;
  static const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
  static const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type min() throw() { return __min; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type max() throw() { return __max; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type lowest() throw() { return min(); }

  static const bool is_integer = true;
  static const bool is_exact = true;
  static const int radix = 2;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type epsilon() throw() { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type round_error() throw() { return type(0); }

  static const int min_exponent = 0;
  static const int min_exponent10 = 0;
  static const int max_exponent = 0;
  static const int max_exponent10 = 0;

  static const bool has_infinity = false;
  static const bool has_quiet_NaN = false;
  static const bool has_signaling_NaN = false;
  static const float_denorm_style has_denorm = denorm_absent;
  static const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type infinity() throw() { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type quiet_NaN() throw() { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type signaling_NaN() throw() { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type denorm_min() throw() { return type(0); }

  static const bool is_iec559 = false;
  static const bool is_bounded = true;
  static const bool is_modulo = !std::is_signed<_Tp>::value;




  static const bool traps = false;

  static const bool tinyness_before = false;
  static const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<bool, true> {
protected:
  typedef bool type;

  static const bool is_specialized = true;

  static const bool is_signed = false;
  static const int digits = 1;
  static const int digits10 = 0;
  static const int max_digits10 = 0;
  static const type __min = false;
  static const type __max = true;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type min() throw() { return __min; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type max() throw() { return __max; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type lowest() throw() { return min(); }

  static const bool is_integer = true;
  static const bool is_exact = true;
  static const int radix = 2;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type epsilon() throw() { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type round_error() throw() { return type(0); }

  static const int min_exponent = 0;
  static const int min_exponent10 = 0;
  static const int max_exponent = 0;
  static const int max_exponent10 = 0;

  static const bool has_infinity = false;
  static const bool has_quiet_NaN = false;
  static const bool has_signaling_NaN = false;
  static const float_denorm_style has_denorm = denorm_absent;
  static const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type infinity() throw() { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type quiet_NaN() throw() { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type signaling_NaN() throw() { return type(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type denorm_min() throw() { return type(0); }

  static const bool is_iec559 = false;
  static const bool is_bounded = true;
  static const bool is_modulo = false;

  static const bool traps = false;
  static const bool tinyness_before = false;
  static const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<float, true> {
protected:
  typedef float type;

  static const bool is_specialized = true;

  static const bool is_signed = true;
  static const int digits = 24;
  static const int digits10 = 6;
  static const int max_digits10 = 2 + (digits * 30103l) / 100000l;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type min() throw() { return 1.17549435e-38F; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type max() throw() { return 3.40282347e+38F; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type lowest() throw() { return -max(); }

  static const bool is_integer = false;
  static const bool is_exact = false;
  static const int radix = 2;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type epsilon() throw() { return 1.19209290e-7F; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type round_error() throw() { return 0.5F; }

  static const int min_exponent = (-125);
  static const int min_exponent10 = (-37);
  static const int max_exponent = 128;
  static const int max_exponent10 = 38;

  static const bool has_infinity = true;
  static const bool has_quiet_NaN = true;
  static const bool has_signaling_NaN = true;
  static const float_denorm_style has_denorm = denorm_present;
  static const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type infinity() throw() { return __builtin_huge_valf(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type quiet_NaN() throw() { return __builtin_nanf(""); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type signaling_NaN() throw() { return __builtin_nansf(""); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type denorm_min() throw() { return 1.40129846e-45F; }

  static const bool is_iec559 = true;
  static const bool is_bounded = true;
  static const bool is_modulo = false;

  static const bool traps = false;

  static const bool tinyness_before = true;



  static const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<double, true> {
protected:
  typedef double type;

  static const bool is_specialized = true;

  static const bool is_signed = true;
  static const int digits = 53;
  static const int digits10 = 15;
  static const int max_digits10 = 2 + (digits * 30103l) / 100000l;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type min() throw() { return 2.2250738585072014e-308; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type max() throw() { return 1.7976931348623157e+308; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type lowest() throw() { return -max(); }

  static const bool is_integer = false;
  static const bool is_exact = false;
  static const int radix = 2;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type epsilon() throw() { return 2.2204460492503131e-16; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type round_error() throw() { return 0.5; }

  static const int min_exponent = (-1021);
  static const int min_exponent10 = (-307);
  static const int max_exponent = 1024;
  static const int max_exponent10 = 308;

  static const bool has_infinity = true;
  static const bool has_quiet_NaN = true;
  static const bool has_signaling_NaN = true;
  static const float_denorm_style has_denorm = denorm_present;
  static const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type infinity() throw() { return __builtin_huge_val(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type quiet_NaN() throw() { return __builtin_nan(""); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type signaling_NaN() throw() { return __builtin_nans(""); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type denorm_min() throw() { return 4.9406564584124654e-324; }

  static const bool is_iec559 = true;
  static const bool is_bounded = true;
  static const bool is_modulo = false;

  static const bool traps = false;

  static const bool tinyness_before = true;



  static const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<long double, true> {
protected:
  typedef long double type;

  static const bool is_specialized = true;

  static const bool is_signed = true;
  static const int digits = 53;
  static const int digits10 = 15;
  static const int max_digits10 = 2 + (digits * 30103l) / 100000l;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type min() throw() { return 2.2250738585072014e-308L; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type max() throw() { return 1.7976931348623157e+308L; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type lowest() throw() { return -max(); }

  static const bool is_integer = false;
  static const bool is_exact = false;
  static const int radix = 2;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type epsilon() throw() { return 2.2204460492503131e-16L; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type round_error() throw() { return 0.5L; }

  static const int min_exponent = (-1021);
  static const int min_exponent10 = (-307);
  static const int max_exponent = 1024;
  static const int max_exponent10 = 308;

  static const bool has_infinity = true;
  static const bool has_quiet_NaN = true;
  static const bool has_signaling_NaN = true;
  static const float_denorm_style has_denorm = denorm_present;
  static const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type infinity() throw() { return __builtin_huge_vall(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type quiet_NaN() throw() { return __builtin_nanl(""); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type signaling_NaN() throw() { return __builtin_nansl(""); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type denorm_min() throw() { return 4.9406564584124654e-324L; }




  static const bool is_iec559 = true;

  static const bool is_bounded = true;
  static const bool is_modulo = false;

  static const bool traps = false;

  static const bool tinyness_before = true;



  static const float_round_style round_style = round_to_nearest;
};

template <class _Tp>
class numeric_limits : private __libcpp_numeric_limits<__remove_cv_t<_Tp> > {
  typedef __libcpp_numeric_limits<__remove_cv_t<_Tp> > __base;
  typedef typename __base::type type;

public:
  static const bool is_specialized = __base::is_specialized;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type min() throw() { return __base::min(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type max() throw() { return __base::max(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type lowest() throw() { return __base::lowest(); }

  static const int digits = __base::digits;
  static const int digits10 = __base::digits10;
  static const int max_digits10 = __base::max_digits10;
  static const bool is_signed = __base::is_signed;
  static const bool is_integer = __base::is_integer;
  static const bool is_exact = __base::is_exact;
  static const int radix = __base::radix;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type epsilon() throw() { return __base::epsilon(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type round_error() throw() { return __base::round_error(); }

  static const int min_exponent = __base::min_exponent;
  static const int min_exponent10 = __base::min_exponent10;
  static const int max_exponent = __base::max_exponent;
  static const int max_exponent10 = __base::max_exponent10;

  static const bool has_infinity = __base::has_infinity;
  static const bool has_quiet_NaN = __base::has_quiet_NaN;
  static const bool has_signaling_NaN = __base::has_signaling_NaN;
#pragma GCC diagnostic push
# 467 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 467 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  static const float_denorm_style has_denorm = __base::has_denorm;
  static const bool has_denorm_loss = __base::has_denorm_loss;
#pragma GCC diagnostic pop
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type infinity() throw() { return __base::infinity(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type quiet_NaN() throw() { return __base::quiet_NaN(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type signaling_NaN() throw() { return __base::signaling_NaN(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type denorm_min() throw() { return __base::denorm_min(); }

  static const bool is_iec559 = __base::is_iec559;
  static const bool is_bounded = __base::is_bounded;
  static const bool is_modulo = __base::is_modulo;

  static const bool traps = __base::traps;
  static const bool tinyness_before = __base::tinyness_before;
  static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                  const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp>
                  const int numeric_limits<_Tp>::digits;
template <class _Tp>
                  const int numeric_limits<_Tp>::digits10;
template <class _Tp>
                  const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
                  const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
                  const bool numeric_limits<_Tp>::is_integer;
template <class _Tp>
                  const bool numeric_limits<_Tp>::is_exact;
template <class _Tp>
                  const int numeric_limits<_Tp>::radix;
template <class _Tp>
                  const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
                  const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
                  const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
                  const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
                  const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
                  const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
                  const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
                  const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
                  const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
                  const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
                  const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
                  const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp>
                  const bool numeric_limits<_Tp>::traps;
template <class _Tp>
                  const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
                  const float_round_style numeric_limits<_Tp>::round_style;

template <class _Tp>
class numeric_limits<const _Tp> : private numeric_limits<_Tp> {
  typedef numeric_limits<_Tp> __base;
  typedef _Tp type;

public:
  static const bool is_specialized = __base::is_specialized;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type min() throw() { return __base::min(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type max() throw() { return __base::max(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type lowest() throw() { return __base::lowest(); }

  static const int digits = __base::digits;
  static const int digits10 = __base::digits10;
  static const int max_digits10 = __base::max_digits10;
  static const bool is_signed = __base::is_signed;
  static const bool is_integer = __base::is_integer;
  static const bool is_exact = __base::is_exact;
  static const int radix = __base::radix;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type epsilon() throw() { return __base::epsilon(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type round_error() throw() { return __base::round_error(); }

  static const int min_exponent = __base::min_exponent;
  static const int min_exponent10 = __base::min_exponent10;
  static const int max_exponent = __base::max_exponent;
  static const int max_exponent10 = __base::max_exponent10;

  static const bool has_infinity = __base::has_infinity;
  static const bool has_quiet_NaN = __base::has_quiet_NaN;
  static const bool has_signaling_NaN = __base::has_signaling_NaN;
#pragma GCC diagnostic push
# 561 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 561 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  static const float_denorm_style has_denorm = __base::has_denorm;
  static const bool has_denorm_loss = __base::has_denorm_loss;
#pragma GCC diagnostic pop
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type infinity() throw() { return __base::infinity(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type quiet_NaN() throw() { return __base::quiet_NaN(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type signaling_NaN() throw() { return __base::signaling_NaN(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type denorm_min() throw() { return __base::denorm_min(); }

  static const bool is_iec559 = __base::is_iec559;
  static const bool is_bounded = __base::is_bounded;
  static const bool is_modulo = __base::is_modulo;

  static const bool traps = __base::traps;
  static const bool tinyness_before = __base::tinyness_before;
  static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                  const bool numeric_limits<const _Tp>::is_specialized;
template <class _Tp>
                  const int numeric_limits<const _Tp>::digits;
template <class _Tp>
                  const int numeric_limits<const _Tp>::digits10;
template <class _Tp>
                  const int numeric_limits<const _Tp>::max_digits10;
template <class _Tp>
                  const bool numeric_limits<const _Tp>::is_signed;
template <class _Tp>
                  const bool numeric_limits<const _Tp>::is_integer;
template <class _Tp>
                  const bool numeric_limits<const _Tp>::is_exact;
template <class _Tp>
                  const int numeric_limits<const _Tp>::radix;
template <class _Tp>
                  const int numeric_limits<const _Tp>::min_exponent;
template <class _Tp>
                  const int numeric_limits<const _Tp>::min_exponent10;
template <class _Tp>
                  const int numeric_limits<const _Tp>::max_exponent;
template <class _Tp>
                  const int numeric_limits<const _Tp>::max_exponent10;
template <class _Tp>
                  const bool numeric_limits<const _Tp>::has_infinity;
template <class _Tp>
                  const bool numeric_limits<const _Tp>::has_quiet_NaN;
template <class _Tp>
                  const bool numeric_limits<const _Tp>::has_signaling_NaN;
template <class _Tp>
                  const float_denorm_style numeric_limits<const _Tp>::has_denorm;
template <class _Tp>
                  const bool numeric_limits<const _Tp>::has_denorm_loss;
template <class _Tp>
                  const bool numeric_limits<const _Tp>::is_iec559;
template <class _Tp>
                  const bool numeric_limits<const _Tp>::is_bounded;
template <class _Tp>
                  const bool numeric_limits<const _Tp>::is_modulo;
template <class _Tp>
                  const bool numeric_limits<const _Tp>::traps;
template <class _Tp>
                  const bool numeric_limits<const _Tp>::tinyness_before;
template <class _Tp>
                  const float_round_style numeric_limits<const _Tp>::round_style;

template <class _Tp>
class numeric_limits<volatile _Tp> : private numeric_limits<_Tp> {
  typedef numeric_limits<_Tp> __base;
  typedef _Tp type;

public:
  static const bool is_specialized = __base::is_specialized;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type min() throw() { return __base::min(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type max() throw() { return __base::max(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type lowest() throw() { return __base::lowest(); }

  static const int digits = __base::digits;
  static const int digits10 = __base::digits10;
  static const int max_digits10 = __base::max_digits10;
  static const bool is_signed = __base::is_signed;
  static const bool is_integer = __base::is_integer;
  static const bool is_exact = __base::is_exact;
  static const int radix = __base::radix;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type epsilon() throw() { return __base::epsilon(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type round_error() throw() { return __base::round_error(); }

  static const int min_exponent = __base::min_exponent;
  static const int min_exponent10 = __base::min_exponent10;
  static const int max_exponent = __base::max_exponent;
  static const int max_exponent10 = __base::max_exponent10;

  static const bool has_infinity = __base::has_infinity;
  static const bool has_quiet_NaN = __base::has_quiet_NaN;
  static const bool has_signaling_NaN = __base::has_signaling_NaN;
#pragma GCC diagnostic push
# 655 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 655 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  static const float_denorm_style has_denorm = __base::has_denorm;
  static const bool has_denorm_loss = __base::has_denorm_loss;
#pragma GCC diagnostic pop
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type infinity() throw() { return __base::infinity(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type quiet_NaN() throw() { return __base::quiet_NaN(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type signaling_NaN() throw() { return __base::signaling_NaN(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type denorm_min() throw() { return __base::denorm_min(); }

  static const bool is_iec559 = __base::is_iec559;
  static const bool is_bounded = __base::is_bounded;
  static const bool is_modulo = __base::is_modulo;

  static const bool traps = __base::traps;
  static const bool tinyness_before = __base::tinyness_before;
  static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                  const bool numeric_limits<volatile _Tp>::is_specialized;
template <class _Tp>
                  const int numeric_limits<volatile _Tp>::digits;
template <class _Tp>
                  const int numeric_limits<volatile _Tp>::digits10;
template <class _Tp>
                  const int numeric_limits<volatile _Tp>::max_digits10;
template <class _Tp>
                  const bool numeric_limits<volatile _Tp>::is_signed;
template <class _Tp>
                  const bool numeric_limits<volatile _Tp>::is_integer;
template <class _Tp>
                  const bool numeric_limits<volatile _Tp>::is_exact;
template <class _Tp>
                  const int numeric_limits<volatile _Tp>::radix;
template <class _Tp>
                  const int numeric_limits<volatile _Tp>::min_exponent;
template <class _Tp>
                  const int numeric_limits<volatile _Tp>::min_exponent10;
template <class _Tp>
                  const int numeric_limits<volatile _Tp>::max_exponent;
template <class _Tp>
                  const int numeric_limits<volatile _Tp>::max_exponent10;
template <class _Tp>
                  const bool numeric_limits<volatile _Tp>::has_infinity;
template <class _Tp>
                  const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
template <class _Tp>
                  const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
template <class _Tp>
                  const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
template <class _Tp>
                  const bool numeric_limits<volatile _Tp>::has_denorm_loss;
template <class _Tp>
                  const bool numeric_limits<volatile _Tp>::is_iec559;
template <class _Tp>
                  const bool numeric_limits<volatile _Tp>::is_bounded;
template <class _Tp>
                  const bool numeric_limits<volatile _Tp>::is_modulo;
template <class _Tp>
                  const bool numeric_limits<volatile _Tp>::traps;
template <class _Tp>
                  const bool numeric_limits<volatile _Tp>::tinyness_before;
template <class _Tp>
                  const float_round_style numeric_limits<volatile _Tp>::round_style;

template <class _Tp>
class numeric_limits<const volatile _Tp> : private numeric_limits<_Tp> {
  typedef numeric_limits<_Tp> __base;
  typedef _Tp type;

public:
  static const bool is_specialized = __base::is_specialized;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type min() throw() { return __base::min(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type max() throw() { return __base::max(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type lowest() throw() { return __base::lowest(); }

  static const int digits = __base::digits;
  static const int digits10 = __base::digits10;
  static const int max_digits10 = __base::max_digits10;
  static const bool is_signed = __base::is_signed;
  static const bool is_integer = __base::is_integer;
  static const bool is_exact = __base::is_exact;
  static const int radix = __base::radix;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type epsilon() throw() { return __base::epsilon(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type round_error() throw() { return __base::round_error(); }

  static const int min_exponent = __base::min_exponent;
  static const int min_exponent10 = __base::min_exponent10;
  static const int max_exponent = __base::max_exponent;
  static const int max_exponent10 = __base::max_exponent10;

  static const bool has_infinity = __base::has_infinity;
  static const bool has_quiet_NaN = __base::has_quiet_NaN;
  static const bool has_signaling_NaN = __base::has_signaling_NaN;
#pragma GCC diagnostic push
# 749 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 749 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  static const float_denorm_style has_denorm = __base::has_denorm;
  static const bool has_denorm_loss = __base::has_denorm_loss;
#pragma GCC diagnostic pop
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type infinity() throw() { return __base::infinity(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type quiet_NaN() throw() { return __base::quiet_NaN(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type signaling_NaN() throw() { return __base::signaling_NaN(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static type denorm_min() throw() { return __base::denorm_min(); }

  static const bool is_iec559 = __base::is_iec559;
  static const bool is_bounded = __base::is_bounded;
  static const bool is_modulo = __base::is_modulo;

  static const bool traps = __base::traps;
  static const bool tinyness_before = __base::tinyness_before;
  static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                  const bool numeric_limits<const volatile _Tp>::is_specialized;
template <class _Tp>
                  const int numeric_limits<const volatile _Tp>::digits;
template <class _Tp>
                  const int numeric_limits<const volatile _Tp>::digits10;
template <class _Tp>
                  const int numeric_limits<const volatile _Tp>::max_digits10;
template <class _Tp>
                  const bool numeric_limits<const volatile _Tp>::is_signed;
template <class _Tp>
                  const bool numeric_limits<const volatile _Tp>::is_integer;
template <class _Tp>
                  const bool numeric_limits<const volatile _Tp>::is_exact;
template <class _Tp>
                  const int numeric_limits<const volatile _Tp>::radix;
template <class _Tp>
                  const int numeric_limits<const volatile _Tp>::min_exponent;
template <class _Tp>
                  const int numeric_limits<const volatile _Tp>::min_exponent10;
template <class _Tp>
                  const int numeric_limits<const volatile _Tp>::max_exponent;
template <class _Tp>
                  const int numeric_limits<const volatile _Tp>::max_exponent10;
template <class _Tp>
                  const bool numeric_limits<const volatile _Tp>::has_infinity;
template <class _Tp>
                  const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
template <class _Tp>
                  const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
template <class _Tp>
                  const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
template <class _Tp>
                  const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
template <class _Tp>
                  const bool numeric_limits<const volatile _Tp>::is_iec559;
template <class _Tp>
                  const bool numeric_limits<const volatile _Tp>::is_bounded;
template <class _Tp>
                  const bool numeric_limits<const volatile _Tp>::is_modulo;
template <class _Tp>
                  const bool numeric_limits<const volatile _Tp>::traps;
template <class _Tp>
                  const bool numeric_limits<const volatile _Tp>::tinyness_before;
template <class _Tp>
                  const float_round_style numeric_limits<const volatile _Tp>::round_style;

}}




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 421 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/hash.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/hash.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class>
struct hash;

}}
# 422 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/add_const.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/add_const.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct add_const {
  typedef __attribute__((__nodebug__)) const _Tp type;
};






}}
# 423 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/add_cv.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/add_cv.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct add_cv {
  typedef __attribute__((__nodebug__)) const volatile _Tp type;
};






}}
# 424 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/add_lvalue_reference.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/add_lvalue_reference.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_referenceable.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_referenceable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
struct __libcpp_is_referenceable : integral_constant<bool, __is_referenceable(_Tp)> {};
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_referenceable.h" 3
}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/add_lvalue_reference.h" 2 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/add_lvalue_reference.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
using __add_lvalue_reference_t = __add_lvalue_reference(_Tp);
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/add_lvalue_reference.h" 3
template <class _Tp>
struct add_lvalue_reference {
  using type __attribute__((__nodebug__)) = __add_lvalue_reference_t<_Tp>;
};






}}
# 425 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/add_pointer.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/add_pointer.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_void.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_void.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_void : _BoolConstant<__is_void(_Tp)> {};
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_void.h" 3
}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/add_pointer.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_reference.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_reference.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstddef" 1 3
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstddef" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 1 3
# 82 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_ptrdiff_t.h" 1 3
# 83 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3




# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_size_t.h" 1 3
# 88 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3




# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_rsize_t.h" 1 3
# 18 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_rsize_t.h" 3
typedef long unsigned int rsize_t;
# 93 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3




# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_wchar_t.h" 1 3
# 98 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3
# 107 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_nullptr_t.h" 1 3
# 108 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3
# 122 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_offsetof.h" 1 3
# 123 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 2 3
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstddef" 2 3
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstddef" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::nullptr_t;
using ::ptrdiff_t __attribute__((__using_if_exists__));
using ::size_t __attribute__((__using_if_exists__));





}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_reference.h" 2 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_reference.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
struct remove_reference {
  using type __attribute__((__nodebug__)) = __remove_reference_t(_Tp);
};

template <class _Tp>
using __libcpp_remove_reference_t = __remove_reference_t(_Tp);
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_reference.h" 3
}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/add_pointer.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/add_pointer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
using __add_pointer_t = __add_pointer(_Tp);
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/add_pointer.h" 3
template <class _Tp>
struct add_pointer {
  using type __attribute__((__nodebug__)) = __add_pointer_t<_Tp>;
};






}}
# 426 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/add_rvalue_reference.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/add_rvalue_reference.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
using __add_rvalue_reference_t = __add_rvalue_reference(_Tp);
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/add_rvalue_reference.h" 3
template <class _Tp>
struct add_rvalue_reference {
  using type = __add_rvalue_reference_t<_Tp>;
};






}}
# 427 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/add_volatile.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/add_volatile.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct add_volatile {
  typedef __attribute__((__nodebug__)) volatile _Tp type;
};






}}
# 428 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/aligned_storage.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/aligned_storage.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/conditional.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/conditional.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <bool>
struct _IfImpl;

template <>
struct _IfImpl<true> {
  template <class _IfRes, class _ElseRes>
  using _Select __attribute__((__nodebug__)) = _IfRes;
};

template <>
struct _IfImpl<false> {
  template <class _IfRes, class _ElseRes>
  using _Select __attribute__((__nodebug__)) = _ElseRes;
};

template <bool _Cond, class _IfRes, class _ElseRes>
using _If __attribute__((__nodebug__)) = typename _IfImpl<_Cond>::template _Select<_IfRes, _ElseRes>;

template <bool _Bp, class _If, class _Then>
struct conditional {
  using type __attribute__((__nodebug__)) = _If;
};
template <class _If, class _Then>
struct conditional<false, _If, _Then> {
  using type __attribute__((__nodebug__)) = _Then;
};







template <bool _Bp, class _If, class _Then>
using __conditional_t __attribute__((__nodebug__)) = typename conditional<_Bp, _If, _Then>::type;

}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/aligned_storage.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/nat.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/nat.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct __nat {






};

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/aligned_storage.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/type_list.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/type_list.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Hp, class _Tp>
struct __type_list {
  typedef _Hp _Head;
  typedef _Tp _Tail;
};

template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)>
struct __find_first;

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true> {
  typedef __attribute__((__nodebug__)) _Hp type;
};

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false> {
  typedef __attribute__((__nodebug__)) typename __find_first<_Tp, _Size>::type type;
};

}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/aligned_storage.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/aligned_storage.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __align_type {
  static const size_t value = __alignof(_Tp);
  typedef _Tp type;
};

struct __struct_double {
  long double __lx;
};
struct __struct_double4 {
  double __lx[4];
};


typedef __type_list<__align_type<unsigned char>,
        __type_list<__align_type<unsigned short>,
        __type_list<__align_type<unsigned int>,
        __type_list<__align_type<unsigned long>,
        __type_list<__align_type<unsigned long long>,
        __type_list<__align_type<double>,
        __type_list<__align_type<long double>,
        __type_list<__align_type<__struct_double>,
        __type_list<__align_type<__struct_double4>,
        __type_list<__align_type<int*>,
        __nat
        > > > > > > > > > > __all_types;


template <size_t _Align>
struct __attribute__((__aligned__(_Align))) __fallback_overaligned {};

template <class _TL, size_t _Align>
struct __find_pod;

template <class _Hp, size_t _Align>
struct __find_pod<__type_list<_Hp, __nat>, _Align> {
  typedef __conditional_t<_Align == _Hp::value, typename _Hp::type, __fallback_overaligned<_Align> > type;
};

template <class _Hp, class _Tp, size_t _Align>
struct __find_pod<__type_list<_Hp, _Tp>, _Align> {
  typedef __conditional_t<_Align == _Hp::value, typename _Hp::type, typename __find_pod<_Tp, _Align>::type> type;
};

template <class _TL, size_t _Len>
struct __find_max_align;

template <class _Hp, size_t _Len>
struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};

template <size_t _Len, size_t _A1, size_t _A2>
struct __select_align {
private:
  static const size_t __min = _A2 < _A1 ? _A2 : _A1;
  static const size_t __max = _A1 < _A2 ? _A2 : _A1;

public:
  static const size_t value = _Len < __max ? __min : __max;
};

template <class _Hp, class _Tp, size_t _Len>
struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};

template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
struct aligned_storage {
  typedef typename __find_pod<__all_types, _Align>::type _Aligner;
  union type {
    _Aligner __align;
    unsigned char __data[(_Len + _Align - 1) / _Align * _Align];
  };
};
# 115 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/aligned_storage.h" 3
template <size_t _Len> struct aligned_storage<_Len, 0x1> { struct __attribute__((__aligned__(0x1))) type { unsigned char __lx[(_Len + 0x1 - 1) / 0x1 * 0x1]; }; };
template <size_t _Len> struct aligned_storage<_Len, 0x2> { struct __attribute__((__aligned__(0x2))) type { unsigned char __lx[(_Len + 0x2 - 1) / 0x2 * 0x2]; }; };
template <size_t _Len> struct aligned_storage<_Len, 0x4> { struct __attribute__((__aligned__(0x4))) type { unsigned char __lx[(_Len + 0x4 - 1) / 0x4 * 0x4]; }; };
template <size_t _Len> struct aligned_storage<_Len, 0x8> { struct __attribute__((__aligned__(0x8))) type { unsigned char __lx[(_Len + 0x8 - 1) / 0x8 * 0x8]; }; };
template <size_t _Len> struct aligned_storage<_Len, 0x10> { struct __attribute__((__aligned__(0x10))) type { unsigned char __lx[(_Len + 0x10 - 1) / 0x10 * 0x10]; }; };
template <size_t _Len> struct aligned_storage<_Len, 0x20> { struct __attribute__((__aligned__(0x20))) type { unsigned char __lx[(_Len + 0x20 - 1) / 0x20 * 0x20]; }; };
template <size_t _Len> struct aligned_storage<_Len, 0x40> { struct __attribute__((__aligned__(0x40))) type { unsigned char __lx[(_Len + 0x40 - 1) / 0x40 * 0x40]; }; };
template <size_t _Len> struct aligned_storage<_Len, 0x80> { struct __attribute__((__aligned__(0x80))) type { unsigned char __lx[(_Len + 0x80 - 1) / 0x80 * 0x80]; }; };
template <size_t _Len> struct aligned_storage<_Len, 0x100> { struct __attribute__((__aligned__(0x100))) type { unsigned char __lx[(_Len + 0x100 - 1) / 0x100 * 0x100]; }; };
template <size_t _Len> struct aligned_storage<_Len, 0x200> { struct __attribute__((__aligned__(0x200))) type { unsigned char __lx[(_Len + 0x200 - 1) / 0x200 * 0x200]; }; };
template <size_t _Len> struct aligned_storage<_Len, 0x400> { struct __attribute__((__aligned__(0x400))) type { unsigned char __lx[(_Len + 0x400 - 1) / 0x400 * 0x400]; }; };
template <size_t _Len> struct aligned_storage<_Len, 0x800> { struct __attribute__((__aligned__(0x800))) type { unsigned char __lx[(_Len + 0x800 - 1) / 0x800 * 0x800]; }; };
template <size_t _Len> struct aligned_storage<_Len, 0x1000> { struct __attribute__((__aligned__(0x1000))) type { unsigned char __lx[(_Len + 0x1000 - 1) / 0x1000 * 0x1000]; }; };
template <size_t _Len> struct aligned_storage<_Len, 0x2000> { struct __attribute__((__aligned__(0x2000))) type { unsigned char __lx[(_Len + 0x2000 - 1) / 0x2000 * 0x2000]; }; };


template <size_t _Len> struct aligned_storage<_Len, 0x4000> { struct __attribute__((__aligned__(0x4000))) type { unsigned char __lx[(_Len + 0x4000 - 1) / 0x4000 * 0x4000]; }; };




}}
# 429 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/aligned_union.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/aligned_union.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <size_t _I0, size_t... _In>
struct __static_max;

template <size_t _I0>
struct __static_max<_I0> {
  static const size_t value = _I0;
};

template <size_t _I0, size_t _I1, size_t... _In>
struct __static_max<_I0, _I1, _In...> {
  static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value : __static_max<_I1, _In...>::value;
};

template <size_t _Len, class _Type0, class... _Types>
struct aligned_union {
  static const size_t alignment_value =
      __static_max<__alignof(_Type0), __alignof(_Types)...>::value;
  static const size_t __len = __static_max<_Len, sizeof(_Type0), sizeof(_Types)...>::value;
  typedef typename aligned_storage<__len, alignment_value>::type type;
};






}}
# 430 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/alignment_of.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/alignment_of.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct alignment_of : public integral_constant<size_t, _Alignof(_Tp)> {};






}}
# 431 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/apply_cv.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/apply_cv.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_const.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_const.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_const : _BoolConstant<__is_const(_Tp)> {};
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_const.h" 3
}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/apply_cv.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_volatile.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_volatile.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_volatile : _BoolConstant<__is_volatile(_Tp)> {};
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_volatile.h" 3
}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/apply_cv.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/apply_cv.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp,
          bool = is_const<__libcpp_remove_reference_t<_Tp> >::value,
          bool = is_volatile<__libcpp_remove_reference_t<_Tp> >::value>
struct __apply_cv_impl {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = _Up;
};

template <class _Tp>
struct __apply_cv_impl<_Tp, true, false> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = const _Up;
};

template <class _Tp>
struct __apply_cv_impl<_Tp, false, true> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = volatile _Up;
};

template <class _Tp>
struct __apply_cv_impl<_Tp, true, true> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = const volatile _Up;
};

template <class _Tp>
struct __apply_cv_impl<_Tp&, false, false> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = _Up&;
};

template <class _Tp>
struct __apply_cv_impl<_Tp&, true, false> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = const _Up&;
};

template <class _Tp>
struct __apply_cv_impl<_Tp&, false, true> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = volatile _Up&;
};

template <class _Tp>
struct __apply_cv_impl<_Tp&, true, true> {
  template <class _Up>
  using __apply __attribute__((__nodebug__)) = const volatile _Up&;
};

template <class _Tp, class _Up>
using __apply_cv_t __attribute__((__nodebug__)) = typename __apply_cv_impl<_Tp>::template __apply<_Up>;

}}
# 432 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/can_extract_key.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/can_extract_key.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/pair.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/pair.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class, class>
struct pair;

}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/can_extract_key.h" 2 3




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_const_ref.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_const_ref.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
using __remove_const_ref_t = __remove_const_t<__libcpp_remove_reference_t<_Tp> >;

}}
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/can_extract_key.h" 2 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/can_extract_key.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


struct __extract_key_fail_tag {};
struct __extract_key_self_tag {};
struct __extract_key_first_tag {};

template <class _ValTy, class _Key, class _RawValTy = __remove_const_ref_t<_ValTy> >
struct __can_extract_key
    : __conditional_t<_IsSame<_RawValTy, _Key>::value, __extract_key_self_tag, __extract_key_fail_tag> {};

template <class _Pair, class _Key, class _First, class _Second>
struct __can_extract_key<_Pair, _Key, pair<_First, _Second> >
    : __conditional_t<_IsSame<__remove_const_t<_First>, _Key>::value, __extract_key_first_tag, __extract_key_fail_tag> {
};




template <class _ValTy, class _Key, class _ContainerValueTy, class _RawValTy = __remove_const_ref_t<_ValTy> >
struct __can_extract_map_key : integral_constant<bool, _IsSame<_RawValTy, _Key>::value> {};



template <class _ValTy, class _Key, class _RawValTy>
struct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy> : false_type {};

}}
# 433 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/common_reference.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/common_reference.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/common_type.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/common_type.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/decay.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/decay.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_array.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_array.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_array.h" 3
template <class _Tp>
struct is_array : public false_type {};
template <class _Tp>
struct is_array<_Tp[]> : public true_type {};
template <class _Tp, size_t _Np>
struct is_array<_Tp[_Np]> : public true_type {};
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_array.h" 3
}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/decay.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_function.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_function.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_reference.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_reference.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_lvalue_reference : _BoolConstant<__is_lvalue_reference(_Tp)> {};

template <class _Tp>
struct is_rvalue_reference : _BoolConstant<__is_rvalue_reference(_Tp)> {};

template <class _Tp>
struct is_reference : _BoolConstant<__is_reference(_Tp)> {};
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_reference.h" 3
}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_function.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_function.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_function : integral_constant<bool, __is_function(_Tp)> {};
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_function.h" 3
}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/decay.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_extent.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_extent.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
struct remove_extent {
  using type __attribute__((__nodebug__)) = __remove_extent(_Tp);
};

template <class _Tp>
using __remove_extent_t = __remove_extent(_Tp);
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_extent.h" 3
}}
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/decay.h" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/decay.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
using __decay_t __attribute__((__nodebug__)) = __decay(_Tp);

template <class _Tp>
struct decay {
  using type __attribute__((__nodebug__)) = __decay_t<_Tp>;
};
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/decay.h" 3
}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/common_type.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_cvref.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_cvref.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
using __remove_cvref_t __attribute__((__nodebug__)) = __remove_cvref(_Tp);





template <class _Tp, class _Up>
struct __is_same_uncvref : _IsSame<__remove_cvref_t<_Tp>, __remove_cvref_t<_Up> > {};
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_cvref.h" 3
}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/common_type.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/void_t.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/void_t.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {






template <class...>
using __void_t = void;

}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/common_type.h" 2 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/common_type.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/common_type.h" 3
template <class _Tp, class _Up, class = void>
struct __common_type2_imp {};



template <class _Tp, class _Up>
struct __common_type2_imp<_Tp, _Up, __void_t<__decltype(true ? std::declval<_Tp>() : std::declval<_Up>())> > {
  typedef __attribute__((__nodebug__)) __decay_t<__decltype(true ? std::declval<_Tp>() : std::declval<_Up>())> type;
};

template <class, class = void>
struct __common_type_impl {};

template <class... _Tp>
struct __common_types;
template <class... _Tp>
struct common_type;

template <class _Tp, class _Up>
struct __common_type_impl< __common_types<_Tp, _Up>, __void_t<typename common_type<_Tp, _Up>::type> > {
  typedef typename common_type<_Tp, _Up>::type type;
};

template <class _Tp, class _Up, class _Vp, class... _Rest>
struct __common_type_impl<__common_types<_Tp, _Up, _Vp, _Rest...>, __void_t<typename common_type<_Tp, _Up>::type> >
    : __common_type_impl<__common_types<typename common_type<_Tp, _Up>::type, _Vp, _Rest...> > {};



template <>
struct common_type<> {};



template <class _Tp>
struct common_type<_Tp> : public common_type<_Tp, _Tp> {};




template <class _Tp, class _Up>
struct common_type<_Tp, _Up>
    : conditional<_IsSame<_Tp, __decay_t<_Tp> >::value && _IsSame<_Up, __decay_t<_Up> >::value,
                  __common_type2_imp<_Tp, _Up>,
                  common_type<__decay_t<_Tp>, __decay_t<_Up> > >::type {};



template <class _Tp, class _Up, class _Vp, class... _Rest>
struct common_type<_Tp, _Up, _Vp, _Rest...>
    : __common_type_impl<__common_types<_Tp, _Up, _Vp, _Rest...> > {};






}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/common_reference.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/copy_cv.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/copy_cv.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _From, class _To>
struct __copy_cv {
  using type = _To;
};

template <class _From, class _To>
struct __copy_cv<const _From, _To> {
  using type = typename add_const<_To>::type;
};

template <class _From, class _To>
struct __copy_cv<volatile _From, _To> {
  using type = typename add_volatile<_To>::type;
};

template <class _From, class _To>
struct __copy_cv<const volatile _From, _To> {
  using type = typename add_cv<_To>::type;
};

template <class _From, class _To>
using __copy_cv_t = typename __copy_cv<_From, _To>::type;

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/common_reference.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/copy_cvref.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/copy_cvref.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _From, class _To>
struct __copy_cvref {
  using type = __copy_cv_t<_From, _To>;
};

template <class _From, class _To>
struct __copy_cvref<_From&, _To> {
  using type = __add_lvalue_reference_t<__copy_cv_t<_From, _To> >;
};

template <class _From, class _To>
struct __copy_cvref<_From&&, _To> {
  using type = __add_rvalue_reference_t<__copy_cv_t<_From, _To> >;
};

template <class _From, class _To>
using __copy_cvref_t = typename __copy_cvref<_From, _To>::type;

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/common_reference.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_convertible.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_convertible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _T1, class _T2>
struct is_convertible : public integral_constant<bool, __is_convertible(_T1, _T2)> {};






}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/common_reference.h" 2 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/common_reference.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 191 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/common_reference.h" 3
}}
# 434 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/conjunction.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/conjunction.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class...>
using __expand_to_true = true_type;

template <class... _Pred>
__expand_to_true<__enable_if_t<_Pred::value>...> __and_helper(int);

template <class...>
false_type __and_helper(...);






template <class... _Pred>
using _And __attribute__((__nodebug__)) = __decltype(std::__and_helper<_Pred...>(0));
# 56 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/conjunction.h" 3
}}
# 437 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/dependent_type.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/dependent_type.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, bool>
struct __dependent_type : public _Tp {};

}}
# 439 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/disjunction.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/disjunction.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <bool>
struct _OrImpl;

template <>
struct _OrImpl<true> {
  template <class _Res, class _First, class... _Rest>
  using _Result __attribute__((__nodebug__)) =
      typename _OrImpl<!bool(_First::value) && sizeof...(_Rest) != 0>::template _Result<_First, _Rest...>;
};

template <>
struct _OrImpl<false> {
  template <class _Res, class...>
  using _Result = _Res;
};







template <class... _Args>
using _Or __attribute__((__nodebug__)) = typename _OrImpl<sizeof...(_Args) != 0>::template _Result<false_type, _Args...>;
# 56 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/disjunction.h" 3
}}
# 440 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/extent.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/extent.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp, size_t _Dim = 0>
struct extent : integral_constant<size_t, __array_extent(_Tp, _Dim)> {};
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/extent.h" 3
}}
# 442 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/has_unique_object_representation.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/has_unique_object_representation.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_all_extents.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_all_extents.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
struct remove_all_extents {
  using type __attribute__((__nodebug__)) = __remove_all_extents(_Tp);
};

template <class _Tp>
using __remove_all_extents_t = __remove_all_extents(_Tp);
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_all_extents.h" 3
}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/has_unique_object_representation.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/has_unique_object_representation.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/has_unique_object_representation.h" 3
}}
# 443 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/has_virtual_destructor.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/has_virtual_destructor.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct has_virtual_destructor : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};






}}
# 444 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/invoke.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/invoke.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_base_of.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_base_of.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Bp, class _Dp>
struct is_base_of : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};






}}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/invoke.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_core_convertible.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_core_convertible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {






template <class _Tp, class _Up, class = void>
struct __is_core_convertible : public false_type {};

template <class _Tp, class _Up>
struct __is_core_convertible<_Tp, _Up, __decltype(static_cast<void (*)(_Up)>(0)(static_cast<_Tp (*)()>(0)()))>
    : public true_type {};

}}
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/invoke.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_member_function_pointer.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_member_function_pointer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __libcpp_is_member_pointer {
  enum { __is_member = false, __is_func = false, __is_obj = false };
};
template <class _Tp, class _Up>
struct __libcpp_is_member_pointer<_Tp _Up::*> {
  enum {
    __is_member = true,
    __is_func = is_function<_Tp>::value,
    __is_obj = !__is_func,
  };
};



template <class _Tp>
struct is_member_function_pointer : _BoolConstant<__is_member_function_pointer(_Tp)> {};
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_member_function_pointer.h" 3
}}
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/invoke.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_member_object_pointer.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_member_object_pointer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_member_object_pointer : _BoolConstant<__is_member_object_pointer(_Tp)> {};
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_member_object_pointer.h" 3
}}
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/invoke.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_reference_wrapper.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_reference_wrapper.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
class reference_wrapper;

template <class _Tp>
struct __is_reference_wrapper_impl : public false_type {};
template <class _Tp>
struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
template <class _Tp>
struct __is_reference_wrapper : public __is_reference_wrapper_impl<__remove_cv_t<_Tp> > {};

}}
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/invoke.h" 2 3





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/forward.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/forward.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp&&
forward( __libcpp_remove_reference_t<_Tp>& __t) throw() {
  return static_cast<_Tp&&>(__t);
}

template <class _Tp>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp&&
forward( __libcpp_remove_reference_t<_Tp>&& __t) throw() {
  _Static_assert(!is_lvalue_reference<_Tp>::value, "cannot forward an rvalue as an lvalue");
  return static_cast<_Tp&&>(__t);
}

}}
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/invoke.h" 2 3
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/invoke.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct __any {
  __any(...);
};

template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
struct __member_pointer_traits_imp {};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false> {
  typedef _Class _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false> {
  typedef _Class _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false> {
  typedef _Class const _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false> {
  typedef _Class const _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false> {
  typedef _Class volatile _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false> {
  typedef _Class volatile _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false> {
  typedef _Class const volatile _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false> {
  typedef _Class const volatile _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...)&, true, false> {
  typedef _Class& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...)&, true, false> {
  typedef _Class& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false> {
  typedef _Class const& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false> {
  typedef _Class const& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false> {
  typedef _Class volatile& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false> {
  typedef _Class volatile& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false> {
  typedef _Class const volatile& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false> {
  typedef _Class const volatile& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...)&&, true, false> {
  typedef _Class&& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...)&&, true, false> {
  typedef _Class&& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false> {
  typedef _Class const&& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false> {
  typedef _Class const&& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false> {
  typedef _Class volatile&& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false> {
  typedef _Class volatile&& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false> {
  typedef _Class const volatile&& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false> {
  typedef _Class const volatile&& _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp _Class::*, false, true> {
  typedef _Class _ClassType;
  typedef _Rp _ReturnType;
};

template <class _MP>
struct __member_pointer_traits
    : public __member_pointer_traits_imp<__remove_cv_t<_MP>,
                                         is_member_function_pointer<_MP>::value,
                                         is_member_object_pointer<_MP>::value> {



};

template <class _DecayedFp>
struct __member_pointer_class_type {};

template <class _Ret, class _ClassType>
struct __member_pointer_class_type<_Ret _ClassType::*> {
  typedef _ClassType type;
};

template <class _Fp,
          class _A0,
          class _DecayFp = __decay_t<_Fp>,
          class _DecayA0 = __decay_t<_A0>,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet1 =
    __enable_if_t<is_member_function_pointer<_DecayFp>::value &&
                  (is_same<_ClassT, _DecayA0>::value || is_base_of<_ClassT, _DecayA0>::value)>;

template <class _Fp, class _A0, class _DecayFp = __decay_t<_Fp>, class _DecayA0 = __decay_t<_A0> >
using __enable_if_bullet2 =
    __enable_if_t<is_member_function_pointer<_DecayFp>::value && __is_reference_wrapper<_DecayA0>::value>;

template <class _Fp,
          class _A0,
          class _DecayFp = __decay_t<_Fp>,
          class _DecayA0 = __decay_t<_A0>,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet3 =
    __enable_if_t<is_member_function_pointer<_DecayFp>::value &&
                  !(is_same<_ClassT, _DecayA0>::value || is_base_of<_ClassT, _DecayA0>::value) &&
                  !__is_reference_wrapper<_DecayA0>::value>;

template <class _Fp,
          class _A0,
          class _DecayFp = __decay_t<_Fp>,
          class _DecayA0 = __decay_t<_A0>,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet4 =
    __enable_if_t<is_member_object_pointer<_DecayFp>::value &&
                  (is_same<_ClassT, _DecayA0>::value || is_base_of<_ClassT, _DecayA0>::value)>;

template <class _Fp, class _A0, class _DecayFp = __decay_t<_Fp>, class _DecayA0 = __decay_t<_A0> >
using __enable_if_bullet5 =
    __enable_if_t<is_member_object_pointer<_DecayFp>::value && __is_reference_wrapper<_DecayA0>::value>;

template <class _Fp,
          class _A0,
          class _DecayFp = __decay_t<_Fp>,
          class _DecayA0 = __decay_t<_A0>,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet6 =
    __enable_if_t<is_member_object_pointer<_DecayFp>::value &&
                  !(is_same<_ClassT, _DecayA0>::value || is_base_of<_ClassT, _DecayA0>::value) &&
                  !__is_reference_wrapper<_DecayA0>::value>;





template <class... _Args>
__nat __invoke(__any, _Args&&... __args);




template <class _Fp, class _A0, class... _Args, class = __enable_if_bullet1<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
__decltype((std::declval<_A0>().*std::declval<_Fp>())(std::declval<_Args>()...))
__invoke(_Fp&& __f, _A0&& __a0, _Args&&... __args)

               { return (static_cast<_A0&&>(__a0).*__f)(static_cast<_Args&&>(__args)...); }

template <class _Fp, class _A0, class... _Args, class = __enable_if_bullet2<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
__decltype((std::declval<_A0>().get().*std::declval<_Fp>())(std::declval<_Args>()...))
__invoke(_Fp&& __f, _A0&& __a0, _Args&&... __args)

               { return (__a0.get().*__f)(static_cast<_Args&&>(__args)...); }

template <class _Fp, class _A0, class... _Args, class = __enable_if_bullet3<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
__decltype(((*std::declval<_A0>()).*std::declval<_Fp>())(std::declval<_Args>()...))
__invoke(_Fp&& __f, _A0&& __a0, _Args&&... __args)

               { return ((*static_cast<_A0&&>(__a0)).*__f)(static_cast<_Args&&>(__args)...); }



template <class _Fp, class _A0, class = __enable_if_bullet4<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
__decltype(std::declval<_A0>().*std::declval<_Fp>())
__invoke(_Fp&& __f, _A0&& __a0)

               { return static_cast<_A0&&>(__a0).*__f; }

template <class _Fp, class _A0, class = __enable_if_bullet5<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
__decltype(std::declval<_A0>().get().*std::declval<_Fp>())
__invoke(_Fp&& __f, _A0&& __a0)

               { return __a0.get().*__f; }

template <class _Fp, class _A0, class = __enable_if_bullet6<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
__decltype((*std::declval<_A0>()).*std::declval<_Fp>())
__invoke(_Fp&& __f, _A0&& __a0)

               { return (*static_cast<_A0&&>(__a0)).*__f; }



template <class _Fp, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
__decltype(std::declval<_Fp>()(std::declval<_Args>()...))
__invoke(_Fp&& __f, _Args&&... __args)

               { return static_cast<_Fp&&>(__f)(static_cast<_Args&&>(__args)...); }



template <class _Ret, class _Fp, class... _Args>
struct __invokable_r {
  template <class _XFp, class... _XArgs>
  static __decltype(std::__invoke(std::declval<_XFp>(), std::declval<_XArgs>()...)) __try_call(int);
  template <class _XFp, class... _XArgs>
  static __nat __try_call(...);



  using _Result = __decltype(__try_call<_Fp, _Args...>(0));

  using type = __conditional_t<_IsNotSame<_Result, __nat>::value,
                               __conditional_t<is_void<_Ret>::value, true_type, __is_core_convertible<_Result, _Ret> >,
                               false_type>;
  static const bool value = type::value;
};
template <class _Fp, class... _Args>
using __invokable = __invokable_r<void, _Fp, _Args...>;

template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class... _Args>
struct __nothrow_invokable_r_imp {
  static const bool value = false;
};

template <class _Ret, class _Fp, class... _Args>
struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...> {
  typedef __nothrow_invokable_r_imp _ThisT;

  template <class _Tp>
  static void __test_noexcept(_Tp) throw();


  static const bool value = false;




};

template <class _Ret, class _Fp, class... _Args>
struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...> {

  static const bool value = false;



};

template <class _Ret, class _Fp, class... _Args>
using __nothrow_invokable_r =
    __nothrow_invokable_r_imp<__invokable_r<_Ret, _Fp, _Args...>::value, is_void<_Ret>::value, _Ret, _Fp, _Args...>;

template <class _Fp, class... _Args>
using __nothrow_invokable = __nothrow_invokable_r_imp<__invokable<_Fp, _Args...>::value, true, void, _Fp, _Args...>;

template <class _Fp, class... _Args>
struct __invoke_of
    : public enable_if<__invokable<_Fp, _Args...>::value, typename __invokable_r<void, _Fp, _Args...>::_Result> {};

template <class _Ret, bool = is_void<_Ret>::value>
struct __invoke_void_return_wrapper {
  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static _Ret __call(_Args&&... __args) {
    return std::__invoke(std::forward<_Args>(__args)...);
  }
};

template <class _Ret>
struct __invoke_void_return_wrapper<_Ret, true> {
  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static void __call(_Args&&... __args) {
    std::__invoke(std::forward<_Args>(__args)...);
  }
};
# 463 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/invoke.h" 3
}}
# 446 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_abstract.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_abstract.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_abstract : public integral_constant<bool, __is_abstract(_Tp)> {};






}}
# 447 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_aggregate.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_aggregate.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_aggregate.h" 3
}}
# 448 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_assignable.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_assignable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Up>
struct is_assignable : _BoolConstant<__is_assignable(_Tp, _Up)> {};






}}
# 451 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_bounded_array.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_bounded_array.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class>
struct __libcpp_is_bounded_array : false_type {};
template <class _Tp, size_t _Np>
struct __libcpp_is_bounded_array<_Tp[_Np]> : true_type {};
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_bounded_array.h" 3
}}
# 453 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_callable.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_callable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Func, class... _Args, class = __decltype(std::declval<_Func>()(std::declval<_Args>()...))>
true_type __is_callable_helper(int);
template <class...>
false_type __is_callable_helper(...);

template <class _Func, class... _Args>
struct __is_callable : __decltype(std::__is_callable_helper<_Func, _Args...>(0)) {};

}}
# 454 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_char_like_type.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_char_like_type.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_standard_layout.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_standard_layout.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_standard_layout : public integral_constant<bool, __is_standard_layout(_Tp)> {};






}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_char_like_type.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivial.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivial.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_trivial : public integral_constant<bool, __is_trivial(_Tp)> {};






}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_char_like_type.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_char_like_type.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT>
using _IsCharLikeType = _And<is_standard_layout<_CharT>, is_trivial<_CharT> >;

}}
# 455 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_class.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_class.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_class : public integral_constant<bool, __is_class(_Tp)> {};






}}
# 456 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_compound.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_compound.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_fundamental.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_fundamental.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_null_pointer.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_null_pointer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __is_nullptr_t_impl : public false_type {};
template <>
struct __is_nullptr_t_impl<nullptr_t> : public true_type {};

template <class _Tp>
struct __is_nullptr_t : public __is_nullptr_t_impl<__remove_cv_t<_Tp> > {};
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_null_pointer.h" 3
}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_fundamental.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_fundamental.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_fundamental : _BoolConstant<__is_fundamental(_Tp)> {};
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_fundamental.h" 3
}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_compound.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_compound.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_compound : _BoolConstant<__is_compound(_Tp)> {};
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_compound.h" 3
}}
# 457 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_constructible.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class... _Args>
struct is_constructible : public integral_constant<bool, __is_constructible(_Tp, _Args...)> {};






}}
# 460 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_copy_assignable.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_copy_assignable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_copy_assignable
    : public integral_constant<
          bool,
          __is_assignable(__add_lvalue_reference_t<_Tp>, __add_lvalue_reference_t<typename add_const<_Tp>::type>)> {};






}}
# 462 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_copy_constructible.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_copy_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_copy_constructible
    : public integral_constant<bool, __is_constructible(_Tp, __add_lvalue_reference_t<typename add_const<_Tp>::type>)> {
};






}}
# 463 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_default_constructible.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_default_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_default_constructible : public integral_constant<bool, __is_constructible(_Tp)> {};






}}
# 464 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_destructible.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_destructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_destructible : _BoolConstant<__is_destructible(_Tp)> {};
# 95 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_destructible.h" 3
}}
# 465 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_empty.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_empty.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_empty : public integral_constant<bool, __is_empty(_Tp)> {};






}}
# 466 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_enum.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_enum.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_enum : public integral_constant<bool, __is_enum(_Tp)> {};






}}
# 467 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_final.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_final.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_final.h" 3
}}
# 468 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_implicitly_default_constructible.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_implicitly_default_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_implicitly_default_constructible.h" 3
}}
# 472 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_literal_type.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_literal_type.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)> {};







}}
# 474 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_member_pointer.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_member_pointer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_member_pointer : _BoolConstant<__is_member_pointer(_Tp)> {};
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_member_pointer.h" 3
}}
# 477 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_move_assignable.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_move_assignable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_move_assignable
    : public integral_constant<bool, __is_assignable(__add_lvalue_reference_t<_Tp>, __add_rvalue_reference_t<_Tp>)> {};






}}
# 478 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_move_constructible.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_move_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_move_constructible
    : public integral_constant<bool, __is_constructible(_Tp, __add_rvalue_reference_t<_Tp>)> {};






}}
# 479 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_assignable.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_assignable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Arg>
struct is_nothrow_assignable : public integral_constant<bool, __is_nothrow_assignable(_Tp, _Arg)> {
};






}}
# 480 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_constructible.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




template < class _Tp, class... _Args>
struct is_nothrow_constructible
    : public integral_constant<bool, __is_nothrow_constructible(_Tp, _Args...)> {};
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_constructible.h" 3
}}
# 481 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_convertible.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_convertible.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/lazy.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/lazy.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <template <class...> class _Func, class... _Args>
struct _Lazy : _Func<_Args...> {};

}}
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_convertible.h" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_convertible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 48 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_convertible.h" 3
}}
# 482 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_copy_assignable.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_copy_assignable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_nothrow_copy_assignable
    : public integral_constant<bool,
                               __is_nothrow_assignable(__add_lvalue_reference_t<_Tp>,
                                                       __add_lvalue_reference_t<typename add_const<_Tp>::type>)> {};






}}
# 483 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_copy_constructible.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_copy_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_copy_constructible.h" 3
template <class _Tp>
struct is_nothrow_copy_constructible
    : public integral_constant<
          bool,
          __is_nothrow_constructible(_Tp, typename add_lvalue_reference<typename add_const<_Tp>::type>::type)> {};
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_copy_constructible.h" 3
}}
# 484 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_default_constructible.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_default_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_nothrow_default_constructible
    : public integral_constant<bool, __is_nothrow_constructible(_Tp)> {};






}}
# 485 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_destructible.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_destructible.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_scalar.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_scalar.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_pointer.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_pointer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_pointer : _BoolConstant<__is_pointer(_Tp)> {};
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_pointer.h" 3
}}
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_scalar.h" 2 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_scalar.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_scalar : _BoolConstant<__is_scalar(_Tp)> {};
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_scalar.h" 3
}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_destructible.h" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_destructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 54 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_destructible.h" 3
template <class _Tp>
struct __libcpp_nothrow_destructor : public integral_constant<bool, is_scalar<_Tp>::value || is_reference<_Tp>::value> {
};

template <class _Tp>
struct is_nothrow_destructible : public __libcpp_nothrow_destructor<__remove_all_extents_t<_Tp> > {
};

template <class _Tp>
struct is_nothrow_destructible<_Tp[]> : public false_type {};
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_destructible.h" 3
}}
# 486 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_move_assignable.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_move_assignable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_nothrow_move_assignable
    : public integral_constant<bool,
                               __is_nothrow_assignable(__add_lvalue_reference_t<_Tp>, __add_rvalue_reference_t<_Tp>)> {
};






}}
# 487 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_move_constructible.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_move_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




template <class _Tp>
struct is_nothrow_move_constructible
    : public integral_constant<bool, __is_nothrow_constructible(_Tp, __add_rvalue_reference_t<_Tp>)> {};
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_nothrow_move_constructible.h" 3
}}
# 488 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_object.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_object.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_union.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_union.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_union : public integral_constant<bool, __is_union(_Tp)> {};






}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_object.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_object.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_object : _BoolConstant<__is_object(_Tp)> {};
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_object.h" 3
}}
# 490 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_pod.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_pod.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_pod : public integral_constant<bool, __is_pod(_Tp)> {};






}}
# 491 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_polymorphic.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_polymorphic.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_polymorphic : public integral_constant<bool, __is_polymorphic(_Tp)> {};






}}
# 493 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_scoped_enum.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_scoped_enum.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/underlying_type.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/underlying_type.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, bool = is_enum<_Tp>::value>
struct __underlying_type_impl;

template <class _Tp>
struct __underlying_type_impl<_Tp, false> {};

template <class _Tp>
struct __underlying_type_impl<_Tp, true> {
  typedef __underlying_type(_Tp) type;
};

template <class _Tp>
struct underlying_type : __underlying_type_impl<_Tp, is_enum<_Tp>::value> {};






}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_scoped_enum.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_scoped_enum.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_scoped_enum.h" 3
}}
# 499 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_specialization.h" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_specialization.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_specialization.h" 3
}}
# 501 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_swappable.h" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_swappable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __is_swappable;
template <class _Tp>
struct __is_nothrow_swappable;





template <class>
using __swap_result_t = void;


template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __swap_result_t<_Tp> swap(_Tp& __x, _Tp& __y)
                                                                                                  ;

template <class _Tp, size_t _Np, __enable_if_t<__is_swappable<_Tp>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np])
                                                  ;

namespace __detail {


template <class _Tp, class _Up = _Tp, bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
struct __swappable_with {
  template <class _LHS, class _RHS>
  static __decltype(swap(std::declval<_LHS>(), std::declval<_RHS>())) __test_swap(int);
  template <class, class>
  static __nat __test_swap(long);


  typedef __decltype((__test_swap<_Tp, _Up>(0))) __swap1;
  typedef __decltype((__test_swap<_Up, _Tp>(0))) __swap2;

  static const bool value = _IsNotSame<__swap1, __nat>::value && _IsNotSame<__swap2, __nat>::value;
};

template <class _Tp, class _Up>
struct __swappable_with<_Tp, _Up, false> : false_type {};

template <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>
struct __nothrow_swappable_with {
  static const bool value =




      false;

};

template <class _Tp, class _Up>
struct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};

}

template <class _Tp>
struct __is_swappable : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value> {};

template <class _Tp>
struct __is_nothrow_swappable : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value> {};
# 132 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_swappable.h" 3
}}
# 503 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_assignable.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_assignable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Arg>
struct is_trivially_assignable : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)> {};






}}
# 505 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_constructible.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class... _Args>
struct is_trivially_constructible
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)> {};






}}
# 506 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_copy_assignable.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_copy_assignable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_trivially_copy_assignable
    : public integral_constant<bool,
                               __is_trivially_assignable(__add_lvalue_reference_t<_Tp>,
                                                         __add_lvalue_reference_t<typename add_const<_Tp>::type>)> {};






}}
# 507 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_copy_constructible.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_copy_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_trivially_copy_constructible
    : public integral_constant<bool, __is_trivially_constructible(_Tp, __add_lvalue_reference_t<const _Tp>)> {};






}}
# 508 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_copyable.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_copyable.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdint" 1 3
# 158 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdint" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::int8_t __attribute__((__using_if_exists__));
using ::int16_t __attribute__((__using_if_exists__));
using ::int32_t __attribute__((__using_if_exists__));
using ::int64_t __attribute__((__using_if_exists__));

using ::uint8_t __attribute__((__using_if_exists__));
using ::uint16_t __attribute__((__using_if_exists__));
using ::uint32_t __attribute__((__using_if_exists__));
using ::uint64_t __attribute__((__using_if_exists__));

using ::int_least8_t __attribute__((__using_if_exists__));
using ::int_least16_t __attribute__((__using_if_exists__));
using ::int_least32_t __attribute__((__using_if_exists__));
using ::int_least64_t __attribute__((__using_if_exists__));

using ::uint_least8_t __attribute__((__using_if_exists__));
using ::uint_least16_t __attribute__((__using_if_exists__));
using ::uint_least32_t __attribute__((__using_if_exists__));
using ::uint_least64_t __attribute__((__using_if_exists__));

using ::int_fast8_t __attribute__((__using_if_exists__));
using ::int_fast16_t __attribute__((__using_if_exists__));
using ::int_fast32_t __attribute__((__using_if_exists__));
using ::int_fast64_t __attribute__((__using_if_exists__));

using ::uint_fast8_t __attribute__((__using_if_exists__));
using ::uint_fast16_t __attribute__((__using_if_exists__));
using ::uint_fast32_t __attribute__((__using_if_exists__));
using ::uint_fast64_t __attribute__((__using_if_exists__));

using ::intptr_t __attribute__((__using_if_exists__));
using ::uintptr_t __attribute__((__using_if_exists__));

using ::intmax_t __attribute__((__using_if_exists__));
using ::uintmax_t __attribute__((__using_if_exists__));

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_copyable.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_copyable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_trivially_copyable : public integral_constant<bool, __is_trivially_copyable(_Tp)> {};
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_copyable.h" 3
}}
# 509 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_default_constructible.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_default_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_trivially_default_constructible
    : public integral_constant<bool, __is_trivially_constructible(_Tp)> {};






}}
# 510 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_destructible.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_destructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_trivially_destructible
    : public integral_constant<bool, __is_trivially_destructible(_Tp)> {};
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_destructible.h" 3
}}
# 511 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_move_assignable.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_move_assignable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_trivially_move_assignable
    : public integral_constant<
          bool,
          __is_trivially_assignable(__add_lvalue_reference_t<_Tp>, __add_rvalue_reference_t<_Tp>)> {};






}}
# 512 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_move_constructible.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_move_constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_trivially_move_constructible
    : public integral_constant<bool, __is_trivially_constructible(_Tp, __add_rvalue_reference_t<_Tp>)> {};






}}
# 513 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_unbounded_array.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_unbounded_array.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class>
struct __libcpp_is_unbounded_array : false_type {};
template <class _Tp>
struct __libcpp_is_unbounded_array<_Tp[]> : true_type {};
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_unbounded_array.h" 3
}}
# 514 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_unsigned.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_unsigned.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
struct is_unsigned : _BoolConstant<__is_unsigned(_Tp)> {};
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_unsigned.h" 3
}}
# 516 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/make_const_lvalue_ref.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/make_const_lvalue_ref.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
using __make_const_lvalue_ref = const __libcpp_remove_reference_t<_Tp>&;

}}
# 519 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/make_signed.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/make_signed.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
using __make_signed_t = __make_signed(_Tp);
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/make_signed.h" 3
template <class _Tp>
struct make_signed {
  using type __attribute__((__nodebug__)) = __make_signed_t<_Tp>;
};






}}
# 520 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/make_unsigned.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/make_unsigned.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Tp>
using __make_unsigned_t = __make_unsigned(_Tp);
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/make_unsigned.h" 3
template <class _Tp>
struct make_unsigned {
  using type __attribute__((__nodebug__)) = __make_unsigned_t<_Tp>;
};
# 96 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/make_unsigned.h" 3
template <class _Tp, class _Up>
using __copy_unsigned_t = __conditional_t<is_unsigned<_Tp>::value, __make_unsigned_t<_Up>, _Up>;

}}
# 521 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/maybe_const.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/maybe_const.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <bool _Const, class _Tp>
using __maybe_const = __conditional_t<_Const, const _Tp, _Tp>;

}}
# 522 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/negation.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/negation.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Pred>
struct _Not : _BoolConstant<!_Pred::value> {};
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/negation.h" 3
}}
# 523 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/rank.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/rank.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/rank.h" 3
template <class _Tp>
struct rank : public integral_constant<size_t, 0> {};
template <class _Tp>
struct rank<_Tp[]> : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, size_t _Np>
struct rank<_Tp[_Np]> : public integral_constant<size_t, rank<_Tp>::value + 1> {};
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/rank.h" 3
}}
# 524 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_pointer.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_pointer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp>
struct remove_pointer {
  using type __attribute__((__nodebug__)) = __remove_pointer(_Tp);
};

template <class _Tp>
using __remove_pointer_t = __remove_pointer(_Tp);
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/remove_pointer.h" 3
}}
# 530 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/result_of.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/result_of.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/invoke.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/invoke.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/invoke.h" 3
}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/result_of.h" 2 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/result_of.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




template <class _Callable>
class result_of;

template <class _Fp, class... _Args>
class result_of<_Fp(_Args...)> : public __invoke_of<_Fp, _Args...> {};







}}
# 533 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/type_identity.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/type_identity.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __type_identity {
  typedef _Tp type;
};

template <class _Tp>
using __type_identity_t __attribute__((__nodebug__)) = typename __type_identity<_Tp>::type;
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/type_identity.h" 3
}}
# 534 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/unwrap_ref.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/unwrap_ref.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __unwrap_reference {
  typedef __attribute__((__nodebug__)) _Tp type;
};

template <class _Tp>
class reference_wrapper;

template <class _Tp>
struct __unwrap_reference<reference_wrapper<_Tp> > {
  typedef __attribute__((__nodebug__)) _Tp& type;
};

template <class _Tp>
struct decay;
# 51 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/unwrap_ref.h" 3
template <class _Tp>
struct __unwrap_ref_decay



    : __unwrap_reference<__decay_t<_Tp> >

{
};

}}
# 536 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 2 3
# 544 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 3
# 820 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/limits" 2 3
# 317 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 1 3
# 298 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 2 3 4

extern "C" {
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
    typedef float float_t;
    typedef double double_t;
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern int __math_errhandling(void);
# 132 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern int __fpclassifyf(float);
extern int __fpclassifyd(double);
extern int __fpclassifyl(long double);
# 175 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
inline __attribute__ ((__always_inline__)) int __inline_isfinitef(float);
inline __attribute__ ((__always_inline__)) int __inline_isfinited(double);
inline __attribute__ ((__always_inline__)) int __inline_isfinitel(long double);
inline __attribute__ ((__always_inline__)) int __inline_isinff(float);
inline __attribute__ ((__always_inline__)) int __inline_isinfd(double);
inline __attribute__ ((__always_inline__)) int __inline_isinfl(long double);
inline __attribute__ ((__always_inline__)) int __inline_isnanf(float);
inline __attribute__ ((__always_inline__)) int __inline_isnand(double);
inline __attribute__ ((__always_inline__)) int __inline_isnanl(long double);
inline __attribute__ ((__always_inline__)) int __inline_isnormalf(float);
inline __attribute__ ((__always_inline__)) int __inline_isnormald(double);
inline __attribute__ ((__always_inline__)) int __inline_isnormall(long double);
inline __attribute__ ((__always_inline__)) int __inline_signbitf(float);
inline __attribute__ ((__always_inline__)) int __inline_signbitd(double);
inline __attribute__ ((__always_inline__)) int __inline_signbitl(long double);

inline __attribute__ ((__always_inline__)) int __inline_isfinitef(float __x) {
    return __x == __x && __builtin_fabsf(__x) != __builtin_inff();
}
inline __attribute__ ((__always_inline__)) int __inline_isfinited(double __x) {
    return __x == __x && __builtin_fabs(__x) != __builtin_inf();
}
inline __attribute__ ((__always_inline__)) int __inline_isfinitel(long double __x) {
    return __x == __x && __builtin_fabsl(__x) != __builtin_infl();
}
inline __attribute__ ((__always_inline__)) int __inline_isinff(float __x) {
    return __builtin_fabsf(__x) == __builtin_inff();
}
inline __attribute__ ((__always_inline__)) int __inline_isinfd(double __x) {
    return __builtin_fabs(__x) == __builtin_inf();
}
inline __attribute__ ((__always_inline__)) int __inline_isinfl(long double __x) {
    return __builtin_fabsl(__x) == __builtin_infl();
}
inline __attribute__ ((__always_inline__)) int __inline_isnanf(float __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_isnand(double __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_isnanl(long double __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_signbitf(float __x) {
    union { float __f; unsigned int __u; } __u;
    __u.__f = __x;
    return (int)(__u.__u >> 31);
}
inline __attribute__ ((__always_inline__)) int __inline_signbitd(double __x) {
    union { double __f; unsigned long long __u; } __u;
    __u.__f = __x;
    return (int)(__u.__u >> 63);
}
# 238 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
inline __attribute__ ((__always_inline__)) int __inline_signbitl(long double __x) {
    union { long double __f; unsigned long long __u;} __u;
    __u.__f = __x;
    return (int)(__u.__u >> 63);
}

inline __attribute__ ((__always_inline__)) int __inline_isnormalf(float __x) {
    return __inline_isfinitef(__x) && __builtin_fabsf(__x) >= 1.17549435e-38F;
}
inline __attribute__ ((__always_inline__)) int __inline_isnormald(double __x) {
    return __inline_isfinited(__x) && __builtin_fabs(__x) >= 2.2250738585072014e-308;
}
inline __attribute__ ((__always_inline__)) int __inline_isnormall(long double __x) {
    return __inline_isfinitel(__x) && __builtin_fabsl(__x) >= 2.2250738585072014e-308L;
}
# 309 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern float acosf(float);
extern double acos(double);
extern long double acosl(long double);

extern float asinf(float);
extern double asin(double);
extern long double asinl(long double);

extern float atanf(float);
extern double atan(double);
extern long double atanl(long double);

extern float atan2f(float, float);
extern double atan2(double, double);
extern long double atan2l(long double, long double);

extern float cosf(float);
extern double cos(double);
extern long double cosl(long double);

extern float sinf(float);
extern double sin(double);
extern long double sinl(long double);

extern float tanf(float);
extern double tan(double);
extern long double tanl(long double);

extern float acoshf(float);
extern double acosh(double);
extern long double acoshl(long double);

extern float asinhf(float);
extern double asinh(double);
extern long double asinhl(long double);

extern float atanhf(float);
extern double atanh(double);
extern long double atanhl(long double);

extern float coshf(float);
extern double cosh(double);
extern long double coshl(long double);

extern float sinhf(float);
extern double sinh(double);
extern long double sinhl(long double);

extern float tanhf(float);
extern double tanh(double);
extern long double tanhl(long double);

extern float expf(float);
extern double exp(double);
extern long double expl(long double);

extern float exp2f(float);
extern double exp2(double);
extern long double exp2l(long double);

extern float expm1f(float);
extern double expm1(double);
extern long double expm1l(long double);

extern float logf(float);
extern double log(double);
extern long double logl(long double);

extern float log10f(float);
extern double log10(double);
extern long double log10l(long double);

extern float log2f(float);
extern double log2(double);
extern long double log2l(long double);

extern float log1pf(float);
extern double log1p(double);
extern long double log1pl(long double);

extern float logbf(float);
extern double logb(double);
extern long double logbl(long double);

extern float modff(float, float *);
extern double modf(double, double *);
extern long double modfl(long double, long double *);

extern float ldexpf(float, int);
extern double ldexp(double, int);
extern long double ldexpl(long double, int);

extern float frexpf(float, int *);
extern double frexp(double, int *);
extern long double frexpl(long double, int *);

extern int ilogbf(float);
extern int ilogb(double);
extern int ilogbl(long double);

extern float scalbnf(float, int);
extern double scalbn(double, int);
extern long double scalbnl(long double, int);

extern float scalblnf(float, long int);
extern double scalbln(double, long int);
extern long double scalblnl(long double, long int);

extern float fabsf(float);
extern double fabs(double);
extern long double fabsl(long double);

extern float cbrtf(float);
extern double cbrt(double);
extern long double cbrtl(long double);

extern float hypotf(float, float);
extern double hypot(double, double);
extern long double hypotl(long double, long double);

extern float powf(float, float);
extern double pow(double, double);
extern long double powl(long double, long double);

extern float sqrtf(float);
extern double sqrt(double);
extern long double sqrtl(long double);

extern float erff(float);
extern double erf(double);
extern long double erfl(long double);

extern float erfcf(float);
extern double erfc(double);
extern long double erfcl(long double);




extern float lgammaf(float);
extern double lgamma(double);
extern long double lgammal(long double);

extern float tgammaf(float);
extern double tgamma(double);
extern long double tgammal(long double);

extern float ceilf(float);
extern double ceil(double);
extern long double ceill(long double);

extern float floorf(float);
extern double floor(double);
extern long double floorl(long double);

extern float nearbyintf(float);
extern double nearbyint(double);
extern long double nearbyintl(long double);

extern float rintf(float);
extern double rint(double);
extern long double rintl(long double);

extern long int lrintf(float);
extern long int lrint(double);
extern long int lrintl(long double);

extern float roundf(float);
extern double round(double);
extern long double roundl(long double);

extern long int lroundf(float);
extern long int lround(double);
extern long int lroundl(long double);




extern long long int llrintf(float);
extern long long int llrint(double);
extern long long int llrintl(long double);

extern long long int llroundf(float);
extern long long int llround(double);
extern long long int llroundl(long double);


extern float truncf(float);
extern double trunc(double);
extern long double truncl(long double);

extern float fmodf(float, float);
extern double fmod(double, double);
extern long double fmodl(long double, long double);

extern float remainderf(float, float);
extern double remainder(double, double);
extern long double remainderl(long double, long double);

extern float remquof(float, float, int *);
extern double remquo(double, double, int *);
extern long double remquol(long double, long double, int *);

extern float copysignf(float, float);
extern double copysign(double, double);
extern long double copysignl(long double, long double);

extern float nanf(const char *);
extern double nan(const char *);
extern long double nanl(const char *);

extern float nextafterf(float, float);
extern double nextafter(double, double);
extern long double nextafterl(long double, long double);

extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);

extern float fdimf(float, float);
extern double fdim(double, double);
extern long double fdiml(long double, long double);

extern float fmaxf(float, float);
extern double fmax(double, double);
extern long double fmaxl(long double, long double);

extern float fminf(float, float);
extern double fmin(double, double);
extern long double fminl(long double, long double);

extern float fmaf(float, float, float);
extern double fma(double, double, double);
extern long double fmal(long double, long double, long double);
# 589 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern float __exp10f(float) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern double __exp10(double) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));





inline __attribute__ ((__always_inline__)) void __sincosf(float __x, float *__sinp, float *__cosp);
inline __attribute__ ((__always_inline__)) void __sincos(double __x, double *__sinp, double *__cosp);
# 606 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern float __cospif(float) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern double __cospi(double) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern float __sinpif(float) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern double __sinpi(double) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern float __tanpif(float) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern double __tanpi(double) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));


extern _Float16 __fabsf16(_Float16) __attribute__((availability(macos,introduced=15.0))) __attribute__((availability(ios,introduced=18.0))) __attribute__((availability(watchos,introduced=11.0))) __attribute__((availability(tvos,introduced=18.0)));
extern _Float16 __hypotf16(_Float16, _Float16) __attribute__((availability(macos,introduced=15.0))) __attribute__((availability(ios,introduced=18.0))) __attribute__((availability(watchos,introduced=11.0))) __attribute__((availability(tvos,introduced=18.0)));
extern _Float16 __sqrtf16(_Float16) __attribute__((availability(macos,introduced=15.0))) __attribute__((availability(ios,introduced=18.0))) __attribute__((availability(watchos,introduced=11.0))) __attribute__((availability(tvos,introduced=18.0)));
extern _Float16 __ceilf16(_Float16) __attribute__((availability(macos,introduced=15.0))) __attribute__((availability(ios,introduced=18.0))) __attribute__((availability(watchos,introduced=11.0))) __attribute__((availability(tvos,introduced=18.0)));
extern _Float16 __floorf16(_Float16) __attribute__((availability(macos,introduced=15.0))) __attribute__((availability(ios,introduced=18.0))) __attribute__((availability(watchos,introduced=11.0))) __attribute__((availability(tvos,introduced=18.0)));
extern _Float16 __rintf16(_Float16) __attribute__((availability(macos,introduced=15.0))) __attribute__((availability(ios,introduced=18.0))) __attribute__((availability(watchos,introduced=11.0))) __attribute__((availability(tvos,introduced=18.0)));
extern _Float16 __roundf16(_Float16) __attribute__((availability(macos,introduced=15.0))) __attribute__((availability(ios,introduced=18.0))) __attribute__((availability(watchos,introduced=11.0))) __attribute__((availability(tvos,introduced=18.0)));
extern _Float16 __truncf16(_Float16) __attribute__((availability(macos,introduced=15.0))) __attribute__((availability(ios,introduced=18.0))) __attribute__((availability(watchos,introduced=11.0))) __attribute__((availability(tvos,introduced=18.0)));
extern _Float16 __copysignf16(_Float16, _Float16) __attribute__((availability(macos,introduced=15.0))) __attribute__((availability(ios,introduced=18.0))) __attribute__((availability(watchos,introduced=11.0))) __attribute__((availability(tvos,introduced=18.0)));
extern _Float16 __nextafterf16(_Float16, _Float16) __attribute__((availability(macos,introduced=15.0))) __attribute__((availability(ios,introduced=18.0))) __attribute__((availability(watchos,introduced=11.0))) __attribute__((availability(tvos,introduced=18.0)));
extern _Float16 __fmaxf16(_Float16, _Float16) __attribute__((availability(macos,introduced=15.0))) __attribute__((availability(ios,introduced=18.0))) __attribute__((availability(watchos,introduced=11.0))) __attribute__((availability(tvos,introduced=18.0)));
extern _Float16 __fminf16(_Float16, _Float16) __attribute__((availability(macos,introduced=15.0))) __attribute__((availability(ios,introduced=18.0))) __attribute__((availability(watchos,introduced=11.0))) __attribute__((availability(tvos,introduced=18.0)));
extern _Float16 __fmaf16(_Float16, _Float16, _Float16) __attribute__((availability(macos,introduced=15.0))) __attribute__((availability(ios,introduced=18.0))) __attribute__((availability(watchos,introduced=11.0))) __attribute__((availability(tvos,introduced=18.0)));
# 652 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
inline __attribute__ ((__always_inline__)) void __sincospif(float __x, float *__sinp, float *__cosp);
inline __attribute__ ((__always_inline__)) void __sincospi(double __x, double *__sinp, double *__cosp);






struct __float2 { float __sinval; float __cosval; };
struct __double2 { double __sinval; double __cosval; };

extern struct __float2 __sincosf_stret(float);
extern struct __double2 __sincos_stret(double);
extern struct __float2 __sincospif_stret(float);
extern struct __double2 __sincospi_stret(double);

inline __attribute__ ((__always_inline__)) void __sincosf(float __x, float *__sinp, float *__cosp) {
    const struct __float2 __stret = __sincosf_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincos(double __x, double *__sinp, double *__cosp) {
    const struct __double2 __stret = __sincos_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincospif(float __x, float *__sinp, float *__cosp) {
    const struct __float2 __stret = __sincospif_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincospi(double __x, double *__sinp, double *__cosp) {
    const struct __double2 __stret = __sincospi_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}







extern double j0(double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double j1(double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double jn(int, double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double y0(double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double y1(double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double yn(int, double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double scalb(double, double);
extern int signgam;
# 790 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
}
# 302 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3






extern "C++" {
# 358 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/abs.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/abs.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float fabs(float __x) throw() { return __builtin_fabsf(__x); }

template <class = int>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double fabs(double __x) throw() {
  return __builtin_fabs(__x);
}

                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double fabs(long double __x) throw() {
  return __builtin_fabsl(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double fabs(_A1 __x) throw() {
  return __builtin_fabs((double)__x);
}

}

}}
# 359 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/copysign.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/copysign.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float copysign(float __x, float __y) throw() {
  return ::__builtin_copysignf(__x, __y);
}

                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double copysign(long double __x, long double __y) throw() {
  return ::__builtin_copysignl(__x, __y);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename __promote<_A1, _A2>::type
copysign(_A1 __x, _A2 __y) throw() {
  return ::__builtin_copysign(__x, __y);
}

}

}}
# 360 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/error_functions.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/error_functions.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float erf(float __x) throw() { return __builtin_erff(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double erf(double __x) throw() {
  return __builtin_erf(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double erf(long double __x) throw() { return __builtin_erfl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double erf(_A1 __x) throw() {
  return __builtin_erf((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float erfc(float __x) throw() { return __builtin_erfcf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double erfc(double __x) throw() {
  return __builtin_erfc(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double erfc(long double __x) throw() { return __builtin_erfcl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double erfc(_A1 __x) throw() {
  return __builtin_erfc((double)__x);
}

}

}}
# 361 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/exponential_functions.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/exponential_functions.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float exp(float __x) throw() { return __builtin_expf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double exp(double __x) throw() {
  return __builtin_exp(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double exp(long double __x) throw() { return __builtin_expl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double exp(_A1 __x) throw() {
  return __builtin_exp((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float frexp(float __x, int* __e) throw() { return __builtin_frexpf(__x, __e); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double frexp(double __x, int* __e) throw() {
  return __builtin_frexp(__x, __e);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double frexp(long double __x, int* __e) throw() {
  return __builtin_frexpl(__x, __e);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double frexp(_A1 __x, int* __e) throw() {
  return __builtin_frexp((double)__x, __e);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float ldexp(float __x, int __e) throw() { return __builtin_ldexpf(__x, __e); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double ldexp(double __x, int __e) throw() {
  return __builtin_ldexp(__x, __e);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double ldexp(long double __x, int __e) throw() {
  return __builtin_ldexpl(__x, __e);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double ldexp(_A1 __x, int __e) throw() {
  return __builtin_ldexp((double)__x, __e);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float exp2(float __x) throw() { return __builtin_exp2f(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double exp2(double __x) throw() {
  return __builtin_exp2(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double exp2(long double __x) throw() { return __builtin_exp2l(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double exp2(_A1 __x) throw() {
  return __builtin_exp2((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float expm1(float __x) throw() { return __builtin_expm1f(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double expm1(double __x) throw() {
  return __builtin_expm1(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double expm1(long double __x) throw() { return __builtin_expm1l(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double expm1(_A1 __x) throw() {
  return __builtin_expm1((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float scalbln(float __x, long __y) throw() { return __builtin_scalblnf(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double scalbln(double __x, long __y) throw() {
  return __builtin_scalbln(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double scalbln(long double __x, long __y) throw() {
  return __builtin_scalblnl(__x, __y);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double scalbln(_A1 __x, long __y) throw() {
  return __builtin_scalbln((double)__x, __y);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float scalbn(float __x, int __y) throw() { return __builtin_scalbnf(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double scalbn(double __x, int __y) throw() {
  return __builtin_scalbn(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double scalbn(long double __x, int __y) throw() {
  return __builtin_scalbnl(__x, __y);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double scalbn(_A1 __x, int __y) throw() {
  return __builtin_scalbn((double)__x, __y);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float pow(float __x, float __y) throw() { return __builtin_powf(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double pow(double __x, double __y) throw() {
  return __builtin_pow(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double pow(long double __x, long double __y) throw() {
  return __builtin_powl(__x, __y);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename __promote<_A1, _A2>::type pow(_A1 __x, _A2 __y) throw() {
  using __result_type = typename __promote<_A1, _A2>::type;
  _Static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::pow((__result_type)__x, (__result_type)__y);
}

}

}}
# 362 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/fdim.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/fdim.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float fdim(float __x, float __y) throw() { return __builtin_fdimf(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double fdim(double __x, double __y) throw() {
  return __builtin_fdim(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double fdim(long double __x, long double __y) throw() {
  return __builtin_fdiml(__x, __y);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename __promote<_A1, _A2>::type fdim(_A1 __x, _A2 __y) throw() {
  using __result_type = typename __promote<_A1, _A2>::type;
  _Static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::fdim((__result_type)__x, (__result_type)__y);
}

}

}}
# 363 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/fma.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/fma.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float fma(float __x, float __y, float __z) throw() {
  return __builtin_fmaf(__x, __y, __z);
}

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double fma(double __x, double __y, double __z) throw() {
  return __builtin_fma(__x, __y, __z);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double fma(long double __x, long double __y, long double __z) throw() {
  return __builtin_fmal(__x, __y, __z);
}

template <class _A1,
          class _A2,
          class _A3,
          __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value && is_arithmetic<_A3>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename __promote<_A1, _A2, _A3>::type fma(_A1 __x, _A2 __y, _A3 __z) throw() {
  using __result_type = typename __promote<_A1, _A2, _A3>::type;
  _Static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value && _IsSame<_A3, __result_type>::value)), "");


  return __builtin_fma((__result_type)__x, (__result_type)__y, (__result_type)__z);
}

}

}}
# 364 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/gamma.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/gamma.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float lgamma(float __x) throw() { return __builtin_lgammaf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double lgamma(double __x) throw() {
  return __builtin_lgamma(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double lgamma(long double __x) throw() { return __builtin_lgammal(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double lgamma(_A1 __x) throw() {
  return __builtin_lgamma((double)__x);
}





inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float tgamma(float __x) throw() { return __builtin_tgammaf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double tgamma(double __x) throw() {
  return __builtin_tgamma(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double tgamma(long double __x) throw() { return __builtin_tgammal(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double tgamma(_A1 __x) throw() {
  return __builtin_tgamma((double)__x);
}

}

}}
# 365 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/hyperbolic_functions.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/hyperbolic_functions.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float cosh(float __x) throw() { return __builtin_coshf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double cosh(double __x) throw() {
  return __builtin_cosh(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double cosh(long double __x) throw() { return __builtin_coshl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double cosh(_A1 __x) throw() {
  return __builtin_cosh((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float sinh(float __x) throw() { return __builtin_sinhf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double sinh(double __x) throw() {
  return __builtin_sinh(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double sinh(long double __x) throw() { return __builtin_sinhl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double sinh(_A1 __x) throw() {
  return __builtin_sinh((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float tanh(float __x) throw() { return __builtin_tanhf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double tanh(double __x) throw() {
  return __builtin_tanh(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double tanh(long double __x) throw() { return __builtin_tanhl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double tanh(_A1 __x) throw() {
  return __builtin_tanh((double)__x);
}

}

}}
# 366 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/hypot.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/hypot.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float hypot(float __x, float __y) throw() { return __builtin_hypotf(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double hypot(double __x, double __y) throw() {
  return __builtin_hypot(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double hypot(long double __x, long double __y) throw() {
  return __builtin_hypotl(__x, __y);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename __promote<_A1, _A2>::type hypot(_A1 __x, _A2 __y) throw() {
  using __result_type = typename __promote<_A1, _A2>::type;
  _Static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::hypot((__result_type)__x, (__result_type)__y);
}

}

}}
# 367 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/inverse_hyperbolic_functions.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/inverse_hyperbolic_functions.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float acosh(float __x) throw() { return __builtin_acoshf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double acosh(double __x) throw() {
  return __builtin_acosh(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double acosh(long double __x) throw() { return __builtin_acoshl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double acosh(_A1 __x) throw() {
  return __builtin_acosh((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float asinh(float __x) throw() { return __builtin_asinhf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double asinh(double __x) throw() {
  return __builtin_asinh(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double asinh(long double __x) throw() { return __builtin_asinhl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double asinh(_A1 __x) throw() {
  return __builtin_asinh((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float atanh(float __x) throw() { return __builtin_atanhf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double atanh(double __x) throw() {
  return __builtin_atanh(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double atanh(long double __x) throw() { return __builtin_atanhl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double atanh(_A1 __x) throw() {
  return __builtin_atanh((double)__x);
}

}

}}
# 368 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/inverse_trigonometric_functions.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/inverse_trigonometric_functions.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float acos(float __x) throw() { return __builtin_acosf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double acos(double __x) throw() {
  return __builtin_acos(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double acos(long double __x) throw() { return __builtin_acosl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double acos(_A1 __x) throw() {
  return __builtin_acos((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float asin(float __x) throw() { return __builtin_asinf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double asin(double __x) throw() {
  return __builtin_asin(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double asin(long double __x) throw() { return __builtin_asinl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double asin(_A1 __x) throw() {
  return __builtin_asin((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float atan(float __x) throw() { return __builtin_atanf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double atan(double __x) throw() {
  return __builtin_atan(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double atan(long double __x) throw() { return __builtin_atanl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double atan(_A1 __x) throw() {
  return __builtin_atan((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float atan2(float __y, float __x) throw() { return __builtin_atan2f(__y, __x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double atan2(double __x, double __y) throw() {
  return __builtin_atan2(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double atan2(long double __y, long double __x) throw() {
  return __builtin_atan2l(__y, __x);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename __promote<_A1, _A2>::type atan2(_A1 __y, _A2 __x) throw() {
  using __result_type = typename __promote<_A1, _A2>::type;
  _Static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::atan2((__result_type)__y, (__result_type)__x);
}

}

}}
# 369 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/logarithms.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/logarithms.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float log(float __x) throw() { return __builtin_logf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double log(double __x) throw() {
  return __builtin_log(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double log(long double __x) throw() { return __builtin_logl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double log(_A1 __x) throw() {
  return __builtin_log((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float log10(float __x) throw() { return __builtin_log10f(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double log10(double __x) throw() {
  return __builtin_log10(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double log10(long double __x) throw() { return __builtin_log10l(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double log10(_A1 __x) throw() {
  return __builtin_log10((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int ilogb(float __x) throw() { return __builtin_ilogbf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double ilogb(double __x) throw() {
  return __builtin_ilogb(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int ilogb(long double __x) throw() { return __builtin_ilogbl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int ilogb(_A1 __x) throw() {
  return __builtin_ilogb((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float log1p(float __x) throw() { return __builtin_log1pf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double log1p(double __x) throw() {
  return __builtin_log1p(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double log1p(long double __x) throw() { return __builtin_log1pl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double log1p(_A1 __x) throw() {
  return __builtin_log1p((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float log2(float __x) throw() { return __builtin_log2f(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double log2(double __x) throw() {
  return __builtin_log2(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double log2(long double __x) throw() { return __builtin_log2l(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double log2(_A1 __x) throw() {
  return __builtin_log2((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float logb(float __x) throw() { return __builtin_logbf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double logb(double __x) throw() {
  return __builtin_logb(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double logb(long double __x) throw() { return __builtin_logbl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double logb(_A1 __x) throw() {
  return __builtin_logb((double)__x);
}

}

}}
# 370 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/min_max.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/min_max.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float fmax(float __x, float __y) throw() {
  return __builtin_fmaxf(__x, __y);
}

template <class = int>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double fmax(double __x, double __y) throw() {
  return __builtin_fmax(__x, __y);
}

                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double fmax(long double __x, long double __y) throw() {
  return __builtin_fmaxl(__x, __y);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename __promote<_A1, _A2>::type fmax(_A1 __x, _A2 __y) throw() {
  using __result_type = typename __promote<_A1, _A2>::type;
  _Static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::fmax((__result_type)__x, (__result_type)__y);
}



                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float fmin(float __x, float __y) throw() {
  return __builtin_fminf(__x, __y);
}

template <class = int>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double fmin(double __x, double __y) throw() {
  return __builtin_fmin(__x, __y);
}

                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double fmin(long double __x, long double __y) throw() {
  return __builtin_fminl(__x, __y);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename __promote<_A1, _A2>::type fmin(_A1 __x, _A2 __y) throw() {
  using __result_type = typename __promote<_A1, _A2>::type;
  _Static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::fmin((__result_type)__x, (__result_type)__y);
}

}

}}
# 371 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/modulo.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/modulo.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float fmod(float __x, float __y) throw() { return __builtin_fmodf(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double fmod(double __x, double __y) throw() {
  return __builtin_fmod(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double fmod(long double __x, long double __y) throw() {
  return __builtin_fmodl(__x, __y);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename __promote<_A1, _A2>::type fmod(_A1 __x, _A2 __y) throw() {
  using __result_type = typename __promote<_A1, _A2>::type;
  _Static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::fmod((__result_type)__x, (__result_type)__y);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float modf(float __x, float* __y) throw() { return __builtin_modff(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double modf(double __x, double* __y) throw() {
  return __builtin_modf(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double modf(long double __x, long double* __y) throw() {
  return __builtin_modfl(__x, __y);
}

}

}}
# 372 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/remainder.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/remainder.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float remainder(float __x, float __y) throw() { return __builtin_remainderf(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double remainder(double __x, double __y) throw() {
  return __builtin_remainder(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double remainder(long double __x, long double __y) throw() {
  return __builtin_remainderl(__x, __y);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename __promote<_A1, _A2>::type remainder(_A1 __x, _A2 __y) throw() {
  using __result_type = typename __promote<_A1, _A2>::type;
  _Static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::remainder((__result_type)__x, (__result_type)__y);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float remquo(float __x, float __y, int* __z) throw() {
  return __builtin_remquof(__x, __y, __z);
}

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double remquo(double __x, double __y, int* __z) throw() {
  return __builtin_remquo(__x, __y, __z);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double remquo(long double __x, long double __y, int* __z) throw() {
  return __builtin_remquol(__x, __y, __z);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename __promote<_A1, _A2>::type remquo(_A1 __x, _A2 __y, int* __z) throw() {
  using __result_type = typename __promote<_A1, _A2>::type;
  _Static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::remquo((__result_type)__x, (__result_type)__y, __z);
}

}

}}
# 373 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/roots.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/roots.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float sqrt(float __x) throw() { return __builtin_sqrtf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double sqrt(double __x) throw() {
  return __builtin_sqrt(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double sqrt(long double __x) throw() { return __builtin_sqrtl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double sqrt(_A1 __x) throw() {
  return __builtin_sqrt((double)__x);
}



                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float cbrt(float __x) throw() { return __builtin_cbrtf(__x); }

template <class = int>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double cbrt(double __x) throw() {
  return __builtin_cbrt(__x);
}

                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double cbrt(long double __x) throw() {
  return __builtin_cbrtl(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double cbrt(_A1 __x) throw() {
  return __builtin_cbrt((double)__x);
}

}

}}
# 374 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/rounding_functions.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/rounding_functions.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float ceil(float __x) throw() { return __builtin_ceilf(__x); }

template <class = int>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double ceil(double __x) throw() {
  return __builtin_ceil(__x);
}

                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double ceil(long double __x) throw() {
  return __builtin_ceill(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double ceil(_A1 __x) throw() {
  return __builtin_ceil((double)__x);
}



                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float floor(float __x) throw() { return __builtin_floorf(__x); }

template <class = int>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double floor(double __x) throw() {
  return __builtin_floor(__x);
}

                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double floor(long double __x) throw() {
  return __builtin_floorl(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double floor(_A1 __x) throw() {
  return __builtin_floor((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long long llrint(float __x) throw() { return __builtin_llrintf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long long llrint(double __x) throw() {
  return __builtin_llrint(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long long llrint(long double __x) throw() { return __builtin_llrintl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long long llrint(_A1 __x) throw() {
  return __builtin_llrint((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long long llround(float __x) throw() { return __builtin_llroundf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long long llround(double __x) throw() {
  return __builtin_llround(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long long llround(long double __x) throw() { return __builtin_llroundl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long long llround(_A1 __x) throw() {
  return __builtin_llround((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long lrint(float __x) throw() { return __builtin_lrintf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long lrint(double __x) throw() {
  return __builtin_lrint(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long lrint(long double __x) throw() { return __builtin_lrintl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long lrint(_A1 __x) throw() {
  return __builtin_lrint((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long lround(float __x) throw() { return __builtin_lroundf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long lround(double __x) throw() {
  return __builtin_lround(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long lround(long double __x) throw() { return __builtin_lroundl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long lround(_A1 __x) throw() {
  return __builtin_lround((double)__x);
}



                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float nearbyint(float __x) throw() {
  return __builtin_nearbyintf(__x);
}

template <class = int>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double nearbyint(double __x) throw() {
  return __builtin_nearbyint(__x);
}

                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double nearbyint(long double __x) throw() {
  return __builtin_nearbyintl(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double nearbyint(_A1 __x) throw() {
  return __builtin_nearbyint((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float nextafter(float __x, float __y) throw() { return __builtin_nextafterf(__x, __y); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double nextafter(double __x, double __y) throw() {
  return __builtin_nextafter(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double nextafter(long double __x, long double __y) throw() {
  return __builtin_nextafterl(__x, __y);
}

template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename __promote<_A1, _A2>::type nextafter(_A1 __x, _A2 __y) throw() {
  using __result_type = typename __promote<_A1, _A2>::type;
  _Static_assert((!(_IsSame<_A1, __result_type>::value && _IsSame<_A2, __result_type>::value)), "");
  return __math::nextafter((__result_type)__x, (__result_type)__y);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float nexttoward(float __x, long double __y) throw() {
  return __builtin_nexttowardf(__x, __y);
}

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double nexttoward(double __x, long double __y) throw() {
  return __builtin_nexttoward(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double nexttoward(long double __x, long double __y) throw() {
  return __builtin_nexttowardl(__x, __y);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double nexttoward(_A1 __x, long double __y) throw() {
  return __builtin_nexttoward((double)__x, __y);
}



                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float rint(float __x) throw() { return __builtin_rintf(__x); }

template <class = int>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double rint(double __x) throw() {
  return __builtin_rint(__x);
}

                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double rint(long double __x) throw() {
  return __builtin_rintl(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double rint(_A1 __x) throw() {
  return __builtin_rint((double)__x);
}



                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float round(float __x) throw() { return __builtin_round(__x); }

template <class = int>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double round(double __x) throw() {
  return __builtin_round(__x);
}

                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double round(long double __x) throw() {
  return __builtin_roundl(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double round(_A1 __x) throw() {
  return __builtin_round((double)__x);
}



                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float trunc(float __x) throw() { return __builtin_trunc(__x); }

template <class = int>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double trunc(double __x) throw() {
  return __builtin_trunc(__x);
}

                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double trunc(long double __x) throw() {
  return __builtin_truncl(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double trunc(_A1 __x) throw() {
  return __builtin_trunc((double)__x);
}

}

}}
# 375 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/traits.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/traits.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



template <class _A1, __enable_if_t<is_floating_point<_A1>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool signbit(_A1 __x) throw() {
  return __builtin_signbit(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value && is_signed<_A1>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool signbit(_A1 __x) throw() {
  return __x < 0;
}

template <class _A1, __enable_if_t<is_integral<_A1>::value && !is_signed<_A1>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool signbit(_A1) throw() {
  return false;
}



template <class _A1, __enable_if_t<is_arithmetic<_A1>::value && numeric_limits<_A1>::has_infinity, int> = 0>
                                                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isfinite(_A1 __x) throw() {
  return __builtin_isfinite((typename __promote<_A1>::type)__x);
}

template <class _A1, __enable_if_t<is_arithmetic<_A1>::value && !numeric_limits<_A1>::has_infinity, int> = 0>
                                                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isfinite(_A1) throw() {
  return true;
}



template <class _A1, __enable_if_t<is_arithmetic<_A1>::value && numeric_limits<_A1>::has_infinity, int> = 0>
                                                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isinf(_A1 __x) throw() {
  return __builtin_isinf((typename __promote<_A1>::type)__x);
}

template <class _A1, __enable_if_t<is_arithmetic<_A1>::value && !numeric_limits<_A1>::has_infinity, int> = 0>
                                                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isinf(_A1) throw() {
  return false;
}


                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isinf(float __x) throw() {
  return __builtin_isinf(__x);
}

                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) bool
isinf(double __x) throw() {
  return __builtin_isinf(__x);
}

                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isinf(long double __x) throw() {
  return __builtin_isinf(__x);
}




template <class _A1, __enable_if_t<is_floating_point<_A1>::value, int> = 0>
                                                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isnan(_A1 __x) throw() {
  return __builtin_isnan(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
                                                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isnan(_A1) throw() {
  return false;
}


                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isnan(float __x) throw() {
  return __builtin_isnan(__x);
}

                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) bool
isnan(double __x) throw() {
  return __builtin_isnan(__x);
}

                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isnan(long double __x) throw() {
  return __builtin_isnan(__x);
}




template <class _A1, __enable_if_t<is_floating_point<_A1>::value, int> = 0>
                                                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isnormal(_A1 __x) throw() {
  return __builtin_isnormal(__x);
}

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
                                                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isnormal(_A1 __x) throw() {
  return __x != 0;
}



template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isgreater(_A1 __x, _A2 __y) throw() {
  using type = typename __promote<_A1, _A2>::type;
  return __builtin_isgreater((type)__x, (type)__y);
}



template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isgreaterequal(_A1 __x, _A2 __y) throw() {
  using type = typename __promote<_A1, _A2>::type;
  return __builtin_isgreaterequal((type)__x, (type)__y);
}



template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isless(_A1 __x, _A2 __y) throw() {
  using type = typename __promote<_A1, _A2>::type;
  return __builtin_isless((type)__x, (type)__y);
}



template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool islessequal(_A1 __x, _A2 __y) throw() {
  using type = typename __promote<_A1, _A2>::type;
  return __builtin_islessequal((type)__x, (type)__y);
}



template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool islessgreater(_A1 __x, _A2 __y) throw() {
  using type = typename __promote<_A1, _A2>::type;
  return __builtin_islessgreater((type)__x, (type)__y);
}



template <class _A1, class _A2, __enable_if_t<is_arithmetic<_A1>::value && is_arithmetic<_A2>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isunordered(_A1 __x, _A2 __y) throw() {
  using type = typename __promote<_A1, _A2>::type;
  return __builtin_isunordered((type)__x, (type)__y);
}

}

}}
# 376 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/trigonometric_functions.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__math/trigonometric_functions.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float cos(float __x) throw() { return __builtin_cosf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double cos(double __x) throw() {
  return __builtin_cos(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double cos(long double __x) throw() { return __builtin_cosl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double cos(_A1 __x) throw() {
  return __builtin_cos((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float sin(float __x) throw() { return __builtin_sinf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double sin(double __x) throw() {
  return __builtin_sin(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double sin(long double __x) throw() { return __builtin_sinl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double sin(_A1 __x) throw() {
  return __builtin_sin((double)__x);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float tan(float __x) throw() { return __builtin_tanf(__x); }

template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double tan(double __x) throw() {
  return __builtin_tan(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double tan(long double __x) throw() { return __builtin_tanl(__x); }

template <class _A1, __enable_if_t<is_integral<_A1>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double tan(_A1 __x) throw() {
  return __builtin_tan((double)__x);
}

}

}}
# 377 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 1 3 4
# 58 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdlib.h" 1 3 4
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdlib.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types.h" 1 3 4
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types.h" 3 4
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;

typedef __uint32_t __darwin_wctype_t;
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdlib.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 1 3 4
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 3 4
typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_pid_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_pid_t.h" 3 4
typedef __darwin_pid_t pid_t;
# 90 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_id_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_id_t.h" 3 4
typedef __darwin_id_t id_t;
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 2 3 4
# 109 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 1 3 4
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/appleapiopts.h" 1 3 4
# 74 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4








# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/signal.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/signal.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/signal.h" 1 3 4
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/signal.h" 3 4
typedef int sig_atomic_t;
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/signal.h" 2 3 4
# 83 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4
# 146 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_mcontext.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_mcontext.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_mcontext.h" 1 3 4
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_mcontext.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/machine/_structs.h" 1 3 4
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/machine/_structs.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/types.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 1 3 4
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int8_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int8_t.h" 3 4
typedef unsigned char u_int8_t;
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int16_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int16_t.h" 3 4
typedef unsigned short u_int16_t;
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int32_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int32_t.h" 3 4
typedef unsigned int u_int32_t;
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int64_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int64_t.h" 3 4
typedef unsigned long long u_int64_t;
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 2 3 4


typedef int64_t register_t;
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 3 4
typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;
# 105 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/types.h" 3 4
typedef u_int64_t syscall_arg_t;
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/types.h" 2 3 4
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 2 3 4



struct __darwin_arm_exception_state
{
 __uint32_t __exception;
 __uint32_t __fsr;
 __uint32_t __far;
};
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 3 4
struct __darwin_arm_exception_state64
{
 __uint64_t __far;
 __uint32_t __esr;
 __uint32_t __exception;
};

struct __darwin_arm_exception_state64_v2
{
 __uint64_t __far;
 __uint64_t __esr;
};
# 89 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 3 4
struct __darwin_arm_thread_state
{
 __uint32_t __r[13];
 __uint32_t __sp;
 __uint32_t __lr;
 __uint32_t __pc;
 __uint32_t __cpsr;
};
# 148 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 3 4
struct __darwin_arm_thread_state64
{
 __uint64_t __x[29];
 __uint64_t __fp;
 __uint64_t __lr;
 __uint64_t __sp;
 __uint64_t __pc;
 __uint32_t __cpsr;
 __uint32_t __pad;
};
# 519 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 3 4
struct __darwin_arm_vfp_state
{
 __uint32_t __r[64];
 __uint32_t __fpscr;
};
# 538 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 3 4
struct __darwin_arm_neon_state64
{
 __uint128_t __v[32];
 __uint32_t __fpsr;
 __uint32_t __fpcr;
};

struct __darwin_arm_neon_state
{
 __uint128_t __v[16];
 __uint32_t __fpsr;
 __uint32_t __fpcr;
};
# 609 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 3 4
struct __arm_pagein_state
{
 int __pagein_error;
};
# 646 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 3 4
struct __arm_legacy_debug_state
{
 __uint32_t __bvr[16];
 __uint32_t __bcr[16];
 __uint32_t __wvr[16];
 __uint32_t __wcr[16];
};
# 669 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 3 4
struct __darwin_arm_debug_state32
{
 __uint32_t __bvr[16];
 __uint32_t __bcr[16];
 __uint32_t __wvr[16];
 __uint32_t __wcr[16];
 __uint64_t __mdscr_el1;
};


struct __darwin_arm_debug_state64
{
 __uint64_t __bvr[16];
 __uint64_t __bcr[16];
 __uint64_t __wvr[16];
 __uint64_t __wcr[16];
 __uint64_t __mdscr_el1;
};
# 711 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/arm/_structs.h" 3 4
struct __darwin_arm_cpmu_state64
{
 __uint64_t __ctrs[16];
};
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/mach/machine/_structs.h" 2 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_mcontext.h" 2 3 4




struct __darwin_mcontext32
{
 struct __darwin_arm_exception_state __es;
 struct __darwin_arm_thread_state __ss;
 struct __darwin_arm_vfp_state __fs;
};
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_mcontext.h" 3 4
struct __darwin_mcontext64
{
 struct __darwin_arm_exception_state64 __es;
 struct __darwin_arm_thread_state64 __ss;
 struct __darwin_arm_neon_state64 __ns;
};
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_mcontext.h" 3 4
typedef struct __darwin_mcontext64 *mcontext_t;
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_mcontext.h" 2 3 4
# 147 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_attr_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_attr_t.h" 3 4
typedef __darwin_pthread_attr_t pthread_attr_t;
# 149 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigaltstack.h" 1 3 4
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigaltstack.h" 3 4
struct __darwin_sigaltstack
{
 void *ss_sp;
 __darwin_size_t ss_size;
 int ss_flags;
};
typedef struct __darwin_sigaltstack stack_t;
# 151 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ucontext.h" 1 3 4
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ucontext.h" 3 4
struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask;
 struct __darwin_sigaltstack uc_stack;
 struct __darwin_ucontext *uc_link;
 __darwin_size_t uc_mcsize;
 struct __darwin_mcontext64 *uc_mcontext;



};


typedef struct __darwin_ucontext ucontext_t;
# 152 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigset_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigset_t.h" 3 4
typedef __darwin_sigset_t sigset_t;
# 155 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 156 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_uid_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_uid_t.h" 3 4
typedef __darwin_uid_t uid_t;
# 157 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4

union sigval {

 int sival_int;
 void *sival_ptr;
};





struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);
 pthread_attr_t *sigev_notify_attributes;
};


typedef struct __siginfo {
 int si_signo;
 int si_errno;
 int si_code;
 pid_t si_pid;
 uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 long si_band;
 unsigned long __pad[7];
} siginfo_t;
# 269 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
union __sigaction_u {
 void (*__sa_handler)(int);
 void (*__sa_sigaction)(int, struct __siginfo *,
     void *);
};


struct __sigaction {
 union __sigaction_u __sigaction_u;
 void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
 sigset_t sa_mask;
 int sa_flags;
};




struct sigaction {
 union __sigaction_u __sigaction_u;
 sigset_t sa_mask;
 int sa_flags;
};
# 331 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
typedef void (*sig_t)(int);
# 348 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
struct sigvec {
 void (*sv_handler)(int);
 int sv_mask;
 int sv_flags;
};
# 367 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
struct sigstack {
 char *ss_sp;
 int ss_onstack;
};
# 389 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
extern "C" {
void(*signal(int, void (*)(int)))(int);
}
# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 1 3 4
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_timeval.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_timeval.h" 3 4
struct timeval
{
 __darwin_time_t tv_sec;
 __darwin_suseconds_t tv_usec;
};
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 2 3 4








typedef __uint64_t rlim_t;
# 152 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;
# 163 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
 long ru_maxrss;

 long ru_ixrss;
 long ru_idrss;
 long ru_isrss;
 long ru_minflt;
 long ru_majflt;
 long ru_nswap;
 long ru_inblock;
 long ru_oublock;
 long ru_msgsnd;
 long ru_msgrcv;
 long ru_nsignals;
 long ru_nvcsw;
 long ru_nivcsw;


};
# 200 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
typedef void *rusage_info_t;

struct rusage_info_v0 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
};

struct rusage_info_v1 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
};

struct rusage_info_v2 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
};

struct rusage_info_v3 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
};

struct rusage_info_v4 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
 uint64_t ri_logical_writes;
 uint64_t ri_lifetime_max_phys_footprint;
 uint64_t ri_instructions;
 uint64_t ri_cycles;
 uint64_t ri_billed_energy;
 uint64_t ri_serviced_energy;
 uint64_t ri_interval_max_phys_footprint;
 uint64_t ri_runnable_time;
};

struct rusage_info_v5 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
 uint64_t ri_logical_writes;
 uint64_t ri_lifetime_max_phys_footprint;
 uint64_t ri_instructions;
 uint64_t ri_cycles;
 uint64_t ri_billed_energy;
 uint64_t ri_serviced_energy;
 uint64_t ri_interval_max_phys_footprint;
 uint64_t ri_runnable_time;
 uint64_t ri_flags;
};

struct rusage_info_v6 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
 uint64_t ri_logical_writes;
 uint64_t ri_lifetime_max_phys_footprint;
 uint64_t ri_instructions;
 uint64_t ri_cycles;
 uint64_t ri_billed_energy;
 uint64_t ri_serviced_energy;
 uint64_t ri_interval_max_phys_footprint;
 uint64_t ri_runnable_time;
 uint64_t ri_flags;
 uint64_t ri_user_ptime;
 uint64_t ri_system_ptime;
 uint64_t ri_pinstructions;
 uint64_t ri_pcycles;
 uint64_t ri_energy_nj;
 uint64_t ri_penergy_nj;
 uint64_t ri_secure_time_in_system;
 uint64_t ri_secure_ptime_in_system;
 uint64_t ri_neural_footprint;
 uint64_t ri_lifetime_max_neural_footprint;
 uint64_t ri_interval_max_neural_footprint;
 uint64_t ri_reserved[9];
};

typedef struct rusage_info_v6 rusage_info_current;
# 464 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
struct rlimit {
 rlim_t rlim_cur;
 rlim_t rlim_max;
};
# 499 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
struct proc_rlimit_control_wakeupmon {
 uint32_t wm_flags;
 int32_t wm_rate;
};
# 569 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
extern "C" {
int getpriority(int, id_t);

int getiopolicy_np(int, int) __attribute__((availability(macosx,introduced=10.5)));

int getrlimit(int, struct rlimit *) __asm("_" "getrlimit" );
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);

int setiopolicy_np(int, int, int) __attribute__((availability(macosx,introduced=10.5)));

int setrlimit(int, const struct rlimit *) __asm("_" "setrlimit" );
}
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 2 3 4
# 186 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/endian.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/endian.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/endian.h" 1 3 4
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/endian.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_endian.h" 1 3 4
# 94 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_endian.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_endian.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_endian.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_endian.h" 1 3 4
# 95 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_endian.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/__endian.h" 1 3 4
# 96 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_endian.h" 2 3 4
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/_endian.h" 2 3 4
# 95 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_endian.h" 2 3 4
# 131 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_endian.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/_OSByteOrder.h" 1 3 4
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/_OSByteOrder.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/_OSByteOrder.h" 1 3 4
# 48 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/_OSByteOrder.h" 3 4
static inline
__uint16_t
_OSSwapInt16(
 __uint16_t _data
 )
{

 return (__uint16_t)(_data << 8 | _data >> 8);
}

static inline
__uint32_t
_OSSwapInt32(
 __uint32_t _data
 )
{

 _data = __builtin_bswap32(_data);





 return _data;
}

static inline
__uint64_t
_OSSwapInt64(
 __uint64_t _data
 )
{

 return __builtin_bswap64(_data);
# 95 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/arm/_OSByteOrder.h" 3 4
}
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/libkern/_OSByteOrder.h" 2 3 4
# 132 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_endian.h" 2 3 4
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/endian.h" 2 3 4
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/endian.h" 2 3 4
# 187 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 2 3 4







union wait {
 int w_status;



 struct {

  unsigned int w_Termsig:7,
      w_Coredump:1,
      w_Retcode:8,
      w_Filler:16;







 } w_T;





 struct {

  unsigned int w_Stopval:8,
      w_Stopsig:8,
      w_Filler:16;






 } w_S;
};
# 247 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 3 4
extern "C" {
pid_t wait(int *) __asm("_" "wait" );
pid_t waitpid(pid_t, int *, int) __asm("_" "waitpid" );

int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_" "waitid" );


pid_t wait3(int *, int, struct rusage *);
pid_t wait4(pid_t, int *, int, struct rusage *);

}
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdlib.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/alloca.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/alloca.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/alloca.h" 2 3 4

extern "C" {
void *alloca(size_t);
}
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdlib.h" 2 3 4





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdlib.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ct_rune_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ct_rune_t.h" 3 4
typedef __darwin_ct_rune_t ct_rune_t;
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdlib.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_rune_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_rune_t.h" 3 4
typedef __darwin_rune_t rune_t;
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdlib.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdlib.h" 2 3 4

typedef struct {
 int quot;
 int rem;
} div_t;

typedef struct {
 long quot;
 long rem;
} ldiv_t;


typedef struct {
 long long quot;
 long long rem;
} lldiv_t;


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_null.h" 1 3 4
# 101 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdlib.h" 2 3 4
# 115 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdlib.h" 3 4
extern int __mb_cur_max;




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/malloc/_malloc.h" 1 3 4
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/malloc/_malloc.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/malloc/_malloc.h" 2 3 4







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/malloc/_malloc_type.h" 1 3 4
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/malloc/_malloc_type.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/malloc/_ptrcheck.h" 1 3 4
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/malloc/_malloc_type.h" 2 3 4


typedef unsigned long long malloc_type_id_t;






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/malloc/_malloc_type.h" 2 3 4
# 47 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/malloc/_malloc_type.h" 3 4
extern "C" {



__attribute__((availability(macos,introduced=14.0))) __attribute__((availability(ios,introduced=17.0))) __attribute__((availability(tvos,introduced=17.0))) __attribute__((availability(watchos,introduced=10.0))) __attribute__((availability(visionos,introduced=1.0))) __attribute__((availability(driverkit,introduced=23.0))) void * malloc_type_malloc(size_t size, malloc_type_id_t type_id) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1)));
__attribute__((availability(macos,introduced=14.0))) __attribute__((availability(ios,introduced=17.0))) __attribute__((availability(tvos,introduced=17.0))) __attribute__((availability(watchos,introduced=10.0))) __attribute__((availability(visionos,introduced=1.0))) __attribute__((availability(driverkit,introduced=23.0))) void * malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1,2)));
__attribute__((availability(macos,introduced=14.0))) __attribute__((availability(ios,introduced=17.0))) __attribute__((availability(tvos,introduced=17.0))) __attribute__((availability(watchos,introduced=10.0))) __attribute__((availability(visionos,introduced=1.0))) __attribute__((availability(driverkit,introduced=23.0))) void malloc_type_free(void * ptr, malloc_type_id_t type_id);
__attribute__((availability(macos,introduced=14.0))) __attribute__((availability(ios,introduced=17.0))) __attribute__((availability(tvos,introduced=17.0))) __attribute__((availability(watchos,introduced=10.0))) __attribute__((availability(visionos,introduced=1.0))) __attribute__((availability(driverkit,introduced=23.0))) void * malloc_type_realloc(void * ptr, size_t size, malloc_type_id_t type_id) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2)));
__attribute__((availability(macos,introduced=14.0))) __attribute__((availability(ios,introduced=17.0))) __attribute__((availability(tvos,introduced=17.0))) __attribute__((availability(watchos,introduced=10.0))) __attribute__((availability(visionos,introduced=1.0))) __attribute__((availability(driverkit,introduced=23.0))) void * malloc_type_valloc(size_t size, malloc_type_id_t type_id) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1)));
__attribute__((availability(macos,introduced=14.0))) __attribute__((availability(ios,introduced=17.0))) __attribute__((availability(tvos,introduced=17.0))) __attribute__((availability(watchos,introduced=10.0))) __attribute__((availability(visionos,introduced=1.0))) __attribute__((availability(driverkit,introduced=23.0))) void * malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2)));

__attribute__((availability(macos,introduced=14.0))) __attribute__((availability(ios,introduced=17.0))) __attribute__((availability(tvos,introduced=17.0))) __attribute__((availability(watchos,introduced=10.0))) __attribute__((availability(visionos,introduced=1.0))) __attribute__((availability(driverkit,introduced=23.0))) int malloc_type_posix_memalign(void * *memptr, size_t alignment, size_t size, malloc_type_id_t type_id) ;




typedef struct _malloc_zone_t malloc_zone_t;

__attribute__((availability(macos,introduced=14.0))) __attribute__((availability(ios,introduced=17.0))) __attribute__((availability(tvos,introduced=17.0))) __attribute__((availability(watchos,introduced=10.0))) __attribute__((availability(visionos,introduced=1.0))) __attribute__((availability(driverkit,introduced=23.0))) void * malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2)));
__attribute__((availability(macos,introduced=14.0))) __attribute__((availability(ios,introduced=17.0))) __attribute__((availability(tvos,introduced=17.0))) __attribute__((availability(watchos,introduced=10.0))) __attribute__((availability(visionos,introduced=1.0))) __attribute__((availability(driverkit,introduced=23.0))) void * malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2,3)));
__attribute__((availability(macos,introduced=14.0))) __attribute__((availability(ios,introduced=17.0))) __attribute__((availability(tvos,introduced=17.0))) __attribute__((availability(watchos,introduced=10.0))) __attribute__((availability(visionos,introduced=1.0))) __attribute__((availability(driverkit,introduced=23.0))) void malloc_type_zone_free(malloc_zone_t *zone, void * ptr, malloc_type_id_t type_id);
__attribute__((availability(macos,introduced=14.0))) __attribute__((availability(ios,introduced=17.0))) __attribute__((availability(tvos,introduced=17.0))) __attribute__((availability(watchos,introduced=10.0))) __attribute__((availability(visionos,introduced=1.0))) __attribute__((availability(driverkit,introduced=23.0))) void * malloc_type_zone_realloc(malloc_zone_t *zone, void * ptr, size_t size, malloc_type_id_t type_id) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(3)));
__attribute__((availability(macos,introduced=14.0))) __attribute__((availability(ios,introduced=17.0))) __attribute__((availability(tvos,introduced=17.0))) __attribute__((availability(watchos,introduced=10.0))) __attribute__((availability(visionos,introduced=1.0))) __attribute__((availability(driverkit,introduced=23.0))) void * malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2)));
__attribute__((availability(macos,introduced=14.0))) __attribute__((availability(ios,introduced=17.0))) __attribute__((availability(tvos,introduced=17.0))) __attribute__((availability(watchos,introduced=10.0))) __attribute__((availability(visionos,introduced=1.0))) __attribute__((availability(driverkit,introduced=23.0))) void * malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(3)));

}
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/malloc/_malloc.h" 2 3 4







extern "C" {

void * malloc(size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1))) ;
void * calloc(size_t __count, size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1,2))) ;
void free(void * );
void * realloc(void * __ptr, size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2))) ;
void * reallocf(void * __ptr, size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2)));

void * valloc(size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1))) ;




void * aligned_alloc(size_t __alignment, size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_align(1))) __attribute__((alloc_size(2))) __attribute__((availability(macosx,introduced=10.15))) __attribute__((availability(ios,introduced=13.0))) __attribute__((availability(tvos,introduced=13.0))) __attribute__((availability(watchos,introduced=6.0)));


int posix_memalign(void * *__memptr, size_t __alignment, size_t __size) __attribute__((availability(macosx,introduced=10.6)));

}
# 121 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdlib.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_abort.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_abort.h" 3 4
extern "C" {
void abort(void) __attribute__((__cold__)) __attribute__((__noreturn__));
}
# 122 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdlib.h" 2 3 4

extern "C" {
int abs(int) __attribute__((__const__));
int atexit(void (* _Nonnull)(void));


int at_quick_exit(void (*)(void));

double atof(const char *);
int atoi(const char *);
long atol(const char *);

long long
  atoll(const char *);

void *bsearch(const void *__key, const void *__base, size_t __nel,
     size_t __width, int (* _Nonnull __compar)(const void *, const void *));

div_t div(int, int) __attribute__((__const__));
void exit(int) __attribute__((__noreturn__));

char *getenv(const char *);
long labs(long) __attribute__((__const__));
ldiv_t ldiv(long, long) __attribute__((__const__));

long long
  llabs(long long);
lldiv_t lldiv(long long, long long);


int mblen(const char *__s, size_t __n);
size_t mbstowcs(wchar_t * , const char * , size_t);
int mbtowc(wchar_t * , const char * , size_t);

void qsort(void *__base, size_t __nel, size_t __width,
     int (* _Nonnull __compar)(const void *, const void *));


void quick_exit(int) __attribute__((__noreturn__));

int rand(void) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));

void srand(unsigned) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
double strtod(const char *, char **) __asm("_" "strtod" );
float strtof(const char *, char **) __asm("_" "strtof" );
long strtol(const char *__str, char **__endptr, int __base);
long double
  strtold(const char *, char **);

long long
  strtoll(const char *__str, char **__endptr, int __base);

unsigned long
  strtoul(const char *__str, char **__endptr, int __base);

unsigned long long
  strtoull(const char *__str, char **__endptr, int __base);


__attribute__((__availability__(swift, unavailable, message="Use posix_spawn APIs or NSTask instead. (On iOS, process spawning is unavailable.)")))
__attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,unavailable)))
__attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)))
int system(const char *) __asm("_" "system" );


size_t wcstombs(char * , const wchar_t * , size_t);
int wctomb(char *, wchar_t);


void _Exit(int) __attribute__((__noreturn__));
long a64l(const char *);
double drand48(void);
char *ecvt(double, int, int *, int *);
double erand48(unsigned short[3]);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
int getsubopt(char **, char * const *, char **);
int grantpt(int);

char *initstate(unsigned, char *, size_t);



long jrand48(unsigned short[3]) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));

__attribute__((__deprecated__("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of mktemp(3), it is highly recommended that you use mkstemp(3) instead.")))

char *mktemp(char *);
int mkstemp(char *);
long mrand48(void) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
long nrand48(unsigned short[3]) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
int posix_openpt(int);
char *ptsname(int);


int ptsname_r(int fildes, char *buffer, size_t buflen) __attribute__((availability(macos,introduced=10.13.4))) __attribute__((availability(ios,introduced=11.3))) __attribute__((availability(tvos,introduced=11.3))) __attribute__((availability(watchos,introduced=4.3)));


int putenv(char *) __asm("_" "putenv" );
long random(void) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
int rand_r(unsigned *) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));

char *realpath(const char * , char * ) __asm("_" "realpath" "$DARWIN_EXTSN");



unsigned short
 *seed48(unsigned short[3]);
int setenv(const char * __name, const char * __value, int __overwrite) __asm("_" "setenv" );

void setkey(const char *) __asm("_" "setkey" );



char *setstate(const char *);
void srand48(long);

void srandom(unsigned);



int unlockpt(int);

int unsetenv(const char *) __asm("_" "unsetenv" );




}



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_dev_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_dev_t.h" 3 4
typedef __darwin_dev_t dev_t;
# 258 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdlib.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_mode_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_mode_t.h" 3 4
typedef __darwin_mode_t mode_t;
# 259 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdlib.h" 2 3 4


extern "C" {
uint32_t arc4random(void);
void arc4random_addrandom(unsigned char * , int )
    __attribute__((availability(macosx,introduced=10.0))) __attribute__((availability(macosx,deprecated=10.12,message="use arc4random_stir")))
    __attribute__((availability(ios,introduced=2.0))) __attribute__((availability(ios,deprecated=10.0,message="use arc4random_stir")))
    __attribute__((availability(tvos,introduced=2.0))) __attribute__((availability(tvos,deprecated=10.0,message="use arc4random_stir")))
    __attribute__((availability(watchos,introduced=1.0))) __attribute__((availability(watchos,deprecated=3.0,message="use arc4random_stir")));
void arc4random_buf(void * __buf, size_t __nbytes) __attribute__((availability(macosx,introduced=10.7)));
void arc4random_stir(void);
uint32_t
  arc4random_uniform(uint32_t __upper_bound) __attribute__((availability(macosx,introduced=10.7)));

int atexit_b(void (^ _Nonnull)(void)) __attribute__((availability(macosx,introduced=10.6)));
# 282 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdlib.h" 3 4
void *bsearch_b(const void *__key, const void *__base, size_t __nel,
     size_t __width, int (^ _Nonnull __compar)(const void *, const void *) __attribute__((__noescape__)))
     __attribute__((availability(macosx,introduced=10.6)));



char *cgetcap(char *, const char *, int);
int cgetclose(void);
int cgetent(char **, char **, const char *);
int cgetfirst(char **, char **);
int cgetmatch(const char *, const char *);
int cgetnext(char **, char **);
int cgetnum(char *, const char *, long *);
int cgetset(const char *);
int cgetstr(char *, const char *, char **);
int cgetustr(char *, const char *, char **);

int daemon(int, int) __asm("_" "daemon" ) __attribute__((availability(macosx,introduced=10.0,deprecated=10.5,message="Use posix_spawn APIs instead."))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)));
char *devname(dev_t, mode_t);
char *devname_r(dev_t, mode_t, char *buf, int len);
char *getbsize(int *, long *);
int getloadavg(double [], int);
const char
 *getprogname(void);
void setprogname(const char *);
# 316 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdlib.h" 3 4
int heapsort(void *__base, size_t __nel, size_t __width,
     int (* _Nonnull __compar)(const void *, const void *));

int heapsort_b(void *__base, size_t __nel, size_t __width,
     int (^ _Nonnull __compar)(const void *, const void *) __attribute__((__noescape__)))
     __attribute__((availability(macosx,introduced=10.6)));

int mergesort(void *__base, size_t __nel, size_t __width,
     int (* _Nonnull __compar)(const void *, const void *));

int mergesort_b(void *__base, size_t __nel, size_t __width,
     int (^ _Nonnull __compar)(const void *, const void *) __attribute__((__noescape__)))
     __attribute__((availability(macosx,introduced=10.6)));

void psort(void *__base, size_t __nel, size_t __width,
     int (* _Nonnull __compar)(const void *, const void *))
     __attribute__((availability(macosx,introduced=10.6)));

void psort_b(void *__base, size_t __nel, size_t __width,
     int (^ _Nonnull __compar)(const void *, const void *) __attribute__((__noescape__)))
     __attribute__((availability(macosx,introduced=10.6)));

void psort_r(void *__base, size_t __nel, size_t __width, void *,
     int (* _Nonnull __compar)(void *, const void *, const void *))
     __attribute__((availability(macosx,introduced=10.6)));

void qsort_b(void *__base, size_t __nel, size_t __width,
     int (^ _Nonnull __compar)(const void *, const void *) __attribute__((__noescape__)))
     __attribute__((availability(macosx,introduced=10.6)));

void qsort_r(void *__base, size_t __nel, size_t __width, void *,
     int (* _Nonnull __compar)(void *, const void *, const void *));
int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table,
     unsigned __endbyte);
int rpmatch(const char *)
 __attribute__((availability(macos,introduced=10.15))) __attribute__((availability(ios,introduced=13.0))) __attribute__((availability(tvos,introduced=13.0))) __attribute__((availability(watchos,introduced=6.0)));
int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table,
     unsigned __endbyte);
void sranddev(void);
void srandomdev(void);

long long
 strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
 __attribute__((availability(macos,introduced=11.0))) __attribute__((availability(ios,introduced=14.0))) __attribute__((availability(tvos,introduced=14.0))) __attribute__((availability(watchos,introduced=7.0)));

long long
  strtoq(const char *__str, char **__endptr, int __base);
unsigned long long
  strtouq(const char *__str, char **__endptr, int __base);

extern char *suboptarg;

}


extern "C" {




}
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4
# 95 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 2 3



extern "C++" {
# 113 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 3
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long abs(long __x) throw() { return __builtin_labs(__x); }
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long long abs(long long __x) throw() {
  return __builtin_llabs(__x);
}


                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float abs(float __lcpp_x) throw() {
  return __builtin_fabsf(__lcpp_x);
}

                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double abs(double __lcpp_x) throw() {
  return __builtin_fabs(__lcpp_x);
}

                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double abs(long double __lcpp_x) throw() {
  return __builtin_fabsl(__lcpp_x);
}
# 145 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 3
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ldiv_t div(long __x, long __y) throw() { return ::ldiv(__x, __y); }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) lldiv_t div(long long __x, long long __y) throw() { return ::lldiv(__x, __y); }


}
# 381 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 2 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __math {




template <class = int>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int fpclassify(float __x) throw() {
  return __builtin_fpclassify(1, 2, 4, 5, 3, __x);
}

template <class = int>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int fpclassify(double __x) throw() {
  return __builtin_fpclassify(1, 2, 4, 5, 3, __x);
}

template <class = int>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int fpclassify(long double __x) throw() {
  return __builtin_fpclassify(1, 2, 4, 5, 3, __x);
}

template <class _A1, std::__enable_if_t<std::is_integral<_A1>::value, int> = 0>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int fpclassify(_A1 __x) throw() {
  return __x == 0 ? 3 : 4;
}

}

}}

using std::__math::fpclassify;
using std::__math::signbit;



using std::__math::isfinite;
using std::__math::isgreater;
using std::__math::isgreaterequal;
using std::__math::isinf;
using std::__math::isless;
using std::__math::islessequal;
using std::__math::islessgreater;
using std::__math::isnan;
using std::__math::isnormal;
using std::__math::isunordered;
# 444 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 3
using std::__math::acos;
using std::__math::acosh;
using std::__math::asin;
using std::__math::asinh;
using std::__math::atan;
using std::__math::atan2;
using std::__math::atanh;
using std::__math::cbrt;
using std::__math::ceil;
using std::__math::copysign;
using std::__math::cos;
using std::__math::cosh;
using std::__math::erf;
using std::__math::erfc;
using std::__math::exp;
using std::__math::exp2;
using std::__math::expm1;
using std::__math::fabs;
using std::__math::fdim;
using std::__math::floor;
using std::__math::fma;
using std::__math::fmax;
using std::__math::fmin;
using std::__math::fmod;
using std::__math::frexp;
using std::__math::hypot;
using std::__math::ilogb;
using std::__math::ldexp;
using std::__math::lgamma;
using std::__math::llrint;
using std::__math::llround;
using std::__math::log;
using std::__math::log10;
using std::__math::log1p;
using std::__math::log2;
using std::__math::logb;
using std::__math::lrint;
using std::__math::lround;
using std::__math::modf;
using std::__math::nearbyint;
using std::__math::nextafter;
using std::__math::nexttoward;
using std::__math::pow;
using std::__math::remainder;
using std::__math::remquo;
using std::__math::rint;
using std::__math::round;
using std::__math::scalbln;
using std::__math::scalbn;
using std::__math::signbit;
using std::__math::sin;
using std::__math::sinh;
using std::__math::sqrt;
using std::__math::tan;
using std::__math::tanh;
using std::__math::tgamma;
using std::__math::trunc;

}
# 320 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 2 3
# 331 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 335 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::signbit __attribute__((__using_if_exists__));
using ::fpclassify __attribute__((__using_if_exists__));
using ::isfinite __attribute__((__using_if_exists__));
using ::isinf __attribute__((__using_if_exists__));
using ::isnan __attribute__((__using_if_exists__));
using ::isnormal __attribute__((__using_if_exists__));
using ::isgreater __attribute__((__using_if_exists__));
using ::isgreaterequal __attribute__((__using_if_exists__));
using ::isless __attribute__((__using_if_exists__));
using ::islessequal __attribute__((__using_if_exists__));
using ::islessgreater __attribute__((__using_if_exists__));
using ::isunordered __attribute__((__using_if_exists__));
using ::isunordered __attribute__((__using_if_exists__));

using ::float_t __attribute__((__using_if_exists__));
using ::double_t __attribute__((__using_if_exists__));

using ::abs __attribute__((__using_if_exists__));

using ::acos __attribute__((__using_if_exists__));
using ::acosf __attribute__((__using_if_exists__));
using ::asin __attribute__((__using_if_exists__));
using ::asinf __attribute__((__using_if_exists__));
using ::atan __attribute__((__using_if_exists__));
using ::atanf __attribute__((__using_if_exists__));
using ::atan2 __attribute__((__using_if_exists__));
using ::atan2f __attribute__((__using_if_exists__));
using ::ceil __attribute__((__using_if_exists__));
using ::ceilf __attribute__((__using_if_exists__));
using ::cos __attribute__((__using_if_exists__));
using ::cosf __attribute__((__using_if_exists__));
using ::cosh __attribute__((__using_if_exists__));
using ::coshf __attribute__((__using_if_exists__));

using ::exp __attribute__((__using_if_exists__));
using ::expf __attribute__((__using_if_exists__));

using ::fabs __attribute__((__using_if_exists__));
using ::fabsf __attribute__((__using_if_exists__));
using ::floor __attribute__((__using_if_exists__));
using ::floorf __attribute__((__using_if_exists__));

using ::fmod __attribute__((__using_if_exists__));
using ::fmodf __attribute__((__using_if_exists__));

using ::frexp __attribute__((__using_if_exists__));
using ::frexpf __attribute__((__using_if_exists__));
using ::ldexp __attribute__((__using_if_exists__));
using ::ldexpf __attribute__((__using_if_exists__));

using ::log __attribute__((__using_if_exists__));
using ::logf __attribute__((__using_if_exists__));

using ::log10 __attribute__((__using_if_exists__));
using ::log10f __attribute__((__using_if_exists__));
using ::modf __attribute__((__using_if_exists__));
using ::modff __attribute__((__using_if_exists__));

using ::pow __attribute__((__using_if_exists__));
using ::powf __attribute__((__using_if_exists__));

using ::sin __attribute__((__using_if_exists__));
using ::sinf __attribute__((__using_if_exists__));
using ::sinh __attribute__((__using_if_exists__));
using ::sinhf __attribute__((__using_if_exists__));

using ::sqrt __attribute__((__using_if_exists__));
using ::sqrtf __attribute__((__using_if_exists__));
using ::tan __attribute__((__using_if_exists__));
using ::tanf __attribute__((__using_if_exists__));

using ::tanh __attribute__((__using_if_exists__));
using ::tanhf __attribute__((__using_if_exists__));

using ::acosh __attribute__((__using_if_exists__));
using ::acoshf __attribute__((__using_if_exists__));
using ::asinh __attribute__((__using_if_exists__));
using ::asinhf __attribute__((__using_if_exists__));
using ::atanh __attribute__((__using_if_exists__));
using ::atanhf __attribute__((__using_if_exists__));
using ::cbrt __attribute__((__using_if_exists__));
using ::cbrtf __attribute__((__using_if_exists__));

using ::copysign __attribute__((__using_if_exists__));
using ::copysignf __attribute__((__using_if_exists__));

using ::erf __attribute__((__using_if_exists__));
using ::erff __attribute__((__using_if_exists__));
using ::erfc __attribute__((__using_if_exists__));
using ::erfcf __attribute__((__using_if_exists__));
using ::exp2 __attribute__((__using_if_exists__));
using ::exp2f __attribute__((__using_if_exists__));
using ::expm1 __attribute__((__using_if_exists__));
using ::expm1f __attribute__((__using_if_exists__));
using ::fdim __attribute__((__using_if_exists__));
using ::fdimf __attribute__((__using_if_exists__));
using ::fmaf __attribute__((__using_if_exists__));
using ::fma __attribute__((__using_if_exists__));
using ::fmax __attribute__((__using_if_exists__));
using ::fmaxf __attribute__((__using_if_exists__));
using ::fmin __attribute__((__using_if_exists__));
using ::fminf __attribute__((__using_if_exists__));
using ::hypot __attribute__((__using_if_exists__));
using ::hypotf __attribute__((__using_if_exists__));
using ::ilogb __attribute__((__using_if_exists__));
using ::ilogbf __attribute__((__using_if_exists__));
using ::lgamma __attribute__((__using_if_exists__));
using ::lgammaf __attribute__((__using_if_exists__));
using ::llrint __attribute__((__using_if_exists__));
using ::llrintf __attribute__((__using_if_exists__));
using ::llround __attribute__((__using_if_exists__));
using ::llroundf __attribute__((__using_if_exists__));
using ::log1p __attribute__((__using_if_exists__));
using ::log1pf __attribute__((__using_if_exists__));
using ::log2 __attribute__((__using_if_exists__));
using ::log2f __attribute__((__using_if_exists__));
using ::logb __attribute__((__using_if_exists__));
using ::logbf __attribute__((__using_if_exists__));
using ::lrint __attribute__((__using_if_exists__));
using ::lrintf __attribute__((__using_if_exists__));
using ::lround __attribute__((__using_if_exists__));
using ::lroundf __attribute__((__using_if_exists__));

using ::nan __attribute__((__using_if_exists__));
using ::nanf __attribute__((__using_if_exists__));

using ::nearbyint __attribute__((__using_if_exists__));
using ::nearbyintf __attribute__((__using_if_exists__));
using ::nextafter __attribute__((__using_if_exists__));
using ::nextafterf __attribute__((__using_if_exists__));
using ::nexttoward __attribute__((__using_if_exists__));
using ::nexttowardf __attribute__((__using_if_exists__));
using ::remainder __attribute__((__using_if_exists__));
using ::remainderf __attribute__((__using_if_exists__));
using ::remquo __attribute__((__using_if_exists__));
using ::remquof __attribute__((__using_if_exists__));
using ::rint __attribute__((__using_if_exists__));
using ::rintf __attribute__((__using_if_exists__));
using ::round __attribute__((__using_if_exists__));
using ::roundf __attribute__((__using_if_exists__));
using ::scalbln __attribute__((__using_if_exists__));
using ::scalblnf __attribute__((__using_if_exists__));
using ::scalbn __attribute__((__using_if_exists__));
using ::scalbnf __attribute__((__using_if_exists__));
using ::tgamma __attribute__((__using_if_exists__));
using ::tgammaf __attribute__((__using_if_exists__));
using ::trunc __attribute__((__using_if_exists__));
using ::truncf __attribute__((__using_if_exists__));

using ::acosl __attribute__((__using_if_exists__));
using ::asinl __attribute__((__using_if_exists__));
using ::atanl __attribute__((__using_if_exists__));
using ::atan2l __attribute__((__using_if_exists__));
using ::ceill __attribute__((__using_if_exists__));
using ::cosl __attribute__((__using_if_exists__));
using ::coshl __attribute__((__using_if_exists__));
using ::expl __attribute__((__using_if_exists__));
using ::fabsl __attribute__((__using_if_exists__));
using ::floorl __attribute__((__using_if_exists__));
using ::fmodl __attribute__((__using_if_exists__));
using ::frexpl __attribute__((__using_if_exists__));
using ::ldexpl __attribute__((__using_if_exists__));
using ::logl __attribute__((__using_if_exists__));
using ::log10l __attribute__((__using_if_exists__));
using ::modfl __attribute__((__using_if_exists__));
using ::powl __attribute__((__using_if_exists__));
using ::sinl __attribute__((__using_if_exists__));
using ::sinhl __attribute__((__using_if_exists__));
using ::sqrtl __attribute__((__using_if_exists__));
using ::tanl __attribute__((__using_if_exists__));

using ::tanhl __attribute__((__using_if_exists__));
using ::acoshl __attribute__((__using_if_exists__));
using ::asinhl __attribute__((__using_if_exists__));
using ::atanhl __attribute__((__using_if_exists__));
using ::cbrtl __attribute__((__using_if_exists__));

using ::copysignl __attribute__((__using_if_exists__));

using ::erfl __attribute__((__using_if_exists__));
using ::erfcl __attribute__((__using_if_exists__));
using ::exp2l __attribute__((__using_if_exists__));
using ::expm1l __attribute__((__using_if_exists__));
using ::fdiml __attribute__((__using_if_exists__));
using ::fmal __attribute__((__using_if_exists__));
using ::fmaxl __attribute__((__using_if_exists__));
using ::fminl __attribute__((__using_if_exists__));
using ::hypotl __attribute__((__using_if_exists__));
using ::ilogbl __attribute__((__using_if_exists__));
using ::lgammal __attribute__((__using_if_exists__));
using ::llrintl __attribute__((__using_if_exists__));
using ::llroundl __attribute__((__using_if_exists__));
using ::log1pl __attribute__((__using_if_exists__));
using ::log2l __attribute__((__using_if_exists__));
using ::logbl __attribute__((__using_if_exists__));
using ::lrintl __attribute__((__using_if_exists__));
using ::lroundl __attribute__((__using_if_exists__));
using ::nanl __attribute__((__using_if_exists__));
using ::nearbyintl __attribute__((__using_if_exists__));
using ::nextafterl __attribute__((__using_if_exists__));
using ::nexttowardl __attribute__((__using_if_exists__));
using ::remainderl __attribute__((__using_if_exists__));
using ::remquol __attribute__((__using_if_exists__));
using ::rintl __attribute__((__using_if_exists__));
using ::roundl __attribute__((__using_if_exists__));
using ::scalblnl __attribute__((__using_if_exists__));
using ::scalbnl __attribute__((__using_if_exists__));
using ::tgammal __attribute__((__using_if_exists__));
using ::truncl __attribute__((__using_if_exists__));
# 572 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 3
template <class _A1, __enable_if_t<is_floating_point<_A1>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __constexpr_isnan(_A1 __lcpp_x) throw() {

  return __builtin_isnan(__lcpp_x);



}

template <class _A1, __enable_if_t<!is_floating_point<_A1>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __constexpr_isnan(_A1 __lcpp_x) throw() {
  return std::isnan(__lcpp_x);
}

template <class _A1, __enable_if_t<is_floating_point<_A1>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __constexpr_isinf(_A1 __lcpp_x) throw() {

  return __builtin_isinf(__lcpp_x);



}

template <class _A1, __enable_if_t<!is_floating_point<_A1>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __constexpr_isinf(_A1 __lcpp_x) throw() {
  return std::isinf(__lcpp_x);
}

template <class _A1, __enable_if_t<is_floating_point<_A1>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __constexpr_isfinite(_A1 __lcpp_x) throw() {

  return __builtin_isfinite(__lcpp_x);



}

template <class _A1, __enable_if_t<!is_floating_point<_A1>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __constexpr_isfinite(_A1 __lcpp_x) throw() {
  return __builtin_isfinite(__lcpp_x);
}

                  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float __constexpr_copysign(float __x, float __y) throw() {
  return __builtin_copysignf(__x, __y);
}

                  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double __constexpr_copysign(double __x, double __y) throw() {
  return __builtin_copysign(__x, __y);
}

                  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double
__constexpr_copysign(long double __x, long double __y) throw() {
  return __builtin_copysignl(__x, __y);
}

template <class _A1,
          class _A2,
          __enable_if_t<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, int> = 0>
                  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename __promote<_A1, _A2>::type
__constexpr_copysign(_A1 __x, _A2 __y) throw() {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  _Static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
  return __builtin_copysign((__result_type)__x, (__result_type)__y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float __constexpr_fabs(float __x) throw() {
  return __builtin_fabsf(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double __constexpr_fabs(double __x) throw() {
  return __builtin_fabs(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double __constexpr_fabs(long double __x) throw() {
  return __builtin_fabsl(__x);
}

template <class _Tp, __enable_if_t<is_integral<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double __constexpr_fabs(_Tp __x) throw() {
  return __builtin_fabs(static_cast<double>(__x));
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float __constexpr_fmax(float __x, float __y) throw() {
# 664 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 3
  return __builtin_fmaxf(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double __constexpr_fmax(double __x, double __y) throw() {
# 677 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 3
  return __builtin_fmax(__x, __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double
__constexpr_fmax(long double __x, long double __y) throw() {
# 691 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 3
  return __builtin_fmaxl(__x, __y);
}

template <class _Tp, class _Up, __enable_if_t<is_arithmetic<_Tp>::value && is_arithmetic<_Up>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename __promote<_Tp, _Up>::type
__constexpr_fmax(_Tp __x, _Up __y) throw() {
  using __result_type = typename __promote<_Tp, _Up>::type;
  return std::__constexpr_fmax(static_cast<__result_type>(__x), static_cast<__result_type>(__y));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp __constexpr_logb(_Tp __x) {

  if (__libcpp_is_constant_evaluated()) {
    if (__x == _Tp(0)) {

      return -numeric_limits<_Tp>::infinity();
    }

    if (std::__constexpr_isinf(__x))
      return numeric_limits<_Tp>::infinity();

    if (std::__constexpr_isnan(__x))
      return numeric_limits<_Tp>::quiet_NaN();

    __x = std::__constexpr_fabs(__x);
    unsigned long long __exp = 0;
    while (__x >= numeric_limits<_Tp>::radix) {
      __x /= numeric_limits<_Tp>::radix;
      __exp += 1;
    }
    return _Tp(__exp);
  }

  return __builtin_logb(__x);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp __constexpr_scalbn(_Tp __x, int __exp) {

  if (__libcpp_is_constant_evaluated()) {
    if (__x == _Tp(0))
      return __x;

    if (std::__constexpr_isinf(__x))
      return __x;

    if (__exp == _Tp(0))
      return __x;

    if (std::__constexpr_isnan(__x))
      return numeric_limits<_Tp>::quiet_NaN();

    _Tp __mult(1);
    if (__exp > 0) {
      __mult = numeric_limits<_Tp>::radix;
      --__exp;
    } else {
      ++__exp;
      __exp = -__exp;
      __mult /= numeric_limits<_Tp>::radix;
    }

    while (__exp > 0) {
      if (!(__exp & 1)) {
        __mult *= __mult;
        __exp >>= 1;
      } else {
        __x *= __mult;
        --__exp;
      }
    }
    return __x;
  }

  return __builtin_scalbn(__x, __exp);
}
# 808 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cmath" 3
}}
# 2 "/opt/homebrew/include/glm/detail/_fixes.hpp" 2
# 105 "/opt/homebrew/include/glm/glm.hpp" 2

# 1 "/opt/homebrew/include/glm/detail/setup.hpp" 1


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 58 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_assert.h" 1 3 4
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_static_assert.h" 1 3 4
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 4 "/opt/homebrew/include/glm/detail/setup.hpp" 2
# 43 "/opt/homebrew/include/glm/detail/setup.hpp"
# 1 "/opt/homebrew/include/glm/detail/../simd/platform.h" 1
# 44 "/opt/homebrew/include/glm/detail/setup.hpp" 2
# 632 "/opt/homebrew/include/glm/detail/setup.hpp"
namespace glm
{
 using std::size_t;



  typedef int length_t;

}
# 670 "/opt/homebrew/include/glm/detail/setup.hpp"
namespace glm{
namespace detail
{
 template<typename T>
 struct is_int
 {
  enum test {value = 0};
 };

 template<>
 struct is_int<unsigned int>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<signed int>
 {
  enum test {value = ~0};
 };
}

 typedef unsigned int uint;
}
# 702 "/opt/homebrew/include/glm/detail/setup.hpp"
namespace glm{
namespace detail
{
# 719 "/opt/homebrew/include/glm/detail/setup.hpp"
#pragma clang diagnostic ignored "-Wc++11-long-long"
  typedef unsigned long long uint64;
  typedef signed long long int64;




}
}
# 744 "/opt/homebrew/include/glm/detail/setup.hpp"
namespace glm{
namespace detail
{
 template<typename genType>
 struct make_unsigned
 {};

 template<>
 struct make_unsigned<char>
 {
  typedef unsigned char type;
 };

 template<>
 struct make_unsigned<signed char>
 {
  typedef unsigned char type;
 };

 template<>
 struct make_unsigned<short>
 {
  typedef unsigned short type;
 };

 template<>
 struct make_unsigned<int>
 {
  typedef unsigned int type;
 };

 template<>
 struct make_unsigned<long>
 {
  typedef unsigned long type;
 };

 template<>
 struct make_unsigned<int64>
 {
  typedef uint64 type;
 };

 template<>
 struct make_unsigned<unsigned char>
 {
  typedef unsigned char type;
 };

 template<>
 struct make_unsigned<unsigned short>
 {
  typedef unsigned short type;
 };

 template<>
 struct make_unsigned<unsigned int>
 {
  typedef unsigned int type;
 };

 template<>
 struct make_unsigned<unsigned long>
 {
  typedef unsigned long type;
 };

 template<>
 struct make_unsigned<uint64>
 {
  typedef uint64 type;
 };
}
}
# 107 "/opt/homebrew/include/glm/glm.hpp" 2




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/climits" 1 3
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/climits" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/limits.h" 1 3
# 21 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/limits.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/limits.h" 1 3 4
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/limits.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/limits.h" 1 3 4
# 11 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/limits.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/limits.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/limits.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/_limits.h" 1 3 4
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/arm/limits.h" 2 3 4
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/machine/limits.h" 2 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/limits.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/syslimits.h" 1 3 4
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/limits.h" 2 3 4
# 22 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/limits.h" 2 3
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/climits" 2 3
# 47 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/climits" 3
# 112 "/opt/homebrew/include/glm/glm.hpp" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cfloat" 1 3
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cfloat" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/float.h" 1 3
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/float.h" 3



# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/float.h" 1 3
# 28 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/float.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/float.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/float.h" 2 3
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/float.h" 2 3
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cfloat" 2 3
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cfloat" 3
# 113 "/opt/homebrew/include/glm/glm.hpp" 2

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 115 "/opt/homebrew/include/glm/glm.hpp" 2
# 1 "/opt/homebrew/include/glm/fwd.hpp" 1


# 1 "/opt/homebrew/include/glm/detail/qualifier.hpp" 1


# 1 "/opt/homebrew/include/glm/detail/setup.hpp" 1
# 4 "/opt/homebrew/include/glm/detail/qualifier.hpp" 2

namespace glm
{

 enum qualifier
 {
  packed_highp,
  packed_mediump,
  packed_lowp,
# 21 "/opt/homebrew/include/glm/detail/qualifier.hpp"
  highp = packed_highp,
  mediump = packed_mediump,
  lowp = packed_lowp,
  packed = packed_highp,




   defaultp = highp

 };

 typedef qualifier precision;

 template<length_t L, typename T, qualifier Q = defaultp> struct vec;
 template<length_t C, length_t R, typename T, qualifier Q = defaultp> struct mat;
 template<typename T, qualifier Q = defaultp> struct qua;
# 56 "/opt/homebrew/include/glm/detail/qualifier.hpp"
namespace detail
{
 template<glm::qualifier P>
 struct is_aligned
 {
  static const bool value = false;
 };
# 84 "/opt/homebrew/include/glm/detail/qualifier.hpp"
 template<length_t L, typename T, bool is_aligned>
 struct storage
 {
  typedef struct type {
   T data[L];
  } type;
 };
# 189 "/opt/homebrew/include/glm/detail/qualifier.hpp"
 enum genTypeEnum
 {
  GENTYPE_VEC,
  GENTYPE_MAT,
  GENTYPE_QUAT
 };

 template <typename genType>
 struct genTypeTrait
 {};

 template <length_t C, length_t R, typename T>
 struct genTypeTrait<mat<C, R, T> >
 {
  static const genTypeEnum GENTYPE = GENTYPE_MAT;
 };

 template<typename genType, genTypeEnum type>
 struct init_gentype
 {
 };

 template<typename genType>
 struct init_gentype<genType, GENTYPE_QUAT>
 {
  inline static genType identity()
  {
   return genType(1, 0, 0, 0);
  }
 };

 template<typename genType>
 struct init_gentype<genType, GENTYPE_MAT>
 {
  inline static genType identity()
  {
   return genType(1);
  }
 };
}
}
# 4 "/opt/homebrew/include/glm/fwd.hpp" 2

namespace glm
{
# 18 "/opt/homebrew/include/glm/fwd.hpp"
 typedef signed char int8;
 typedef signed short int16;
 typedef signed int int32;
 typedef detail::int64 int64;

 typedef unsigned char uint8;
 typedef unsigned short uint16;
 typedef unsigned int uint32;
 typedef detail::uint64 uint64;




 typedef int8 lowp_i8;
 typedef int8 mediump_i8;
 typedef int8 highp_i8;
 typedef int8 i8;

 typedef int8 lowp_int8;
 typedef int8 mediump_int8;
 typedef int8 highp_int8;

 typedef int8 lowp_int8_t;
 typedef int8 mediump_int8_t;
 typedef int8 highp_int8_t;
 typedef int8 int8_t;

 typedef int16 lowp_i16;
 typedef int16 mediump_i16;
 typedef int16 highp_i16;
 typedef int16 i16;

 typedef int16 lowp_int16;
 typedef int16 mediump_int16;
 typedef int16 highp_int16;

 typedef int16 lowp_int16_t;
 typedef int16 mediump_int16_t;
 typedef int16 highp_int16_t;
 typedef int16 int16_t;

 typedef int32 lowp_i32;
 typedef int32 mediump_i32;
 typedef int32 highp_i32;
 typedef int32 i32;

 typedef int32 lowp_int32;
 typedef int32 mediump_int32;
 typedef int32 highp_int32;

 typedef int32 lowp_int32_t;
 typedef int32 mediump_int32_t;
 typedef int32 highp_int32_t;
 typedef int32 int32_t;

 typedef int64 lowp_i64;
 typedef int64 mediump_i64;
 typedef int64 highp_i64;
 typedef int64 i64;

 typedef int64 lowp_int64;
 typedef int64 mediump_int64;
 typedef int64 highp_int64;

 typedef int64 lowp_int64_t;
 typedef int64 mediump_int64_t;
 typedef int64 highp_int64_t;
 typedef int64 int64_t;



 typedef unsigned int uint;

 typedef uint8 lowp_u8;
 typedef uint8 mediump_u8;
 typedef uint8 highp_u8;
 typedef uint8 u8;

 typedef uint8 lowp_uint8;
 typedef uint8 mediump_uint8;
 typedef uint8 highp_uint8;

 typedef uint8 lowp_uint8_t;
 typedef uint8 mediump_uint8_t;
 typedef uint8 highp_uint8_t;
 typedef uint8 uint8_t;

 typedef uint16 lowp_u16;
 typedef uint16 mediump_u16;
 typedef uint16 highp_u16;
 typedef uint16 u16;

 typedef uint16 lowp_uint16;
 typedef uint16 mediump_uint16;
 typedef uint16 highp_uint16;

 typedef uint16 lowp_uint16_t;
 typedef uint16 mediump_uint16_t;
 typedef uint16 highp_uint16_t;
 typedef uint16 uint16_t;

 typedef uint32 lowp_u32;
 typedef uint32 mediump_u32;
 typedef uint32 highp_u32;
 typedef uint32 u32;

 typedef uint32 lowp_uint32;
 typedef uint32 mediump_uint32;
 typedef uint32 highp_uint32;

 typedef uint32 lowp_uint32_t;
 typedef uint32 mediump_uint32_t;
 typedef uint32 highp_uint32_t;
 typedef uint32 uint32_t;

 typedef uint64 lowp_u64;
 typedef uint64 mediump_u64;
 typedef uint64 highp_u64;
 typedef uint64 u64;

 typedef uint64 lowp_uint64;
 typedef uint64 mediump_uint64;
 typedef uint64 highp_uint64;

 typedef uint64 lowp_uint64_t;
 typedef uint64 mediump_uint64_t;
 typedef uint64 highp_uint64_t;
 typedef uint64 uint64_t;



 typedef float lowp_f32;
 typedef float mediump_f32;
 typedef float highp_f32;
 typedef float f32;

 typedef float lowp_float32;
 typedef float mediump_float32;
 typedef float highp_float32;
 typedef float float32;

 typedef float lowp_float32_t;
 typedef float mediump_float32_t;
 typedef float highp_float32_t;
 typedef float float32_t;


 typedef double lowp_f64;
 typedef double mediump_f64;
 typedef double highp_f64;
 typedef double f64;

 typedef double lowp_float64;
 typedef double mediump_float64;
 typedef double highp_float64;
 typedef double float64;

 typedef double lowp_float64_t;
 typedef double mediump_float64_t;
 typedef double highp_float64_t;
 typedef double float64_t;



 typedef vec<1, bool, lowp> lowp_bvec1;
 typedef vec<2, bool, lowp> lowp_bvec2;
 typedef vec<3, bool, lowp> lowp_bvec3;
 typedef vec<4, bool, lowp> lowp_bvec4;

 typedef vec<1, bool, mediump> mediump_bvec1;
 typedef vec<2, bool, mediump> mediump_bvec2;
 typedef vec<3, bool, mediump> mediump_bvec3;
 typedef vec<4, bool, mediump> mediump_bvec4;

 typedef vec<1, bool, highp> highp_bvec1;
 typedef vec<2, bool, highp> highp_bvec2;
 typedef vec<3, bool, highp> highp_bvec3;
 typedef vec<4, bool, highp> highp_bvec4;

 typedef vec<1, bool, defaultp> bvec1;
 typedef vec<2, bool, defaultp> bvec2;
 typedef vec<3, bool, defaultp> bvec3;
 typedef vec<4, bool, defaultp> bvec4;



 typedef vec<1, int, lowp> lowp_ivec1;
 typedef vec<2, int, lowp> lowp_ivec2;
 typedef vec<3, int, lowp> lowp_ivec3;
 typedef vec<4, int, lowp> lowp_ivec4;

 typedef vec<1, int, mediump> mediump_ivec1;
 typedef vec<2, int, mediump> mediump_ivec2;
 typedef vec<3, int, mediump> mediump_ivec3;
 typedef vec<4, int, mediump> mediump_ivec4;

 typedef vec<1, int, highp> highp_ivec1;
 typedef vec<2, int, highp> highp_ivec2;
 typedef vec<3, int, highp> highp_ivec3;
 typedef vec<4, int, highp> highp_ivec4;

 typedef vec<1, int, defaultp> ivec1;
 typedef vec<2, int, defaultp> ivec2;
 typedef vec<3, int, defaultp> ivec3;
 typedef vec<4, int, defaultp> ivec4;

 typedef vec<1, i8, lowp> lowp_i8vec1;
 typedef vec<2, i8, lowp> lowp_i8vec2;
 typedef vec<3, i8, lowp> lowp_i8vec3;
 typedef vec<4, i8, lowp> lowp_i8vec4;

 typedef vec<1, i8, mediump> mediump_i8vec1;
 typedef vec<2, i8, mediump> mediump_i8vec2;
 typedef vec<3, i8, mediump> mediump_i8vec3;
 typedef vec<4, i8, mediump> mediump_i8vec4;

 typedef vec<1, i8, highp> highp_i8vec1;
 typedef vec<2, i8, highp> highp_i8vec2;
 typedef vec<3, i8, highp> highp_i8vec3;
 typedef vec<4, i8, highp> highp_i8vec4;

 typedef vec<1, i8, defaultp> i8vec1;
 typedef vec<2, i8, defaultp> i8vec2;
 typedef vec<3, i8, defaultp> i8vec3;
 typedef vec<4, i8, defaultp> i8vec4;

 typedef vec<1, i16, lowp> lowp_i16vec1;
 typedef vec<2, i16, lowp> lowp_i16vec2;
 typedef vec<3, i16, lowp> lowp_i16vec3;
 typedef vec<4, i16, lowp> lowp_i16vec4;

 typedef vec<1, i16, mediump> mediump_i16vec1;
 typedef vec<2, i16, mediump> mediump_i16vec2;
 typedef vec<3, i16, mediump> mediump_i16vec3;
 typedef vec<4, i16, mediump> mediump_i16vec4;

 typedef vec<1, i16, highp> highp_i16vec1;
 typedef vec<2, i16, highp> highp_i16vec2;
 typedef vec<3, i16, highp> highp_i16vec3;
 typedef vec<4, i16, highp> highp_i16vec4;

 typedef vec<1, i16, defaultp> i16vec1;
 typedef vec<2, i16, defaultp> i16vec2;
 typedef vec<3, i16, defaultp> i16vec3;
 typedef vec<4, i16, defaultp> i16vec4;

 typedef vec<1, i32, lowp> lowp_i32vec1;
 typedef vec<2, i32, lowp> lowp_i32vec2;
 typedef vec<3, i32, lowp> lowp_i32vec3;
 typedef vec<4, i32, lowp> lowp_i32vec4;

 typedef vec<1, i32, mediump> mediump_i32vec1;
 typedef vec<2, i32, mediump> mediump_i32vec2;
 typedef vec<3, i32, mediump> mediump_i32vec3;
 typedef vec<4, i32, mediump> mediump_i32vec4;

 typedef vec<1, i32, highp> highp_i32vec1;
 typedef vec<2, i32, highp> highp_i32vec2;
 typedef vec<3, i32, highp> highp_i32vec3;
 typedef vec<4, i32, highp> highp_i32vec4;

 typedef vec<1, i32, defaultp> i32vec1;
 typedef vec<2, i32, defaultp> i32vec2;
 typedef vec<3, i32, defaultp> i32vec3;
 typedef vec<4, i32, defaultp> i32vec4;

 typedef vec<1, i64, lowp> lowp_i64vec1;
 typedef vec<2, i64, lowp> lowp_i64vec2;
 typedef vec<3, i64, lowp> lowp_i64vec3;
 typedef vec<4, i64, lowp> lowp_i64vec4;

 typedef vec<1, i64, mediump> mediump_i64vec1;
 typedef vec<2, i64, mediump> mediump_i64vec2;
 typedef vec<3, i64, mediump> mediump_i64vec3;
 typedef vec<4, i64, mediump> mediump_i64vec4;

 typedef vec<1, i64, highp> highp_i64vec1;
 typedef vec<2, i64, highp> highp_i64vec2;
 typedef vec<3, i64, highp> highp_i64vec3;
 typedef vec<4, i64, highp> highp_i64vec4;

 typedef vec<1, i64, defaultp> i64vec1;
 typedef vec<2, i64, defaultp> i64vec2;
 typedef vec<3, i64, defaultp> i64vec3;
 typedef vec<4, i64, defaultp> i64vec4;



 typedef vec<1, uint, lowp> lowp_uvec1;
 typedef vec<2, uint, lowp> lowp_uvec2;
 typedef vec<3, uint, lowp> lowp_uvec3;
 typedef vec<4, uint, lowp> lowp_uvec4;

 typedef vec<1, uint, mediump> mediump_uvec1;
 typedef vec<2, uint, mediump> mediump_uvec2;
 typedef vec<3, uint, mediump> mediump_uvec3;
 typedef vec<4, uint, mediump> mediump_uvec4;

 typedef vec<1, uint, highp> highp_uvec1;
 typedef vec<2, uint, highp> highp_uvec2;
 typedef vec<3, uint, highp> highp_uvec3;
 typedef vec<4, uint, highp> highp_uvec4;

 typedef vec<1, uint, defaultp> uvec1;
 typedef vec<2, uint, defaultp> uvec2;
 typedef vec<3, uint, defaultp> uvec3;
 typedef vec<4, uint, defaultp> uvec4;

 typedef vec<1, u8, lowp> lowp_u8vec1;
 typedef vec<2, u8, lowp> lowp_u8vec2;
 typedef vec<3, u8, lowp> lowp_u8vec3;
 typedef vec<4, u8, lowp> lowp_u8vec4;

 typedef vec<1, u8, mediump> mediump_u8vec1;
 typedef vec<2, u8, mediump> mediump_u8vec2;
 typedef vec<3, u8, mediump> mediump_u8vec3;
 typedef vec<4, u8, mediump> mediump_u8vec4;

 typedef vec<1, u8, highp> highp_u8vec1;
 typedef vec<2, u8, highp> highp_u8vec2;
 typedef vec<3, u8, highp> highp_u8vec3;
 typedef vec<4, u8, highp> highp_u8vec4;

 typedef vec<1, u8, defaultp> u8vec1;
 typedef vec<2, u8, defaultp> u8vec2;
 typedef vec<3, u8, defaultp> u8vec3;
 typedef vec<4, u8, defaultp> u8vec4;

 typedef vec<1, u16, lowp> lowp_u16vec1;
 typedef vec<2, u16, lowp> lowp_u16vec2;
 typedef vec<3, u16, lowp> lowp_u16vec3;
 typedef vec<4, u16, lowp> lowp_u16vec4;

 typedef vec<1, u16, mediump> mediump_u16vec1;
 typedef vec<2, u16, mediump> mediump_u16vec2;
 typedef vec<3, u16, mediump> mediump_u16vec3;
 typedef vec<4, u16, mediump> mediump_u16vec4;

 typedef vec<1, u16, highp> highp_u16vec1;
 typedef vec<2, u16, highp> highp_u16vec2;
 typedef vec<3, u16, highp> highp_u16vec3;
 typedef vec<4, u16, highp> highp_u16vec4;

 typedef vec<1, u16, defaultp> u16vec1;
 typedef vec<2, u16, defaultp> u16vec2;
 typedef vec<3, u16, defaultp> u16vec3;
 typedef vec<4, u16, defaultp> u16vec4;

 typedef vec<1, u32, lowp> lowp_u32vec1;
 typedef vec<2, u32, lowp> lowp_u32vec2;
 typedef vec<3, u32, lowp> lowp_u32vec3;
 typedef vec<4, u32, lowp> lowp_u32vec4;

 typedef vec<1, u32, mediump> mediump_u32vec1;
 typedef vec<2, u32, mediump> mediump_u32vec2;
 typedef vec<3, u32, mediump> mediump_u32vec3;
 typedef vec<4, u32, mediump> mediump_u32vec4;

 typedef vec<1, u32, highp> highp_u32vec1;
 typedef vec<2, u32, highp> highp_u32vec2;
 typedef vec<3, u32, highp> highp_u32vec3;
 typedef vec<4, u32, highp> highp_u32vec4;

 typedef vec<1, u32, defaultp> u32vec1;
 typedef vec<2, u32, defaultp> u32vec2;
 typedef vec<3, u32, defaultp> u32vec3;
 typedef vec<4, u32, defaultp> u32vec4;

 typedef vec<1, u64, lowp> lowp_u64vec1;
 typedef vec<2, u64, lowp> lowp_u64vec2;
 typedef vec<3, u64, lowp> lowp_u64vec3;
 typedef vec<4, u64, lowp> lowp_u64vec4;

 typedef vec<1, u64, mediump> mediump_u64vec1;
 typedef vec<2, u64, mediump> mediump_u64vec2;
 typedef vec<3, u64, mediump> mediump_u64vec3;
 typedef vec<4, u64, mediump> mediump_u64vec4;

 typedef vec<1, u64, highp> highp_u64vec1;
 typedef vec<2, u64, highp> highp_u64vec2;
 typedef vec<3, u64, highp> highp_u64vec3;
 typedef vec<4, u64, highp> highp_u64vec4;

 typedef vec<1, u64, defaultp> u64vec1;
 typedef vec<2, u64, defaultp> u64vec2;
 typedef vec<3, u64, defaultp> u64vec3;
 typedef vec<4, u64, defaultp> u64vec4;



 typedef vec<1, float, lowp> lowp_vec1;
 typedef vec<2, float, lowp> lowp_vec2;
 typedef vec<3, float, lowp> lowp_vec3;
 typedef vec<4, float, lowp> lowp_vec4;

 typedef vec<1, float, mediump> mediump_vec1;
 typedef vec<2, float, mediump> mediump_vec2;
 typedef vec<3, float, mediump> mediump_vec3;
 typedef vec<4, float, mediump> mediump_vec4;

 typedef vec<1, float, highp> highp_vec1;
 typedef vec<2, float, highp> highp_vec2;
 typedef vec<3, float, highp> highp_vec3;
 typedef vec<4, float, highp> highp_vec4;

 typedef vec<1, float, defaultp> vec1;
 typedef vec<2, float, defaultp> vec2;
 typedef vec<3, float, defaultp> vec3;
 typedef vec<4, float, defaultp> vec4;

 typedef vec<1, float, lowp> lowp_fvec1;
 typedef vec<2, float, lowp> lowp_fvec2;
 typedef vec<3, float, lowp> lowp_fvec3;
 typedef vec<4, float, lowp> lowp_fvec4;

 typedef vec<1, float, mediump> mediump_fvec1;
 typedef vec<2, float, mediump> mediump_fvec2;
 typedef vec<3, float, mediump> mediump_fvec3;
 typedef vec<4, float, mediump> mediump_fvec4;

 typedef vec<1, float, highp> highp_fvec1;
 typedef vec<2, float, highp> highp_fvec2;
 typedef vec<3, float, highp> highp_fvec3;
 typedef vec<4, float, highp> highp_fvec4;

 typedef vec<1, f32, defaultp> fvec1;
 typedef vec<2, f32, defaultp> fvec2;
 typedef vec<3, f32, defaultp> fvec3;
 typedef vec<4, f32, defaultp> fvec4;

 typedef vec<1, f32, lowp> lowp_f32vec1;
 typedef vec<2, f32, lowp> lowp_f32vec2;
 typedef vec<3, f32, lowp> lowp_f32vec3;
 typedef vec<4, f32, lowp> lowp_f32vec4;

 typedef vec<1, f32, mediump> mediump_f32vec1;
 typedef vec<2, f32, mediump> mediump_f32vec2;
 typedef vec<3, f32, mediump> mediump_f32vec3;
 typedef vec<4, f32, mediump> mediump_f32vec4;

 typedef vec<1, f32, highp> highp_f32vec1;
 typedef vec<2, f32, highp> highp_f32vec2;
 typedef vec<3, f32, highp> highp_f32vec3;
 typedef vec<4, f32, highp> highp_f32vec4;

 typedef vec<1, f32, defaultp> f32vec1;
 typedef vec<2, f32, defaultp> f32vec2;
 typedef vec<3, f32, defaultp> f32vec3;
 typedef vec<4, f32, defaultp> f32vec4;

 typedef vec<1, f64, lowp> lowp_dvec1;
 typedef vec<2, f64, lowp> lowp_dvec2;
 typedef vec<3, f64, lowp> lowp_dvec3;
 typedef vec<4, f64, lowp> lowp_dvec4;

 typedef vec<1, f64, mediump> mediump_dvec1;
 typedef vec<2, f64, mediump> mediump_dvec2;
 typedef vec<3, f64, mediump> mediump_dvec3;
 typedef vec<4, f64, mediump> mediump_dvec4;

 typedef vec<1, f64, highp> highp_dvec1;
 typedef vec<2, f64, highp> highp_dvec2;
 typedef vec<3, f64, highp> highp_dvec3;
 typedef vec<4, f64, highp> highp_dvec4;

 typedef vec<1, f64, defaultp> dvec1;
 typedef vec<2, f64, defaultp> dvec2;
 typedef vec<3, f64, defaultp> dvec3;
 typedef vec<4, f64, defaultp> dvec4;

 typedef vec<1, f64, lowp> lowp_f64vec1;
 typedef vec<2, f64, lowp> lowp_f64vec2;
 typedef vec<3, f64, lowp> lowp_f64vec3;
 typedef vec<4, f64, lowp> lowp_f64vec4;

 typedef vec<1, f64, mediump> mediump_f64vec1;
 typedef vec<2, f64, mediump> mediump_f64vec2;
 typedef vec<3, f64, mediump> mediump_f64vec3;
 typedef vec<4, f64, mediump> mediump_f64vec4;

 typedef vec<1, f64, highp> highp_f64vec1;
 typedef vec<2, f64, highp> highp_f64vec2;
 typedef vec<3, f64, highp> highp_f64vec3;
 typedef vec<4, f64, highp> highp_f64vec4;

 typedef vec<1, f64, defaultp> f64vec1;
 typedef vec<2, f64, defaultp> f64vec2;
 typedef vec<3, f64, defaultp> f64vec3;
 typedef vec<4, f64, defaultp> f64vec4;



 typedef mat<2, 2, f32, lowp> lowp_mat2;
 typedef mat<3, 3, f32, lowp> lowp_mat3;
 typedef mat<4, 4, f32, lowp> lowp_mat4;

 typedef mat<2, 2, f32, mediump> mediump_mat2;
 typedef mat<3, 3, f32, mediump> mediump_mat3;
 typedef mat<4, 4, f32, mediump> mediump_mat4;

 typedef mat<2, 2, f32, highp> highp_mat2;
 typedef mat<3, 3, f32, highp> highp_mat3;
 typedef mat<4, 4, f32, highp> highp_mat4;

 typedef mat<2, 2, f32, defaultp> mat2;
 typedef mat<3, 3, f32, defaultp> mat3;
 typedef mat<4, 4, f32, defaultp> mat4;

 typedef mat<2, 2, f32, lowp> lowp_fmat2;
 typedef mat<3, 3, f32, lowp> lowp_fmat3;
 typedef mat<4, 4, f32, lowp> lowp_fmat4;

 typedef mat<2, 2, f32, mediump> mediump_fmat2;
 typedef mat<3, 3, f32, mediump> mediump_fmat3;
 typedef mat<4, 4, f32, mediump> mediump_fmat4;

 typedef mat<2, 2, f32, highp> highp_fmat2;
 typedef mat<3, 3, f32, highp> highp_fmat3;
 typedef mat<4, 4, f32, highp> highp_fmat4;

 typedef mat<2, 2, f32, defaultp> fmat2;
 typedef mat<3, 3, f32, defaultp> fmat3;
 typedef mat<4, 4, f32, defaultp> fmat4;

 typedef mat<2, 2, f32, lowp> lowp_f32mat2;
 typedef mat<3, 3, f32, lowp> lowp_f32mat3;
 typedef mat<4, 4, f32, lowp> lowp_f32mat4;

 typedef mat<2, 2, f32, mediump> mediump_f32mat2;
 typedef mat<3, 3, f32, mediump> mediump_f32mat3;
 typedef mat<4, 4, f32, mediump> mediump_f32mat4;

 typedef mat<2, 2, f32, highp> highp_f32mat2;
 typedef mat<3, 3, f32, highp> highp_f32mat3;
 typedef mat<4, 4, f32, highp> highp_f32mat4;

 typedef mat<2, 2, f32, defaultp> f32mat2;
 typedef mat<3, 3, f32, defaultp> f32mat3;
 typedef mat<4, 4, f32, defaultp> f32mat4;

 typedef mat<2, 2, f64, lowp> lowp_dmat2;
 typedef mat<3, 3, f64, lowp> lowp_dmat3;
 typedef mat<4, 4, f64, lowp> lowp_dmat4;

 typedef mat<2, 2, f64, mediump> mediump_dmat2;
 typedef mat<3, 3, f64, mediump> mediump_dmat3;
 typedef mat<4, 4, f64, mediump> mediump_dmat4;

 typedef mat<2, 2, f64, highp> highp_dmat2;
 typedef mat<3, 3, f64, highp> highp_dmat3;
 typedef mat<4, 4, f64, highp> highp_dmat4;

 typedef mat<2, 2, f64, defaultp> dmat2;
 typedef mat<3, 3, f64, defaultp> dmat3;
 typedef mat<4, 4, f64, defaultp> dmat4;

 typedef mat<2, 2, f64, lowp> lowp_f64mat2;
 typedef mat<3, 3, f64, lowp> lowp_f64mat3;
 typedef mat<4, 4, f64, lowp> lowp_f64mat4;

 typedef mat<2, 2, f64, mediump> mediump_f64mat2;
 typedef mat<3, 3, f64, mediump> mediump_f64mat3;
 typedef mat<4, 4, f64, mediump> mediump_f64mat4;

 typedef mat<2, 2, f64, highp> highp_f64mat2;
 typedef mat<3, 3, f64, highp> highp_f64mat3;
 typedef mat<4, 4, f64, highp> highp_f64mat4;

 typedef mat<2, 2, f64, defaultp> f64mat2;
 typedef mat<3, 3, f64, defaultp> f64mat3;
 typedef mat<4, 4, f64, defaultp> f64mat4;



 typedef mat<2, 2, f32, lowp> lowp_mat2x2;
 typedef mat<2, 3, f32, lowp> lowp_mat2x3;
 typedef mat<2, 4, f32, lowp> lowp_mat2x4;
 typedef mat<3, 2, f32, lowp> lowp_mat3x2;
 typedef mat<3, 3, f32, lowp> lowp_mat3x3;
 typedef mat<3, 4, f32, lowp> lowp_mat3x4;
 typedef mat<4, 2, f32, lowp> lowp_mat4x2;
 typedef mat<4, 3, f32, lowp> lowp_mat4x3;
 typedef mat<4, 4, f32, lowp> lowp_mat4x4;

 typedef mat<2, 2, f32, mediump> mediump_mat2x2;
 typedef mat<2, 3, f32, mediump> mediump_mat2x3;
 typedef mat<2, 4, f32, mediump> mediump_mat2x4;
 typedef mat<3, 2, f32, mediump> mediump_mat3x2;
 typedef mat<3, 3, f32, mediump> mediump_mat3x3;
 typedef mat<3, 4, f32, mediump> mediump_mat3x4;
 typedef mat<4, 2, f32, mediump> mediump_mat4x2;
 typedef mat<4, 3, f32, mediump> mediump_mat4x3;
 typedef mat<4, 4, f32, mediump> mediump_mat4x4;

 typedef mat<2, 2, f32, highp> highp_mat2x2;
 typedef mat<2, 3, f32, highp> highp_mat2x3;
 typedef mat<2, 4, f32, highp> highp_mat2x4;
 typedef mat<3, 2, f32, highp> highp_mat3x2;
 typedef mat<3, 3, f32, highp> highp_mat3x3;
 typedef mat<3, 4, f32, highp> highp_mat3x4;
 typedef mat<4, 2, f32, highp> highp_mat4x2;
 typedef mat<4, 3, f32, highp> highp_mat4x3;
 typedef mat<4, 4, f32, highp> highp_mat4x4;

 typedef mat<2, 2, f32, defaultp> mat2x2;
 typedef mat<2, 3, f32, defaultp> mat2x3;
 typedef mat<2, 4, f32, defaultp> mat2x4;
 typedef mat<3, 2, f32, defaultp> mat3x2;
 typedef mat<3, 3, f32, defaultp> mat3x3;
 typedef mat<3, 4, f32, defaultp> mat3x4;
 typedef mat<4, 2, f32, defaultp> mat4x2;
 typedef mat<4, 3, f32, defaultp> mat4x3;
 typedef mat<4, 4, f32, defaultp> mat4x4;

 typedef mat<2, 2, f32, lowp> lowp_fmat2x2;
 typedef mat<2, 3, f32, lowp> lowp_fmat2x3;
 typedef mat<2, 4, f32, lowp> lowp_fmat2x4;
 typedef mat<3, 2, f32, lowp> lowp_fmat3x2;
 typedef mat<3, 3, f32, lowp> lowp_fmat3x3;
 typedef mat<3, 4, f32, lowp> lowp_fmat3x4;
 typedef mat<4, 2, f32, lowp> lowp_fmat4x2;
 typedef mat<4, 3, f32, lowp> lowp_fmat4x3;
 typedef mat<4, 4, f32, lowp> lowp_fmat4x4;

 typedef mat<2, 2, f32, mediump> mediump_fmat2x2;
 typedef mat<2, 3, f32, mediump> mediump_fmat2x3;
 typedef mat<2, 4, f32, mediump> mediump_fmat2x4;
 typedef mat<3, 2, f32, mediump> mediump_fmat3x2;
 typedef mat<3, 3, f32, mediump> mediump_fmat3x3;
 typedef mat<3, 4, f32, mediump> mediump_fmat3x4;
 typedef mat<4, 2, f32, mediump> mediump_fmat4x2;
 typedef mat<4, 3, f32, mediump> mediump_fmat4x3;
 typedef mat<4, 4, f32, mediump> mediump_fmat4x4;

 typedef mat<2, 2, f32, highp> highp_fmat2x2;
 typedef mat<2, 3, f32, highp> highp_fmat2x3;
 typedef mat<2, 4, f32, highp> highp_fmat2x4;
 typedef mat<3, 2, f32, highp> highp_fmat3x2;
 typedef mat<3, 3, f32, highp> highp_fmat3x3;
 typedef mat<3, 4, f32, highp> highp_fmat3x4;
 typedef mat<4, 2, f32, highp> highp_fmat4x2;
 typedef mat<4, 3, f32, highp> highp_fmat4x3;
 typedef mat<4, 4, f32, highp> highp_fmat4x4;

 typedef mat<2, 2, f32, defaultp> fmat2x2;
 typedef mat<2, 3, f32, defaultp> fmat2x3;
 typedef mat<2, 4, f32, defaultp> fmat2x4;
 typedef mat<3, 2, f32, defaultp> fmat3x2;
 typedef mat<3, 3, f32, defaultp> fmat3x3;
 typedef mat<3, 4, f32, defaultp> fmat3x4;
 typedef mat<4, 2, f32, defaultp> fmat4x2;
 typedef mat<4, 3, f32, defaultp> fmat4x3;
 typedef mat<4, 4, f32, defaultp> fmat4x4;

 typedef mat<2, 2, f32, lowp> lowp_f32mat2x2;
 typedef mat<2, 3, f32, lowp> lowp_f32mat2x3;
 typedef mat<2, 4, f32, lowp> lowp_f32mat2x4;
 typedef mat<3, 2, f32, lowp> lowp_f32mat3x2;
 typedef mat<3, 3, f32, lowp> lowp_f32mat3x3;
 typedef mat<3, 4, f32, lowp> lowp_f32mat3x4;
 typedef mat<4, 2, f32, lowp> lowp_f32mat4x2;
 typedef mat<4, 3, f32, lowp> lowp_f32mat4x3;
 typedef mat<4, 4, f32, lowp> lowp_f32mat4x4;

 typedef mat<2, 2, f32, mediump> mediump_f32mat2x2;
 typedef mat<2, 3, f32, mediump> mediump_f32mat2x3;
 typedef mat<2, 4, f32, mediump> mediump_f32mat2x4;
 typedef mat<3, 2, f32, mediump> mediump_f32mat3x2;
 typedef mat<3, 3, f32, mediump> mediump_f32mat3x3;
 typedef mat<3, 4, f32, mediump> mediump_f32mat3x4;
 typedef mat<4, 2, f32, mediump> mediump_f32mat4x2;
 typedef mat<4, 3, f32, mediump> mediump_f32mat4x3;
 typedef mat<4, 4, f32, mediump> mediump_f32mat4x4;

 typedef mat<2, 2, f32, highp> highp_f32mat2x2;
 typedef mat<2, 3, f32, highp> highp_f32mat2x3;
 typedef mat<2, 4, f32, highp> highp_f32mat2x4;
 typedef mat<3, 2, f32, highp> highp_f32mat3x2;
 typedef mat<3, 3, f32, highp> highp_f32mat3x3;
 typedef mat<3, 4, f32, highp> highp_f32mat3x4;
 typedef mat<4, 2, f32, highp> highp_f32mat4x2;
 typedef mat<4, 3, f32, highp> highp_f32mat4x3;
 typedef mat<4, 4, f32, highp> highp_f32mat4x4;

 typedef mat<2, 2, f32, defaultp> f32mat2x2;
 typedef mat<2, 3, f32, defaultp> f32mat2x3;
 typedef mat<2, 4, f32, defaultp> f32mat2x4;
 typedef mat<3, 2, f32, defaultp> f32mat3x2;
 typedef mat<3, 3, f32, defaultp> f32mat3x3;
 typedef mat<3, 4, f32, defaultp> f32mat3x4;
 typedef mat<4, 2, f32, defaultp> f32mat4x2;
 typedef mat<4, 3, f32, defaultp> f32mat4x3;
 typedef mat<4, 4, f32, defaultp> f32mat4x4;

 typedef mat<2, 2, double, lowp> lowp_dmat2x2;
 typedef mat<2, 3, double, lowp> lowp_dmat2x3;
 typedef mat<2, 4, double, lowp> lowp_dmat2x4;
 typedef mat<3, 2, double, lowp> lowp_dmat3x2;
 typedef mat<3, 3, double, lowp> lowp_dmat3x3;
 typedef mat<3, 4, double, lowp> lowp_dmat3x4;
 typedef mat<4, 2, double, lowp> lowp_dmat4x2;
 typedef mat<4, 3, double, lowp> lowp_dmat4x3;
 typedef mat<4, 4, double, lowp> lowp_dmat4x4;

 typedef mat<2, 2, double, mediump> mediump_dmat2x2;
 typedef mat<2, 3, double, mediump> mediump_dmat2x3;
 typedef mat<2, 4, double, mediump> mediump_dmat2x4;
 typedef mat<3, 2, double, mediump> mediump_dmat3x2;
 typedef mat<3, 3, double, mediump> mediump_dmat3x3;
 typedef mat<3, 4, double, mediump> mediump_dmat3x4;
 typedef mat<4, 2, double, mediump> mediump_dmat4x2;
 typedef mat<4, 3, double, mediump> mediump_dmat4x3;
 typedef mat<4, 4, double, mediump> mediump_dmat4x4;

 typedef mat<2, 2, double, highp> highp_dmat2x2;
 typedef mat<2, 3, double, highp> highp_dmat2x3;
 typedef mat<2, 4, double, highp> highp_dmat2x4;
 typedef mat<3, 2, double, highp> highp_dmat3x2;
 typedef mat<3, 3, double, highp> highp_dmat3x3;
 typedef mat<3, 4, double, highp> highp_dmat3x4;
 typedef mat<4, 2, double, highp> highp_dmat4x2;
 typedef mat<4, 3, double, highp> highp_dmat4x3;
 typedef mat<4, 4, double, highp> highp_dmat4x4;

 typedef mat<2, 2, double, defaultp> dmat2x2;
 typedef mat<2, 3, double, defaultp> dmat2x3;
 typedef mat<2, 4, double, defaultp> dmat2x4;
 typedef mat<3, 2, double, defaultp> dmat3x2;
 typedef mat<3, 3, double, defaultp> dmat3x3;
 typedef mat<3, 4, double, defaultp> dmat3x4;
 typedef mat<4, 2, double, defaultp> dmat4x2;
 typedef mat<4, 3, double, defaultp> dmat4x3;
 typedef mat<4, 4, double, defaultp> dmat4x4;

 typedef mat<2, 2, f64, lowp> lowp_f64mat2x2;
 typedef mat<2, 3, f64, lowp> lowp_f64mat2x3;
 typedef mat<2, 4, f64, lowp> lowp_f64mat2x4;
 typedef mat<3, 2, f64, lowp> lowp_f64mat3x2;
 typedef mat<3, 3, f64, lowp> lowp_f64mat3x3;
 typedef mat<3, 4, f64, lowp> lowp_f64mat3x4;
 typedef mat<4, 2, f64, lowp> lowp_f64mat4x2;
 typedef mat<4, 3, f64, lowp> lowp_f64mat4x3;
 typedef mat<4, 4, f64, lowp> lowp_f64mat4x4;

 typedef mat<2, 2, f64, mediump> mediump_f64mat2x2;
 typedef mat<2, 3, f64, mediump> mediump_f64mat2x3;
 typedef mat<2, 4, f64, mediump> mediump_f64mat2x4;
 typedef mat<3, 2, f64, mediump> mediump_f64mat3x2;
 typedef mat<3, 3, f64, mediump> mediump_f64mat3x3;
 typedef mat<3, 4, f64, mediump> mediump_f64mat3x4;
 typedef mat<4, 2, f64, mediump> mediump_f64mat4x2;
 typedef mat<4, 3, f64, mediump> mediump_f64mat4x3;
 typedef mat<4, 4, f64, mediump> mediump_f64mat4x4;

 typedef mat<2, 2, f64, highp> highp_f64mat2x2;
 typedef mat<2, 3, f64, highp> highp_f64mat2x3;
 typedef mat<2, 4, f64, highp> highp_f64mat2x4;
 typedef mat<3, 2, f64, highp> highp_f64mat3x2;
 typedef mat<3, 3, f64, highp> highp_f64mat3x3;
 typedef mat<3, 4, f64, highp> highp_f64mat3x4;
 typedef mat<4, 2, f64, highp> highp_f64mat4x2;
 typedef mat<4, 3, f64, highp> highp_f64mat4x3;
 typedef mat<4, 4, f64, highp> highp_f64mat4x4;

 typedef mat<2, 2, f64, defaultp> f64mat2x2;
 typedef mat<2, 3, f64, defaultp> f64mat2x3;
 typedef mat<2, 4, f64, defaultp> f64mat2x4;
 typedef mat<3, 2, f64, defaultp> f64mat3x2;
 typedef mat<3, 3, f64, defaultp> f64mat3x3;
 typedef mat<3, 4, f64, defaultp> f64mat3x4;
 typedef mat<4, 2, f64, defaultp> f64mat4x2;
 typedef mat<4, 3, f64, defaultp> f64mat4x3;
 typedef mat<4, 4, f64, defaultp> f64mat4x4;



 typedef mat<2, 2, int, lowp> lowp_imat2x2;
 typedef mat<2, 3, int, lowp> lowp_imat2x3;
 typedef mat<2, 4, int, lowp> lowp_imat2x4;
 typedef mat<3, 2, int, lowp> lowp_imat3x2;
 typedef mat<3, 3, int, lowp> lowp_imat3x3;
 typedef mat<3, 4, int, lowp> lowp_imat3x4;
 typedef mat<4, 2, int, lowp> lowp_imat4x2;
 typedef mat<4, 3, int, lowp> lowp_imat4x3;
 typedef mat<4, 4, int, lowp> lowp_imat4x4;

 typedef mat<2, 2, int, mediump> mediump_imat2x2;
 typedef mat<2, 3, int, mediump> mediump_imat2x3;
 typedef mat<2, 4, int, mediump> mediump_imat2x4;
 typedef mat<3, 2, int, mediump> mediump_imat3x2;
 typedef mat<3, 3, int, mediump> mediump_imat3x3;
 typedef mat<3, 4, int, mediump> mediump_imat3x4;
 typedef mat<4, 2, int, mediump> mediump_imat4x2;
 typedef mat<4, 3, int, mediump> mediump_imat4x3;
 typedef mat<4, 4, int, mediump> mediump_imat4x4;

 typedef mat<2, 2, int, highp> highp_imat2x2;
 typedef mat<2, 3, int, highp> highp_imat2x3;
 typedef mat<2, 4, int, highp> highp_imat2x4;
 typedef mat<3, 2, int, highp> highp_imat3x2;
 typedef mat<3, 3, int, highp> highp_imat3x3;
 typedef mat<3, 4, int, highp> highp_imat3x4;
 typedef mat<4, 2, int, highp> highp_imat4x2;
 typedef mat<4, 3, int, highp> highp_imat4x3;
 typedef mat<4, 4, int, highp> highp_imat4x4;

 typedef mat<2, 2, int, defaultp> imat2x2;
 typedef mat<2, 3, int, defaultp> imat2x3;
 typedef mat<2, 4, int, defaultp> imat2x4;
 typedef mat<3, 2, int, defaultp> imat3x2;
 typedef mat<3, 3, int, defaultp> imat3x3;
 typedef mat<3, 4, int, defaultp> imat3x4;
 typedef mat<4, 2, int, defaultp> imat4x2;
 typedef mat<4, 3, int, defaultp> imat4x3;
 typedef mat<4, 4, int, defaultp> imat4x4;


 typedef mat<2, 2, int8, lowp> lowp_i8mat2x2;
 typedef mat<2, 3, int8, lowp> lowp_i8mat2x3;
 typedef mat<2, 4, int8, lowp> lowp_i8mat2x4;
 typedef mat<3, 2, int8, lowp> lowp_i8mat3x2;
 typedef mat<3, 3, int8, lowp> lowp_i8mat3x3;
 typedef mat<3, 4, int8, lowp> lowp_i8mat3x4;
 typedef mat<4, 2, int8, lowp> lowp_i8mat4x2;
 typedef mat<4, 3, int8, lowp> lowp_i8mat4x3;
 typedef mat<4, 4, int8, lowp> lowp_i8mat4x4;

 typedef mat<2, 2, int8, mediump> mediump_i8mat2x2;
 typedef mat<2, 3, int8, mediump> mediump_i8mat2x3;
 typedef mat<2, 4, int8, mediump> mediump_i8mat2x4;
 typedef mat<3, 2, int8, mediump> mediump_i8mat3x2;
 typedef mat<3, 3, int8, mediump> mediump_i8mat3x3;
 typedef mat<3, 4, int8, mediump> mediump_i8mat3x4;
 typedef mat<4, 2, int8, mediump> mediump_i8mat4x2;
 typedef mat<4, 3, int8, mediump> mediump_i8mat4x3;
 typedef mat<4, 4, int8, mediump> mediump_i8mat4x4;

 typedef mat<2, 2, int8, highp> highp_i8mat2x2;
 typedef mat<2, 3, int8, highp> highp_i8mat2x3;
 typedef mat<2, 4, int8, highp> highp_i8mat2x4;
 typedef mat<3, 2, int8, highp> highp_i8mat3x2;
 typedef mat<3, 3, int8, highp> highp_i8mat3x3;
 typedef mat<3, 4, int8, highp> highp_i8mat3x4;
 typedef mat<4, 2, int8, highp> highp_i8mat4x2;
 typedef mat<4, 3, int8, highp> highp_i8mat4x3;
 typedef mat<4, 4, int8, highp> highp_i8mat4x4;

 typedef mat<2, 2, int8, defaultp> i8mat2x2;
 typedef mat<2, 3, int8, defaultp> i8mat2x3;
 typedef mat<2, 4, int8, defaultp> i8mat2x4;
 typedef mat<3, 2, int8, defaultp> i8mat3x2;
 typedef mat<3, 3, int8, defaultp> i8mat3x3;
 typedef mat<3, 4, int8, defaultp> i8mat3x4;
 typedef mat<4, 2, int8, defaultp> i8mat4x2;
 typedef mat<4, 3, int8, defaultp> i8mat4x3;
 typedef mat<4, 4, int8, defaultp> i8mat4x4;


 typedef mat<2, 2, int16, lowp> lowp_i16mat2x2;
 typedef mat<2, 3, int16, lowp> lowp_i16mat2x3;
 typedef mat<2, 4, int16, lowp> lowp_i16mat2x4;
 typedef mat<3, 2, int16, lowp> lowp_i16mat3x2;
 typedef mat<3, 3, int16, lowp> lowp_i16mat3x3;
 typedef mat<3, 4, int16, lowp> lowp_i16mat3x4;
 typedef mat<4, 2, int16, lowp> lowp_i16mat4x2;
 typedef mat<4, 3, int16, lowp> lowp_i16mat4x3;
 typedef mat<4, 4, int16, lowp> lowp_i16mat4x4;

 typedef mat<2, 2, int16, mediump> mediump_i16mat2x2;
 typedef mat<2, 3, int16, mediump> mediump_i16mat2x3;
 typedef mat<2, 4, int16, mediump> mediump_i16mat2x4;
 typedef mat<3, 2, int16, mediump> mediump_i16mat3x2;
 typedef mat<3, 3, int16, mediump> mediump_i16mat3x3;
 typedef mat<3, 4, int16, mediump> mediump_i16mat3x4;
 typedef mat<4, 2, int16, mediump> mediump_i16mat4x2;
 typedef mat<4, 3, int16, mediump> mediump_i16mat4x3;
 typedef mat<4, 4, int16, mediump> mediump_i16mat4x4;

 typedef mat<2, 2, int16, highp> highp_i16mat2x2;
 typedef mat<2, 3, int16, highp> highp_i16mat2x3;
 typedef mat<2, 4, int16, highp> highp_i16mat2x4;
 typedef mat<3, 2, int16, highp> highp_i16mat3x2;
 typedef mat<3, 3, int16, highp> highp_i16mat3x3;
 typedef mat<3, 4, int16, highp> highp_i16mat3x4;
 typedef mat<4, 2, int16, highp> highp_i16mat4x2;
 typedef mat<4, 3, int16, highp> highp_i16mat4x3;
 typedef mat<4, 4, int16, highp> highp_i16mat4x4;

 typedef mat<2, 2, int16, defaultp> i16mat2x2;
 typedef mat<2, 3, int16, defaultp> i16mat2x3;
 typedef mat<2, 4, int16, defaultp> i16mat2x4;
 typedef mat<3, 2, int16, defaultp> i16mat3x2;
 typedef mat<3, 3, int16, defaultp> i16mat3x3;
 typedef mat<3, 4, int16, defaultp> i16mat3x4;
 typedef mat<4, 2, int16, defaultp> i16mat4x2;
 typedef mat<4, 3, int16, defaultp> i16mat4x3;
 typedef mat<4, 4, int16, defaultp> i16mat4x4;


 typedef mat<2, 2, int32, lowp> lowp_i32mat2x2;
 typedef mat<2, 3, int32, lowp> lowp_i32mat2x3;
 typedef mat<2, 4, int32, lowp> lowp_i32mat2x4;
 typedef mat<3, 2, int32, lowp> lowp_i32mat3x2;
 typedef mat<3, 3, int32, lowp> lowp_i32mat3x3;
 typedef mat<3, 4, int32, lowp> lowp_i32mat3x4;
 typedef mat<4, 2, int32, lowp> lowp_i32mat4x2;
 typedef mat<4, 3, int32, lowp> lowp_i32mat4x3;
 typedef mat<4, 4, int32, lowp> lowp_i32mat4x4;

 typedef mat<2, 2, int32, mediump> mediump_i32mat2x2;
 typedef mat<2, 3, int32, mediump> mediump_i32mat2x3;
 typedef mat<2, 4, int32, mediump> mediump_i32mat2x4;
 typedef mat<3, 2, int32, mediump> mediump_i32mat3x2;
 typedef mat<3, 3, int32, mediump> mediump_i32mat3x3;
 typedef mat<3, 4, int32, mediump> mediump_i32mat3x4;
 typedef mat<4, 2, int32, mediump> mediump_i32mat4x2;
 typedef mat<4, 3, int32, mediump> mediump_i32mat4x3;
 typedef mat<4, 4, int32, mediump> mediump_i32mat4x4;

 typedef mat<2, 2, int32, highp> highp_i32mat2x2;
 typedef mat<2, 3, int32, highp> highp_i32mat2x3;
 typedef mat<2, 4, int32, highp> highp_i32mat2x4;
 typedef mat<3, 2, int32, highp> highp_i32mat3x2;
 typedef mat<3, 3, int32, highp> highp_i32mat3x3;
 typedef mat<3, 4, int32, highp> highp_i32mat3x4;
 typedef mat<4, 2, int32, highp> highp_i32mat4x2;
 typedef mat<4, 3, int32, highp> highp_i32mat4x3;
 typedef mat<4, 4, int32, highp> highp_i32mat4x4;

 typedef mat<2, 2, int32, defaultp> i32mat2x2;
 typedef mat<2, 3, int32, defaultp> i32mat2x3;
 typedef mat<2, 4, int32, defaultp> i32mat2x4;
 typedef mat<3, 2, int32, defaultp> i32mat3x2;
 typedef mat<3, 3, int32, defaultp> i32mat3x3;
 typedef mat<3, 4, int32, defaultp> i32mat3x4;
 typedef mat<4, 2, int32, defaultp> i32mat4x2;
 typedef mat<4, 3, int32, defaultp> i32mat4x3;
 typedef mat<4, 4, int32, defaultp> i32mat4x4;


 typedef mat<2, 2, int64, lowp> lowp_i64mat2x2;
 typedef mat<2, 3, int64, lowp> lowp_i64mat2x3;
 typedef mat<2, 4, int64, lowp> lowp_i64mat2x4;
 typedef mat<3, 2, int64, lowp> lowp_i64mat3x2;
 typedef mat<3, 3, int64, lowp> lowp_i64mat3x3;
 typedef mat<3, 4, int64, lowp> lowp_i64mat3x4;
 typedef mat<4, 2, int64, lowp> lowp_i64mat4x2;
 typedef mat<4, 3, int64, lowp> lowp_i64mat4x3;
 typedef mat<4, 4, int64, lowp> lowp_i64mat4x4;

 typedef mat<2, 2, int64, mediump> mediump_i64mat2x2;
 typedef mat<2, 3, int64, mediump> mediump_i64mat2x3;
 typedef mat<2, 4, int64, mediump> mediump_i64mat2x4;
 typedef mat<3, 2, int64, mediump> mediump_i64mat3x2;
 typedef mat<3, 3, int64, mediump> mediump_i64mat3x3;
 typedef mat<3, 4, int64, mediump> mediump_i64mat3x4;
 typedef mat<4, 2, int64, mediump> mediump_i64mat4x2;
 typedef mat<4, 3, int64, mediump> mediump_i64mat4x3;
 typedef mat<4, 4, int64, mediump> mediump_i64mat4x4;

 typedef mat<2, 2, int64, highp> highp_i64mat2x2;
 typedef mat<2, 3, int64, highp> highp_i64mat2x3;
 typedef mat<2, 4, int64, highp> highp_i64mat2x4;
 typedef mat<3, 2, int64, highp> highp_i64mat3x2;
 typedef mat<3, 3, int64, highp> highp_i64mat3x3;
 typedef mat<3, 4, int64, highp> highp_i64mat3x4;
 typedef mat<4, 2, int64, highp> highp_i64mat4x2;
 typedef mat<4, 3, int64, highp> highp_i64mat4x3;
 typedef mat<4, 4, int64, highp> highp_i64mat4x4;

 typedef mat<2, 2, int64, defaultp> i64mat2x2;
 typedef mat<2, 3, int64, defaultp> i64mat2x3;
 typedef mat<2, 4, int64, defaultp> i64mat2x4;
 typedef mat<3, 2, int64, defaultp> i64mat3x2;
 typedef mat<3, 3, int64, defaultp> i64mat3x3;
 typedef mat<3, 4, int64, defaultp> i64mat3x4;
 typedef mat<4, 2, int64, defaultp> i64mat4x2;
 typedef mat<4, 3, int64, defaultp> i64mat4x3;
 typedef mat<4, 4, int64, defaultp> i64mat4x4;




 typedef mat<2, 2, uint, lowp> lowp_umat2x2;
 typedef mat<2, 3, uint, lowp> lowp_umat2x3;
 typedef mat<2, 4, uint, lowp> lowp_umat2x4;
 typedef mat<3, 2, uint, lowp> lowp_umat3x2;
 typedef mat<3, 3, uint, lowp> lowp_umat3x3;
 typedef mat<3, 4, uint, lowp> lowp_umat3x4;
 typedef mat<4, 2, uint, lowp> lowp_umat4x2;
 typedef mat<4, 3, uint, lowp> lowp_umat4x3;
 typedef mat<4, 4, uint, lowp> lowp_umat4x4;

 typedef mat<2, 2, uint, mediump> mediump_umat2x2;
 typedef mat<2, 3, uint, mediump> mediump_umat2x3;
 typedef mat<2, 4, uint, mediump> mediump_umat2x4;
 typedef mat<3, 2, uint, mediump> mediump_umat3x2;
 typedef mat<3, 3, uint, mediump> mediump_umat3x3;
 typedef mat<3, 4, uint, mediump> mediump_umat3x4;
 typedef mat<4, 2, uint, mediump> mediump_umat4x2;
 typedef mat<4, 3, uint, mediump> mediump_umat4x3;
 typedef mat<4, 4, uint, mediump> mediump_umat4x4;

 typedef mat<2, 2, uint, highp> highp_umat2x2;
 typedef mat<2, 3, uint, highp> highp_umat2x3;
 typedef mat<2, 4, uint, highp> highp_umat2x4;
 typedef mat<3, 2, uint, highp> highp_umat3x2;
 typedef mat<3, 3, uint, highp> highp_umat3x3;
 typedef mat<3, 4, uint, highp> highp_umat3x4;
 typedef mat<4, 2, uint, highp> highp_umat4x2;
 typedef mat<4, 3, uint, highp> highp_umat4x3;
 typedef mat<4, 4, uint, highp> highp_umat4x4;

 typedef mat<2, 2, uint, defaultp> umat2x2;
 typedef mat<2, 3, uint, defaultp> umat2x3;
 typedef mat<2, 4, uint, defaultp> umat2x4;
 typedef mat<3, 2, uint, defaultp> umat3x2;
 typedef mat<3, 3, uint, defaultp> umat3x3;
 typedef mat<3, 4, uint, defaultp> umat3x4;
 typedef mat<4, 2, uint, defaultp> umat4x2;
 typedef mat<4, 3, uint, defaultp> umat4x3;
 typedef mat<4, 4, uint, defaultp> umat4x4;


 typedef mat<2, 2, uint8, lowp> lowp_u8mat2x2;
 typedef mat<2, 3, uint8, lowp> lowp_u8mat2x3;
 typedef mat<2, 4, uint8, lowp> lowp_u8mat2x4;
 typedef mat<3, 2, uint8, lowp> lowp_u8mat3x2;
 typedef mat<3, 3, uint8, lowp> lowp_u8mat3x3;
 typedef mat<3, 4, uint8, lowp> lowp_u8mat3x4;
 typedef mat<4, 2, uint8, lowp> lowp_u8mat4x2;
 typedef mat<4, 3, uint8, lowp> lowp_u8mat4x3;
 typedef mat<4, 4, uint8, lowp> lowp_u8mat4x4;

 typedef mat<2, 2, uint8, mediump> mediump_u8mat2x2;
 typedef mat<2, 3, uint8, mediump> mediump_u8mat2x3;
 typedef mat<2, 4, uint8, mediump> mediump_u8mat2x4;
 typedef mat<3, 2, uint8, mediump> mediump_u8mat3x2;
 typedef mat<3, 3, uint8, mediump> mediump_u8mat3x3;
 typedef mat<3, 4, uint8, mediump> mediump_u8mat3x4;
 typedef mat<4, 2, uint8, mediump> mediump_u8mat4x2;
 typedef mat<4, 3, uint8, mediump> mediump_u8mat4x3;
 typedef mat<4, 4, uint8, mediump> mediump_u8mat4x4;

 typedef mat<2, 2, uint8, highp> highp_u8mat2x2;
 typedef mat<2, 3, uint8, highp> highp_u8mat2x3;
 typedef mat<2, 4, uint8, highp> highp_u8mat2x4;
 typedef mat<3, 2, uint8, highp> highp_u8mat3x2;
 typedef mat<3, 3, uint8, highp> highp_u8mat3x3;
 typedef mat<3, 4, uint8, highp> highp_u8mat3x4;
 typedef mat<4, 2, uint8, highp> highp_u8mat4x2;
 typedef mat<4, 3, uint8, highp> highp_u8mat4x3;
 typedef mat<4, 4, uint8, highp> highp_u8mat4x4;

 typedef mat<2, 2, uint8, defaultp> u8mat2x2;
 typedef mat<2, 3, uint8, defaultp> u8mat2x3;
 typedef mat<2, 4, uint8, defaultp> u8mat2x4;
 typedef mat<3, 2, uint8, defaultp> u8mat3x2;
 typedef mat<3, 3, uint8, defaultp> u8mat3x3;
 typedef mat<3, 4, uint8, defaultp> u8mat3x4;
 typedef mat<4, 2, uint8, defaultp> u8mat4x2;
 typedef mat<4, 3, uint8, defaultp> u8mat4x3;
 typedef mat<4, 4, uint8, defaultp> u8mat4x4;


 typedef mat<2, 2, uint16, lowp> lowp_u16mat2x2;
 typedef mat<2, 3, uint16, lowp> lowp_u16mat2x3;
 typedef mat<2, 4, uint16, lowp> lowp_u16mat2x4;
 typedef mat<3, 2, uint16, lowp> lowp_u16mat3x2;
 typedef mat<3, 3, uint16, lowp> lowp_u16mat3x3;
 typedef mat<3, 4, uint16, lowp> lowp_u16mat3x4;
 typedef mat<4, 2, uint16, lowp> lowp_u16mat4x2;
 typedef mat<4, 3, uint16, lowp> lowp_u16mat4x3;
 typedef mat<4, 4, uint16, lowp> lowp_u16mat4x4;

 typedef mat<2, 2, uint16, mediump> mediump_u16mat2x2;
 typedef mat<2, 3, uint16, mediump> mediump_u16mat2x3;
 typedef mat<2, 4, uint16, mediump> mediump_u16mat2x4;
 typedef mat<3, 2, uint16, mediump> mediump_u16mat3x2;
 typedef mat<3, 3, uint16, mediump> mediump_u16mat3x3;
 typedef mat<3, 4, uint16, mediump> mediump_u16mat3x4;
 typedef mat<4, 2, uint16, mediump> mediump_u16mat4x2;
 typedef mat<4, 3, uint16, mediump> mediump_u16mat4x3;
 typedef mat<4, 4, uint16, mediump> mediump_u16mat4x4;

 typedef mat<2, 2, uint16, highp> highp_u16mat2x2;
 typedef mat<2, 3, uint16, highp> highp_u16mat2x3;
 typedef mat<2, 4, uint16, highp> highp_u16mat2x4;
 typedef mat<3, 2, uint16, highp> highp_u16mat3x2;
 typedef mat<3, 3, uint16, highp> highp_u16mat3x3;
 typedef mat<3, 4, uint16, highp> highp_u16mat3x4;
 typedef mat<4, 2, uint16, highp> highp_u16mat4x2;
 typedef mat<4, 3, uint16, highp> highp_u16mat4x3;
 typedef mat<4, 4, uint16, highp> highp_u16mat4x4;

 typedef mat<2, 2, uint16, defaultp> u16mat2x2;
 typedef mat<2, 3, uint16, defaultp> u16mat2x3;
 typedef mat<2, 4, uint16, defaultp> u16mat2x4;
 typedef mat<3, 2, uint16, defaultp> u16mat3x2;
 typedef mat<3, 3, uint16, defaultp> u16mat3x3;
 typedef mat<3, 4, uint16, defaultp> u16mat3x4;
 typedef mat<4, 2, uint16, defaultp> u16mat4x2;
 typedef mat<4, 3, uint16, defaultp> u16mat4x3;
 typedef mat<4, 4, uint16, defaultp> u16mat4x4;


 typedef mat<2, 2, uint32, lowp> lowp_u32mat2x2;
 typedef mat<2, 3, uint32, lowp> lowp_u32mat2x3;
 typedef mat<2, 4, uint32, lowp> lowp_u32mat2x4;
 typedef mat<3, 2, uint32, lowp> lowp_u32mat3x2;
 typedef mat<3, 3, uint32, lowp> lowp_u32mat3x3;
 typedef mat<3, 4, uint32, lowp> lowp_u32mat3x4;
 typedef mat<4, 2, uint32, lowp> lowp_u32mat4x2;
 typedef mat<4, 3, uint32, lowp> lowp_u32mat4x3;
 typedef mat<4, 4, uint32, lowp> lowp_u32mat4x4;

 typedef mat<2, 2, uint32, mediump> mediump_u32mat2x2;
 typedef mat<2, 3, uint32, mediump> mediump_u32mat2x3;
 typedef mat<2, 4, uint32, mediump> mediump_u32mat2x4;
 typedef mat<3, 2, uint32, mediump> mediump_u32mat3x2;
 typedef mat<3, 3, uint32, mediump> mediump_u32mat3x3;
 typedef mat<3, 4, uint32, mediump> mediump_u32mat3x4;
 typedef mat<4, 2, uint32, mediump> mediump_u32mat4x2;
 typedef mat<4, 3, uint32, mediump> mediump_u32mat4x3;
 typedef mat<4, 4, uint32, mediump> mediump_u32mat4x4;

 typedef mat<2, 2, uint32, highp> highp_u32mat2x2;
 typedef mat<2, 3, uint32, highp> highp_u32mat2x3;
 typedef mat<2, 4, uint32, highp> highp_u32mat2x4;
 typedef mat<3, 2, uint32, highp> highp_u32mat3x2;
 typedef mat<3, 3, uint32, highp> highp_u32mat3x3;
 typedef mat<3, 4, uint32, highp> highp_u32mat3x4;
 typedef mat<4, 2, uint32, highp> highp_u32mat4x2;
 typedef mat<4, 3, uint32, highp> highp_u32mat4x3;
 typedef mat<4, 4, uint32, highp> highp_u32mat4x4;

 typedef mat<2, 2, uint32, defaultp> u32mat2x2;
 typedef mat<2, 3, uint32, defaultp> u32mat2x3;
 typedef mat<2, 4, uint32, defaultp> u32mat2x4;
 typedef mat<3, 2, uint32, defaultp> u32mat3x2;
 typedef mat<3, 3, uint32, defaultp> u32mat3x3;
 typedef mat<3, 4, uint32, defaultp> u32mat3x4;
 typedef mat<4, 2, uint32, defaultp> u32mat4x2;
 typedef mat<4, 3, uint32, defaultp> u32mat4x3;
 typedef mat<4, 4, uint32, defaultp> u32mat4x4;


 typedef mat<2, 2, uint64, lowp> lowp_u64mat2x2;
 typedef mat<2, 3, uint64, lowp> lowp_u64mat2x3;
 typedef mat<2, 4, uint64, lowp> lowp_u64mat2x4;
 typedef mat<3, 2, uint64, lowp> lowp_u64mat3x2;
 typedef mat<3, 3, uint64, lowp> lowp_u64mat3x3;
 typedef mat<3, 4, uint64, lowp> lowp_u64mat3x4;
 typedef mat<4, 2, uint64, lowp> lowp_u64mat4x2;
 typedef mat<4, 3, uint64, lowp> lowp_u64mat4x3;
 typedef mat<4, 4, uint64, lowp> lowp_u64mat4x4;

 typedef mat<2, 2, uint64, mediump> mediump_u64mat2x2;
 typedef mat<2, 3, uint64, mediump> mediump_u64mat2x3;
 typedef mat<2, 4, uint64, mediump> mediump_u64mat2x4;
 typedef mat<3, 2, uint64, mediump> mediump_u64mat3x2;
 typedef mat<3, 3, uint64, mediump> mediump_u64mat3x3;
 typedef mat<3, 4, uint64, mediump> mediump_u64mat3x4;
 typedef mat<4, 2, uint64, mediump> mediump_u64mat4x2;
 typedef mat<4, 3, uint64, mediump> mediump_u64mat4x3;
 typedef mat<4, 4, uint64, mediump> mediump_u64mat4x4;

 typedef mat<2, 2, uint64, highp> highp_u64mat2x2;
 typedef mat<2, 3, uint64, highp> highp_u64mat2x3;
 typedef mat<2, 4, uint64, highp> highp_u64mat2x4;
 typedef mat<3, 2, uint64, highp> highp_u64mat3x2;
 typedef mat<3, 3, uint64, highp> highp_u64mat3x3;
 typedef mat<3, 4, uint64, highp> highp_u64mat3x4;
 typedef mat<4, 2, uint64, highp> highp_u64mat4x2;
 typedef mat<4, 3, uint64, highp> highp_u64mat4x3;
 typedef mat<4, 4, uint64, highp> highp_u64mat4x4;

 typedef mat<2, 2, uint64, defaultp> u64mat2x2;
 typedef mat<2, 3, uint64, defaultp> u64mat2x3;
 typedef mat<2, 4, uint64, defaultp> u64mat2x4;
 typedef mat<3, 2, uint64, defaultp> u64mat3x2;
 typedef mat<3, 3, uint64, defaultp> u64mat3x3;
 typedef mat<3, 4, uint64, defaultp> u64mat3x4;
 typedef mat<4, 2, uint64, defaultp> u64mat4x2;
 typedef mat<4, 3, uint64, defaultp> u64mat4x3;
 typedef mat<4, 4, uint64, defaultp> u64mat4x4;



 typedef qua<float, lowp> lowp_quat;
 typedef qua<float, mediump> mediump_quat;
 typedef qua<float, highp> highp_quat;
 typedef qua<float, defaultp> quat;

 typedef qua<float, lowp> lowp_fquat;
 typedef qua<float, mediump> mediump_fquat;
 typedef qua<float, highp> highp_fquat;
 typedef qua<float, defaultp> fquat;

 typedef qua<f32, lowp> lowp_f32quat;
 typedef qua<f32, mediump> mediump_f32quat;
 typedef qua<f32, highp> highp_f32quat;
 typedef qua<f32, defaultp> f32quat;

 typedef qua<double, lowp> lowp_dquat;
 typedef qua<double, mediump> mediump_dquat;
 typedef qua<double, highp> highp_dquat;
 typedef qua<double, defaultp> dquat;

 typedef qua<f64, lowp> lowp_f64quat;
 typedef qua<f64, mediump> mediump_f64quat;
 typedef qua<f64, highp> highp_f64quat;
 typedef qua<f64, defaultp> f64quat;
}
# 116 "/opt/homebrew/include/glm/glm.hpp" 2

# 1 "/opt/homebrew/include/glm/vec2.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/vector_bool2.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/type_vec2.hpp" 1
# 14 "/opt/homebrew/include/glm/./ext/../detail/type_vec2.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<2, T, Q>
 {


  typedef T value_type;
  typedef vec<2, T, Q> type;
  typedef vec<2, bool, Q> bool_type;








#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
#pragma clang diagnostic ignored "-Wnested-anon-types"
# 68 "/opt/homebrew/include/glm/./ext/../detail/type_vec2.hpp"
   union {T x, r, s;};
   union {T y, g, t;};








#pragma clang diagnostic pop
# 89 "/opt/homebrew/include/glm/./ext/../detail/type_vec2.hpp"
  typedef length_t length_type;
                static length_type length(){return 2;}

                              T& operator[](length_type i);
                              T const& operator[](length_type i) const;



                                                vec() ;
                                        vec(vec const& v) ;
  template<qualifier P>
                vec(vec<2, T, P> const& v);



                explicit vec(T scalar);
                vec(T x, T y);



  template<typename U, qualifier P>
                explicit vec(vec<1, U, P> const& v);


  template<typename A, typename B>
                vec(A x, B y);
  template<typename A, typename B>
                vec(vec<1, A, Q> const& x, B y);
  template<typename A, typename B>
                vec(A x, vec<1, B, Q> const& y);
  template<typename A, typename B>
                vec(vec<1, A, Q> const& x, vec<1, B, Q> const& y);




  template<typename U, qualifier P>
                             vec(vec<3, U, P> const& v);

  template<typename U, qualifier P>
                             vec(vec<4, U, P> const& v);


  template<typename U, qualifier P>
                             vec(vec<2, U, P> const& v);
# 146 "/opt/homebrew/include/glm/./ext/../detail/type_vec2.hpp"
                                        vec<2, T, Q> & operator=(vec const& v) ;

  template<typename U>
                                      vec<2, T, Q> & operator=(vec<2, U, Q> const& v);
  template<typename U>
                                      vec<2, T, Q> & operator+=(U scalar);
  template<typename U>
                                      vec<2, T, Q> & operator+=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<2, T, Q> & operator+=(vec<2, U, Q> const& v);
  template<typename U>
                                      vec<2, T, Q> & operator-=(U scalar);
  template<typename U>
                                      vec<2, T, Q> & operator-=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<2, T, Q> & operator-=(vec<2, U, Q> const& v);
  template<typename U>
                                      vec<2, T, Q> & operator*=(U scalar);
  template<typename U>
                                      vec<2, T, Q> & operator*=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<2, T, Q> & operator*=(vec<2, U, Q> const& v);
  template<typename U>
                                      vec<2, T, Q> & operator/=(U scalar);
  template<typename U>
                                      vec<2, T, Q> & operator/=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<2, T, Q> & operator/=(vec<2, U, Q> const& v);



                                      vec<2, T, Q> & operator++();
                                      vec<2, T, Q> & operator--();
                              vec<2, T, Q> operator++(int);
                              vec<2, T, Q> operator--(int);



  template<typename U>
                                      vec<2, T, Q> & operator%=(U scalar);
  template<typename U>
                                      vec<2, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<2, T, Q> & operator%=(vec<2, U, Q> const& v);
  template<typename U>
                                      vec<2, T, Q> & operator&=(U scalar);
  template<typename U>
                                      vec<2, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<2, T, Q> & operator&=(vec<2, U, Q> const& v);
  template<typename U>
                                      vec<2, T, Q> & operator|=(U scalar);
  template<typename U>
                                      vec<2, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<2, T, Q> & operator|=(vec<2, U, Q> const& v);
  template<typename U>
                                      vec<2, T, Q> & operator^=(U scalar);
  template<typename U>
                                      vec<2, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<2, T, Q> & operator^=(vec<2, U, Q> const& v);
  template<typename U>
                                      vec<2, T, Q> & operator<<=(U scalar);
  template<typename U>
                                      vec<2, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<2, T, Q> & operator<<=(vec<2, U, Q> const& v);
  template<typename U>
                                      vec<2, T, Q> & operator>>=(U scalar);
  template<typename U>
                                      vec<2, T, Q> & operator>>=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<2, T, Q> & operator>>=(vec<2, U, Q> const& v);
 };



 template<typename T, qualifier Q>
                             vec<2, T, Q> operator+(vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator-(vec<2, T, Q> const& v);



 template<typename T, qualifier Q>
                             vec<2, T, Q> operator+(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator+(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator+(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator-(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator-(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator-(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator*(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator*(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator*(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator/(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator/(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator/(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator%(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator%(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator%(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator&(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator&(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator&(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator|(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator|(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator|(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator^(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator^(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator^(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator<<(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator<<(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator<<(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator>>(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator>>(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator>>(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<2, T, Q> operator~(vec<2, T, Q> const& v);



 template<typename T, qualifier Q>
                             bool operator==(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
                             bool operator!=(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<qualifier Q>
                             vec<2, bool, Q> operator&&(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2);

 template<qualifier Q>
                             vec<2, bool, Q> operator||(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2);
}


# 1 "/opt/homebrew/include/glm/./ext/../detail/type_vec2.inl" 1


# 1 "/opt/homebrew/include/glm/./ext/../detail/./compute_vector_relational.hpp" 1



# 1 "/opt/homebrew/include/glm/detail/setup.hpp" 1
# 5 "/opt/homebrew/include/glm/./ext/../detail/./compute_vector_relational.hpp" 2


namespace glm{
namespace detail
{
 template <typename T, bool isFloat>
 struct compute_equal
 {
  inline static bool call(T a, T b)
  {
   return a == b;
  }
 };
# 29 "/opt/homebrew/include/glm/./ext/../detail/./compute_vector_relational.hpp"
}
}
# 4 "/opt/homebrew/include/glm/./ext/../detail/type_vec2.inl" 2

namespace glm
{



  template<typename T, qualifier Q>
  inline vec<2, T, Q>::vec()



  {}



  template<typename T, qualifier Q>
  inline vec<2, T, Q>::vec(vec<2, T, Q> const& v)
   : x(v.x), y(v.y)
  {}


 template<typename T, qualifier Q>
 template<qualifier P>
 inline vec<2, T, Q>::vec(vec<2, T, P> const& v)
  : x(v.x), y(v.y)
 {}



 template<typename T, qualifier Q>
 inline vec<2, T, Q>::vec(T scalar)
  : x(scalar), y(scalar)
 {}

 template<typename T, qualifier Q>
 inline vec<2, T, Q>::vec(T _x, T _y)
  : x(_x), y(_y)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline vec<2, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 inline vec<2, T, Q>::vec(A _x, B _y)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 inline vec<2, T, Q>::vec(vec<1, A, Q> const& _x, B _y)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 inline vec<2, T, Q>::vec(A _x, vec<1, B, Q> const& _y)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 inline vec<2, T, Q>::vec(vec<1, A, Q> const& _x, vec<1, B, Q> const& _y)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline vec<2, T, Q>::vec(vec<2, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline vec<2, T, Q>::vec(vec<3, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline vec<2, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}



 template<typename T, qualifier Q>
 inline T & vec<2, T, Q>::operator[](typename vec<2, T, Q>::length_type i)
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_vec2.inl", 108, "(i) >= 0 && (i) < (this->length())") : (void)0));
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  }
 }

 template<typename T, qualifier Q>
 inline T const& vec<2, T, Q>::operator[](typename vec<2, T, Q>::length_type i) const
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_vec2.inl", 122, "(i) >= 0 && (i) < (this->length())") : (void)0));
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  }
 }




  template<typename T, qualifier Q>
  inline vec<2, T, Q> & vec<2, T, Q>::operator=(vec<2, T, Q> const& v)
  {
   this->x = v.x;
   this->y = v.y;
   return *this;
  }


 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator=(vec<2, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  this->y += static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator+=(vec<2, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  this->y -= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator-=(vec<2, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  this->y *= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator*=(vec<2, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator/=(U scalar)
 {
  this->x /= static_cast<T>(scalar);
  this->y /= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator/=(vec<2, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  return *this;
 }



 template<typename T, qualifier Q>
 inline vec<2, T, Q> & vec<2, T, Q>::operator++()
 {
  ++this->x;
  ++this->y;
  return *this;
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> & vec<2, T, Q>::operator--()
 {
  --this->x;
  --this->y;
  return *this;
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> vec<2, T, Q>::operator++(int)
 {
  vec<2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> vec<2, T, Q>::operator--(int)
 {
  vec<2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator%=(U scalar)
 {
  this->x %= static_cast<T>(scalar);
  this->y %= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator%=(vec<2, U, Q> const& v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator&=(U scalar)
 {
  this->x &= static_cast<T>(scalar);
  this->y &= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator&=(vec<2, U, Q> const& v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator|=(U scalar)
 {
  this->x |= static_cast<T>(scalar);
  this->y |= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator|=(vec<2, U, Q> const& v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator^=(U scalar)
 {
  this->x ^= static_cast<T>(scalar);
  this->y ^= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator^=(vec<2, U, Q> const& v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator<<=(U scalar)
 {
  this->x <<= static_cast<T>(scalar);
  this->y <<= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator<<=(vec<2, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  this->y >>= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<2, T, Q> & vec<2, T, Q>::operator>>=(vec<2, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  return *this;
 }



 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator+(vec<2, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator-(vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   -v.x,
   -v.y);
 }



 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator+(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x + scalar,
   v.y + scalar);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x + v2.x,
   v1.y + v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator+(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar + v.x,
   scalar + v.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator+(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x + v2.x,
   v1.x + v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x + v2.x,
   v1.y + v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator-(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x - scalar,
   v.y - scalar);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x - v2.x,
   v1.y - v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator-(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar - v.x,
   scalar - v.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator-(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x - v2.x,
   v1.x - v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x - v2.x,
   v1.y - v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator*(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x * scalar,
   v.y * scalar);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x * v2.x,
   v1.y * v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator*(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar * v.x,
   scalar * v.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator*(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x * v2.x,
   v1.x * v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x * v2.x,
   v1.y * v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator/(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x / scalar,
   v.y / scalar);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x / v2.x,
   v1.y / v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator/(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar / v.x,
   scalar / v.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator/(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x / v2.x,
   v1.x / v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x / v2.x,
   v1.y / v2.y);
 }



 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator%(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x % scalar,
   v.y % scalar);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x % v2.x,
   v1.y % v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator%(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar % v.x,
   scalar % v.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator%(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x % v2.x,
   v1.x % v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x % v2.x,
   v1.y % v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator&(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x & scalar,
   v.y & scalar);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x & v2.x,
   v1.y & v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator&(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar & v.x,
   scalar & v.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator&(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x & v2.x,
   v1.x & v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x & v2.x,
   v1.y & v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator|(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x | scalar,
   v.y | scalar);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x | v2.x,
   v1.y | v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator|(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar | v.x,
   scalar | v.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator|(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x | v2.x,
   v1.x | v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x | v2.x,
   v1.y | v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator^(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x ^ scalar,
   v.y ^ scalar);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x ^ v2.x,
   v1.y ^ v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator^(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar ^ v.x,
   scalar ^ v.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator^(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x ^ v2.x,
   v1.x ^ v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x ^ v2.x,
   v1.y ^ v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator<<(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x << scalar,
   v.y << scalar);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x << v2.x,
   v1.y << v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator<<(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar << v.x,
   scalar << v.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator<<(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x << v2.x,
   v1.x << v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x << v2.x,
   v1.y << v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator>>(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x >> scalar,
   v.y >> scalar);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x >> v2.x,
   v1.y >> v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator>>(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar >> v.x,
   scalar >> v.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator>>(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x >> v2.x,
   v1.x >> v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x >> v2.x,
   v1.y >> v2.y);
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> operator~(vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   ~v.x,
   ~v.y);
 }



 template<typename T, qualifier Q>
 inline bool operator==(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y);
 }

 template<typename T, qualifier Q>
 inline bool operator!=(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return !(v1 == v2);
 }

 template<qualifier Q>
 inline vec<2, bool, Q> operator&&(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2)
 {
  return vec<2, bool, Q>(v1.x && v2.x, v1.y && v2.y);
 }

 template<qualifier Q>
 inline vec<2, bool, Q> operator||(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2)
 {
  return vec<2, bool, Q>(v1.x || v2.x, v1.y || v2.y);
 }
}
# 402 "/opt/homebrew/include/glm/./ext/../detail/type_vec2.hpp" 2
# 6 "/opt/homebrew/include/glm/./ext/vector_bool2.hpp" 2

namespace glm
{






 typedef vec<2, bool, defaultp> bvec2;


}
# 6 "/opt/homebrew/include/glm/vec2.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_bool2_precision.hpp" 1






namespace glm
{







 typedef vec<2, bool, highp> highp_bvec2;





 typedef vec<2, bool, mediump> mediump_bvec2;





 typedef vec<2, bool, lowp> lowp_bvec2;


}
# 7 "/opt/homebrew/include/glm/vec2.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_float2.hpp" 1






namespace glm
{






 typedef vec<2, float, defaultp> vec2;


}
# 8 "/opt/homebrew/include/glm/vec2.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_float2_precision.hpp" 1






namespace glm
{







 typedef vec<2, float, highp> highp_vec2;





 typedef vec<2, float, mediump> mediump_vec2;





 typedef vec<2, float, lowp> lowp_vec2;


}
# 9 "/opt/homebrew/include/glm/vec2.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_double2.hpp" 1






namespace glm
{






 typedef vec<2, double, defaultp> dvec2;


}
# 10 "/opt/homebrew/include/glm/vec2.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_double2_precision.hpp" 1






namespace glm
{







 typedef vec<2, double, highp> highp_dvec2;





 typedef vec<2, double, mediump> mediump_dvec2;





 typedef vec<2, double, lowp> lowp_dvec2;


}
# 11 "/opt/homebrew/include/glm/vec2.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_int2.hpp" 1






namespace glm
{






 typedef vec<2, int, defaultp> ivec2;


}
# 12 "/opt/homebrew/include/glm/vec2.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_int2_sized.hpp" 1
# 17 "/opt/homebrew/include/glm/./ext/vector_int2_sized.hpp"
# 1 "/opt/homebrew/include/glm/./ext/../ext/scalar_int_sized.hpp" 1
# 15 "/opt/homebrew/include/glm/./ext/../ext/scalar_int_sized.hpp"
# 1 "/opt/homebrew/include/glm/detail/setup.hpp" 1
# 16 "/opt/homebrew/include/glm/./ext/../ext/scalar_int_sized.hpp" 2





namespace glm{
namespace detail
{





  typedef signed char int8;
  typedef signed short int16;
  typedef signed int int32;


 template<>
 struct is_int<int8>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<int16>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<int64>
 {
  enum test {value = ~0};
 };
}






 typedef detail::int8 int8;


 typedef detail::int16 int16;


 typedef detail::int32 int32;


 typedef detail::int64 int64;


}
# 18 "/opt/homebrew/include/glm/./ext/vector_int2_sized.hpp" 2





namespace glm
{






 typedef vec<2, int8, defaultp> i8vec2;




 typedef vec<2, int16, defaultp> i16vec2;




 typedef vec<2, int32, defaultp> i32vec2;




 typedef vec<2, int64, defaultp> i64vec2;


}
# 13 "/opt/homebrew/include/glm/vec2.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_uint2.hpp" 1






namespace glm
{






 typedef vec<2, unsigned int, defaultp> uvec2;


}
# 14 "/opt/homebrew/include/glm/vec2.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_uint2_sized.hpp" 1
# 17 "/opt/homebrew/include/glm/./ext/vector_uint2_sized.hpp"
# 1 "/opt/homebrew/include/glm/./ext/../ext/scalar_uint_sized.hpp" 1
# 15 "/opt/homebrew/include/glm/./ext/../ext/scalar_uint_sized.hpp"
# 1 "/opt/homebrew/include/glm/detail/setup.hpp" 1
# 16 "/opt/homebrew/include/glm/./ext/../ext/scalar_uint_sized.hpp" 2





namespace glm{
namespace detail
{





  typedef unsigned char uint8;
  typedef unsigned short uint16;
  typedef unsigned int uint32;


 template<>
 struct is_int<uint8>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<uint16>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<uint64>
 {
  enum test {value = ~0};
 };
}






 typedef detail::uint8 uint8;


 typedef detail::uint16 uint16;


 typedef detail::uint32 uint32;


 typedef detail::uint64 uint64;


}
# 18 "/opt/homebrew/include/glm/./ext/vector_uint2_sized.hpp" 2





namespace glm
{






 typedef vec<2, uint8, defaultp> u8vec2;




 typedef vec<2, uint16, defaultp> u16vec2;




 typedef vec<2, uint32, defaultp> u32vec2;




 typedef vec<2, uint64, defaultp> u64vec2;


}
# 15 "/opt/homebrew/include/glm/vec2.hpp" 2
# 118 "/opt/homebrew/include/glm/glm.hpp" 2
# 1 "/opt/homebrew/include/glm/vec3.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/vector_bool3.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/type_vec3.hpp" 1
# 14 "/opt/homebrew/include/glm/./ext/../detail/type_vec3.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<3, T, Q>
 {


  typedef T value_type;
  typedef vec<3, T, Q> type;
  typedef vec<3, bool, Q> bool_type;








#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
#pragma clang diagnostic ignored "-Wnested-anon-types"
#pragma clang diagnostic ignored "-Wpadded"
# 72 "/opt/homebrew/include/glm/./ext/../detail/type_vec3.hpp"
   union { T x, r, s; };
   union { T y, g, t; };
   union { T z, b, p; };








#pragma clang diagnostic pop
# 94 "/opt/homebrew/include/glm/./ext/../detail/type_vec3.hpp"
  typedef length_t length_type;
                static length_type length(){return 3;}

                              T & operator[](length_type i);
                              T const& operator[](length_type i) const;



                                                vec() ;
                                        vec(vec const& v) ;
  template<qualifier P>
                vec(vec<3, T, P> const& v);



                explicit vec(T scalar);
                vec(T a, T b, T c);



  template<typename U, qualifier P>
                explicit vec(vec<1, U, P> const& v);


  template<typename X, typename Y, typename Z>
                vec(X x, Y y, Z z);
  template<typename X, typename Y, typename Z>
                vec(vec<1, X, Q> const& _x, Y _y, Z _z);
  template<typename X, typename Y, typename Z>
                vec(X _x, vec<1, Y, Q> const& _y, Z _z);
  template<typename X, typename Y, typename Z>
                vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z);
  template<typename X, typename Y, typename Z>
                vec(X _x, Y _y, vec<1, Z, Q> const& _z);
  template<typename X, typename Y, typename Z>
                vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z);
  template<typename X, typename Y, typename Z>
                vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z);
  template<typename X, typename Y, typename Z>
                vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z);




  template<typename A, typename B, qualifier P>
                vec(vec<2, A, P> const& _xy, B _z);

  template<typename A, typename B, qualifier P>
                vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z);

  template<typename A, typename B, qualifier P>
                vec(A _x, vec<2, B, P> const& _yz);

  template<typename A, typename B, qualifier P>
                vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz);

  template<typename U, qualifier P>
                             vec(vec<4, U, P> const& v);


  template<typename U, qualifier P>
                             vec(vec<3, U, P> const& v);
# 180 "/opt/homebrew/include/glm/./ext/../detail/type_vec3.hpp"
                                        vec<3, T, Q>& operator=(vec<3, T, Q> const& v) ;

  template<typename U>
                                      vec<3, T, Q> & operator=(vec<3, U, Q> const& v);
  template<typename U>
                                      vec<3, T, Q> & operator+=(U scalar);
  template<typename U>
                                      vec<3, T, Q> & operator+=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<3, T, Q> & operator+=(vec<3, U, Q> const& v);
  template<typename U>
                                      vec<3, T, Q> & operator-=(U scalar);
  template<typename U>
                                      vec<3, T, Q> & operator-=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<3, T, Q> & operator-=(vec<3, U, Q> const& v);
  template<typename U>
                                      vec<3, T, Q> & operator*=(U scalar);
  template<typename U>
                                      vec<3, T, Q> & operator*=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<3, T, Q> & operator*=(vec<3, U, Q> const& v);
  template<typename U>
                                      vec<3, T, Q> & operator/=(U scalar);
  template<typename U>
                                      vec<3, T, Q> & operator/=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<3, T, Q> & operator/=(vec<3, U, Q> const& v);



                                      vec<3, T, Q> & operator++();
                                      vec<3, T, Q> & operator--();
                              vec<3, T, Q> operator++(int);
                              vec<3, T, Q> operator--(int);



  template<typename U>
                                      vec<3, T, Q> & operator%=(U scalar);
  template<typename U>
                                      vec<3, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<3, T, Q> & operator%=(vec<3, U, Q> const& v);
  template<typename U>
                                      vec<3, T, Q> & operator&=(U scalar);
  template<typename U>
                                      vec<3, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<3, T, Q> & operator&=(vec<3, U, Q> const& v);
  template<typename U>
                                      vec<3, T, Q> & operator|=(U scalar);
  template<typename U>
                                      vec<3, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<3, T, Q> & operator|=(vec<3, U, Q> const& v);
  template<typename U>
                                      vec<3, T, Q> & operator^=(U scalar);
  template<typename U>
                                      vec<3, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<3, T, Q> & operator^=(vec<3, U, Q> const& v);
  template<typename U>
                                      vec<3, T, Q> & operator<<=(U scalar);
  template<typename U>
                                      vec<3, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<3, T, Q> & operator<<=(vec<3, U, Q> const& v);
  template<typename U>
                                      vec<3, T, Q> & operator>>=(U scalar);
  template<typename U>
                                      vec<3, T, Q> & operator>>=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<3, T, Q> & operator>>=(vec<3, U, Q> const& v);
 };



 template<typename T, qualifier Q>
                             vec<3, T, Q> operator+(vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator-(vec<3, T, Q> const& v);



 template<typename T, qualifier Q>
                             vec<3, T, Q> operator+(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator+(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator+(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator+(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator+(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator-(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator-(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator-(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator*(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator*(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator*(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator/(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator/(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator/(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator%(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator%(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator%(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator&(vec<3, T, Q> const& v1, T scalar);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator&(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator&(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator|(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator|(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator|(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator^(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator^(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator^(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator<<(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator<<(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator<<(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator>>(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator>>(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator>>(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<3, T, Q> operator~(vec<3, T, Q> const& v);



 template<typename T, qualifier Q>
                             bool operator==(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
                             bool operator!=(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<qualifier Q>
                             vec<3, bool, Q> operator&&(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2);

 template<qualifier Q>
                             vec<3, bool, Q> operator||(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2);
}


# 1 "/opt/homebrew/include/glm/./ext/../detail/type_vec3.inl" 1




namespace glm
{



  template<typename T, qualifier Q>
  inline vec<3, T, Q>::vec()



  {}



  template<typename T, qualifier Q>
  inline vec<3, T, Q>::vec(vec<3, T, Q> const& v)
   : x(v.x), y(v.y), z(v.z)
  {}


 template<typename T, qualifier Q>
 template<qualifier P>
 inline vec<3, T, Q>::vec(vec<3, T, P> const& v)
  : x(v.x), y(v.y), z(v.z)
 {}



 template<typename T, qualifier Q>
 inline vec<3, T, Q>::vec(T scalar)
  : x(scalar), y(scalar), z(scalar)
 {}

 template <typename T, qualifier Q>
 inline vec<3, T, Q>::vec(T _x, T _y, T _z)
  : x(_x), y(_y), z(_z)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline vec<3, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.x))
  , z(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline vec<3, T, Q>::vec(X _x, Y _y, Z _z)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline vec<3, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline vec<3, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline vec<3, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline vec<3, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline vec<3, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline vec<3, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline vec<3, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
 {}



 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline vec<3, T, Q>::vec(vec<2, A, P> const& _xy, B _z)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline vec<3, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline vec<3, T, Q>::vec(A _x, vec<2, B, P> const& _yz)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline vec<3, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline vec<3, T, Q>::vec(vec<3, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
  , z(static_cast<T>(v.z))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline vec<3, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
  , z(static_cast<T>(v.z))
 {}



 template<typename T, qualifier Q>
 inline T & vec<3, T, Q>::operator[](typename vec<3, T, Q>::length_type i)
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_vec3.inl", 172, "(i) >= 0 && (i) < (this->length())") : (void)0));
  switch(i)
  {
  default:
   case 0:
  return x;
   case 1:
  return y;
   case 2:
  return z;
  }
 }

 template<typename T, qualifier Q>
 inline T const& vec<3, T, Q>::operator[](typename vec<3, T, Q>::length_type i) const
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_vec3.inl", 188, "(i) >= 0 && (i) < (this->length())") : (void)0));
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  case 2:
   return z;
  }
 }




  template<typename T, qualifier Q>
  inline vec<3, T, Q>& vec<3, T, Q>::operator=(vec<3, T, Q> const& v)
  {
   this->x = v.x;
   this->y = v.y;
   this->z = v.z;
   return *this;
  }


 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q>& vec<3, T, Q>::operator=(vec<3, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  this->z = static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  this->y += static_cast<T>(scalar);
  this->z += static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.x);
  this->z += static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator+=(vec<3, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  this->z += static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  this->y -= static_cast<T>(scalar);
  this->z -= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.x);
  this->z -= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator-=(vec<3, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  this->z -= static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  this->y *= static_cast<T>(scalar);
  this->z *= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.x);
  this->z *= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator*=(vec<3, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  this->z *= static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator/=(U v)
 {
  this->x /= static_cast<T>(v);
  this->y /= static_cast<T>(v);
  this->z /= static_cast<T>(v);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.x);
  this->z /= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator/=(vec<3, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  this->z /= static_cast<T>(v.z);
  return *this;
 }



 template<typename T, qualifier Q>
 inline vec<3, T, Q> & vec<3, T, Q>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  return *this;
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> & vec<3, T, Q>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  return *this;
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> vec<3, T, Q>::operator++(int)
 {
  vec<3, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> vec<3, T, Q>::operator--(int)
 {
  vec<3, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator%=(U scalar)
 {
  this->x %= scalar;
  this->y %= scalar;
  this->z %= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  this->x %= v.x;
  this->y %= v.x;
  this->z %= v.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator%=(vec<3, U, Q> const& v)
 {
  this->x %= v.x;
  this->y %= v.y;
  this->z %= v.z;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator&=(U scalar)
 {
  this->x &= scalar;
  this->y &= scalar;
  this->z &= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  this->x &= v.x;
  this->y &= v.x;
  this->z &= v.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator&=(vec<3, U, Q> const& v)
 {
  this->x &= v.x;
  this->y &= v.y;
  this->z &= v.z;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator|=(U scalar)
 {
  this->x |= scalar;
  this->y |= scalar;
  this->z |= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  this->x |= v.x;
  this->y |= v.x;
  this->z |= v.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator|=(vec<3, U, Q> const& v)
 {
  this->x |= v.x;
  this->y |= v.y;
  this->z |= v.z;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator^=(U scalar)
 {
  this->x ^= scalar;
  this->y ^= scalar;
  this->z ^= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  this->x ^= v.x;
  this->y ^= v.x;
  this->z ^= v.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator^=(vec<3, U, Q> const& v)
 {
  this->x ^= v.x;
  this->y ^= v.y;
  this->z ^= v.z;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator<<=(U scalar)
 {
  this->x <<= scalar;
  this->y <<= scalar;
  this->z <<= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.x);
  this->z <<= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator<<=(vec<3, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  this->z <<= static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  this->y >>= static_cast<T>(scalar);
  this->z >>= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.x);
  this->z >>= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<3, T, Q> & vec<3, T, Q>::operator>>=(vec<3, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  this->z >>= static_cast<T>(v.z);
  return *this;
 }



 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator+(vec<3, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator-(vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   -v.x,
   -v.y,
   -v.z);
 }



 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator+(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x + scalar,
   v.y + scalar,
   v.z + scalar);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator+(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x + scalar.x,
   v.y + scalar.x,
   v.z + scalar.x);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator+(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar + v.x,
   scalar + v.y,
   scalar + v.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator+(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x + v.x,
   scalar.x + v.y,
   scalar.x + v.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator+(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x + v2.x,
   v1.y + v2.y,
   v1.z + v2.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator-(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x - scalar,
   v.y - scalar,
   v.z - scalar);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator-(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x - scalar.x,
   v.y - scalar.x,
   v.z - scalar.x);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator-(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar - v.x,
   scalar - v.y,
   scalar - v.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator-(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x - v.x,
   scalar.x - v.y,
   scalar.x - v.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x - v2.x,
   v1.y - v2.y,
   v1.z - v2.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator*(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x * scalar,
   v.y * scalar,
   v.z * scalar);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator*(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x * scalar.x,
   v.y * scalar.x,
   v.z * scalar.x);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator*(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar * v.x,
   scalar * v.y,
   scalar * v.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator*(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x * v.x,
   scalar.x * v.y,
   scalar.x * v.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x * v2.x,
   v1.y * v2.y,
   v1.z * v2.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator/(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x / scalar,
   v.y / scalar,
   v.z / scalar);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator/(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x / scalar.x,
   v.y / scalar.x,
   v.z / scalar.x);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator/(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar / v.x,
   scalar / v.y,
   scalar / v.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator/(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x / v.x,
   scalar.x / v.y,
   scalar.x / v.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x / v2.x,
   v1.y / v2.y,
   v1.z / v2.z);
 }



 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator%(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x % scalar,
   v.y % scalar,
   v.z % scalar);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator%(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x % scalar.x,
   v.y % scalar.x,
   v.z % scalar.x);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator%(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar % v.x,
   scalar % v.y,
   scalar % v.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator%(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x % v.x,
   scalar.x % v.y,
   scalar.x % v.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x % v2.x,
   v1.y % v2.y,
   v1.z % v2.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator&(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x & scalar,
   v.y & scalar,
   v.z & scalar);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator&(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x & scalar.x,
   v.y & scalar.x,
   v.z & scalar.x);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator&(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar & v.x,
   scalar & v.y,
   scalar & v.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator&(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x & v.x,
   scalar.x & v.y,
   scalar.x & v.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x & v2.x,
   v1.y & v2.y,
   v1.z & v2.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator|(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x | scalar,
   v.y | scalar,
   v.z | scalar);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator|(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x | scalar.x,
   v.y | scalar.x,
   v.z | scalar.x);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator|(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar | v.x,
   scalar | v.y,
   scalar | v.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator|(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x | v.x,
   scalar.x | v.y,
   scalar.x | v.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x | v2.x,
   v1.y | v2.y,
   v1.z | v2.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator^(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x ^ scalar,
   v.y ^ scalar,
   v.z ^ scalar);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator^(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x ^ scalar.x,
   v.y ^ scalar.x,
   v.z ^ scalar.x);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator^(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar ^ v.x,
   scalar ^ v.y,
   scalar ^ v.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator^(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x ^ v.x,
   scalar.x ^ v.y,
   scalar.x ^ v.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x ^ v2.x,
   v1.y ^ v2.y,
   v1.z ^ v2.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator<<(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x << scalar,
   v.y << scalar,
   v.z << scalar);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator<<(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x << scalar.x,
   v.y << scalar.x,
   v.z << scalar.x);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator<<(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar << v.x,
   scalar << v.y,
   scalar << v.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator<<(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x << v.x,
   scalar.x << v.y,
   scalar.x << v.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x << v2.x,
   v1.y << v2.y,
   v1.z << v2.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator>>(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x >> scalar,
   v.y >> scalar,
   v.z >> scalar);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator>>(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x >> scalar.x,
   v.y >> scalar.x,
   v.z >> scalar.x);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator>>(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar >> v.x,
   scalar >> v.y,
   scalar >> v.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator>>(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x >> v.x,
   scalar.x >> v.y,
   scalar.x >> v.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x >> v2.x,
   v1.y >> v2.y,
   v1.z >> v2.z);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> operator~(vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   ~v.x,
   ~v.y,
   ~v.z);
 }



 template<typename T, qualifier Q>
 inline bool operator==(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y) &&
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.z, v2.z);
 }

 template<typename T, qualifier Q>
 inline bool operator!=(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return !(v1 == v2);
 }

 template<qualifier Q>
 inline vec<3, bool, Q> operator&&(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2)
 {
  return vec<3, bool, Q>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z);
 }

 template<qualifier Q>
 inline vec<3, bool, Q> operator||(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2)
 {
  return vec<3, bool, Q>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z);
 }
}
# 436 "/opt/homebrew/include/glm/./ext/../detail/type_vec3.hpp" 2
# 6 "/opt/homebrew/include/glm/./ext/vector_bool3.hpp" 2

namespace glm
{






 typedef vec<3, bool, defaultp> bvec3;


}
# 6 "/opt/homebrew/include/glm/vec3.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_bool3_precision.hpp" 1






namespace glm
{







 typedef vec<3, bool, highp> highp_bvec3;





 typedef vec<3, bool, mediump> mediump_bvec3;





 typedef vec<3, bool, lowp> lowp_bvec3;


}
# 7 "/opt/homebrew/include/glm/vec3.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_float3.hpp" 1






namespace glm
{






 typedef vec<3, float, defaultp> vec3;


}
# 8 "/opt/homebrew/include/glm/vec3.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_float3_precision.hpp" 1






namespace glm
{







 typedef vec<3, float, highp> highp_vec3;





 typedef vec<3, float, mediump> mediump_vec3;





 typedef vec<3, float, lowp> lowp_vec3;


}
# 9 "/opt/homebrew/include/glm/vec3.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_double3.hpp" 1






namespace glm
{






 typedef vec<3, double, defaultp> dvec3;


}
# 10 "/opt/homebrew/include/glm/vec3.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_double3_precision.hpp" 1






namespace glm
{
# 17 "/opt/homebrew/include/glm/./ext/vector_double3_precision.hpp"
 typedef vec<3, double, highp> highp_dvec3;






 typedef vec<3, double, mediump> mediump_dvec3;






 typedef vec<3, double, lowp> lowp_dvec3;


}
# 11 "/opt/homebrew/include/glm/vec3.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_int3.hpp" 1






namespace glm
{






 typedef vec<3, int, defaultp> ivec3;


}
# 12 "/opt/homebrew/include/glm/vec3.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_int3_sized.hpp" 1
# 23 "/opt/homebrew/include/glm/./ext/vector_int3_sized.hpp"
namespace glm
{






 typedef vec<3, int8, defaultp> i8vec3;




 typedef vec<3, int16, defaultp> i16vec3;




 typedef vec<3, int32, defaultp> i32vec3;




 typedef vec<3, int64, defaultp> i64vec3;


}
# 13 "/opt/homebrew/include/glm/vec3.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_uint3.hpp" 1






namespace glm
{






 typedef vec<3, unsigned int, defaultp> uvec3;


}
# 14 "/opt/homebrew/include/glm/vec3.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_uint3_sized.hpp" 1
# 23 "/opt/homebrew/include/glm/./ext/vector_uint3_sized.hpp"
namespace glm
{






 typedef vec<3, uint8, defaultp> u8vec3;




 typedef vec<3, uint16, defaultp> u16vec3;




 typedef vec<3, uint32, defaultp> u32vec3;




 typedef vec<3, uint64, defaultp> u64vec3;


}
# 15 "/opt/homebrew/include/glm/vec3.hpp" 2
# 119 "/opt/homebrew/include/glm/glm.hpp" 2
# 1 "/opt/homebrew/include/glm/vec4.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/vector_bool4.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/type_vec4.hpp" 1
# 14 "/opt/homebrew/include/glm/./ext/../detail/type_vec4.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<4, T, Q>
 {


  typedef T value_type;
  typedef vec<4, T, Q> type;
  typedef vec<4, bool, Q> bool_type;








#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
#pragma clang diagnostic ignored "-Wnested-anon-types"
# 68 "/opt/homebrew/include/glm/./ext/../detail/type_vec4.hpp"
   union { T x, r, s; };
   union { T y, g, t; };
   union { T z, b, p; };
   union { T w, a, q; };








#pragma clang diagnostic pop
# 90 "/opt/homebrew/include/glm/./ext/../detail/type_vec4.hpp"
  typedef length_t length_type;


                static length_type length(){return 4;}

                              T & operator[](length_type i);
                              T const& operator[](length_type i) const;



                                                vec() ;
                                        vec(vec<4, T, Q> const& v) ;
  template<qualifier P>
                vec(vec<4, T, P> const& v);



                explicit vec(T scalar);
                vec(T x, T y, T z, T w);



  template<typename U, qualifier P>
                explicit vec(vec<1, U, P> const& v);


  template<typename X, typename Y, typename Z, typename W>
                vec(X _x, Y _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
                vec(vec<1, X, Q> const& _x, Y _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
                vec(X _x, vec<1, Y, Q> const& _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
                vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
                vec(X _x, Y _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
                vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
                vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
                vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
                vec(vec<1, X, Q> const& _x, Y _y, Z _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
                vec(X _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
                vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
                vec(X _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
                vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
                vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
                vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);




  template<typename A, typename B, typename C, qualifier P>
                vec(vec<2, A, P> const& _xy, B _z, C _w);

  template<typename A, typename B, typename C, qualifier P>
                vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, C _w);

  template<typename A, typename B, typename C, qualifier P>
                vec(vec<2, A, P> const& _xy, B _z, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
                vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
                vec(A _x, vec<2, B, P> const& _yz, C _w);

  template<typename A, typename B, typename C, qualifier P>
                vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, C _w);

  template<typename A, typename B, typename C, qualifier P>
                vec(A _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
                vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
                vec(A _x, B _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, typename C, qualifier P>
                vec(vec<1, A, P> const& _x, B _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, typename C, qualifier P>
                vec(A _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, typename C, qualifier P>
                vec(vec<1, A, P> const& _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, qualifier P>
                vec(vec<3, A, P> const& _xyz, B _w);

  template<typename A, typename B, qualifier P>
                vec(vec<3, A, P> const& _xyz, vec<1, B, P> const& _w);

  template<typename A, typename B, qualifier P>
                vec(A _x, vec<3, B, P> const& _yzw);

  template<typename A, typename B, qualifier P>
                vec(vec<1, A, P> const& _x, vec<3, B, P> const& _yzw);

  template<typename A, typename B, qualifier P>
                vec(vec<2, A, P> const& _xy, vec<2, B, P> const& _zw);


  template<typename U, qualifier P>
                             vec(vec<4, U, P> const& v);
# 252 "/opt/homebrew/include/glm/./ext/../detail/type_vec4.hpp"
                                        vec<4, T, Q>& operator=(vec<4, T, Q> const& v) ;

  template<typename U>
                                      vec<4, T, Q>& operator=(vec<4, U, Q> const& v);
  template<typename U>
                                      vec<4, T, Q>& operator+=(U scalar);
  template<typename U>
                                      vec<4, T, Q>& operator+=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<4, T, Q>& operator+=(vec<4, U, Q> const& v);
  template<typename U>
                                      vec<4, T, Q>& operator-=(U scalar);
  template<typename U>
                                      vec<4, T, Q>& operator-=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<4, T, Q>& operator-=(vec<4, U, Q> const& v);
  template<typename U>
                                      vec<4, T, Q>& operator*=(U scalar);
  template<typename U>
                                      vec<4, T, Q>& operator*=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<4, T, Q>& operator*=(vec<4, U, Q> const& v);
  template<typename U>
                                      vec<4, T, Q>& operator/=(U scalar);
  template<typename U>
                                      vec<4, T, Q>& operator/=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<4, T, Q>& operator/=(vec<4, U, Q> const& v);



                                      vec<4, T, Q> & operator++();
                                      vec<4, T, Q> & operator--();
                              vec<4, T, Q> operator++(int);
                              vec<4, T, Q> operator--(int);



  template<typename U>
                              vec<4, T, Q> & operator%=(U scalar);
  template<typename U>
                              vec<4, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator%=(vec<4, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator&=(U scalar);
  template<typename U>
                              vec<4, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator&=(vec<4, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator|=(U scalar);
  template<typename U>
                              vec<4, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator|=(vec<4, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator^=(U scalar);
  template<typename U>
                              vec<4, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator^=(vec<4, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator<<=(U scalar);
  template<typename U>
                              vec<4, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator<<=(vec<4, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator>>=(U scalar);
  template<typename U>
                              vec<4, T, Q> & operator>>=(vec<1, U, Q> const& v);
  template<typename U>
                              vec<4, T, Q> & operator>>=(vec<4, U, Q> const& v);
 };



 template<typename T, qualifier Q>
                             vec<4, T, Q> operator+(vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator-(vec<4, T, Q> const& v);



 template<typename T, qualifier Q>
                             vec<4, T, Q> operator+(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator+(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator+(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator-(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator-(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator-(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator*(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator*(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator*(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator/(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator/(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator/(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator%(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator%(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator%(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator%(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator&(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator&(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator&(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator&(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator&(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator|(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator|(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator|(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator|(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator^(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator^(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator^(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator^(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator<<(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator<<(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator<<(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator<<(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator>>(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator>>(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator>>(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator>>(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<4, T, Q> operator~(vec<4, T, Q> const& v);



 template<typename T, qualifier Q>
                             bool operator==(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
                             bool operator!=(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<qualifier Q>
                             vec<4, bool, Q> operator&&(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2);

 template<qualifier Q>
                             vec<4, bool, Q> operator||(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2);
}


# 1 "/opt/homebrew/include/glm/./ext/../detail/type_vec4.inl" 1




namespace glm{
namespace detail
{
 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_add
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_sub
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_mul
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_div
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_mod
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x % b.x, a.y % b.y, a.z % b.z, a.w % b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_and
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_or
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_xor
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_shift_left
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x << b.x, a.y << b.y, a.z << b.z, a.w << b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_shift_right
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x >> b.x, a.y >> b.y, a.z >> b.z, a.w >> b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_equal
 {
  inline static bool call(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
  {
   return
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y) &&
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.z, v2.z) &&
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.w, v2.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_nequal
 {
  inline static bool call(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
  {
   return !compute_vec4_equal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_bitwise_not
 {
  inline static vec<4, T, Q> call(vec<4, T, Q> const& v)
  {
   return vec<4, T, Q>(~v.x, ~v.y, ~v.z, ~v.w);
  }
 };
}




  template<typename T, qualifier Q>
  inline vec<4, T, Q>::vec()



  {}



  template<typename T, qualifier Q>
  inline vec<4, T, Q>::vec(vec<4, T, Q> const& v)
   : x(v.x), y(v.y), z(v.z), w(v.w)
  {}


 template<typename T, qualifier Q>
 template<qualifier P>
 inline vec<4, T, Q>::vec(vec<4, T, P> const& v)
  : x(v.x), y(v.y), z(v.z), w(v.w)
 {}



 template<typename T, qualifier Q>
 inline vec<4, T, Q>::vec(T scalar)
  : x(scalar), y(scalar), z(scalar), w(scalar)
 {}

 template <typename T, qualifier Q>
 inline vec<4, T, Q>::vec(T _x, T _y, T _z, T _w)
  : x(_x), y(_y), z(_z), w(_w)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline vec<4, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.x))
  , z(static_cast<T>(v.x))
  , w(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(X _x, Y _y, Z _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}



 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(vec<2, A, P> const& _xy, B _z, C _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, C _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(vec<2, A, P> const& _xy, B _z, vec<1, C, P> const& _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, vec<1, C, P> const& _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(A _x, vec<2, B, P> const& _yz, C _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, C _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(A _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(A _x, B _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(vec<1, A, P> const& _x, B _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(A _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline vec<4, T, Q>::vec(vec<3, A, P> const& _xyz, B _w)
  : x(static_cast<T>(_xyz.x))
  , y(static_cast<T>(_xyz.y))
  , z(static_cast<T>(_xyz.z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline vec<4, T, Q>::vec(vec<3, A, P> const& _xyz, vec<1, B, P> const& _w)
  : x(static_cast<T>(_xyz.x))
  , y(static_cast<T>(_xyz.y))
  , z(static_cast<T>(_xyz.z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline vec<4, T, Q>::vec(A _x, vec<3, B, P> const& _yzw)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yzw.x))
  , z(static_cast<T>(_yzw.y))
  , w(static_cast<T>(_yzw.z))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<3, B, P> const& _yzw)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yzw.x))
  , z(static_cast<T>(_yzw.y))
  , w(static_cast<T>(_yzw.z))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<2, B, P> const& _zw)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline vec<4, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
  , z(static_cast<T>(v.z))
  , w(static_cast<T>(v.w))
 {}



 template<typename T, qualifier Q>
 inline T& vec<4, T, Q>::operator[](typename vec<4, T, Q>::length_type i)
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_vec4.inl", 481, "(i) >= 0 && (i) < (this->length())") : (void)0));
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  case 2:
   return z;
  case 3:
   return w;
  }
 }

 template<typename T, qualifier Q>
 inline T const& vec<4, T, Q>::operator[](typename vec<4, T, Q>::length_type i) const
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_vec4.inl", 499, "(i) >= 0 && (i) < (this->length())") : (void)0));
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  case 2:
   return z;
  case 3:
   return w;
  }
 }




  template<typename T, qualifier Q>
  inline vec<4, T, Q>& vec<4, T, Q>::operator=(vec<4, T, Q> const& v)
  {
   this->x = v.x;
   this->y = v.y;
   this->z = v.z;
   this->w = v.w;
   return *this;
  }


 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q>& vec<4, T, Q>::operator=(vec<4, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  this->z = static_cast<T>(v.z);
  this->w = static_cast<T>(v.w);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator+=(U scalar)
 {
  return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator+=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator-=(U scalar)
 {
  return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator-=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator*=(U scalar)
 {
  return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator*=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator/=(U scalar)
 {
  return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator/=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }



 template<typename T, qualifier Q>
 inline vec<4, T, Q> & vec<4, T, Q>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  ++this->w;
  return *this;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> & vec<4, T, Q>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  --this->w;
  return *this;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> vec<4, T, Q>::operator++(int)
 {
  vec<4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> vec<4, T, Q>::operator--(int)
 {
  vec<4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator%=(U scalar)
 {
  return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator%=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator&=(U scalar)
 {
  return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator&=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator|=(U scalar)
 {
  return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator|=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator^=(U scalar)
 {
  return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator^=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator<<=(U scalar)
 {
  return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator<<=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator>>=(U scalar)
 {
  return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<4, T, Q> & vec<4, T, Q>::operator>>=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }



 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator+(vec<4, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator-(vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(0) -= v;
 }



 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator+(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) += scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) += v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator+(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(v) += scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator+(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v2) += v1;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) += v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator-(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) -= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) -= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator-(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) -= v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator-(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) -= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) -= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator*(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) *= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) *= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator*(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(v) *= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator*(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v2) *= v1;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) *= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator/(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) /= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) /= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator/(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) /= v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator/(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) /= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) /= v2;
 }



 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator%(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) %= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) %= v2.x;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator%(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) %= v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator%(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar.x) %= v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) %= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator&(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) &= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator&(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<4, T, Q>(v) &= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator&(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) &= v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator&(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) &= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator&(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) &= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator|(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) |= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) |= v2.x;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator|(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) |= v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator|(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) |= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) |= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator^(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) ^= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) ^= v2.x;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator^(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) ^= v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator^(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) ^= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) ^= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator<<(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) <<= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) <<= v2.x;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator<<(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) <<= v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator<<(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) <<= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) <<= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator>>(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) >>= scalar;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) >>= v2.x;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator>>(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) >>= v;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator>>(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) >>= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) >>= v2;
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> operator~(vec<4, T, Q> const& v)
 {
  return detail::compute_vec4_bitwise_not<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v);
 }



 template<typename T, qualifier Q>
 inline bool operator==(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return detail::compute_vec4_equal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
 }

 template<typename T, qualifier Q>
 inline bool operator!=(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return detail::compute_vec4_nequal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
 }

 template<qualifier Q>
 inline vec<4, bool, Q> operator&&(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2)
 {
  return vec<4, bool, Q>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z, v1.w && v2.w);
 }

 template<qualifier Q>
 inline vec<4, bool, Q> operator||(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2)
 {
  return vec<4, bool, Q>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z, v1.w || v2.w);
 }
}
# 508 "/opt/homebrew/include/glm/./ext/../detail/type_vec4.hpp" 2
# 6 "/opt/homebrew/include/glm/./ext/vector_bool4.hpp" 2

namespace glm
{






 typedef vec<4, bool, defaultp> bvec4;


}
# 6 "/opt/homebrew/include/glm/vec4.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_bool4_precision.hpp" 1






namespace glm
{







 typedef vec<4, bool, highp> highp_bvec4;





 typedef vec<4, bool, mediump> mediump_bvec4;





 typedef vec<4, bool, lowp> lowp_bvec4;


}
# 7 "/opt/homebrew/include/glm/vec4.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_float4.hpp" 1






namespace glm
{






 typedef vec<4, float, defaultp> vec4;


}
# 8 "/opt/homebrew/include/glm/vec4.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_float4_precision.hpp" 1






namespace glm
{







 typedef vec<4, float, highp> highp_vec4;





 typedef vec<4, float, mediump> mediump_vec4;





 typedef vec<4, float, lowp> lowp_vec4;


}
# 9 "/opt/homebrew/include/glm/vec4.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_double4.hpp" 1






namespace glm
{






 typedef vec<4, double, defaultp> dvec4;


}
# 10 "/opt/homebrew/include/glm/vec4.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_double4_precision.hpp" 1




# 1 "/opt/homebrew/include/glm/detail/setup.hpp" 1
# 6 "/opt/homebrew/include/glm/./ext/vector_double4_precision.hpp" 2


namespace glm
{
# 18 "/opt/homebrew/include/glm/./ext/vector_double4_precision.hpp"
 typedef vec<4, double, highp> highp_dvec4;






 typedef vec<4, double, mediump> mediump_dvec4;






 typedef vec<4, double, lowp> lowp_dvec4;


}
# 11 "/opt/homebrew/include/glm/vec4.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_int4.hpp" 1






namespace glm
{






 typedef vec<4, int, defaultp> ivec4;


}
# 12 "/opt/homebrew/include/glm/vec4.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_int4_sized.hpp" 1
# 23 "/opt/homebrew/include/glm/./ext/vector_int4_sized.hpp"
namespace glm
{






 typedef vec<4, int8, defaultp> i8vec4;




 typedef vec<4, int16, defaultp> i16vec4;




 typedef vec<4, int32, defaultp> i32vec4;




 typedef vec<4, int64, defaultp> i64vec4;


}
# 13 "/opt/homebrew/include/glm/vec4.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_uint4.hpp" 1






namespace glm
{






 typedef vec<4, unsigned int, defaultp> uvec4;


}
# 14 "/opt/homebrew/include/glm/vec4.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/vector_uint4_sized.hpp" 1
# 23 "/opt/homebrew/include/glm/./ext/vector_uint4_sized.hpp"
namespace glm
{






 typedef vec<4, uint8, defaultp> u8vec4;




 typedef vec<4, uint16, defaultp> u16vec4;




 typedef vec<4, uint32, defaultp> u32vec4;




 typedef vec<4, uint64, defaultp> u64vec4;


}
# 15 "/opt/homebrew/include/glm/vec4.hpp" 2
# 120 "/opt/homebrew/include/glm/glm.hpp" 2
# 1 "/opt/homebrew/include/glm/mat2x2.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/matrix_double2x2.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/type_mat2x2.hpp" 1
# 10 "/opt/homebrew/include/glm/./ext/../detail/type_mat2x2.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct mat<2, 2, T, Q>
 {
  typedef vec<2, T, Q> col_type;
  typedef vec<2, T, Q> row_type;
  typedef mat<2, 2, T, Q> type;
  typedef mat<2, 2, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


  typedef length_t length_type;
                static length_type length() { return 2; }

                              col_type & operator[](length_type i) ;
                              col_type const& operator[](length_type i) const ;



                                                mat() ;
  template<qualifier P>
                mat(mat<2, 2, T, P> const& m);

                             mat(T scalar);
                mat(
   T const& x1, T const& y1,
   T const& x2, T const& y2);
                mat(
   col_type const& v1,
   col_type const& v2);



  template<typename U, typename V, typename M, typename N>
                mat(
   U const& x1, V const& y1,
   M const& x2, N const& y2);

  template<typename U, typename V>
                mat(
   vec<2, U, Q> const& v1,
   vec<2, V, Q> const& v2);



  template<typename U, qualifier P>
                             mat(mat<2, 2, U, P> const& m);

                             mat(mat<3, 3, T, Q> const& x);
                             mat(mat<4, 4, T, Q> const& x);
                             mat(mat<2, 3, T, Q> const& x);
                             mat(mat<3, 2, T, Q> const& x);
                             mat(mat<2, 4, T, Q> const& x);
                             mat(mat<4, 2, T, Q> const& x);
                             mat(mat<3, 4, T, Q> const& x);
                             mat(mat<4, 3, T, Q> const& x);



  template<typename U>
                                      mat<2, 2, T, Q> & operator=(mat<2, 2, U, Q> const& m);
  template<typename U>
                                      mat<2, 2, T, Q> & operator+=(U s);
  template<typename U>
                                      mat<2, 2, T, Q> & operator+=(mat<2, 2, U, Q> const& m);
  template<typename U>
                                      mat<2, 2, T, Q> & operator-=(U s);
  template<typename U>
                                      mat<2, 2, T, Q> & operator-=(mat<2, 2, U, Q> const& m);
  template<typename U>
                                      mat<2, 2, T, Q> & operator*=(U s);
  template<typename U>
                                      mat<2, 2, T, Q> & operator*=(mat<2, 2, U, Q> const& m);
  template<typename U>
                                      mat<2, 2, T, Q> & operator/=(U s);
  template<typename U>
                                      mat<2, 2, T, Q> & operator/=(mat<2, 2, U, Q> const& m);



                                      mat<2, 2, T, Q> & operator++ ();
                                      mat<2, 2, T, Q> & operator-- ();
                              mat<2, 2, T, Q> operator++(int);
                              mat<2, 2, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
                             mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m);



 template<typename T, qualifier Q>
                             mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<2, 2, T, Q> operator+(T scalar, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<2, 2, T, Q> operator-(T scalar, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<2, 2, T, Q> operator*(T scalar, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
                             typename mat<2, 2, T, Q>::col_type operator*(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
                             typename mat<2, 2, T, Q>::row_type operator*(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<3, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<4, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<2, 2, T, Q> operator/(T scalar, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
                             typename mat<2, 2, T, Q>::col_type operator/(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
                             typename mat<2, 2, T, Q>::row_type operator/(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);



 template<typename T, qualifier Q>
                             bool operator==(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
                             bool operator!=(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);
}


# 1 "/opt/homebrew/include/glm/./ext/../detail/type_mat2x2.inl" 1
# 1 "/opt/homebrew/include/glm/./ext/../detail/../matrix.hpp" 1
# 17 "/opt/homebrew/include/glm/./ext/../detail/../matrix.hpp"
# 1 "/opt/homebrew/include/glm/detail/setup.hpp" 1
# 18 "/opt/homebrew/include/glm/./ext/../detail/../matrix.hpp" 2




# 1 "/opt/homebrew/include/glm/./ext/../detail/../mat2x3.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double2x3.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat2x3.hpp" 1
# 11 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat2x3.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct mat<2, 3, T, Q>
 {
  typedef vec<3, T, Q> col_type;
  typedef vec<2, T, Q> row_type;
  typedef mat<2, 3, T, Q> type;
  typedef mat<3, 2, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


  typedef length_t length_type;
                static length_type length() { return 2; }

                              col_type & operator[](length_type i) ;
                              col_type const& operator[](length_type i) const ;



                                                mat() ;
  template<qualifier P>
                mat(mat<2, 3, T, P> const& m);

                             mat(T scalar);
                mat(
   T x0, T y0, T z0,
   T x1, T y1, T z1);
                mat(
   col_type const& v0,
   col_type const& v1);



  template<typename X1, typename Y1, typename Z1, typename X2, typename Y2, typename Z2>
                mat(
   X1 x1, Y1 y1, Z1 z1,
   X2 x2, Y2 y2, Z2 z2);

  template<typename U, typename V>
                mat(
   vec<3, U, Q> const& v1,
   vec<3, V, Q> const& v2);



  template<typename U, qualifier P>
                             mat(mat<2, 3, U, P> const& m);

                             mat(mat<2, 2, T, Q> const& x);
                             mat(mat<3, 3, T, Q> const& x);
                             mat(mat<4, 4, T, Q> const& x);
                             mat(mat<2, 4, T, Q> const& x);
                             mat(mat<3, 2, T, Q> const& x);
                             mat(mat<3, 4, T, Q> const& x);
                             mat(mat<4, 2, T, Q> const& x);
                             mat(mat<4, 3, T, Q> const& x);



  template<typename U>
                                      mat<2, 3, T, Q> & operator=(mat<2, 3, U, Q> const& m);
  template<typename U>
                                      mat<2, 3, T, Q> & operator+=(U s);
  template<typename U>
                                      mat<2, 3, T, Q> & operator+=(mat<2, 3, U, Q> const& m);
  template<typename U>
                                      mat<2, 3, T, Q> & operator-=(U s);
  template<typename U>
                                      mat<2, 3, T, Q> & operator-=(mat<2, 3, U, Q> const& m);
  template<typename U>
                                      mat<2, 3, T, Q> & operator*=(U s);
  template<typename U>
                                      mat<2, 3, T, Q> & operator/=(U s);



                                      mat<2, 3, T, Q> & operator++ ();
                                      mat<2, 3, T, Q> & operator-- ();
                              mat<2, 3, T, Q> operator++(int);
                              mat<2, 3, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
                             mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m);



 template<typename T, qualifier Q>
                             mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<2, 3, T, Q> operator*(T scalar, mat<2, 3, T, Q> const& m);

 template<typename T, qualifier Q>
                             typename mat<2, 3, T, Q>::col_type operator*(mat<2, 3, T, Q> const& m, typename mat<2, 3, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
                             typename mat<2, 3, T, Q>::row_type operator*(typename mat<2, 3, T, Q>::col_type const& v, mat<2, 3, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<3, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<4, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<2, 3, T, Q> operator/(mat<2, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<2, 3, T, Q> operator/(T scalar, mat<2, 3, T, Q> const& m);



 template<typename T, qualifier Q>
                             bool operator==(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
                             bool operator!=(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);
}


# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat2x3.inl" 1
namespace glm
{



  template<typename T, qualifier Q>
  inline mat<2, 3, T, Q>::mat()



  {




  }


 template<typename T, qualifier Q>
 template<qualifier P>
 inline mat<2, 3, T, Q>::mat(mat<2, 3, T, P> const& m)



 {

   this->value[0] = m.value[0];
   this->value[1] = m.value[1];

 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q>::mat(T scalar)



 {

   this->value[0] = col_type(scalar, 0, 0);
   this->value[1] = col_type(0, scalar, 0);

 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q>::mat
 (
  T x0, T y0, T z0,
  T x1, T y1, T z1
 )



 {

   this->value[0] = col_type(x0, y0, z0);
   this->value[1] = col_type(x1, y1, z1);

 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q>::mat(col_type const& v0, col_type const& v1)



 {

   this->value[0] = col_type(v0);
   this->value[1] = col_type(v1);

 }



 template<typename T, qualifier Q>
 template<
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2>
 inline mat<2, 3, T, Q>::mat
 (
  X1 x1, Y1 y1, Z1 z1,
  X2 x2, Y2 y2, Z2 z2
 )



 {

   this->value[0] = col_type(x1, y1, z1);
   this->value[1] = col_type(x2, y2, z2);

 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2>
 inline mat<2, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2)



 {

   this->value[0] = col_type(v1);
   this->value[1] = col_type(v2);

 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline mat<2, 3, T, Q>::mat(mat<2, 3, U, P> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);

 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0);
   this->value[1] = col_type(m[1], 0);

 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q>::mat(mat<3, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);

 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);

 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);

 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0);
   this->value[1] = col_type(m[1], 0);

 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);

 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0);
   this->value[1] = col_type(m[1], 0);

 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q>::mat(mat<4, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);

 }



 template<typename T, qualifier Q>
 inline typename mat<2, 3, T, Q>::col_type & mat<2, 3, T, Q>::operator[](typename mat<2, 3, T, Q>::length_type i)
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_mat2x3.inl", 222, "(i) >= 0 && (i) < (this->length())") : (void)0));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline typename mat<2, 3, T, Q>::col_type const& mat<2, 3, T, Q>::operator[](typename mat<2, 3, T, Q>::length_type i) const
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_mat2x3.inl", 229, "(i) >= 0 && (i) < (this->length())") : (void)0));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator=(mat<2, 3, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator+=(mat<2, 3, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator-=(mat<2, 3, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q> mat<2, 3, T, Q>::operator++(int)
 {
  mat<2, 3, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q> mat<2, 3, T, Q>::operator--(int)
 {
  mat<2, 3, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m)
 {
  return mat<2, 3, T, Q>(
   -m[0],
   -m[1]);
 }



 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m, T scalar)
 {
  return mat<2, 3, T, Q>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m, T scalar)
 {
  return mat<2, 3, T, Q>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m, T scalar)
 {
  return mat<2, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q> operator*(T scalar, mat<2, 3, T, Q> const& m)
 {
  return mat<2, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline typename mat<2, 3, T, Q>::col_type operator*
 (
  mat<2, 3, T, Q> const& m,
  typename mat<2, 3, T, Q>::row_type const& v)
 {
  return typename mat<2, 3, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y,
   m[0][2] * v.x + m[1][2] * v.y);
 }

 template<typename T, qualifier Q>
 inline typename mat<2, 3, T, Q>::row_type operator*
 (
  typename mat<2, 3, T, Q>::col_type const& v,
  mat<2, 3, T, Q> const& m)
 {
  return typename mat<2, 3, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2]);
 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1]);
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  T SrcA00 = m1[0][0];
  T SrcA01 = m1[0][1];
  T SrcA02 = m1[0][2];
  T SrcA10 = m1[1][0];
  T SrcA11 = m1[1][1];
  T SrcA12 = m1[1][2];

  T SrcB00 = m2[0][0];
  T SrcB01 = m2[0][1];
  T SrcB10 = m2[1][0];
  T SrcB11 = m2[1][1];
  T SrcB20 = m2[2][0];
  T SrcB21 = m2[2][1];

  mat<3, 3, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1]);
 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q> operator/(mat<2, 3, T, Q> const& m, T scalar)
 {
  return mat<2, 3, T, Q>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q> operator/(T scalar, mat<2, 3, T, Q> const& m)
 {
  return mat<2, 3, T, Q>(
   scalar / m[0],
   scalar / m[1]);
 }



 template<typename T, qualifier Q>
 inline bool operator==(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template<typename T, qualifier Q>
 inline bool operator!=(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 159 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat2x3.hpp" 2
# 6 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double2x3.hpp" 2

namespace glm
{






 typedef mat<2, 3, double, defaultp> dmat2x3;


}
# 6 "/opt/homebrew/include/glm/./ext/../detail/../mat2x3.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double2x3_precision.hpp" 1






namespace glm
{







 typedef mat<2, 3, double, lowp> lowp_dmat2x3;





 typedef mat<2, 3, double, mediump> mediump_dmat2x3;





 typedef mat<2, 3, double, highp> highp_dmat2x3;


}
# 7 "/opt/homebrew/include/glm/./ext/../detail/../mat2x3.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_float2x3.hpp" 1






namespace glm
{






 typedef mat<2, 3, float, defaultp> mat2x3;


}
# 8 "/opt/homebrew/include/glm/./ext/../detail/../mat2x3.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_float2x3_precision.hpp" 1






namespace glm
{







 typedef mat<2, 3, float, lowp> lowp_mat2x3;





 typedef mat<2, 3, float, mediump> mediump_mat2x3;





 typedef mat<2, 3, float, highp> highp_mat2x3;


}
# 9 "/opt/homebrew/include/glm/./ext/../detail/../mat2x3.hpp" 2
# 23 "/opt/homebrew/include/glm/./ext/../detail/../matrix.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/../mat2x4.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double2x4.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat2x4.hpp" 1
# 11 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat2x4.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct mat<2, 4, T, Q>
 {
  typedef vec<4, T, Q> col_type;
  typedef vec<2, T, Q> row_type;
  typedef mat<2, 4, T, Q> type;
  typedef mat<4, 2, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


  typedef length_t length_type;
                static length_type length() { return 2; }

                              col_type & operator[](length_type i) ;
                              col_type const& operator[](length_type i) const ;



                                                mat() ;
  template<qualifier P>
                mat(mat<2, 4, T, P> const& m);

                             mat(T scalar);
                mat(
   T x0, T y0, T z0, T w0,
   T x1, T y1, T z1, T w1);
                mat(
   col_type const& v0,
   col_type const& v1);



  template<
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2>
                mat(
   X1 x1, Y1 y1, Z1 z1, W1 w1,
   X2 x2, Y2 y2, Z2 z2, W2 w2);

  template<typename U, typename V>
                mat(
   vec<4, U, Q> const& v1,
   vec<4, V, Q> const& v2);



  template<typename U, qualifier P>
                             mat(mat<2, 4, U, P> const& m);

                             mat(mat<2, 2, T, Q> const& x);
                             mat(mat<3, 3, T, Q> const& x);
                             mat(mat<4, 4, T, Q> const& x);
                             mat(mat<2, 3, T, Q> const& x);
                             mat(mat<3, 2, T, Q> const& x);
                             mat(mat<3, 4, T, Q> const& x);
                             mat(mat<4, 2, T, Q> const& x);
                             mat(mat<4, 3, T, Q> const& x);



  template<typename U>
                                      mat<2, 4, T, Q> & operator=(mat<2, 4, U, Q> const& m);
  template<typename U>
                                      mat<2, 4, T, Q> & operator+=(U s);
  template<typename U>
                                      mat<2, 4, T, Q> & operator+=(mat<2, 4, U, Q> const& m);
  template<typename U>
                                      mat<2, 4, T, Q> & operator-=(U s);
  template<typename U>
                                      mat<2, 4, T, Q> & operator-=(mat<2, 4, U, Q> const& m);
  template<typename U>
                                      mat<2, 4, T, Q> & operator*=(U s);
  template<typename U>
                                      mat<2, 4, T, Q> & operator/=(U s);



                                      mat<2, 4, T, Q> & operator++ ();
                                      mat<2, 4, T, Q> & operator-- ();
                              mat<2, 4, T, Q> operator++(int);
                              mat<2, 4, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
                             mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m);



 template<typename T, qualifier Q>
                             mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<2, 4, T, Q> operator*(T scalar, mat<2, 4, T, Q> const& m);

 template<typename T, qualifier Q>
                             typename mat<2, 4, T, Q>::col_type operator*(mat<2, 4, T, Q> const& m, typename mat<2, 4, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
                             typename mat<2, 4, T, Q>::row_type operator*(typename mat<2, 4, T, Q>::col_type const& v, mat<2, 4, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<4, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<3, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<2, 4, T, Q> operator/(mat<2, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<2, 4, T, Q> operator/(T scalar, mat<2, 4, T, Q> const& m);



 template<typename T, qualifier Q>
                             bool operator==(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
                             bool operator!=(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);
}


# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat2x4.inl" 1
namespace glm
{



  template<typename T, qualifier Q>
  inline mat<2, 4, T, Q>::mat()



  {




  }


 template<typename T, qualifier Q>
 template<qualifier P>
 inline mat<2, 4, T, Q>::mat(mat<2, 4, T, P> const& m)



 {

   this->value[0] = m[0];
   this->value[1] = m[1];

 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q>::mat(T s)



 {

   this->value[0] = col_type(s, 0, 0, 0);
   this->value[1] = col_type(0, s, 0, 0);

 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q>::mat
 (
  T x0, T y0, T z0, T w0,
  T x1, T y1, T z1, T w1
 )



 {

   this->value[0] = col_type(x0, y0, z0, w0);
   this->value[1] = col_type(x1, y1, z1, w1);

 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q>::mat(col_type const& v0, col_type const& v1)



 {

   this->value[0] = v0;
   this->value[1] = v1;

 }



 template<typename T, qualifier Q>
 template<
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2>
 inline mat<2, 4, T, Q>::mat
 (
  X1 x1, Y1 y1, Z1 z1, W1 w1,
  X2 x2, Y2 y2, Z2 z2, W2 w2
 )





 {

   this->value[0] = col_type(x1, y1, z1, w1);
   this->value[1] = col_type(x2, y2, z2, w2);

 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2>
 inline mat<2, 4, T, Q>::mat(vec<4, V1, Q> const& v1, vec<4, V2, Q> const& v2)



 {

   this->value[0] = col_type(v1);
   this->value[1] = col_type(v2);

 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline mat<2, 4, T, Q>::mat(mat<2, 4, U, P> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);

 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0, 0);
   this->value[1] = col_type(m[1], 0, 0);

 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0);
   this->value[1] = col_type(m[1], 0);

 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q>::mat(mat<4, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);

 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0);
   this->value[1] = col_type(m[1], 0);

 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0, 0);
   this->value[1] = col_type(m[1], 0, 0);

 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q>::mat(mat<3, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);

 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0, 0);
   this->value[1] = col_type(m[1], 0, 0);

 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0);
   this->value[1] = col_type(m[1], 0);

 }



 template<typename T, qualifier Q>
 inline typename mat<2, 4, T, Q>::col_type & mat<2, 4, T, Q>::operator[](typename mat<2, 4, T, Q>::length_type i)
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_mat2x4.inl", 224, "(i) >= 0 && (i) < (this->length())") : (void)0));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline typename mat<2, 4, T, Q>::col_type const& mat<2, 4, T, Q>::operator[](typename mat<2, 4, T, Q>::length_type i) const
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_mat2x4.inl", 231, "(i) >= 0 && (i) < (this->length())") : (void)0));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator=(mat<2, 4, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator+=(mat<2, 4, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator-=(mat<2, 4, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 4, T, Q> & mat<2, 4, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q> mat<2, 4, T, Q>::operator++(int)
 {
  mat<2, 4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q> mat<2, 4, T, Q>::operator--(int)
 {
  mat<2, 4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m)
 {
  return mat<2, 4, T, Q>(
   -m[0],
   -m[1]);
 }



 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m, T scalar)
 {
  return mat<2, 4, T, Q>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m, T scalar)
 {
  return mat<2, 4, T, Q>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m, T scalar)
 {
  return mat<2, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q> operator*(T scalar, mat<2, 4, T, Q> const& m)
 {
  return mat<2, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline typename mat<2, 4, T, Q>::col_type operator*(mat<2, 4, T, Q> const& m, typename mat<2, 4, T, Q>::row_type const& v)
 {
  return typename mat<2, 4, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y,
   m[0][2] * v.x + m[1][2] * v.y,
   m[0][3] * v.x + m[1][3] * v.y);
 }

 template<typename T, qualifier Q>
 inline typename mat<2, 4, T, Q>::row_type operator*(typename mat<2, 4, T, Q>::col_type const& v, mat<2, 4, T, Q> const& m)
 {
  return typename mat<2, 4, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3]);
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  T SrcA00 = m1[0][0];
  T SrcA01 = m1[0][1];
  T SrcA02 = m1[0][2];
  T SrcA03 = m1[0][3];
  T SrcA10 = m1[1][0];
  T SrcA11 = m1[1][1];
  T SrcA12 = m1[1][2];
  T SrcA13 = m1[1][3];

  T SrcB00 = m2[0][0];
  T SrcB01 = m2[0][1];
  T SrcB10 = m2[1][0];
  T SrcB11 = m2[1][1];
  T SrcB20 = m2[2][0];
  T SrcB21 = m2[2][1];
  T SrcB30 = m2[3][0];
  T SrcB31 = m2[3][1];

  mat<4, 4, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31;
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1]);
 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1]);
 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q> operator/(mat<2, 4, T, Q> const& m, T scalar)
 {
  return mat<2, 4, T, Q>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q> operator/(T scalar, mat<2, 4, T, Q> const& m)
 {
  return mat<2, 4, T, Q>(
   scalar / m[0],
   scalar / m[1]);
 }



 template<typename T, qualifier Q>
 inline bool operator==(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template<typename T, qualifier Q>
 inline bool operator!=(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 161 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat2x4.hpp" 2
# 6 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double2x4.hpp" 2

namespace glm
{






 typedef mat<2, 4, double, defaultp> dmat2x4;


}
# 6 "/opt/homebrew/include/glm/./ext/../detail/../mat2x4.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double2x4_precision.hpp" 1






namespace glm
{







 typedef mat<2, 4, double, lowp> lowp_dmat2x4;





 typedef mat<2, 4, double, mediump> mediump_dmat2x4;





 typedef mat<2, 4, double, highp> highp_dmat2x4;


}
# 7 "/opt/homebrew/include/glm/./ext/../detail/../mat2x4.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_float2x4.hpp" 1






namespace glm
{






 typedef mat<2, 4, float, defaultp> mat2x4;


}
# 8 "/opt/homebrew/include/glm/./ext/../detail/../mat2x4.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_float2x4_precision.hpp" 1






namespace glm
{







 typedef mat<2, 4, float, lowp> lowp_mat2x4;





 typedef mat<2, 4, float, mediump> mediump_mat2x4;





 typedef mat<2, 4, float, highp> highp_mat2x4;


}
# 9 "/opt/homebrew/include/glm/./ext/../detail/../mat2x4.hpp" 2
# 24 "/opt/homebrew/include/glm/./ext/../detail/../matrix.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/../mat3x2.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double3x2.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat3x2.hpp" 1
# 11 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat3x2.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct mat<3, 2, T, Q>
 {
  typedef vec<2, T, Q> col_type;
  typedef vec<3, T, Q> row_type;
  typedef mat<3, 2, T, Q> type;
  typedef mat<2, 3, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


  typedef length_t length_type;
                static length_type length() { return 3; }

                              col_type & operator[](length_type i) ;
                              col_type const& operator[](length_type i) const ;



                                                mat() ;
  template<qualifier P>
                mat(mat<3, 2, T, P> const& m);

                             mat(T scalar);
                mat(
   T x0, T y0,
   T x1, T y1,
   T x2, T y2);
                mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2);



  template<
   typename X1, typename Y1,
   typename X2, typename Y2,
   typename X3, typename Y3>
                 mat(
   X1 x1, Y1 y1,
   X2 x2, Y2 y2,
   X3 x3, Y3 y3);

  template<typename V1, typename V2, typename V3>
                mat(
   vec<2, V1, Q> const& v1,
   vec<2, V2, Q> const& v2,
   vec<2, V3, Q> const& v3);



  template<typename U, qualifier P>
                             mat(mat<3, 2, U, P> const& m);

                             mat(mat<2, 2, T, Q> const& x);
                             mat(mat<3, 3, T, Q> const& x);
                             mat(mat<4, 4, T, Q> const& x);
                             mat(mat<2, 3, T, Q> const& x);
                             mat(mat<2, 4, T, Q> const& x);
                             mat(mat<3, 4, T, Q> const& x);
                             mat(mat<4, 2, T, Q> const& x);
                             mat(mat<4, 3, T, Q> const& x);



  template<typename U>
                                      mat<3, 2, T, Q> & operator=(mat<3, 2, U, Q> const& m);
  template<typename U>
                                      mat<3, 2, T, Q> & operator+=(U s);
  template<typename U>
                                      mat<3, 2, T, Q> & operator+=(mat<3, 2, U, Q> const& m);
  template<typename U>
                                      mat<3, 2, T, Q> & operator-=(U s);
  template<typename U>
                                      mat<3, 2, T, Q> & operator-=(mat<3, 2, U, Q> const& m);
  template<typename U>
                                      mat<3, 2, T, Q> & operator*=(U s);
  template<typename U>
                                      mat<3, 2, T, Q> & operator/=(U s);



                                      mat<3, 2, T, Q> & operator++ ();
                                      mat<3, 2, T, Q> & operator-- ();
                              mat<3, 2, T, Q> operator++(int);
                              mat<3, 2, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
                             mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m);



 template<typename T, qualifier Q>
                             mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<3, 2, T, Q> operator*(T scalar, mat<3, 2, T, Q> const& m);

 template<typename T, qualifier Q>
                             typename mat<3, 2, T, Q>::col_type operator*(mat<3, 2, T, Q> const& m, typename mat<3, 2, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
                             typename mat<3, 2, T, Q>::row_type operator*(typename mat<3, 2, T, Q>::col_type const& v, mat<3, 2, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<2, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<4, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<3, 2, T, Q> operator/(mat<3, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<3, 2, T, Q> operator/(T scalar, mat<3, 2, T, Q> const& m);



 template<typename T, qualifier Q>
                             bool operator==(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
                             bool operator!=(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

}


# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat3x2.inl" 1
namespace glm
{



  template<typename T, qualifier Q>
  inline mat<3, 2, T, Q>::mat()



  {





  }


 template<typename T, qualifier Q>
 template<qualifier P>
 inline mat<3, 2, T, Q>::mat(mat<3, 2, T, P> const& m)



 {

   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];

 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q>::mat(T s)



 {

   this->value[0] = col_type(s, 0);
   this->value[1] = col_type(0, s);
   this->value[2] = col_type(0, 0);

 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q>::mat
 (
  T x0, T y0,
  T x1, T y1,
  T x2, T y2
 )



 {

   this->value[0] = col_type(x0, y0);
   this->value[1] = col_type(x1, y1);
   this->value[2] = col_type(x2, y2);

 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)



 {

   this->value[0] = v0;
   this->value[1] = v1;
   this->value[2] = v2;

 }



 template<typename T, qualifier Q>
 template<
  typename X0, typename Y0,
  typename X1, typename Y1,
  typename X2, typename Y2>
 inline mat<3, 2, T, Q>::mat
 (
  X0 x0, Y0 y0,
  X1 x1, Y1 y1,
  X2 x2, Y2 y2
 )



 {

   this->value[0] = col_type(x0, y0);
   this->value[1] = col_type(x1, y1);
   this->value[2] = col_type(x2, y2);

 }

 template<typename T, qualifier Q>
 template<typename V0, typename V1, typename V2>
 inline mat<3, 2, T, Q>::mat(vec<2, V0, Q> const& v0, vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2)



 {

   this->value[0] = col_type(v0);
   this->value[1] = col_type(v1);
   this->value[2] = col_type(v2);

 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline mat<3, 2, T, Q>::mat(mat<3, 2, U, P> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);

 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q>::mat(mat<2, 2, T, Q> const& m)



 {

   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = col_type(0);

 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);

 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);

 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(0);

 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(0);

 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);

 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q>::mat(mat<4, 2, T, Q> const& m)



 {

   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];

 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);

 }



 template<typename T, qualifier Q>
 inline typename mat<3, 2, T, Q>::col_type & mat<3, 2, T, Q>::operator[](typename mat<3, 2, T, Q>::length_type i)
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_mat3x2.inl", 241, "(i) >= 0 && (i) < (this->length())") : (void)0));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline typename mat<3, 2, T, Q>::col_type const& mat<3, 2, T, Q>::operator[](typename mat<3, 2, T, Q>::length_type i) const
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_mat3x2.inl", 248, "(i) >= 0 && (i) < (this->length())") : (void)0));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator=(mat<3, 2, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator+=(mat<3, 2, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator-=(mat<3, 2, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 2, T, Q> & mat<3, 2, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q> mat<3, 2, T, Q>::operator++(int)
 {
  mat<3, 2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q> mat<3, 2, T, Q>::operator--(int)
 {
  mat<3, 2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m)
 {
  return mat<3, 2, T, Q>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m, T scalar)
 {
  return mat<3, 2, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m, T scalar)
 {
  return mat<3, 2, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m, T scalar)
 {
  return mat<3, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q> operator*(T scalar, mat<3, 2, T, Q> const& m)
 {
  return mat<3, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline typename mat<3, 2, T, Q>::col_type operator*(mat<3, 2, T, Q> const& m, typename mat<3, 2, T, Q>::row_type const& v)
 {
  return typename mat<3, 2, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z);
 }

 template<typename T, qualifier Q>
 inline typename mat<3, 2, T, Q>::row_type operator*(typename mat<3, 2, T, Q>::col_type const& v, mat<3, 2, T, Q> const& m)
 {
  return typename mat<3, 2, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1],
   v.x * m[2][0] + v.y * m[2][1]);
 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  const T SrcA00 = m1[0][0];
  const T SrcA01 = m1[0][1];
  const T SrcA10 = m1[1][0];
  const T SrcA11 = m1[1][1];
  const T SrcA20 = m1[2][0];
  const T SrcA21 = m1[2][1];

  const T SrcB00 = m2[0][0];
  const T SrcB01 = m2[0][1];
  const T SrcB02 = m2[0][2];
  const T SrcB10 = m2[1][0];
  const T SrcB11 = m2[1][1];
  const T SrcB12 = m2[1][2];

  mat<2, 2, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2]);
 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2]);
 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q> operator/(mat<3, 2, T, Q> const& m, T scalar)
 {
  return mat<3, 2, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q> operator/(T scalar, mat<3, 2, T, Q> const& m)
 {
  return mat<3, 2, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }



 template<typename T, qualifier Q>
 inline bool operator==(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template<typename T, qualifier Q>
 inline bool operator!=(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 167 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat3x2.hpp" 2
# 6 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double3x2.hpp" 2

namespace glm
{






 typedef mat<3, 2, double, defaultp> dmat3x2;


}
# 6 "/opt/homebrew/include/glm/./ext/../detail/../mat3x2.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double3x2_precision.hpp" 1






namespace glm
{







 typedef mat<3, 2, double, lowp> lowp_dmat3x2;





 typedef mat<3, 2, double, mediump> mediump_dmat3x2;





 typedef mat<3, 2, double, highp> highp_dmat3x2;


}
# 7 "/opt/homebrew/include/glm/./ext/../detail/../mat3x2.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_float3x2.hpp" 1






namespace glm
{






 typedef mat<3, 2, float, defaultp> mat3x2;


}
# 8 "/opt/homebrew/include/glm/./ext/../detail/../mat3x2.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_float3x2_precision.hpp" 1






namespace glm
{







 typedef mat<3, 2, float, lowp> lowp_mat3x2;





 typedef mat<3, 2, float, mediump> mediump_mat3x2;





 typedef mat<3, 2, float, highp> highp_mat3x2;


}
# 9 "/opt/homebrew/include/glm/./ext/../detail/../mat3x2.hpp" 2
# 25 "/opt/homebrew/include/glm/./ext/../detail/../matrix.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/../mat3x3.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double3x3.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat3x3.hpp" 1
# 10 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat3x3.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct mat<3, 3, T, Q>
 {
  typedef vec<3, T, Q> col_type;
  typedef vec<3, T, Q> row_type;
  typedef mat<3, 3, T, Q> type;
  typedef mat<3, 3, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


  typedef length_t length_type;
                static length_type length() { return 3; }

                              col_type & operator[](length_type i) ;
                              col_type const& operator[](length_type i) const ;



                                                mat() ;
  template<qualifier P>
                mat(mat<3, 3, T, P> const& m);

                             mat(T scalar);
                mat(
   T x0, T y0, T z0,
   T x1, T y1, T z1,
   T x2, T y2, T z2);
                mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2);



  template<
   typename X1, typename Y1, typename Z1,
   typename X2, typename Y2, typename Z2,
   typename X3, typename Y3, typename Z3>
                mat(
   X1 x1, Y1 y1, Z1 z1,
   X2 x2, Y2 y2, Z2 z2,
   X3 x3, Y3 y3, Z3 z3);

  template<typename V1, typename V2, typename V3>
                mat(
   vec<3, V1, Q> const& v1,
   vec<3, V2, Q> const& v2,
   vec<3, V3, Q> const& v3);



  template<typename U, qualifier P>
                             mat(mat<3, 3, U, P> const& m);

                             mat(mat<2, 2, T, Q> const& x);
                             mat(mat<4, 4, T, Q> const& x);
                             mat(mat<2, 3, T, Q> const& x);
                             mat(mat<3, 2, T, Q> const& x);
                             mat(mat<2, 4, T, Q> const& x);
                             mat(mat<4, 2, T, Q> const& x);
                             mat(mat<3, 4, T, Q> const& x);
                             mat(mat<4, 3, T, Q> const& x);



  template<typename U>
                                      mat<3, 3, T, Q> & operator=(mat<3, 3, U, Q> const& m);
  template<typename U>
                                      mat<3, 3, T, Q> & operator+=(U s);
  template<typename U>
                                      mat<3, 3, T, Q> & operator+=(mat<3, 3, U, Q> const& m);
  template<typename U>
                                      mat<3, 3, T, Q> & operator-=(U s);
  template<typename U>
                                      mat<3, 3, T, Q> & operator-=(mat<3, 3, U, Q> const& m);
  template<typename U>
                                      mat<3, 3, T, Q> & operator*=(U s);
  template<typename U>
                                      mat<3, 3, T, Q> & operator*=(mat<3, 3, U, Q> const& m);
  template<typename U>
                                      mat<3, 3, T, Q> & operator/=(U s);
  template<typename U>
                                      mat<3, 3, T, Q> & operator/=(mat<3, 3, U, Q> const& m);



                                      mat<3, 3, T, Q> & operator++();
                                      mat<3, 3, T, Q> & operator--();
                              mat<3, 3, T, Q> operator++(int);
                              mat<3, 3, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
                             mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m);



 template<typename T, qualifier Q>
                             mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<3, 3, T, Q> operator+(T scalar, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<3, 3, T, Q> operator-(T scalar, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<3, 3, T, Q> operator*(T scalar, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
                             typename mat<3, 3, T, Q>::col_type operator*(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
                             typename mat<3, 3, T, Q>::row_type operator*(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<2, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<4, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<3, 3, T, Q> operator/(T scalar, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
                             typename mat<3, 3, T, Q>::col_type operator/(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
                             typename mat<3, 3, T, Q>::row_type operator/(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);



 template<typename T, qualifier Q>
                             bool operator==(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
                             bool operator!=(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);
}


# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat3x3.inl" 1


namespace glm
{



  template<typename T, qualifier Q>
  inline mat<3, 3, T, Q>::mat()



  {





  }


 template<typename T, qualifier Q>
 template<qualifier P>
 inline mat<3, 3, T, Q>::mat(mat<3, 3, T, P> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);

 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q>::mat(T s)



 {

   this->value[0] = col_type(s, 0, 0);
   this->value[1] = col_type(0, s, 0);
   this->value[2] = col_type(0, 0, s);

 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q>::mat
 (
  T x0, T y0, T z0,
  T x1, T y1, T z1,
  T x2, T y2, T z2
 )



 {

   this->value[0] = col_type(x0, y0, z0);
   this->value[1] = col_type(x1, y1, z1);
   this->value[2] = col_type(x2, y2, z2);

 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)



 {

   this->value[0] = col_type(v0);
   this->value[1] = col_type(v1);
   this->value[2] = col_type(v2);

 }



 template<typename T, qualifier Q>
 template<
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3>
 inline mat<3, 3, T, Q>::mat
 (
  X1 x1, Y1 y1, Z1 z1,
  X2 x2, Y2 y2, Z2 z2,
  X3 x3, Y3 y3, Z3 z3
 )



 {

   this->value[0] = col_type(x1, y1, z1);
   this->value[1] = col_type(x2, y2, z2);
   this->value[2] = col_type(x3, y3, z3);

 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2, typename V3>
 inline mat<3, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2, vec<3, V3, Q> const& v3)



 {

   this->value[0] = col_type(v1);
   this->value[1] = col_type(v2);
   this->value[2] = col_type(v3);

 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline mat<3, 3, T, Q>::mat(mat<3, 3, U, P> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);

 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0);
   this->value[1] = col_type(m[1], 0);
   this->value[2] = col_type(0, 0, 1);

 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);

 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q>::mat(mat<2, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(0, 0, 1);

 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0);
   this->value[1] = col_type(m[1], 0);
   this->value[2] = col_type(m[2], 1);

 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(0, 0, 1);

 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0);
   this->value[1] = col_type(m[1], 0);
   this->value[2] = col_type(m[2], 1);

 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);

 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q>::mat(mat<4, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);

 }



 template<typename T, qualifier Q>
 inline typename mat<3, 3, T, Q>::col_type & mat<3, 3, T, Q>::operator[](typename mat<3, 3, T, Q>::length_type i)
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_mat3x3.inl", 243, "(i) >= 0 && (i) < (this->length())") : (void)0));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline typename mat<3, 3, T, Q>::col_type const& mat<3, 3, T, Q>::operator[](typename mat<3, 3, T, Q>::length_type i) const
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_mat3x3.inl", 250, "(i) >= 0 && (i) < (this->length())") : (void)0));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator=(mat<3, 3, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator+=(mat<3, 3, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator-=(mat<3, 3, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator*=(mat<3, 3, U, Q> const& m)
 {
  return (*this = *this * m);
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator/=(mat<3, 3, U, Q> const& m)
 {
  return *this *= inverse(m);
 }



 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> mat<3, 3, T, Q>::operator++(int)
 {
  mat<3, 3, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> mat<3, 3, T, Q>::operator--(int)
 {
  mat<3, 3, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m, T scalar)
 {
  return mat<3, 3, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> operator+(T scalar, mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return mat<3, 3, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m, T scalar)
 {
  return mat<3, 3, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> operator-(T scalar, mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   scalar - m[0],
   scalar - m[1],
   scalar - m[2]);
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return mat<3, 3, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m, T scalar)
 {
  return mat<3, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> operator*(T scalar, mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline typename mat<3, 3, T, Q>::col_type operator*(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v)
 {
  return typename mat<3, 3, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z);
 }

 template<typename T, qualifier Q>
 inline typename mat<3, 3, T, Q>::row_type operator*(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m)
 {
  return typename mat<3, 3, T, Q>::row_type(
   m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,
   m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,
   m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA02 = m1[0][2];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA12 = m1[1][2];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA22 = m1[2][2];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB20 = m2[2][0];
  T const SrcB21 = m2[2][1];
  T const SrcB22 = m2[2][2];

  mat<3, 3, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2]);
 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2]);
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m, T scalar)
 {
  return mat<3, 3, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> operator/(T scalar, mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }

 template<typename T, qualifier Q>
 inline typename mat<3, 3, T, Q>::col_type operator/(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v)
 {
  return inverse(m) * v;
 }

 template<typename T, qualifier Q>
 inline typename mat<3, 3, T, Q>::row_type operator/(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m)
 {
  return v * inverse(m);
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  mat<3, 3, T, Q> m1_copy(m1);
  return m1_copy /= m2;
 }



 template<typename T, qualifier Q>
 inline bool operator==(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template<typename T, qualifier Q>
 inline bool operator!=(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 184 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat3x3.hpp" 2
# 6 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double3x3.hpp" 2

namespace glm
{






 typedef mat<3, 3, double, defaultp> dmat3x3;




 typedef mat<3, 3, double, defaultp> dmat3;


}
# 6 "/opt/homebrew/include/glm/./ext/../detail/../mat3x3.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double3x3_precision.hpp" 1






namespace glm
{







 typedef mat<3, 3, double, lowp> lowp_dmat3;





 typedef mat<3, 3, double, mediump> mediump_dmat3;





 typedef mat<3, 3, double, highp> highp_dmat3;





 typedef mat<3, 3, double, lowp> lowp_dmat3x3;





 typedef mat<3, 3, double, mediump> mediump_dmat3x3;





 typedef mat<3, 3, double, highp> highp_dmat3x3;


}
# 7 "/opt/homebrew/include/glm/./ext/../detail/../mat3x3.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_float3x3.hpp" 1






namespace glm
{






 typedef mat<3, 3, float, defaultp> mat3x3;




 typedef mat<3, 3, float, defaultp> mat3;


}
# 8 "/opt/homebrew/include/glm/./ext/../detail/../mat3x3.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_float3x3_precision.hpp" 1






namespace glm
{







 typedef mat<3, 3, float, lowp> lowp_mat3;





 typedef mat<3, 3, float, mediump> mediump_mat3;





 typedef mat<3, 3, float, highp> highp_mat3;





 typedef mat<3, 3, float, lowp> lowp_mat3x3;





 typedef mat<3, 3, float, mediump> mediump_mat3x3;





 typedef mat<3, 3, float, highp> highp_mat3x3;


}
# 9 "/opt/homebrew/include/glm/./ext/../detail/../mat3x3.hpp" 2
# 26 "/opt/homebrew/include/glm/./ext/../detail/../matrix.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/../mat3x4.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double3x4.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat3x4.hpp" 1
# 11 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat3x4.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct mat<3, 4, T, Q>
 {
  typedef vec<4, T, Q> col_type;
  typedef vec<3, T, Q> row_type;
  typedef mat<3, 4, T, Q> type;
  typedef mat<4, 3, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


  typedef length_t length_type;
                static length_type length() { return 3; }

                              col_type & operator[](length_type i) ;
                              col_type const& operator[](length_type i) const ;



                                                mat() ;
  template<qualifier P>
                mat(mat<3, 4, T, P> const& m);

                             mat(T scalar);
                mat(
   T x0, T y0, T z0, T w0,
   T x1, T y1, T z1, T w1,
   T x2, T y2, T z2, T w2);
                mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2);



  template<
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2,
   typename X3, typename Y3, typename Z3, typename W3>
                mat(
   X1 x1, Y1 y1, Z1 z1, W1 w1,
   X2 x2, Y2 y2, Z2 z2, W2 w2,
   X3 x3, Y3 y3, Z3 z3, W3 w3);

  template<typename V1, typename V2, typename V3>
                mat(
   vec<4, V1, Q> const& v1,
   vec<4, V2, Q> const& v2,
   vec<4, V3, Q> const& v3);



  template<typename U, qualifier P>
                             mat(mat<3, 4, U, P> const& m);

                             mat(mat<2, 2, T, Q> const& x);
                             mat(mat<3, 3, T, Q> const& x);
                             mat(mat<4, 4, T, Q> const& x);
                             mat(mat<2, 3, T, Q> const& x);
                             mat(mat<3, 2, T, Q> const& x);
                             mat(mat<2, 4, T, Q> const& x);
                             mat(mat<4, 2, T, Q> const& x);
                             mat(mat<4, 3, T, Q> const& x);



  template<typename U>
                                      mat<3, 4, T, Q> & operator=(mat<3, 4, U, Q> const& m);
  template<typename U>
                                      mat<3, 4, T, Q> & operator+=(U s);
  template<typename U>
                                      mat<3, 4, T, Q> & operator+=(mat<3, 4, U, Q> const& m);
  template<typename U>
                                      mat<3, 4, T, Q> & operator-=(U s);
  template<typename U>
                                      mat<3, 4, T, Q> & operator-=(mat<3, 4, U, Q> const& m);
  template<typename U>
                                      mat<3, 4, T, Q> & operator*=(U s);
  template<typename U>
                                      mat<3, 4, T, Q> & operator/=(U s);



                                      mat<3, 4, T, Q> & operator++();
                                      mat<3, 4, T, Q> & operator--();
                              mat<3, 4, T, Q> operator++(int);
                              mat<3, 4, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
                             mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m);



 template<typename T, qualifier Q>
                             mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<3, 4, T, Q> operator*(T scalar, mat<3, 4, T, Q> const& m);

 template<typename T, qualifier Q>
                             typename mat<3, 4, T, Q>::col_type operator*(mat<3, 4, T, Q> const& m, typename mat<3, 4, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
                             typename mat<3, 4, T, Q>::row_type operator*(typename mat<3, 4, T, Q>::col_type const& v, mat<3, 4, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<4, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<2, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<3, 4, T, Q> operator/(mat<3, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<3, 4, T, Q> operator/(T scalar, mat<3, 4, T, Q> const& m);



 template<typename T, qualifier Q>
                             bool operator==(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
                             bool operator!=(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);
}


# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat3x4.inl" 1
namespace glm
{



  template<typename T, qualifier Q>
  inline mat<3, 4, T, Q>::mat()



  {





  }


 template<typename T, qualifier Q>
 template<qualifier P>
 inline mat<3, 4, T, Q>::mat(mat<3, 4, T, P> const& m)



 {

   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];

 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q>::mat(T s)



 {

   this->value[0] = col_type(s, 0, 0, 0);
   this->value[1] = col_type(0, s, 0, 0);
   this->value[2] = col_type(0, 0, s, 0);

 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q>::mat
 (
  T x0, T y0, T z0, T w0,
  T x1, T y1, T z1, T w1,
  T x2, T y2, T z2, T w2
 )






 {

   this->value[0] = col_type(x0, y0, z0, w0);
   this->value[1] = col_type(x1, y1, z1, w1);
   this->value[2] = col_type(x2, y2, z2, w2);

 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)



 {

   this->value[0] = v0;
   this->value[1] = v1;
   this->value[2] = v2;

 }



 template<typename T, qualifier Q>
 template<
  typename X0, typename Y0, typename Z0, typename W0,
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2>
 inline mat<3, 4, T, Q>::mat
 (
  X0 x0, Y0 y0, Z0 z0, W0 w0,
  X1 x1, Y1 y1, Z1 z1, W1 w1,
  X2 x2, Y2 y2, Z2 z2, W2 w2
 )






 {

   this->value[0] = col_type(x0, y0, z0, w0);
   this->value[1] = col_type(x1, y1, z1, w1);
   this->value[2] = col_type(x2, y2, z2, w2);

 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2, typename V3>
 inline mat<3, 4, T, Q>::mat(vec<4, V1, Q> const& v0, vec<4, V2, Q> const& v1, vec<4, V3, Q> const& v2)



 {

   this->value[0] = col_type(v0);
   this->value[1] = col_type(v1);
   this->value[2] = col_type(v2);

 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline mat<3, 4, T, Q>::mat(mat<3, 4, U, P> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);

 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0, 0);
   this->value[1] = col_type(m[1], 0, 0);
   this->value[2] = col_type(0, 0, 1, 0);

 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0);
   this->value[1] = col_type(m[1], 0);
   this->value[2] = col_type(m[2], 0);

 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q>::mat(mat<4, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);

 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0);
   this->value[1] = col_type(m[1], 0);
   this->value[2] = col_type(0, 0, 1, 0);

 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0, 0);
   this->value[1] = col_type(m[1], 0, 0);
   this->value[2] = col_type(m[2], 1, 0);

 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q>::mat(mat<2, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(0, 0, 1, 0);

 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0, 0);
   this->value[1] = col_type(m[1], 0, 0);
   this->value[2] = col_type(m[2], 1, 0);

 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0);
   this->value[1] = col_type(m[1], 0);
   this->value[2] = col_type(m[2], 0);

 }



 template<typename T, qualifier Q>
 inline typename mat<3, 4, T, Q>::col_type & mat<3, 4, T, Q>::operator[](typename mat<3, 4, T, Q>::length_type i)
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_mat3x4.inl", 247, "(i) >= 0 && (i) < (this->length())") : (void)0));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline typename mat<3, 4, T, Q>::col_type const& mat<3, 4, T, Q>::operator[](typename mat<3, 4, T, Q>::length_type i) const
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_mat3x4.inl", 254, "(i) >= 0 && (i) < (this->length())") : (void)0));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator=(mat<3, 4, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator+=(mat<3, 4, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator-=(mat<3, 4, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<3, 4, T, Q> & mat<3, 4, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q> mat<3, 4, T, Q>::operator++(int)
 {
  mat<3, 4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q> mat<3, 4, T, Q>::operator--(int)
 {
  mat<3, 4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m)
 {
  return mat<3, 4, T, Q>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m, T scalar)
 {
  return mat<3, 4, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m, T scalar)
 {
  return mat<3, 4, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m, T scalar)
 {
  return mat<3, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q> operator*(T scalar, mat<3, 4, T, Q> const& m)
 {
  return mat<3, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline typename mat<3, 4, T, Q>::col_type operator*
 (
  mat<3, 4, T, Q> const& m,
  typename mat<3, 4, T, Q>::row_type const& v
 )
 {
  return typename mat<3, 4, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z,
   m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z);
 }

 template<typename T, qualifier Q>
 inline typename mat<3, 4, T, Q>::row_type operator*
 (
  typename mat<3, 4, T, Q>::col_type const& v,
  mat<3, 4, T, Q> const& m
 )
 {
  return typename mat<3, 4, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3],
   v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2] + v.w * m[2][3]);
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  const T SrcA00 = m1[0][0];
  const T SrcA01 = m1[0][1];
  const T SrcA02 = m1[0][2];
  const T SrcA03 = m1[0][3];
  const T SrcA10 = m1[1][0];
  const T SrcA11 = m1[1][1];
  const T SrcA12 = m1[1][2];
  const T SrcA13 = m1[1][3];
  const T SrcA20 = m1[2][0];
  const T SrcA21 = m1[2][1];
  const T SrcA22 = m1[2][2];
  const T SrcA23 = m1[2][3];

  const T SrcB00 = m2[0][0];
  const T SrcB01 = m2[0][1];
  const T SrcB02 = m2[0][2];
  const T SrcB10 = m2[1][0];
  const T SrcB11 = m2[1][1];
  const T SrcB12 = m2[1][2];
  const T SrcB20 = m2[2][0];
  const T SrcB21 = m2[2][1];
  const T SrcB22 = m2[2][2];
  const T SrcB30 = m2[3][0];
  const T SrcB31 = m2[3][1];
  const T SrcB32 = m2[3][2];

  mat<4, 4, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01 + SrcA23 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11 + SrcA23 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21 + SrcA23 * SrcB22;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31 + SrcA20 * SrcB32;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31 + SrcA21 * SrcB32;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31 + SrcA22 * SrcB32;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31 + SrcA23 * SrcB32;
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2]);
 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2]);
 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q> operator/(mat<3, 4, T, Q> const& m, T scalar)
 {
  return mat<3, 4, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q> operator/(T scalar, mat<3, 4, T, Q> const& m)
 {
  return mat<3, 4, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }



 template<typename T, qualifier Q>
 inline bool operator==(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template<typename T, qualifier Q>
 inline bool operator!=(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 166 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat3x4.hpp" 2
# 6 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double3x4.hpp" 2

namespace glm
{






 typedef mat<3, 4, double, defaultp> dmat3x4;


}
# 6 "/opt/homebrew/include/glm/./ext/../detail/../mat3x4.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double3x4_precision.hpp" 1






namespace glm
{







 typedef mat<3, 4, double, lowp> lowp_dmat3x4;





 typedef mat<3, 4, double, mediump> mediump_dmat3x4;





 typedef mat<3, 4, double, highp> highp_dmat3x4;


}
# 7 "/opt/homebrew/include/glm/./ext/../detail/../mat3x4.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_float3x4.hpp" 1






namespace glm
{






 typedef mat<3, 4, float, defaultp> mat3x4;


}
# 8 "/opt/homebrew/include/glm/./ext/../detail/../mat3x4.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_float3x4_precision.hpp" 1






namespace glm
{







 typedef mat<3, 4, float, lowp> lowp_mat3x4;





 typedef mat<3, 4, float, mediump> mediump_mat3x4;





 typedef mat<3, 4, float, highp> highp_mat3x4;


}
# 9 "/opt/homebrew/include/glm/./ext/../detail/../mat3x4.hpp" 2
# 27 "/opt/homebrew/include/glm/./ext/../detail/../matrix.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/../mat4x2.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double4x2.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat4x2.hpp" 1
# 11 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat4x2.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct mat<4, 2, T, Q>
 {
  typedef vec<2, T, Q> col_type;
  typedef vec<4, T, Q> row_type;
  typedef mat<4, 2, T, Q> type;
  typedef mat<2, 4, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


  typedef length_t length_type;
                static length_type length() { return 4; }

                              col_type & operator[](length_type i) ;
                              col_type const& operator[](length_type i) const ;



                                                mat() ;
  template<qualifier P>
                mat(mat<4, 2, T, P> const& m);

                mat(T scalar);
                mat(
   T x0, T y0,
   T x1, T y1,
   T x2, T y2,
   T x3, T y3);
                mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2,
   col_type const& v3);



  template<
   typename X0, typename Y0,
   typename X1, typename Y1,
   typename X2, typename Y2,
   typename X3, typename Y3>
                mat(
   X0 x0, Y0 y0,
   X1 x1, Y1 y1,
   X2 x2, Y2 y2,
   X3 x3, Y3 y3);

  template<typename V1, typename V2, typename V3, typename V4>
                mat(
   vec<2, V1, Q> const& v1,
   vec<2, V2, Q> const& v2,
   vec<2, V3, Q> const& v3,
   vec<2, V4, Q> const& v4);



  template<typename U, qualifier P>
                mat(mat<4, 2, U, P> const& m);

                mat(mat<2, 2, T, Q> const& x);
                mat(mat<3, 3, T, Q> const& x);
                mat(mat<4, 4, T, Q> const& x);
                mat(mat<2, 3, T, Q> const& x);
                mat(mat<3, 2, T, Q> const& x);
                mat(mat<2, 4, T, Q> const& x);
                mat(mat<4, 3, T, Q> const& x);
                mat(mat<3, 4, T, Q> const& x);



  template<typename U>
                                      mat<4, 2, T, Q> & operator=(mat<4, 2, U, Q> const& m);
  template<typename U>
                                      mat<4, 2, T, Q> & operator+=(U s);
  template<typename U>
                                      mat<4, 2, T, Q> & operator+=(mat<4, 2, U, Q> const& m);
  template<typename U>
                                      mat<4, 2, T, Q> & operator-=(U s);
  template<typename U>
                                      mat<4, 2, T, Q> & operator-=(mat<4, 2, U, Q> const& m);
  template<typename U>
                                      mat<4, 2, T, Q> & operator*=(U s);
  template<typename U>
                                      mat<4, 2, T, Q> & operator/=(U s);



                                      mat<4, 2, T, Q> & operator++ ();
                                      mat<4, 2, T, Q> & operator-- ();
                              mat<4, 2, T, Q> operator++(int);
                              mat<4, 2, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
                             mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m);



 template<typename T, qualifier Q>
                             mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<4, 2, T, Q> operator*(T scalar, mat<4, 2, T, Q> const& m);

 template<typename T, qualifier Q>
                             typename mat<4, 2, T, Q>::col_type operator*(mat<4, 2, T, Q> const& m, typename mat<4, 2, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
                             typename mat<4, 2, T, Q>::row_type operator*(typename mat<4, 2, T, Q>::col_type const& v, mat<4, 2, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<2, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<3, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<4, 2, T, Q> operator/(mat<4, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<4, 2, T, Q> operator/(T scalar, mat<4, 2, T, Q> const& m);



 template<typename T, qualifier Q>
                             bool operator==(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
                             bool operator!=(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);
}


# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat4x2.inl" 1
namespace glm
{



  template<typename T, qualifier Q>
  inline mat<4, 2, T, Q>::mat()



  {






  }


 template<typename T, qualifier Q>
 template<qualifier P>
 inline mat<4, 2, T, Q>::mat(mat<4, 2, T, P> const& m)



 {

   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];
   this->value[3] = m[3];

 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q>::mat(T s)



 {

   this->value[0] = col_type(s, 0);
   this->value[1] = col_type(0, s);
   this->value[2] = col_type(0, 0);
   this->value[3] = col_type(0, 0);

 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q>::mat
 (
  T x0, T y0,
  T x1, T y1,
  T x2, T y2,
  T x3, T y3
 )



 {

   this->value[0] = col_type(x0, y0);
   this->value[1] = col_type(x1, y1);
   this->value[2] = col_type(x2, y2);
   this->value[3] = col_type(x3, y3);

 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)



 {

   this->value[0] = v0;
   this->value[1] = v1;
   this->value[2] = v2;
   this->value[3] = v3;

 }



 template<typename T, qualifier Q>
 template<
  typename X0, typename Y0,
  typename X1, typename Y1,
  typename X2, typename Y2,
  typename X3, typename Y3>
 inline mat<4, 2, T, Q>::mat
 (
  X0 x0, Y0 y0,
  X1 x1, Y1 y1,
  X2 x2, Y2 y2,
  X3 x3, Y3 y3
 )



 {

   this->value[0] = col_type(x0, y0);
   this->value[1] = col_type(x1, y1);
   this->value[2] = col_type(x2, y2);
   this->value[3] = col_type(x3, y3);

 }

 template<typename T, qualifier Q>
 template<typename V0, typename V1, typename V2, typename V3>
 inline mat<4, 2, T, Q>::mat(vec<2, V0, Q> const& v0, vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2, vec<2, V3, Q> const& v3)



 {

   this->value[0] = col_type(v0);
   this->value[1] = col_type(v1);
   this->value[2] = col_type(v2);
   this->value[3] = col_type(v3);

 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline mat<4, 2, T, Q>::mat(mat<4, 2, U, P> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);
   this->value[3] = col_type(m[3]);

 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q>::mat(mat<2, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(0);
   this->value[3] = col_type(0);

 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);
   this->value[3] = col_type(0);

 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);
   this->value[3] = col_type(m[3]);

 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(0);
   this->value[3] = col_type(0);

 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q>::mat(mat<3, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);
   this->value[3] = col_type(0);

 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(0);
   this->value[3] = col_type(0);

 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)



 {

    this->value[0] = col_type(m[0]);
    this->value[1] = col_type(m[1]);
    this->value[2] = col_type(m[2]);
    this->value[3] = col_type(m[3]);

 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);
   this->value[3] = col_type(0);

 }



 template<typename T, qualifier Q>
 inline typename mat<4, 2, T, Q>::col_type & mat<4, 2, T, Q>::operator[](typename mat<4, 2, T, Q>::length_type i)
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_mat4x2.inl", 260, "(i) >= 0 && (i) < (this->length())") : (void)0));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline typename mat<4, 2, T, Q>::col_type const& mat<4, 2, T, Q>::operator[](typename mat<4, 2, T, Q>::length_type i) const
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_mat4x2.inl", 267, "(i) >= 0 && (i) < (this->length())") : (void)0));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 2, T, Q>& mat<4, 2, T, Q>::operator=(mat<4, 2, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator+=(mat<4, 2, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator-=(mat<4, 2, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q> mat<4, 2, T, Q>::operator++(int)
 {
  mat<4, 2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q> mat<4, 2, T, Q>::operator--(int)
 {
  mat<4, 2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m)
 {
  return mat<4, 2, T, Q>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m, T scalar)
 {
  return mat<4, 2, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar,
   m[3] + scalar);
 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m, T scalar)
 {
  return mat<4, 2, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar,
   m[3] - scalar);
 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m, T scalar)
 {
  return mat<4, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q> operator*(T scalar, mat<4, 2, T, Q> const& m)
 {
  return mat<4, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline typename mat<4, 2, T, Q>::col_type operator*(mat<4, 2, T, Q> const& m, typename mat<4, 2, T, Q>::row_type const& v)
 {
  return typename mat<4, 2, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w);
 }

 template<typename T, qualifier Q>
 inline typename mat<4, 2, T, Q>::row_type operator*(typename mat<4, 2, T, Q>::col_type const& v, mat<4, 2, T, Q> const& m)
 {
  return typename mat<4, 2, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1],
   v.x * m[2][0] + v.y * m[2][1],
   v.x * m[3][0] + v.y * m[3][1]);
 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA30 = m1[3][0];
  T const SrcA31 = m1[3][1];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB03 = m2[0][3];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB13 = m2[1][3];

  mat<2, 2, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3]);
 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3]);
 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q> operator/(mat<4, 2, T, Q> const& m, T scalar)
 {
  return mat<4, 2, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar,
   m[3] / scalar);
 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q> operator/(T scalar, mat<4, 2, T, Q> const& m)
 {
  return mat<4, 2, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2],
   scalar / m[3]);
 }



 template<typename T, qualifier Q>
 inline bool operator==(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template<typename T, qualifier Q>
 inline bool operator!=(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 171 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat4x2.hpp" 2
# 6 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double4x2.hpp" 2

namespace glm
{






 typedef mat<4, 2, double, defaultp> dmat4x2;


}
# 6 "/opt/homebrew/include/glm/./ext/../detail/../mat4x2.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double4x2_precision.hpp" 1






namespace glm
{







 typedef mat<4, 2, double, lowp> lowp_dmat4x2;





 typedef mat<4, 2, double, mediump> mediump_dmat4x2;





 typedef mat<4, 2, double, highp> highp_dmat4x2;


}
# 7 "/opt/homebrew/include/glm/./ext/../detail/../mat4x2.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_float4x2.hpp" 1






namespace glm
{






 typedef mat<4, 2, float, defaultp> mat4x2;


}
# 8 "/opt/homebrew/include/glm/./ext/../detail/../mat4x2.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_float4x2_precision.hpp" 1






namespace glm
{







 typedef mat<4, 2, float, lowp> lowp_mat4x2;





 typedef mat<4, 2, float, mediump> mediump_mat4x2;





 typedef mat<4, 2, float, highp> highp_mat4x2;


}
# 9 "/opt/homebrew/include/glm/./ext/../detail/../mat4x2.hpp" 2
# 28 "/opt/homebrew/include/glm/./ext/../detail/../matrix.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/../mat4x3.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double4x3.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat4x3.hpp" 1
# 11 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat4x3.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct mat<4, 3, T, Q>
 {
  typedef vec<3, T, Q> col_type;
  typedef vec<4, T, Q> row_type;
  typedef mat<4, 3, T, Q> type;
  typedef mat<3, 4, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


  typedef length_t length_type;
                static length_type length() { return 4; }

                              col_type & operator[](length_type i) ;
                              col_type const& operator[](length_type i) const ;



                                                mat() ;
  template<qualifier P>
                mat(mat<4, 3, T, P> const& m);

                             mat(T s);
                mat(
   T const& x0, T const& y0, T const& z0,
   T const& x1, T const& y1, T const& z1,
   T const& x2, T const& y2, T const& z2,
   T const& x3, T const& y3, T const& z3);
                mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2,
   col_type const& v3);



  template<
   typename X1, typename Y1, typename Z1,
   typename X2, typename Y2, typename Z2,
   typename X3, typename Y3, typename Z3,
   typename X4, typename Y4, typename Z4>
                mat(
   X1 const& x1, Y1 const& y1, Z1 const& z1,
   X2 const& x2, Y2 const& y2, Z2 const& z2,
   X3 const& x3, Y3 const& y3, Z3 const& z3,
   X4 const& x4, Y4 const& y4, Z4 const& z4);

  template<typename V1, typename V2, typename V3, typename V4>
                mat(
   vec<3, V1, Q> const& v1,
   vec<3, V2, Q> const& v2,
   vec<3, V3, Q> const& v3,
   vec<3, V4, Q> const& v4);



  template<typename U, qualifier P>
                mat(mat<4, 3, U, P> const& m);

                mat(mat<2, 2, T, Q> const& x);
                mat(mat<3, 3, T, Q> const& x);
                mat(mat<4, 4, T, Q> const& x);
                mat(mat<2, 3, T, Q> const& x);
                mat(mat<3, 2, T, Q> const& x);
                mat(mat<2, 4, T, Q> const& x);
                mat(mat<4, 2, T, Q> const& x);
                mat(mat<3, 4, T, Q> const& x);



  template<typename U>
                                      mat<4, 3, T, Q> & operator=(mat<4, 3, U, Q> const& m);
  template<typename U>
                                      mat<4, 3, T, Q> & operator+=(U s);
  template<typename U>
                                      mat<4, 3, T, Q> & operator+=(mat<4, 3, U, Q> const& m);
  template<typename U>
                                      mat<4, 3, T, Q> & operator-=(U s);
  template<typename U>
                                      mat<4, 3, T, Q> & operator-=(mat<4, 3, U, Q> const& m);
  template<typename U>
                                      mat<4, 3, T, Q> & operator*=(U s);
  template<typename U>
                                      mat<4, 3, T, Q> & operator/=(U s);



                                      mat<4, 3, T, Q>& operator++();
                                      mat<4, 3, T, Q>& operator--();
                              mat<4, 3, T, Q> operator++(int);
                              mat<4, 3, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
                             mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m);



 template<typename T, qualifier Q>
                             mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<4, 3, T, Q> operator*(T scalar, mat<4, 3, T, Q> const& m);

 template<typename T, qualifier Q>
                             typename mat<4, 3, T, Q>::col_type operator*(mat<4, 3, T, Q> const& m, typename mat<4, 3, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
                             typename mat<4, 3, T, Q>::row_type operator*(typename mat<4, 3, T, Q>::col_type const& v, mat<4, 3, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<2, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<3, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<4, 3, T, Q> operator/(mat<4, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<4, 3, T, Q> operator/(T scalar, mat<4, 3, T, Q> const& m);



 template<typename T, qualifier Q>
                             bool operator==(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
                             bool operator!=(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);
}


# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat4x3.inl" 1
namespace glm
{



  template<typename T, qualifier Q>
  inline mat<4, 3, T, Q>::mat()



  {






  }


 template<typename T, qualifier Q>
 template<qualifier P>
 inline mat<4, 3, T, Q>::mat(mat<4, 3, T, P> const& m)



 {

   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];
   this->value[3] = m[3];

 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q>::mat(T s)



 {

   this->value[0] = col_type(s, 0, 0);
   this->value[1] = col_type(0, s, 0);
   this->value[2] = col_type(0, 0, s);
   this->value[3] = col_type(0, 0, 0);

 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q>::mat
 (
  T const& x0, T const& y0, T const& z0,
  T const& x1, T const& y1, T const& z1,
  T const& x2, T const& y2, T const& z2,
  T const& x3, T const& y3, T const& z3
 )



 {

   this->value[0] = col_type(x0, y0, z0);
   this->value[1] = col_type(x1, y1, z1);
   this->value[2] = col_type(x2, y2, z2);
   this->value[3] = col_type(x3, y3, z3);

 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)



 {

   this->value[0] = v0;
   this->value[1] = v1;
   this->value[2] = v2;
   this->value[3] = v3;

 }



 template<typename T, qualifier Q>
 template<
  typename X0, typename Y0, typename Z0,
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3>
 inline mat<4, 3, T, Q>::mat
 (
  X0 const& x0, Y0 const& y0, Z0 const& z0,
  X1 const& x1, Y1 const& y1, Z1 const& z1,
  X2 const& x2, Y2 const& y2, Z2 const& z2,
  X3 const& x3, Y3 const& y3, Z3 const& z3
 )



 {

   this->value[0] = col_type(x0, y0, z0);
   this->value[1] = col_type(x1, y1, z1);
   this->value[2] = col_type(x2, y2, z2);
   this->value[3] = col_type(x3, y3, z3);

 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2, typename V3, typename V4>
 inline mat<4, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2, vec<3, V3, Q> const& v3, vec<3, V4, Q> const& v4)



 {

   this->value[0] = col_type(v1);
   this->value[1] = col_type(v2);
   this->value[2] = col_type(v3);
   this->value[3] = col_type(v4);

 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline mat<4, 3, T, Q>::mat(mat<4, 3, U, P> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);
   this->value[3] = col_type(m[3]);

 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0);
   this->value[1] = col_type(m[1], 0);
   this->value[2] = col_type(0, 0, 1);
   this->value[3] = col_type(0);

 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q>::mat(mat<3, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);
   this->value[3] = col_type(0);

 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);
   this->value[3] = col_type(m[3]);

 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q>::mat(mat<2, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(0, 0, 1);
   this->value[3] = col_type(0);

 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0);
   this->value[1] = col_type(m[1], 0);
   this->value[2] = col_type(m[2], 1);
   this->value[3] = col_type(0);

 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(0, 0, 1);
   this->value[3] = col_type(0);

 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0);
   this->value[1] = col_type(m[1], 0);
   this->value[2] = col_type(m[2], 1);
   this->value[3] = col_type(m[3], 0);

 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);
   this->value[3] = col_type(0);

 }



 template<typename T, qualifier Q>
 inline typename mat<4, 3, T, Q>::col_type & mat<4, 3, T, Q>::operator[](typename mat<4, 3, T, Q>::length_type i)
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_mat4x3.inl", 260, "(i) >= 0 && (i) < (this->length())") : (void)0));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline typename mat<4, 3, T, Q>::col_type const& mat<4, 3, T, Q>::operator[](typename mat<4, 3, T, Q>::length_type i) const
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_mat4x3.inl", 267, "(i) >= 0 && (i) < (this->length())") : (void)0));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 3, T, Q>& mat<4, 3, T, Q>::operator=(mat<4, 3, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator+=(mat<4, 3, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator-=(mat<4, 3, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q> mat<4, 3, T, Q>::operator++(int)
 {
  mat<4, 3, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q> mat<4, 3, T, Q>::operator--(int)
 {
  mat<4, 3, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m)
 {
  return mat<4, 3, T, Q>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m, T scalar)
 {
  return mat<4, 3, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar,
   m[3] + scalar);
 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m, T scalar)
 {
  return mat<4, 3, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar,
   m[3] - scalar);
 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m, T scalar)
 {
  return mat<4, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q> operator*(T scalar, mat<4, 3, T, Q> const& m)
 {
  return mat<4, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline typename mat<4, 3, T, Q>::col_type operator*
 (
  mat<4, 3, T, Q> const& m,
  typename mat<4, 3, T, Q>::row_type const& v)
 {
  return typename mat<4, 3, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w);
 }

 template<typename T, qualifier Q>
 inline typename mat<4, 3, T, Q>::row_type operator*
 (
  typename mat<4, 3, T, Q>::col_type const& v,
  mat<4, 3, T, Q> const& m)
 {
  return typename mat<4, 3, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2],
   v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2],
   v.x * m[3][0] + v.y * m[3][1] + v.z * m[3][2]);
 }

 template<typename T, qualifier Q>
 inline mat<2, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3]);
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA02 = m1[0][2];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA12 = m1[1][2];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA22 = m1[2][2];
  T const SrcA30 = m1[3][0];
  T const SrcA31 = m1[3][1];
  T const SrcA32 = m1[3][2];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB03 = m2[0][3];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB13 = m2[1][3];
  T const SrcB20 = m2[2][0];
  T const SrcB21 = m2[2][1];
  T const SrcB22 = m2[2][2];
  T const SrcB23 = m2[2][3];

  mat<3, 3, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02 + SrcA32 * SrcB03;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12 + SrcA32 * SrcB13;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22 + SrcA30 * SrcB23;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22 + SrcA31 * SrcB23;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22 + SrcA32 * SrcB23;
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2] + m1[3][2] * m2[3][3]);
 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q> operator/(mat<4, 3, T, Q> const& m, T scalar)
 {
  return mat<4, 3, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar,
   m[3] / scalar);
 }

 template<typename T, qualifier Q>
 inline mat<4, 3, T, Q> operator/(T scalar, mat<4, 3, T, Q> const& m)
 {
  return mat<4, 3, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2],
   scalar / m[3]);
 }



 template<typename T, qualifier Q>
 inline bool operator==(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template<typename T, qualifier Q>
 inline bool operator!=(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 171 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat4x3.hpp" 2
# 6 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double4x3.hpp" 2

namespace glm
{






 typedef mat<4, 3, double, defaultp> dmat4x3;


}
# 6 "/opt/homebrew/include/glm/./ext/../detail/../mat4x3.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double4x3_precision.hpp" 1






namespace glm
{







 typedef mat<4, 3, double, lowp> lowp_dmat4x3;





 typedef mat<4, 3, double, mediump> mediump_dmat4x3;





 typedef mat<4, 3, double, highp> highp_dmat4x3;


}
# 7 "/opt/homebrew/include/glm/./ext/../detail/../mat4x3.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_float4x3.hpp" 1






namespace glm
{






 typedef mat<4, 3, float, defaultp> mat4x3;


}
# 8 "/opt/homebrew/include/glm/./ext/../detail/../mat4x3.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_float4x3_precision.hpp" 1






namespace glm
{







 typedef mat<4, 3, float, lowp> lowp_mat4x3;





 typedef mat<4, 3, float, mediump> mediump_mat4x3;





 typedef mat<4, 3, float, highp> highp_mat4x3;


}
# 9 "/opt/homebrew/include/glm/./ext/../detail/../mat4x3.hpp" 2
# 29 "/opt/homebrew/include/glm/./ext/../detail/../matrix.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/../mat4x4.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double4x4.hpp" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat4x4.hpp" 1
# 10 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat4x4.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct mat<4, 4, T, Q>
 {
  typedef vec<4, T, Q> col_type;
  typedef vec<4, T, Q> row_type;
  typedef mat<4, 4, T, Q> type;
  typedef mat<4, 4, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


  typedef length_t length_type;
                static length_type length(){return 4;}

                              col_type & operator[](length_type i) ;
                              col_type const& operator[](length_type i) const ;



                                                mat() ;
  template<qualifier P>
                mat(mat<4, 4, T, P> const& m);

                             mat(T s);
                mat(
   T const& x0, T const& y0, T const& z0, T const& w0,
   T const& x1, T const& y1, T const& z1, T const& w1,
   T const& x2, T const& y2, T const& z2, T const& w2,
   T const& x3, T const& y3, T const& z3, T const& w3);
                mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2,
   col_type const& v3);



  template<
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2,
   typename X3, typename Y3, typename Z3, typename W3,
   typename X4, typename Y4, typename Z4, typename W4>
                mat(
   X1 const& x1, Y1 const& y1, Z1 const& z1, W1 const& w1,
   X2 const& x2, Y2 const& y2, Z2 const& z2, W2 const& w2,
   X3 const& x3, Y3 const& y3, Z3 const& z3, W3 const& w3,
   X4 const& x4, Y4 const& y4, Z4 const& z4, W4 const& w4);

  template<typename V1, typename V2, typename V3, typename V4>
                mat(
   vec<4, V1, Q> const& v1,
   vec<4, V2, Q> const& v2,
   vec<4, V3, Q> const& v3,
   vec<4, V4, Q> const& v4);



  template<typename U, qualifier P>
                             mat(mat<4, 4, U, P> const& m);

                             mat(mat<2, 2, T, Q> const& x);
                             mat(mat<3, 3, T, Q> const& x);
                             mat(mat<2, 3, T, Q> const& x);
                             mat(mat<3, 2, T, Q> const& x);
                             mat(mat<2, 4, T, Q> const& x);
                             mat(mat<4, 2, T, Q> const& x);
                             mat(mat<3, 4, T, Q> const& x);
                             mat(mat<4, 3, T, Q> const& x);



  template<typename U>
                                      mat<4, 4, T, Q> & operator=(mat<4, 4, U, Q> const& m);
  template<typename U>
                                      mat<4, 4, T, Q> & operator+=(U s);
  template<typename U>
                                      mat<4, 4, T, Q> & operator+=(mat<4, 4, U, Q> const& m);
  template<typename U>
                                      mat<4, 4, T, Q> & operator-=(U s);
  template<typename U>
                                      mat<4, 4, T, Q> & operator-=(mat<4, 4, U, Q> const& m);
  template<typename U>
                                      mat<4, 4, T, Q> & operator*=(U s);
  template<typename U>
                                      mat<4, 4, T, Q> & operator*=(mat<4, 4, U, Q> const& m);
  template<typename U>
                                      mat<4, 4, T, Q> & operator/=(U s);
  template<typename U>
                                      mat<4, 4, T, Q> & operator/=(mat<4, 4, U, Q> const& m);



                                      mat<4, 4, T, Q> & operator++();
                                      mat<4, 4, T, Q> & operator--();
                              mat<4, 4, T, Q> operator++(int);
                              mat<4, 4, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
                             mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m);



 template<typename T, qualifier Q>
                             mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<4, 4, T, Q> operator+(T scalar, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<4, 4, T, Q> operator-(T scalar, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<4, 4, T, Q> operator*(T scalar, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
                             typename mat<4, 4, T, Q>::col_type operator*(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
                             typename mat<4, 4, T, Q>::row_type operator*(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<2, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<3, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
                             mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
                             mat<4, 4, T, Q> operator/(T scalar, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
                             typename mat<4, 4, T, Q>::col_type operator/(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
                             typename mat<4, 4, T, Q>::row_type operator/(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
                             mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);



 template<typename T, qualifier Q>
                             bool operator==(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
                             bool operator!=(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);
}


# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl" 1


namespace glm
{



  template<typename T, qualifier Q>
  inline mat<4, 4, T, Q>::mat()



  {






  }


 template<typename T, qualifier Q>
 template<qualifier P>
 inline mat<4, 4, T, Q>::mat(mat<4, 4, T, P> const& m)



 {

   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];
   this->value[3] = m[3];

 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q>::mat(T s)



 {

   this->value[0] = col_type(s, 0, 0, 0);
   this->value[1] = col_type(0, s, 0, 0);
   this->value[2] = col_type(0, 0, s, 0);
   this->value[3] = col_type(0, 0, 0, s);

 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q>::mat
 (
  T const& x0, T const& y0, T const& z0, T const& w0,
  T const& x1, T const& y1, T const& z1, T const& w1,
  T const& x2, T const& y2, T const& z2, T const& w2,
  T const& x3, T const& y3, T const& z3, T const& w3
 )







 {

   this->value[0] = col_type(x0, y0, z0, w0);
   this->value[1] = col_type(x1, y1, z1, w1);
   this->value[2] = col_type(x2, y2, z2, w2);
   this->value[3] = col_type(x3, y3, z3, w3);

 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)



 {

   this->value[0] = v0;
   this->value[1] = v1;
   this->value[2] = v2;
   this->value[3] = v3;

 }

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline mat<4, 4, T, Q>::mat(mat<4, 4, U, P> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);
   this->value[2] = col_type(m[2]);
   this->value[3] = col_type(m[3]);

 }



 template<typename T, qualifier Q>
 template<
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2,
  typename X3, typename Y3, typename Z3, typename W3,
  typename X4, typename Y4, typename Z4, typename W4>
 inline mat<4, 4, T, Q>::mat
 (
  X1 const& x1, Y1 const& y1, Z1 const& z1, W1 const& w1,
  X2 const& x2, Y2 const& y2, Z2 const& z2, W2 const& w2,
  X3 const& x3, Y3 const& y3, Z3 const& z3, W3 const& w3,
  X4 const& x4, Y4 const& y4, Z4 const& z4, W4 const& w4
 )



 {
  (__builtin_expect(!(std::numeric_limits<X1>::is_iec559 || std::numeric_limits<X1>::is_integer || 0), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 124, "std::numeric_limits<X1>::is_iec559 || std::numeric_limits<X1>::is_integer || 0") : (void)0);
  (__builtin_expect(!(std::numeric_limits<Y1>::is_iec559 || std::numeric_limits<Y1>::is_integer || 0), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 125, "std::numeric_limits<Y1>::is_iec559 || std::numeric_limits<Y1>::is_integer || 0") : (void)0);
  (__builtin_expect(!(std::numeric_limits<Z1>::is_iec559 || std::numeric_limits<Z1>::is_integer || 0), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 126, "std::numeric_limits<Z1>::is_iec559 || std::numeric_limits<Z1>::is_integer || 0") : (void)0);
  (__builtin_expect(!(std::numeric_limits<W1>::is_iec559 || std::numeric_limits<W1>::is_integer || 0), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 127, "std::numeric_limits<W1>::is_iec559 || std::numeric_limits<W1>::is_integer || 0") : (void)0);

  (__builtin_expect(!(std::numeric_limits<X2>::is_iec559 || std::numeric_limits<X2>::is_integer || 0), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 129, "std::numeric_limits<X2>::is_iec559 || std::numeric_limits<X2>::is_integer || 0") : (void)0);
  (__builtin_expect(!(std::numeric_limits<Y2>::is_iec559 || std::numeric_limits<Y2>::is_integer || 0), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 130, "std::numeric_limits<Y2>::is_iec559 || std::numeric_limits<Y2>::is_integer || 0") : (void)0);
  (__builtin_expect(!(std::numeric_limits<Z2>::is_iec559 || std::numeric_limits<Z2>::is_integer || 0), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 131, "std::numeric_limits<Z2>::is_iec559 || std::numeric_limits<Z2>::is_integer || 0") : (void)0);
  (__builtin_expect(!(std::numeric_limits<W2>::is_iec559 || std::numeric_limits<W2>::is_integer || 0), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 132, "std::numeric_limits<W2>::is_iec559 || std::numeric_limits<W2>::is_integer || 0") : (void)0);

  (__builtin_expect(!(std::numeric_limits<X3>::is_iec559 || std::numeric_limits<X3>::is_integer || 0), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 134, "std::numeric_limits<X3>::is_iec559 || std::numeric_limits<X3>::is_integer || 0") : (void)0);
  (__builtin_expect(!(std::numeric_limits<Y3>::is_iec559 || std::numeric_limits<Y3>::is_integer || 0), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 135, "std::numeric_limits<Y3>::is_iec559 || std::numeric_limits<Y3>::is_integer || 0") : (void)0);
  (__builtin_expect(!(std::numeric_limits<Z3>::is_iec559 || std::numeric_limits<Z3>::is_integer || 0), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 136, "std::numeric_limits<Z3>::is_iec559 || std::numeric_limits<Z3>::is_integer || 0") : (void)0);
  (__builtin_expect(!(std::numeric_limits<W3>::is_iec559 || std::numeric_limits<W3>::is_integer || 0), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 137, "std::numeric_limits<W3>::is_iec559 || std::numeric_limits<W3>::is_integer || 0") : (void)0);

  (__builtin_expect(!(std::numeric_limits<X4>::is_iec559 || std::numeric_limits<X4>::is_integer || 0), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 139, "std::numeric_limits<X4>::is_iec559 || std::numeric_limits<X4>::is_integer || 0") : (void)0);
  (__builtin_expect(!(std::numeric_limits<Y4>::is_iec559 || std::numeric_limits<Y4>::is_integer || 0), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 140, "std::numeric_limits<Y4>::is_iec559 || std::numeric_limits<Y4>::is_integer || 0") : (void)0);
  (__builtin_expect(!(std::numeric_limits<Z4>::is_iec559 || std::numeric_limits<Z4>::is_integer || 0), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 141, "std::numeric_limits<Z4>::is_iec559 || std::numeric_limits<Z4>::is_integer || 0") : (void)0);
  (__builtin_expect(!(std::numeric_limits<W4>::is_iec559 || std::numeric_limits<W4>::is_integer || 0), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 142, "std::numeric_limits<W4>::is_iec559 || std::numeric_limits<W4>::is_integer || 0") : (void)0);


   this->value[0] = col_type(x1, y1, z1, w1);
   this->value[1] = col_type(x2, y2, z2, w2);
   this->value[2] = col_type(x3, y3, z3, w3);
   this->value[3] = col_type(x4, y4, z4, w4);

 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2, typename V3, typename V4>
 inline mat<4, 4, T, Q>::mat(vec<4, V1, Q> const& v1, vec<4, V2, Q> const& v2, vec<4, V3, Q> const& v3, vec<4, V4, Q> const& v4)



 {
  (__builtin_expect(!(std::numeric_limits<V1>::is_iec559 || std::numeric_limits<V1>::is_integer || 0), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 159, "std::numeric_limits<V1>::is_iec559 || std::numeric_limits<V1>::is_integer || 0") : (void)0);
  (__builtin_expect(!(std::numeric_limits<V2>::is_iec559 || std::numeric_limits<V2>::is_integer || 0), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 160, "std::numeric_limits<V2>::is_iec559 || std::numeric_limits<V2>::is_integer || 0") : (void)0);
  (__builtin_expect(!(std::numeric_limits<V3>::is_iec559 || std::numeric_limits<V3>::is_integer || 0), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 161, "std::numeric_limits<V3>::is_iec559 || std::numeric_limits<V3>::is_integer || 0") : (void)0);
  (__builtin_expect(!(std::numeric_limits<V4>::is_iec559 || std::numeric_limits<V4>::is_integer || 0), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 162, "std::numeric_limits<V4>::is_iec559 || std::numeric_limits<V4>::is_integer || 0") : (void)0);


   this->value[0] = col_type(v1);
   this->value[1] = col_type(v2);
   this->value[2] = col_type(v3);
   this->value[3] = col_type(v4);

 }



 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0, 0);
   this->value[1] = col_type(m[1], 0, 0);
   this->value[2] = col_type(0, 0, 1, 0);
   this->value[3] = col_type(0, 0, 0, 1);

 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0);
   this->value[1] = col_type(m[1], 0);
   this->value[2] = col_type(m[2], 0);
   this->value[3] = col_type(0, 0, 0, 1);

 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0);
   this->value[1] = col_type(m[1], 0);
   this->value[2] = col_type(0, 0, 1, 0);
   this->value[3] = col_type(0, 0, 0, 1);

 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0, 0);
   this->value[1] = col_type(m[1], 0, 0);
   this->value[2] = col_type(m[2], 1, 0);
   this->value[3] = col_type(0, 0, 0, 1);

 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q>::mat(mat<2, 4, T, Q> const& m)



 {

   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = col_type(0, 0, 1, 0);
   this->value[3] = col_type(0, 0, 0, 1);

 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0, 0);
   this->value[1] = col_type(m[1], 0, 0);
   this->value[2] = col_type(0, 0, 1, 0);
   this->value[3] = col_type(0, 0, 0, 1);

 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q>::mat(mat<3, 4, T, Q> const& m)



 {

   this->value[0] = m[0];
   this->value[1] = m[1];
   this->value[2] = m[2];
   this->value[3] = col_type(0, 0, 0, 1);

 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0], 0);
   this->value[1] = col_type(m[1], 0);
   this->value[2] = col_type(m[2], 0);
   this->value[3] = col_type(m[3], 1);

 }



 template<typename T, qualifier Q>
 inline typename mat<4, 4, T, Q>::col_type & mat<4, 4, T, Q>::operator[](typename mat<4, 4, T, Q>::length_type i)
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 291, "(i) >= 0 && (i) < (this->length())") : (void)0));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline typename mat<4, 4, T, Q>::col_type const& mat<4, 4, T, Q>::operator[](typename mat<4, 4, T, Q>::length_type i) const
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_mat4x4.inl", 298, "(i) >= 0 && (i) < (this->length())") : (void)0));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator=(mat<4, 4, U, Q> const& m)
 {


  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator+=(mat<4, 4, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator-=(mat<4, 4, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator*=(mat<4, 4, U, Q> const& m)
 {
  return (*this = *this * m);
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator/=(mat<4, 4, U, Q> const& m)
 {
  return *this *= inverse(m);
 }



 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> mat<4, 4, T, Q>::operator++(int)
 {
  mat<4, 4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> mat<4, 4, T, Q>::operator--(int)
 {
  mat<4, 4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m, T scalar)
 {
  return mat<4, 4, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar,
   m[3] + scalar);
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> operator+(T scalar, mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar,
   m[3] + scalar);
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return mat<4, 4, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m, T scalar)
 {
  return mat<4, 4, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar,
   m[3] - scalar);
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> operator-(T scalar, mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   scalar - m[0],
   scalar - m[1],
   scalar - m[2],
   scalar - m[3]);
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return mat<4, 4, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m, T scalar)
 {
  return mat<4, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> operator*(T scalar, mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline typename mat<4, 4, T, Q>::col_type operator*
 (
  mat<4, 4, T, Q> const& m,
  typename mat<4, 4, T, Q>::row_type const& v
 )
 {
# 561 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl"
  typename mat<4, 4, T, Q>::col_type const Mov0(v[0]);
  typename mat<4, 4, T, Q>::col_type const Mov1(v[1]);
  typename mat<4, 4, T, Q>::col_type const Mul0 = m[0] * Mov0;
  typename mat<4, 4, T, Q>::col_type const Mul1 = m[1] * Mov1;
  typename mat<4, 4, T, Q>::col_type const Add0 = Mul0 + Mul1;
  typename mat<4, 4, T, Q>::col_type const Mov2(v[2]);
  typename mat<4, 4, T, Q>::col_type const Mov3(v[3]);
  typename mat<4, 4, T, Q>::col_type const Mul2 = m[2] * Mov2;
  typename mat<4, 4, T, Q>::col_type const Mul3 = m[3] * Mov3;
  typename mat<4, 4, T, Q>::col_type const Add1 = Mul2 + Mul3;
  typename mat<4, 4, T, Q>::col_type const Add2 = Add0 + Add1;
  return Add2;
# 581 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat4x4.inl"
 }

 template<typename T, qualifier Q>
 inline typename mat<4, 4, T, Q>::row_type operator*
 (
  typename mat<4, 4, T, Q>::col_type const& v,
  mat<4, 4, T, Q> const& m
 )
 {
  return typename mat<4, 4, T, Q>::row_type(
   m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2] + m[0][3] * v[3],
   m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2] + m[1][3] * v[3],
   m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] + m[2][3] * v[3],
   m[3][0] * v[0] + m[3][1] * v[1] + m[3][2] * v[2] + m[3][3] * v[3]);
 }

 template<typename T, qualifier Q>
 inline mat<2, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);
 }

 template<typename T, qualifier Q>
 inline mat<3, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  typename mat<4, 4, T, Q>::col_type const SrcA0 = m1[0];
  typename mat<4, 4, T, Q>::col_type const SrcA1 = m1[1];
  typename mat<4, 4, T, Q>::col_type const SrcA2 = m1[2];
  typename mat<4, 4, T, Q>::col_type const SrcA3 = m1[3];

  typename mat<4, 4, T, Q>::col_type const SrcB0 = m2[0];
  typename mat<4, 4, T, Q>::col_type const SrcB1 = m2[1];
  typename mat<4, 4, T, Q>::col_type const SrcB2 = m2[2];
  typename mat<4, 4, T, Q>::col_type const SrcB3 = m2[3];

  mat<4, 4, T, Q> Result;
  Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];
  Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];
  Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];
  Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m, T scalar)
 {
  return mat<4, 4, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar,
   m[3] / scalar);
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> operator/(T scalar, mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2],
   scalar / m[3]);
 }

 template<typename T, qualifier Q>
 inline typename mat<4, 4, T, Q>::col_type operator/(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v)
 {
  return inverse(m) * v;
 }

 template<typename T, qualifier Q>
 inline typename mat<4, 4, T, Q>::row_type operator/(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m)
 {
  return v * inverse(m);
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  mat<4, 4, T, Q> m1_copy(m1);
  return m1_copy /= m2;
 }



 template<typename T, qualifier Q>
 inline bool operator==(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template<typename T, qualifier Q>
 inline bool operator!=(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 189 "/opt/homebrew/include/glm/./ext/../detail/.././ext/../detail/type_mat4x4.hpp" 2
# 6 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double4x4.hpp" 2

namespace glm
{






 typedef mat<4, 4, double, defaultp> dmat4x4;




 typedef mat<4, 4, double, defaultp> dmat4;


}
# 6 "/opt/homebrew/include/glm/./ext/../detail/../mat4x4.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_double4x4_precision.hpp" 1






namespace glm
{







 typedef mat<4, 4, double, lowp> lowp_dmat4;





 typedef mat<4, 4, double, mediump> mediump_dmat4;





 typedef mat<4, 4, double, highp> highp_dmat4;





 typedef mat<4, 4, double, lowp> lowp_dmat4x4;





 typedef mat<4, 4, double, mediump> mediump_dmat4x4;





 typedef mat<4, 4, double, highp> highp_dmat4x4;


}
# 7 "/opt/homebrew/include/glm/./ext/../detail/../mat4x4.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_float4x4.hpp" 1






namespace glm
{






 typedef mat<4, 4, float, defaultp> mat4x4;




 typedef mat<4, 4, float, defaultp> mat4;


}
# 8 "/opt/homebrew/include/glm/./ext/../detail/../mat4x4.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/.././ext/matrix_float4x4_precision.hpp" 1






namespace glm
{







 typedef mat<4, 4, float, lowp> lowp_mat4;





 typedef mat<4, 4, float, mediump> mediump_mat4;





 typedef mat<4, 4, float, highp> highp_mat4;





 typedef mat<4, 4, float, lowp> lowp_mat4x4;





 typedef mat<4, 4, float, mediump> mediump_mat4x4;





 typedef mat<4, 4, float, highp> highp_mat4x4;


}
# 9 "/opt/homebrew/include/glm/./ext/../detail/../mat4x4.hpp" 2
# 30 "/opt/homebrew/include/glm/./ext/../detail/../matrix.hpp" 2

namespace glm {
namespace detail
{
 template<length_t C, length_t R, typename T, qualifier Q>
 struct outerProduct_trait{};

 template<typename T, qualifier Q>
 struct outerProduct_trait<2, 2, T, Q>
 {
  typedef mat<2, 2, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<2, 3, T, Q>
 {
  typedef mat<3, 2, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<2, 4, T, Q>
 {
  typedef mat<4, 2, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<3, 2, T, Q>
 {
  typedef mat<2, 3, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<3, 3, T, Q>
 {
  typedef mat<3, 3, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<3, 4, T, Q>
 {
  typedef mat<4, 3, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<4, 2, T, Q>
 {
  typedef mat<2, 4, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<4, 3, T, Q>
 {
  typedef mat<3, 4, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<4, 4, T, Q>
 {
  typedef mat<4, 4, T, Q> type;
 };
}
# 105 "/opt/homebrew/include/glm/./ext/../detail/../matrix.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
               mat<C, R, T, Q> matrixCompMult(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y);
# 119 "/opt/homebrew/include/glm/./ext/../detail/../matrix.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
               typename detail::outerProduct_trait<C, R, T, Q>::type outerProduct(vec<C, T, Q> const& c, vec<R, T, Q> const& r);
# 131 "/opt/homebrew/include/glm/./ext/../detail/../matrix.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
               typename mat<C, R, T, Q>::transpose_type transpose(mat<C, R, T, Q> const& x);
# 143 "/opt/homebrew/include/glm/./ext/../detail/../matrix.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
               T determinant(mat<C, R, T, Q> const& m);
# 155 "/opt/homebrew/include/glm/./ext/../detail/../matrix.hpp"
 template<length_t C, length_t R, typename T, qualifier Q>
               mat<C, R, T, Q> inverse(mat<C, R, T, Q> const& m);


}

# 1 "/opt/homebrew/include/glm/./ext/../detail/../detail/func_matrix.inl" 1
# 1 "/opt/homebrew/include/glm/./ext/../detail/../detail/../geometric.hpp" 1
# 17 "/opt/homebrew/include/glm/./ext/../detail/../detail/../geometric.hpp"
namespace glm
{
# 29 "/opt/homebrew/include/glm/./ext/../detail/../detail/../geometric.hpp"
 template<length_t L, typename T, qualifier Q>
               T length(vec<L, T, Q> const& x);
# 39 "/opt/homebrew/include/glm/./ext/../detail/../detail/../geometric.hpp"
 template<length_t L, typename T, qualifier Q>
               T distance(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1);
# 49 "/opt/homebrew/include/glm/./ext/../detail/../detail/../geometric.hpp"
 template<length_t L, typename T, qualifier Q>
                             T dot(vec<L, T, Q> const& x, vec<L, T, Q> const& y);







 template<typename T, qualifier Q>
                             vec<3, T, Q> cross(vec<3, T, Q> const& x, vec<3, T, Q> const& y);
# 69 "/opt/homebrew/include/glm/./ext/../detail/../detail/../geometric.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> normalize(vec<L, T, Q> const& x);
# 79 "/opt/homebrew/include/glm/./ext/../detail/../detail/../geometric.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> faceforward(
  vec<L, T, Q> const& N,
  vec<L, T, Q> const& I,
  vec<L, T, Q> const& Nref);
# 93 "/opt/homebrew/include/glm/./ext/../detail/../detail/../geometric.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> reflect(
  vec<L, T, Q> const& I,
  vec<L, T, Q> const& N);
# 107 "/opt/homebrew/include/glm/./ext/../detail/../detail/../geometric.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> refract(
  vec<L, T, Q> const& I,
  vec<L, T, Q> const& N,
  T eta);


}

# 1 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/func_geometric.inl" 1
# 1 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../exponential.hpp" 1
# 17 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../exponential.hpp"
# 1 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/type_vec1.hpp" 1
# 14 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/type_vec1.hpp"
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<1, T, Q>
 {


  typedef T value_type;
  typedef vec<1, T, Q> type;
  typedef vec<1, bool, Q> bool_type;








#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
#pragma clang diagnostic ignored "-Wnested-anon-types"
# 66 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/type_vec1.hpp"
   union {T x, r, s;};
# 76 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/type_vec1.hpp"
#pragma clang diagnostic pop
# 87 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/type_vec1.hpp"
  typedef length_t length_type;
                static length_type length(){return 1;}

                              T & operator[](length_type i);
                              T const& operator[](length_type i) const;



                                                vec() ;
                                        vec(vec const& v) ;
  template<qualifier P>
                vec(vec<1, T, P> const& v);



                explicit vec(T scalar);




  template<typename U, qualifier P>
                             vec(vec<2, U, P> const& v);

  template<typename U, qualifier P>
                             vec(vec<3, U, P> const& v);

  template<typename U, qualifier P>
                             vec(vec<4, U, P> const& v);


  template<typename U, qualifier P>
                             vec(vec<1, U, P> const& v);
# 132 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/type_vec1.hpp"
                                        vec<1, T, Q> & operator=(vec const& v) ;

  template<typename U>
                                      vec<1, T, Q> & operator=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<1, T, Q> & operator+=(U scalar);
  template<typename U>
                                      vec<1, T, Q> & operator+=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<1, T, Q> & operator-=(U scalar);
  template<typename U>
                                      vec<1, T, Q> & operator-=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<1, T, Q> & operator*=(U scalar);
  template<typename U>
                                      vec<1, T, Q> & operator*=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<1, T, Q> & operator/=(U scalar);
  template<typename U>
                                      vec<1, T, Q> & operator/=(vec<1, U, Q> const& v);



                                      vec<1, T, Q> & operator++();
                                      vec<1, T, Q> & operator--();
                              vec<1, T, Q> operator++(int);
                              vec<1, T, Q> operator--(int);



  template<typename U>
                                      vec<1, T, Q> & operator%=(U scalar);
  template<typename U>
                                      vec<1, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<1, T, Q> & operator&=(U scalar);
  template<typename U>
                                      vec<1, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<1, T, Q> & operator|=(U scalar);
  template<typename U>
                                      vec<1, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<1, T, Q> & operator^=(U scalar);
  template<typename U>
                                      vec<1, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<1, T, Q> & operator<<=(U scalar);
  template<typename U>
                                      vec<1, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
                                      vec<1, T, Q> & operator>>=(U scalar);
  template<typename U>
                                      vec<1, T, Q> & operator>>=(vec<1, U, Q> const& v);
 };



 template<typename T, qualifier Q>
                             vec<1, T, Q> operator+(vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator-(vec<1, T, Q> const& v);



 template<typename T, qualifier Q>
                             vec<1, T, Q> operator+(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator+(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator+(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator-(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator-(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator-(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator*(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator*(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator*(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator/(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator/(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator/(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator%(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator%(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator%(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator&(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator&(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator&(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator|(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator|(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator|(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator^(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator^(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator^(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator<<(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator<<(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator<<(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator>>(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator>>(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator>>(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             vec<1, T, Q> operator~(vec<1, T, Q> const& v);



 template<typename T, qualifier Q>
                             bool operator==(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
                             bool operator!=(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<qualifier Q>
                             vec<1, bool, Q> operator&&(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2);

 template<qualifier Q>
                             vec<1, bool, Q> operator||(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2);
}


# 1 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/type_vec1.inl" 1




namespace glm
{



  template<typename T, qualifier Q>
  inline vec<1, T, Q>::vec()



  {}



  template<typename T, qualifier Q>
  inline vec<1, T, Q>::vec(vec<1, T, Q> const& v)
   : x(v.x)
  {}


 template<typename T, qualifier Q>
 template<qualifier P>
 inline vec<1, T, Q>::vec(vec<1, T, P> const& v)
  : x(v.x)
 {}



 template<typename T, qualifier Q>
 inline vec<1, T, Q>::vec(T scalar)
  : x(scalar)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline vec<1, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline vec<1, T, Q>::vec(vec<2, U, P> const& v)
  : x(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline vec<1, T, Q>::vec(vec<3, U, P> const& v)
  : x(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline vec<1, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
 {}



 template<typename T, qualifier Q>
 inline T & vec<1, T, Q>::operator[](typename vec<1, T, Q>::length_type)
 {
  return x;
 }

 template<typename T, qualifier Q>
 inline T const& vec<1, T, Q>::operator[](typename vec<1, T, Q>::length_type) const
 {
  return x;
 }




  template<typename T, qualifier Q>
  inline vec<1, T, Q> & vec<1, T, Q>::operator=(vec<1, T, Q> const& v)
  {
   this->x = v.x;
   return *this;
  }


 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator=(vec<1, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator/=(U scalar)
 {
  this->x /= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  return *this;
 }



 template<typename T, qualifier Q>
 inline vec<1, T, Q> & vec<1, T, Q>::operator++()
 {
  ++this->x;
  return *this;
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> & vec<1, T, Q>::operator--()
 {
  --this->x;
  return *this;
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> vec<1, T, Q>::operator++(int)
 {
  vec<1, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> vec<1, T, Q>::operator--(int)
 {
  vec<1, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator%=(U scalar)
 {
  this->x %= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  this->x %= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator&=(U scalar)
 {
  this->x &= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  this->x &= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator|=(U scalar)
 {
  this->x |= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  this->x |= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator^=(U scalar)
 {
  this->x ^= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  this->x ^= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator<<=(U scalar)
 {
  this->x <<= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline vec<1, T, Q> & vec<1, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  return *this;
 }



 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator+(vec<1, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator-(vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   -v.x);
 }



 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator+(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x + scalar);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator+(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar + v.x);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator+(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x + v2.x);
 }


 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator-(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x - scalar);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator-(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar - v.x);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator-(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x - v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator*(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x * scalar);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator*(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar * v.x);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator*(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x * v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator/(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x / scalar);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator/(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar / v.x);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator/(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x / v2.x);
 }



 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator%(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x % scalar);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator%(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar % v.x);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator%(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x % v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator&(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x & scalar);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator&(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar & v.x);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator&(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x & v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator|(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x | scalar);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator|(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar | v.x);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator|(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x | v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator^(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x ^ scalar);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator^(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar ^ v.x);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator^(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x ^ v2.x);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator<<(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   static_cast<T>(v.x << scalar));
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator<<(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   static_cast<T>(scalar << v.x));
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator<<(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   static_cast<T>(v1.x << v2.x));
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator>>(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   static_cast<T>(v.x >> scalar));
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator>>(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   static_cast<T>(scalar >> v.x));
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator>>(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   static_cast<T>(v1.x >> v2.x));
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> operator~(vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   ~v.x);
 }



 template<typename T, qualifier Q>
 inline bool operator==(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x);
 }

 template<typename T, qualifier Q>
 inline bool operator!=(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return !(v1 == v2);
 }

 template<qualifier Q>
 inline vec<1, bool, Q> operator&&(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2)
 {
  return vec<1, bool, Q>(v1.x && v2.x);
 }

 template<qualifier Q>
 inline vec<1, bool, Q> operator||(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2)
 {
  return vec<1, bool, Q>(v1.x || v2.x);
 }
}
# 308 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/type_vec1.hpp" 2
# 18 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../exponential.hpp" 2





namespace glm
{
# 35 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../exponential.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> pow(vec<L, T, Q> const& base, vec<L, T, Q> const& exponent);
# 46 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../exponential.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> exp(vec<L, T, Q> const& v);
# 59 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../exponential.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> log(vec<L, T, Q> const& v);
# 70 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../exponential.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> exp2(vec<L, T, Q> const& v);
# 82 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../exponential.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> log2(vec<L, T, Q> const& v);
# 93 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../exponential.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> sqrt(vec<L, T, Q> const& v);
# 104 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../exponential.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> inversesqrt(vec<L, T, Q> const& v);


}

# 1 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/func_exponential.inl" 1



# 1 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp" 1
# 23 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp"
# 1 "/opt/homebrew/include/glm/detail/setup.hpp" 1
# 24 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp" 2

namespace glm
{
# 37 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp"
 template<length_t L, typename T, qualifier Q>
                             vec<L, bool, Q> lessThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 47 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp"
 template<length_t L, typename T, qualifier Q>
                             vec<L, bool, Q> lessThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 57 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp"
 template<length_t L, typename T, qualifier Q>
                             vec<L, bool, Q> greaterThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 67 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp"
 template<length_t L, typename T, qualifier Q>
                             vec<L, bool, Q> greaterThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 77 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp"
 template<length_t L, typename T, qualifier Q>
                             vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 87 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp"
 template<length_t L, typename T, qualifier Q>
                             vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);







 template<length_t L, qualifier Q>
                             bool any(vec<L, bool, Q> const& v);







 template<length_t L, qualifier Q>
                             bool all(vec<L, bool, Q> const& v);
# 115 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp"
 template<length_t L, qualifier Q>
                             vec<L, bool, Q> not_(vec<L, bool, Q> const& v);


}

# 1 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/../detail/func_vector_relational.inl" 1
namespace glm
{
 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> lessThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] < y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> lessThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] <= y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> greaterThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] > y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> greaterThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] >= y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] == y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] != y[i];
  return Result;
 }

 template<length_t L, qualifier Q>
 inline bool any(vec<L, bool, Q> const& v)
 {
  bool Result = false;
  for(length_t i = 0; i < L; ++i)
   Result = Result || v[i];
  return Result;
 }

 template<length_t L, qualifier Q>
 inline bool all(vec<L, bool, Q> const& v)
 {
  bool Result = true;
  for(length_t i = 0; i < L; ++i)
   Result = Result && v[i];
  return Result;
 }

 template<length_t L, qualifier Q>
 inline vec<L, bool, Q> not_(vec<L, bool, Q> const& v)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = !v[i];
  return Result;
 }
}
# 122 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/../vector_relational.hpp" 2
# 5 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/func_exponential.inl" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/_vectorize.hpp" 1


namespace glm{
namespace detail
{
 template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename R, typename T, qualifier Q>
 struct functor1{};

 template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
 struct functor1<vec, 1, R, T, Q>
 {
  inline static vec<1, R, Q> call(R (*Func) (T x), vec<1, T, Q> const& v)
  {
   return vec<1, R, Q>(Func(v.x));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
 struct functor1<vec, 2, R, T, Q>
 {
  inline static vec<2, R, Q> call(R (*Func) (T x), vec<2, T, Q> const& v)
  {
   return vec<2, R, Q>(Func(v.x), Func(v.y));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
 struct functor1<vec, 3, R, T, Q>
 {
  inline static vec<3, R, Q> call(R (*Func) (T x), vec<3, T, Q> const& v)
  {
   return vec<3, R, Q>(Func(v.x), Func(v.y), Func(v.z));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
 struct functor1<vec, 4, R, T, Q>
 {
  inline static vec<4, R, Q> call(R (*Func) (T x), vec<4, T, Q> const& v)
  {
   return vec<4, R, Q>(Func(v.x), Func(v.y), Func(v.z), Func(v.w));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename T, qualifier Q>
 struct functor2{};

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2<vec, 1, T, Q>
 {
  inline static vec<1, T, Q> call(T (*Func) (T x, T y), vec<1, T, Q> const& a, vec<1, T, Q> const& b)
  {
   return vec<1, T, Q>(Func(a.x, b.x));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2<vec, 2, T, Q>
 {
  inline static vec<2, T, Q> call(T (*Func) (T x, T y), vec<2, T, Q> const& a, vec<2, T, Q> const& b)
  {
   return vec<2, T, Q>(Func(a.x, b.x), Func(a.y, b.y));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2<vec, 3, T, Q>
 {
  inline static vec<3, T, Q> call(T (*Func) (T x, T y), vec<3, T, Q> const& a, vec<3, T, Q> const& b)
  {
   return vec<3, T, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2<vec, 4, T, Q>
 {
  inline static vec<4, T, Q> call(T (*Func) (T x, T y), vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename T, qualifier Q>
 struct functor2_vec_sca{};

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2_vec_sca<vec, 1, T, Q>
 {
  inline static vec<1, T, Q> call(T (*Func) (T x, T y), vec<1, T, Q> const& a, T b)
  {
   return vec<1, T, Q>(Func(a.x, b));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2_vec_sca<vec, 2, T, Q>
 {
  inline static vec<2, T, Q> call(T (*Func) (T x, T y), vec<2, T, Q> const& a, T b)
  {
   return vec<2, T, Q>(Func(a.x, b), Func(a.y, b));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2_vec_sca<vec, 3, T, Q>
 {
  inline static vec<3, T, Q> call(T (*Func) (T x, T y), vec<3, T, Q> const& a, T b)
  {
   return vec<3, T, Q>(Func(a.x, b), Func(a.y, b), Func(a.z, b));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2_vec_sca<vec, 4, T, Q>
 {
  inline static vec<4, T, Q> call(T (*Func) (T x, T y), vec<4, T, Q> const& a, T b)
  {
   return vec<4, T, Q>(Func(a.x, b), Func(a.y, b), Func(a.z, b), Func(a.w, b));
  }
 };

 template<length_t L, typename T, qualifier Q>
 struct functor2_vec_int {};

 template<typename T, qualifier Q>
 struct functor2_vec_int<1, T, Q>
 {
  inline static vec<1, int, Q> call(int (*Func) (T x, int y), vec<1, T, Q> const& a, vec<1, int, Q> const& b)
  {
   return vec<1, int, Q>(Func(a.x, b.x));
  }
 };

 template<typename T, qualifier Q>
 struct functor2_vec_int<2, T, Q>
 {
  inline static vec<2, int, Q> call(int (*Func) (T x, int y), vec<2, T, Q> const& a, vec<2, int, Q> const& b)
  {
   return vec<2, int, Q>(Func(a.x, b.x), Func(a.y, b.y));
  }
 };

 template<typename T, qualifier Q>
 struct functor2_vec_int<3, T, Q>
 {
  inline static vec<3, int, Q> call(int (*Func) (T x, int y), vec<3, T, Q> const& a, vec<3, int, Q> const& b)
  {
   return vec<3, int, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
  }
 };

 template<typename T, qualifier Q>
 struct functor2_vec_int<4, T, Q>
 {
  inline static vec<4, int, Q> call(int (*Func) (T x, int y), vec<4, T, Q> const& a, vec<4, int, Q> const& b)
  {
   return vec<4, int, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
  }
 };
}
}
# 6 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/func_exponential.inl" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 9 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/func_exponential.inl" 2

namespace glm{
namespace detail
{

  using std::log2;
# 23 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/func_exponential.inl"
 template<length_t L, typename T, qualifier Q, bool isFloat, bool Aligned>
 struct compute_log2
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v)
  {
   (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_exponential.inl", 28, "std::numeric_limits<T>::is_iec559 || 0") : (void)0);

   return detail::functor1<vec, L, T, T, Q>::call(log2, v);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_sqrt
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(std::sqrt, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_inversesqrt
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return static_cast<T>(1) / sqrt(x);
  }
 };

 template<length_t L, bool Aligned>
 struct compute_inversesqrt<L, float, lowp, Aligned>
 {
  inline static vec<L, float, lowp> call(vec<L, float, lowp> const& x)
  {
   vec<L, float, lowp> tmp(x);
   vec<L, float, lowp> xhalf(tmp * 0.5f);
   vec<L, uint, lowp>* p = reinterpret_cast<vec<L, uint, lowp>*>(const_cast<vec<L, float, lowp>*>(&x));
   vec<L, uint, lowp> i = vec<L, uint, lowp>(0x5f375a86) - (*p >> vec<L, uint, lowp>(1));
   vec<L, float, lowp>* ptmp = reinterpret_cast<vec<L, float, lowp>*>(&i);
   tmp = *ptmp;
   tmp = tmp * (1.5f - xhalf * tmp * tmp);
   return tmp;
  }
 };
}


 using std::pow;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> pow(vec<L, T, Q> const& base, vec<L, T, Q> const& exponent)
 {
  return detail::functor2<vec, L, T, Q>::call(pow, base, exponent);
 }


 using std::exp;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> exp(vec<L, T, Q> const& x)
 {
  return detail::functor1<vec, L, T, T, Q>::call(exp, x);
 }


 using std::log;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> log(vec<L, T, Q> const& x)
 {
  return detail::functor1<vec, L, T, T, Q>::call(log, x);
 }


    using std::exp2;
# 106 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/func_exponential.inl"
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> exp2(vec<L, T, Q> const& x)
 {
  return detail::functor1<vec, L, T, T, Q>::call(exp2, x);
 }


 template<typename genType>
 inline genType log2(genType x)
 {
  return log2(vec<1, genType>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> log2(vec<L, T, Q> const& x)
 {
  return detail::compute_log2<L, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x);
 }


 using std::sqrt;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> sqrt(vec<L, T, Q> const& x)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_exponential.inl", 130, "std::numeric_limits<T>::is_iec559 || 0") : (void)0);
  return detail::compute_sqrt<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }


 template<typename genType>
 inline genType inversesqrt(genType x)
 {
  return static_cast<genType>(1) / sqrt(x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> inversesqrt(vec<L, T, Q> const& x)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_exponential.inl", 144, "std::numeric_limits<T>::is_iec559 || 0") : (void)0);
  return detail::compute_inversesqrt<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }
}
# 111 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../exponential.hpp" 2
# 2 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/func_geometric.inl" 2
# 1 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp" 1
# 18 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
# 1 "/opt/homebrew/include/glm/detail/_fixes.hpp" 1
# 19 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp" 2

namespace glm
{
# 31 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<typename genType>
                             genType abs(genType x);
# 42 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
                             vec<L, T, Q> abs(vec<L, T, Q> const& x);
# 53 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
                             vec<L, T, Q> sign(vec<L, T, Q> const& x);
# 64 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> floor(vec<L, T, Q> const& x);
# 76 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> trunc(vec<L, T, Q> const& x);
# 91 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> round(vec<L, T, Q> const& x);
# 105 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> roundEven(vec<L, T, Q> const& x);
# 117 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> ceil(vec<L, T, Q> const& x);







 template<typename genType>
               genType fract(genType x);
# 137 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> fract(vec<L, T, Q> const& x);

 template<typename genType>
               genType mod(genType x, genType y);

 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> mod(vec<L, T, Q> const& x, T y);
# 155 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> mod(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 167 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<typename genType>
               genType modf(genType x, genType& i);







 template<typename genType>
                             genType min(genType x, genType y);
# 187 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
                             vec<L, T, Q> min(vec<L, T, Q> const& x, T y);
# 198 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
                             vec<L, T, Q> min(vec<L, T, Q> const& x, vec<L, T, Q> const& y);







 template<typename genType>
                             genType max(genType x, genType y);
# 218 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
                             vec<L, T, Q> max(vec<L, T, Q> const& x, T y);
# 229 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
                             vec<L, T, Q> max(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 239 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<typename genType>
                             genType clamp(genType x, genType minVal, genType maxVal);
# 251 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
                             vec<L, T, Q> clamp(vec<L, T, Q> const& x, T minVal, T maxVal);
# 263 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
                             vec<L, T, Q> clamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal);
# 308 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<typename genTypeT, typename genTypeU>
                             genTypeT mix(genTypeT x, genTypeT y, genTypeU a);

 template<length_t L, typename T, typename U, qualifier Q>
                             vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a);

 template<length_t L, typename T, typename U, qualifier Q>
                             vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U a);





 template<typename genType>
               genType step(genType edge, genType x);
# 332 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> step(T edge, vec<L, T, Q> const& x);
# 343 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> step(vec<L, T, Q> const& edge, vec<L, T, Q> const& x);
# 360 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<typename genType>
               genType smoothstep(genType edge0, genType edge1, genType x);

 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> smoothstep(T edge0, T edge1, vec<L, T, Q> const& x);

 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> smoothstep(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x);
# 383 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, bool, Q> isnan(vec<L, T, Q> const& x);
# 398 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, bool, Q> isinf(vec<L, T, Q> const& x);







               int floatBitsToInt(float v);
# 418 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, qualifier Q>
               vec<L, int, Q> floatBitsToInt(vec<L, float, Q> const& v);







               uint floatBitsToUint(float v);
# 438 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, qualifier Q>
               vec<L, uint, Q> floatBitsToUint(vec<L, float, Q> const& v);
# 449 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
               float intBitsToFloat(int v);
# 462 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, qualifier Q>
               vec<L, float, Q> intBitsToFloat(vec<L, int, Q> const& v);
# 473 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
               float uintBitsToFloat(uint v);
# 486 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<length_t L, qualifier Q>
               vec<L, float, Q> uintBitsToFloat(vec<L, uint, Q> const& v);







 template<typename genType>
               genType fma(genType const& a, genType const& b, genType const& c);
# 512 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<typename genType>
               genType frexp(genType x, int& exp);

 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> frexp(vec<L, T, Q> const& v, vec<L, int, Q>& exp);
# 529 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp"
 template<typename genType>
               genType ldexp(genType const& x, int const& exp);

 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> ldexp(vec<L, T, Q> const& v, vec<L, int, Q> const& exp);


}

# 1 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/func_common.inl" 1




# 1 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/compute_common.hpp" 1


# 1 "/opt/homebrew/include/glm/detail/setup.hpp" 1
# 4 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/compute_common.hpp" 2


namespace glm{
namespace detail
{
 template<typename genFIType, bool >
 struct compute_abs
 {};

 template<typename genFIType>
 struct compute_abs<genFIType, true>
 {
  inline static genFIType call(genFIType x)
  {
   (__builtin_expect(!(std::numeric_limits<genFIType>::is_iec559 || 0 || std::numeric_limits<genFIType>::is_signed), 0) ? __assert_rtn(__func__, "compute_common.hpp", 20, "std::numeric_limits<genFIType>::is_iec559 || 0 || std::numeric_limits<genFIType>::is_signed") : (void)0);



   return x >= genFIType(0) ? x : -x;

  }
 };
# 38 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/compute_common.hpp"
 template<typename genFIType>
 struct compute_abs<genFIType, false>
 {
  inline static genFIType call(genFIType x)
  {
   (__builtin_expect(!((!std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer)), 0) ? __assert_rtn(__func__, "compute_common.hpp", 45, "(!std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer)") : (void)0);


   return x;
  }
 };
}
}
# 6 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/func_common.inl" 2







namespace glm
{

 template<typename genType>
 inline genType min(genType x, genType y)
 {
  (__builtin_expect(!(std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer), 0) ? __assert_rtn(__func__, "func_common.inl", 19, "std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer") : (void)0);
  return (y < x) ? y : x;
 }


 template<typename genType>
 inline genType max(genType x, genType y)
 {
  (__builtin_expect(!(std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer), 0) ? __assert_rtn(__func__, "func_common.inl", 27, "std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer") : (void)0);

  return (x < y) ? y : x;
 }


 template<>
 inline int abs(int x)
 {
  int const y = x >> (sizeof(int) * 8 - 1);
  return (x ^ y) - y;
 }



  using ::std::round;
# 55 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/func_common.inl"
  using ::std::trunc;
# 66 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/func_common.inl"
}

namespace glm{
namespace detail
{
 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_abs_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(abs, x);
  }
 };

 template<length_t L, typename T, typename U, qualifier Q, bool Aligned>
 struct compute_mix_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a)
  {
   (__builtin_expect(!(std::numeric_limits<U>::is_iec559 || 0 || 0), 0) ? __assert_rtn(__func__, "func_common.inl", 85, "std::numeric_limits<U>::is_iec559 || 0 || 0") : (void)0);

   return vec<L, T, Q>(vec<L, U, Q>(x) * (static_cast<U>(1) - a) + vec<L, U, Q>(y) * a);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_mix_vector<L, T, bool, Q, Aligned>
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, bool, Q> const& a)
  {
   vec<L, T, Q> Result(0);
   for(length_t i = 0; i < x.length(); ++i)
    Result[i] = a[i] ? y[i] : x[i];
   return Result;
  }
 };

 template<length_t L, typename T, typename U, qualifier Q, bool Aligned>
 struct compute_mix_scalar
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U const& a)
  {
   (__builtin_expect(!(std::numeric_limits<U>::is_iec559 || 0 || 0), 0) ? __assert_rtn(__func__, "func_common.inl", 108, "std::numeric_limits<U>::is_iec559 || 0 || 0") : (void)0);

   return vec<L, T, Q>(vec<L, U, Q>(x) * (static_cast<U>(1) - a) + vec<L, U, Q>(y) * a);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_mix_scalar<L, T, bool, Q, Aligned>
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, bool const& a)
  {
   return a ? y : x;
  }
 };

 template<typename T, typename U>
 struct compute_mix
 {
  inline static T call(T const& x, T const& y, U const& a)
  {
   (__builtin_expect(!(std::numeric_limits<U>::is_iec559 || 0 || 0), 0) ? __assert_rtn(__func__, "func_common.inl", 128, "std::numeric_limits<U>::is_iec559 || 0 || 0") : (void)0);

   return static_cast<T>(static_cast<U>(x) * (static_cast<U>(1) - a) + static_cast<U>(y) * a);
  }
 };

 template<typename T>
 struct compute_mix<T, bool>
 {
  inline static T call(T const& x, T const& y, bool const& a)
  {
   return a ? y : x;
  }
 };

 template<length_t L, typename T, qualifier Q, bool isFloat, bool Aligned>
 struct compute_sign
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return vec<L, T, Q>(glm::lessThan(vec<L, T, Q>(0), x)) - vec<L, T, Q>(glm::lessThan(x, vec<L, T, Q>(0)));
  }
 };
# 166 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/func_common.inl"
 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_floor
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(std::floor, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_ceil
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(std::ceil, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_fract
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return x - floor(x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_trunc
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(trunc, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_round
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(round, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_mod
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
  {
   (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_common.inl", 216, "std::numeric_limits<T>::is_iec559 || 0") : (void)0);
   return a - b * floor(a / b);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_min_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
  {
   return detail::functor2<vec, L, T, Q>::call(min, x, y);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_max_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
  {
   return detail::functor2<vec, L, T, Q>::call(max, x, y);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_clamp_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal)
  {
   return min(max(x, minVal), maxVal);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_step_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& edge, vec<L, T, Q> const& x)
  {
   return mix(vec<L, T, Q>(1), vec<L, T, Q>(0), glm::lessThan(x, edge));
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_smoothstep_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x)
  {
   (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0 || 0), 0) ? __assert_rtn(__func__, "func_common.inl", 262, "std::numeric_limits<T>::is_iec559 || 0 || 0") : (void)0);
   vec<L, T, Q> const tmp(clamp((x - edge0) / (edge1 - edge0), static_cast<T>(0), static_cast<T>(1)));
   return tmp * tmp * (static_cast<T>(3) - static_cast<T>(2) * tmp);
  }
 };
}

 template<typename genFIType>
 inline genFIType abs(genFIType x)
 {
  return detail::compute_abs<genFIType, std::numeric_limits<genFIType>::is_signed>::call(x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> abs(vec<L, T, Q> const& x)
 {
  return detail::compute_abs_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }



 template<typename genFIType>
 inline genFIType sign(genFIType x)
 {
  (__builtin_expect(!(std::numeric_limits<genFIType>::is_iec559 || 0 || (std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer)), 0) ? __assert_rtn(__func__, "func_common.inl", 288, "std::numeric_limits<genFIType>::is_iec559 || 0 || (std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer)") : (void)0);



  return detail::compute_sign<1, genFIType, defaultp,
                                    std::numeric_limits<genFIType>::is_iec559, detail::is_aligned<highp>::value>::call(vec<1, genFIType>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> sign(vec<L, T, Q> const& x)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0 || (std::numeric_limits<T>::is_signed && std::numeric_limits<T>::is_integer)), 0) ? __assert_rtn(__func__, "func_common.inl", 299, "std::numeric_limits<T>::is_iec559 || 0 || (std::numeric_limits<T>::is_signed && std::numeric_limits<T>::is_integer)") : (void)0);



  return detail::compute_sign<L, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x);
 }


 using ::std::floor;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> floor(vec<L, T, Q> const& x)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_common.inl", 309, "std::numeric_limits<T>::is_iec559 || 0") : (void)0);
  return detail::compute_floor<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> trunc(vec<L, T, Q> const& x)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_common.inl", 316, "std::numeric_limits<T>::is_iec559 || 0") : (void)0);
  return detail::compute_trunc<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> round(vec<L, T, Q> const& x)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_common.inl", 323, "std::numeric_limits<T>::is_iec559 || 0") : (void)0);
  return detail::compute_round<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }
# 339 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/func_common.inl"
 template<typename genType>
 inline genType roundEven(genType x)
 {
  (__builtin_expect(!(std::numeric_limits<genType>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_common.inl", 342, "std::numeric_limits<genType>::is_iec559 || 0") : (void)0);

  int Integer = static_cast<int>(x);
  genType IntegerPart = static_cast<genType>(Integer);
  genType FractionalPart = fract(x);

  if(FractionalPart > static_cast<genType>(0.5) || FractionalPart < static_cast<genType>(0.5))
  {
   return round(x);
  }
  else if((Integer % 2) == 0)
  {
   return IntegerPart;
  }
  else if(x <= static_cast<genType>(0))
  {
   return IntegerPart - static_cast<genType>(1);
  }
  else
  {
   return IntegerPart + static_cast<genType>(1);
  }




 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> roundEven(vec<L, T, Q> const& x)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_common.inl", 373, "std::numeric_limits<T>::is_iec559 || 0") : (void)0);
  return detail::functor1<vec, L, T, T, Q>::call(roundEven, x);
 }


 using ::std::ceil;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> ceil(vec<L, T, Q> const& x)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_common.inl", 382, "std::numeric_limits<T>::is_iec559 || 0") : (void)0);
  return detail::compute_ceil<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }


 template<typename genType>
 inline genType fract(genType x)
 {
  return fract(vec<1, genType>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> fract(vec<L, T, Q> const& x)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_common.inl", 396, "std::numeric_limits<T>::is_iec559 || 0") : (void)0);
  return detail::compute_fract<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }


 template<typename genType>
 inline genType mod(genType x, genType y)
 {





   return mod(vec<1, genType, defaultp>(x), y).x;

 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> mod(vec<L, T, Q> const& x, T y)
 {
  return detail::compute_mod<L, T, Q, detail::is_aligned<Q>::value>::call(x, vec<L, T, Q>(y));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> mod(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  return detail::compute_mod<L, T, Q, detail::is_aligned<Q>::value>::call(x, y);
 }


 template<typename genType>
 inline genType modf(genType x, genType & i)
 {
  (__builtin_expect(!(std::numeric_limits<genType>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_common.inl", 429, "std::numeric_limits<genType>::is_iec559 || 0") : (void)0);
  return std::modf(x, &i);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> modf(vec<1, T, Q> const& x, vec<1, T, Q> & i)
 {
  return vec<1, T, Q>(
   modf(x.x, i.x));
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> modf(vec<2, T, Q> const& x, vec<2, T, Q> & i)
 {
  return vec<2, T, Q>(
   modf(x.x, i.x),
   modf(x.y, i.y));
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> modf(vec<3, T, Q> const& x, vec<3, T, Q> & i)
 {
  return vec<3, T, Q>(
   modf(x.x, i.x),
   modf(x.y, i.y),
   modf(x.z, i.z));
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> modf(vec<4, T, Q> const& x, vec<4, T, Q> & i)
 {
  return vec<4, T, Q>(
   modf(x.x, i.x),
   modf(x.y, i.y),
   modf(x.z, i.z),
   modf(x.w, i.w));
 }
# 476 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/func_common.inl"
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> min(vec<L, T, Q> const& a, T b)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer), 0) ? __assert_rtn(__func__, "func_common.inl", 479, "std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer") : (void)0);
  return detail::compute_min_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, vec<L, T, Q>(b));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> min(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
 {
  return detail::compute_min_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, b);
 }


 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> max(vec<L, T, Q> const& a, T b)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer), 0) ? __assert_rtn(__func__, "func_common.inl", 493, "std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer") : (void)0);
  return detail::compute_max_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, vec<L, T, Q>(b));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> max(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
 {
  return detail::compute_max_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, b);
 }


 template<typename genType>
 inline genType clamp(genType x, genType minVal, genType maxVal)
 {
  (__builtin_expect(!(std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer), 0) ? __assert_rtn(__func__, "func_common.inl", 507, "std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer") : (void)0);
  return min(max(x, minVal), maxVal);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> clamp(vec<L, T, Q> const& x, T minVal, T maxVal)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer), 0) ? __assert_rtn(__func__, "func_common.inl", 514, "std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer") : (void)0);
  return detail::compute_clamp_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x, vec<L, T, Q>(minVal), vec<L, T, Q>(maxVal));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> clamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer), 0) ? __assert_rtn(__func__, "func_common.inl", 521, "std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer") : (void)0);
  return detail::compute_clamp_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x, minVal, maxVal);
 }

 template<typename genTypeT, typename genTypeU>
 inline genTypeT mix(genTypeT x, genTypeT y, genTypeU a)
 {
  return detail::compute_mix<genTypeT, genTypeU>::call(x, y, a);
 }

 template<length_t L, typename T, typename U, qualifier Q>
 inline vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U a)
 {
  return detail::compute_mix_scalar<L, T, U, Q, detail::is_aligned<Q>::value>::call(x, y, a);
 }

 template<length_t L, typename T, typename U, qualifier Q>
 inline vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a)
 {
  return detail::compute_mix_vector<L, T, U, Q, detail::is_aligned<Q>::value>::call(x, y, a);
 }


 template<typename genType>
 inline genType step(genType edge, genType x)
 {
  return mix(static_cast<genType>(1), static_cast<genType>(0), x < edge);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> step(T edge, vec<L, T, Q> const& x)
 {
  return detail::compute_step_vector<L, T, Q, detail::is_aligned<Q>::value>::call(vec<L, T, Q>(edge), x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> step(vec<L, T, Q> const& edge, vec<L, T, Q> const& x)
 {
  return detail::compute_step_vector<L, T, Q, detail::is_aligned<Q>::value>::call(edge, x);
 }


 template<typename genType>
 inline genType smoothstep(genType edge0, genType edge1, genType x)
 {
  (__builtin_expect(!(std::numeric_limits<genType>::is_iec559 || 0 || 0), 0) ? __assert_rtn(__func__, "func_common.inl", 566, "std::numeric_limits<genType>::is_iec559 || 0 || 0") : (void)0);

  genType const tmp(clamp((x - edge0) / (edge1 - edge0), genType(0), genType(1)));
  return tmp * tmp * (genType(3) - genType(2) * tmp);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> smoothstep(T edge0, T edge1, vec<L, T, Q> const& x)
 {
  return detail::compute_smoothstep_vector<L, T, Q, detail::is_aligned<Q>::value>::call(vec<L, T, Q>(edge0), vec<L, T, Q>(edge1), x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> smoothstep(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x)
 {
  return detail::compute_smoothstep_vector<L, T, Q, detail::is_aligned<Q>::value>::call(edge0, edge1, x);
 }


  using std::isnan;
# 612 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/func_common.inl"
 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> isnan(vec<L, T, Q> const& v)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_common.inl", 615, "std::numeric_limits<T>::is_iec559 || 0") : (void)0);

  vec<L, bool, Q> Result(0);
  for (length_t l = 0; l < v.length(); ++l)
   Result[l] = glm::isnan(v[l]);
  return Result;
 }


  using std::isinf;
# 654 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/func_common.inl"
 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> isinf(vec<L, T, Q> const& v)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_common.inl", 657, "std::numeric_limits<T>::is_iec559 || 0") : (void)0);

  vec<L, bool, Q> Result(0);
  for (length_t l = 0; l < v.length(); ++l)
   Result[l] = glm::isinf(v[l]);
  return Result;
 }

 inline int floatBitsToInt(float v)
 {
  union
  {
   float in;
   int out;
  } u;

  u.in = v;

  return u.out;
 }

 template<length_t L, qualifier Q>
 inline vec<L, int, Q> floatBitsToInt(vec<L, float, Q> const& v)
 {
  return detail::functor1<vec, L, int, float, Q>::call(floatBitsToInt, v);
 }

 inline uint floatBitsToUint(float v)
 {
  union
  {
   float in;
   uint out;
  } u;

  u.in = v;

  return u.out;
 }

 template<length_t L, qualifier Q>
 inline vec<L, uint, Q> floatBitsToUint(vec<L, float, Q> const& v)
 {
  return detail::functor1<vec, L, uint, float, Q>::call(floatBitsToUint, v);
 }

 inline float intBitsToFloat(int v)
 {
  union
  {
   int in;
   float out;
  } u;

  u.in = v;

  return u.out;
 }

 template<length_t L, qualifier Q>
 inline vec<L, float, Q> intBitsToFloat(vec<L, int, Q> const& v)
 {
  return detail::functor1<vec, L, float, int, Q>::call(intBitsToFloat, v);
 }

 inline float uintBitsToFloat(uint v)
 {
  union
  {
   uint in;
   float out;
  } u;

  u.in = v;

  return u.out;
 }

 template<length_t L, qualifier Q>
 inline vec<L, float, Q> uintBitsToFloat(vec<L, uint, Q> const& v)
 {
  return reinterpret_cast<vec<L, float, Q>&>(const_cast<vec<L, uint, Q>&>(v));
 }


  using std::fma;
# 751 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../detail/func_common.inl"
 template<typename genType>
 inline genType frexp(genType x, int& exp)
 {
  (__builtin_expect(!(std::numeric_limits<genType>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_common.inl", 754, "std::numeric_limits<genType>::is_iec559 || 0") : (void)0);

  return std::frexp(x, &exp);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> frexp(vec<L, T, Q> const& v, vec<L, int, Q>& exp)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_common.inl", 762, "std::numeric_limits<T>::is_iec559 || 0") : (void)0);

  vec<L, T, Q> Result(0);
  for (length_t l = 0; l < v.length(); ++l)
   Result[l] = std::frexp(v[l], &exp[l]);
  return Result;
 }

 template<typename genType>
 inline genType ldexp(genType const& x, int const& exp)
 {
  (__builtin_expect(!(std::numeric_limits<genType>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_common.inl", 773, "std::numeric_limits<genType>::is_iec559 || 0") : (void)0);

  return std::ldexp(x, exp);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> ldexp(vec<L, T, Q> const& v, vec<L, int, Q> const& exp)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_common.inl", 781, "std::numeric_limits<T>::is_iec559 || 0") : (void)0);

  vec<L, T, Q> Result(0);
  for (length_t l = 0; l < v.length(); ++l)
   Result[l] = std::ldexp(v[l], exp[l]);
  return Result;
 }
}
# 539 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/../common.hpp" 2
# 3 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/func_geometric.inl" 2

namespace glm{
namespace detail
{
 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_length
 {
  inline static T call(vec<L, T, Q> const& v)
  {
   return sqrt(dot(v, v));
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_distance
 {
  inline static T call(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1)
  {
   return length(p1 - p0);
  }
 };

 template<typename V, typename T, bool Aligned>
 struct compute_dot{};

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<vec<1, T, Q>, T, Aligned>
 {
  inline static T call(vec<1, T, Q> const& a, vec<1, T, Q> const& b)
  {
   return a.x * b.x;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<vec<2, T, Q>, T, Aligned>
 {
  inline static T call(vec<2, T, Q> const& a, vec<2, T, Q> const& b)
  {
   vec<2, T, Q> tmp(a * b);
   return tmp.x + tmp.y;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<vec<3, T, Q>, T, Aligned>
 {
  inline static T call(vec<3, T, Q> const& a, vec<3, T, Q> const& b)
  {
   vec<3, T, Q> tmp(a * b);
   return tmp.x + tmp.y + tmp.z;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<vec<4, T, Q>, T, Aligned>
 {
  inline static T call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   vec<4, T, Q> tmp(a * b);
   return (tmp.x + tmp.y) + (tmp.z + tmp.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_cross
 {
  inline static vec<3, T, Q> call(vec<3, T, Q> const& x, vec<3, T, Q> const& y)
  {
   (__builtin_expect(!(std::numeric_limits<T>::is_iec559), 0) ? __assert_rtn(__func__, "func_geometric.inl", 72, "std::numeric_limits<T>::is_iec559") : (void)0);

   return vec<3, T, Q>(
    x.y * y.z - y.y * x.z,
    x.z * y.x - y.z * x.x,
    x.x * y.y - y.x * x.y);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_normalize
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v)
  {
   (__builtin_expect(!(std::numeric_limits<T>::is_iec559), 0) ? __assert_rtn(__func__, "func_geometric.inl", 86, "std::numeric_limits<T>::is_iec559") : (void)0);

   return v * inversesqrt(dot(v, v));
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_faceforward
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& N, vec<L, T, Q> const& I, vec<L, T, Q> const& Nref)
  {
   (__builtin_expect(!(std::numeric_limits<T>::is_iec559), 0) ? __assert_rtn(__func__, "func_geometric.inl", 97, "std::numeric_limits<T>::is_iec559") : (void)0);

   return dot(Nref, I) < static_cast<T>(0) ? N : -N;
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_reflect
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& I, vec<L, T, Q> const& N)
  {
   return I - N * dot(N, I) * static_cast<T>(2);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_refract
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& I, vec<L, T, Q> const& N, T eta)
  {
   T const dotValue(dot(N, I));
   T const k(static_cast<T>(1) - eta * eta * (static_cast<T>(1) - dotValue * dotValue));
   vec<L, T, Q> const Result =
                (k >= static_cast<T>(0)) ? (eta * I - (eta * dotValue + std::sqrt(k)) * N) : vec<L, T, Q>(0);
   return Result;
  }
 };
}


 template<typename genType>
 inline genType length(genType x)
 {
  (__builtin_expect(!(std::numeric_limits<genType>::is_iec559), 0) ? __assert_rtn(__func__, "func_geometric.inl", 130, "std::numeric_limits<genType>::is_iec559") : (void)0);

  return abs(x);
 }

 template<length_t L, typename T, qualifier Q>
 inline T length(vec<L, T, Q> const& v)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559), 0) ? __assert_rtn(__func__, "func_geometric.inl", 138, "std::numeric_limits<T>::is_iec559") : (void)0);

  return detail::compute_length<L, T, Q, detail::is_aligned<Q>::value>::call(v);
 }


 template<typename genType>
 inline genType distance(genType const& p0, genType const& p1)
 {
  (__builtin_expect(!(std::numeric_limits<genType>::is_iec559), 0) ? __assert_rtn(__func__, "func_geometric.inl", 147, "std::numeric_limits<genType>::is_iec559") : (void)0);

  return length(p1 - p0);
 }

 template<length_t L, typename T, qualifier Q>
 inline T distance(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1)
 {
  return detail::compute_distance<L, T, Q, detail::is_aligned<Q>::value>::call(p0, p1);
 }


 template<typename T>
 inline T dot(T x, T y)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559), 0) ? __assert_rtn(__func__, "func_geometric.inl", 162, "std::numeric_limits<T>::is_iec559") : (void)0);
  return x * y;
 }

 template<length_t L, typename T, qualifier Q>
 inline T dot(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559), 0) ? __assert_rtn(__func__, "func_geometric.inl", 169, "std::numeric_limits<T>::is_iec559") : (void)0);
  return detail::compute_dot<vec<L, T, Q>, T, detail::is_aligned<Q>::value>::call(x, y);
 }


 template<typename T, qualifier Q>
 inline vec<3, T, Q> cross(vec<3, T, Q> const& x, vec<3, T, Q> const& y)
 {
  return detail::compute_cross<T, Q, detail::is_aligned<Q>::value>::call(x, y);
 }
# 189 "/opt/homebrew/include/glm/./ext/../detail/../detail/../detail/func_geometric.inl"
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> normalize(vec<L, T, Q> const& x)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559), 0) ? __assert_rtn(__func__, "func_geometric.inl", 192, "std::numeric_limits<T>::is_iec559") : (void)0);

  return detail::compute_normalize<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }


 template<typename genType>
 inline genType faceforward(genType const& N, genType const& I, genType const& Nref)
 {
  return dot(Nref, I) < static_cast<genType>(0) ? N : -N;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> faceforward(vec<L, T, Q> const& N, vec<L, T, Q> const& I, vec<L, T, Q> const& Nref)
 {
  return detail::compute_faceforward<L, T, Q, detail::is_aligned<Q>::value>::call(N, I, Nref);
 }


 template<typename genType>
 inline genType reflect(genType const& I, genType const& N)
 {
  return I - N * dot(N, I) * genType(2);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> reflect(vec<L, T, Q> const& I, vec<L, T, Q> const& N)
 {
  return detail::compute_reflect<L, T, Q, detail::is_aligned<Q>::value>::call(I, N);
 }


 template<typename genType>
 inline genType refract(genType const& I, genType const& N, genType eta)
 {
  (__builtin_expect(!(std::numeric_limits<genType>::is_iec559), 0) ? __assert_rtn(__func__, "func_geometric.inl", 227, "std::numeric_limits<genType>::is_iec559") : (void)0);
  genType const dotValue(dot(N, I));
  genType const k(static_cast<genType>(1) - eta * eta * (static_cast<genType>(1) - dotValue * dotValue));
  return (eta * I - (eta * dotValue + sqrt(k)) * N) * static_cast<genType>(k >= static_cast<genType>(0));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> refract(vec<L, T, Q> const& I, vec<L, T, Q> const& N, T eta)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559), 0) ? __assert_rtn(__func__, "func_geometric.inl", 236, "std::numeric_limits<T>::is_iec559") : (void)0);
  return detail::compute_refract<L, T, Q, detail::is_aligned<Q>::value>::call(I, N, eta);
 }
}
# 117 "/opt/homebrew/include/glm/./ext/../detail/../detail/../geometric.hpp" 2
# 2 "/opt/homebrew/include/glm/./ext/../detail/../detail/func_matrix.inl" 2


namespace glm{
namespace detail
{
 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_matrixCompMult
 {
  inline static mat<C, R, T, Q> call(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
  {
   mat<C, R, T, Q> Result(1);
   for(length_t i = 0; i < Result.length(); ++i)
    Result[i] = x[i] * y[i];
   return Result;
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool IsFloat, bool Aligned>
 struct compute_matrixCompMult_type {
  inline static mat<C, R, T, Q> call(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
  {
   (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_matrix.inl", 24, "std::numeric_limits<T>::is_iec559 || 0") : (void)0);

   return detail::compute_matrixCompMult<C, R, T, Q, detail::is_aligned<Q>::value>::call(x, y);
  }
 };

 template<length_t DA, length_t DB, typename T, qualifier Q>
 struct compute_outerProduct {
  inline static typename detail::outerProduct_trait<DA, DB, T, Q>::type call(vec<DA, T, Q> const& c, vec<DB, T, Q> const& r)
  {
   typename detail::outerProduct_trait<DA, DB, T, Q>::type m(0);
   for(length_t i = 0; i < m.length(); ++i)
    m[i] = c * r[i];
   return m;
  }
 };

 template<length_t DA, length_t DB, typename T, qualifier Q, bool IsFloat>
 struct compute_outerProduct_type {
  inline static typename detail::outerProduct_trait<DA, DB, T, Q>::type call(vec<DA, T, Q> const& c, vec<DB, T, Q> const& r)
  {
   (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_matrix.inl", 45, "std::numeric_limits<T>::is_iec559 || 0") : (void)0);


   return detail::compute_outerProduct<DA, DB, T, Q>::call(c, r);
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_transpose{};

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<2, 2, T, Q, Aligned>
 {
  inline static mat<2, 2, T, Q> call(mat<2, 2, T, Q> const& m)
  {
   mat<2, 2, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<2, 3, T, Q, Aligned>
 {
  inline static mat<3, 2, T, Q> call(mat<2, 3, T, Q> const& m)
  {
   mat<3,2, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<2, 4, T, Q, Aligned>
 {
  inline static mat<4, 2, T, Q> call(mat<2, 4, T, Q> const& m)
  {
   mat<4, 2, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[3][0] = m[0][3];
   Result[3][1] = m[1][3];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<3, 2, T, Q, Aligned>
 {
  inline static mat<2, 3, T, Q> call(mat<3, 2, T, Q> const& m)
  {
   mat<2, 3, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<3, 3, T, Q, Aligned>
 {
  inline static mat<3, 3, T, Q> call(mat<3, 3, T, Q> const& m)
  {
   mat<3, 3, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];

   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];

   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[2][2] = m[2][2];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<3, 4, T, Q, Aligned>
 {
  inline static mat<4, 3, T, Q> call(mat<3, 4, T, Q> const& m)
  {
   mat<4, 3, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[2][2] = m[2][2];
   Result[3][0] = m[0][3];
   Result[3][1] = m[1][3];
   Result[3][2] = m[2][3];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<4, 2, T, Q, Aligned>
 {
  inline static mat<2, 4, T, Q> call(mat<4, 2, T, Q> const& m)
  {
   mat<2, 4, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[0][3] = m[3][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   Result[1][3] = m[3][1];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<4, 3, T, Q, Aligned>
 {
  inline static mat<3, 4, T, Q> call(mat<4, 3, T, Q> const& m)
  {
   mat<3, 4, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[0][3] = m[3][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   Result[1][3] = m[3][1];
   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[2][2] = m[2][2];
   Result[2][3] = m[3][2];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<4, 4, T, Q, Aligned>
 {
  inline static mat<4, 4, T, Q> call(mat<4, 4, T, Q> const& m)
  {
   mat<4, 4, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[0][3] = m[3][0];

   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   Result[1][3] = m[3][1];

   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[2][2] = m[2][2];
   Result[2][3] = m[3][2];

   Result[3][0] = m[0][3];
   Result[3][1] = m[1][3];
   Result[3][2] = m[2][3];
   Result[3][3] = m[3][3];
   return Result;
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool IsFloat, bool Aligned>
 struct compute_transpose_type {
  inline static mat<R, C, T, Q> call(mat<C, R, T, Q> const& m)
  {
   (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_matrix.inl", 235, "std::numeric_limits<T>::is_iec559 || 0") : (void)0);

   return detail::compute_transpose<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_determinant{};

 template<typename T, qualifier Q, bool Aligned>
 struct compute_determinant<2, 2, T, Q, Aligned>
 {
  inline static T call(mat<2, 2, T, Q> const& m)
  {
   return m[0][0] * m[1][1] - m[1][0] * m[0][1];
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_determinant<3, 3, T, Q, Aligned>
 {
  inline static T call(mat<3, 3, T, Q> const& m)
  {
   return
    + m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
    - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
    + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_determinant<4, 4, T, Q, Aligned>
 {
  inline static T call(mat<4, 4, T, Q> const& m)
  {
   T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
   T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
   T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
   T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
   T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
   T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];

   vec<4, T, Q> DetCof(
    + (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),
    - (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),
    + (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),
    - (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));

   return
    m[0][0] * DetCof[0] + m[0][1] * DetCof[1] +
    m[0][2] * DetCof[2] + m[0][3] * DetCof[3];
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool IsFloat, bool Aligned>
 struct compute_determinant_type{

  inline static T call(mat<C, R, T, Q> const& m)
  {
   (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_matrix.inl", 294, "std::numeric_limits<T>::is_iec559 || 0") : (void)0);

   return detail::compute_determinant<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_inverse{};

 template<typename T, qualifier Q, bool Aligned>
 struct compute_inverse<2, 2, T, Q, Aligned>
 {
  inline static mat<2, 2, T, Q> call(mat<2, 2, T, Q> const& m)
  {
   T OneOverDeterminant = static_cast<T>(1) / (
    + m[0][0] * m[1][1]
    - m[1][0] * m[0][1]);

   mat<2, 2, T, Q> Inverse(
    + m[1][1] * OneOverDeterminant,
    - m[0][1] * OneOverDeterminant,
    - m[1][0] * OneOverDeterminant,
    + m[0][0] * OneOverDeterminant);

   return Inverse;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_inverse<3, 3, T, Q, Aligned>
 {
  inline static mat<3, 3, T, Q> call(mat<3, 3, T, Q> const& m)
  {
   T OneOverDeterminant = static_cast<T>(1) / (
    + m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
    - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
    + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]));

   mat<3, 3, T, Q> Inverse;
   Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]) * OneOverDeterminant;
   Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]) * OneOverDeterminant;
   Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]) * OneOverDeterminant;
   Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]) * OneOverDeterminant;
   Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]) * OneOverDeterminant;
   Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]) * OneOverDeterminant;
   Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]) * OneOverDeterminant;
   Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]) * OneOverDeterminant;
   Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * OneOverDeterminant;

   return Inverse;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_inverse<4, 4, T, Q, Aligned>
 {
  inline static mat<4, 4, T, Q> call(mat<4, 4, T, Q> const& m)
  {
   T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
   T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
   T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];

   T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
   T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
   T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];

   T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
   T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
   T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];

   T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
   T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
   T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];

   T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
   T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
   T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];

   T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
   T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
   T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

   vec<4, T, Q> Fac0(Coef00, Coef00, Coef02, Coef03);
   vec<4, T, Q> Fac1(Coef04, Coef04, Coef06, Coef07);
   vec<4, T, Q> Fac2(Coef08, Coef08, Coef10, Coef11);
   vec<4, T, Q> Fac3(Coef12, Coef12, Coef14, Coef15);
   vec<4, T, Q> Fac4(Coef16, Coef16, Coef18, Coef19);
   vec<4, T, Q> Fac5(Coef20, Coef20, Coef22, Coef23);

   vec<4, T, Q> Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
   vec<4, T, Q> Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
   vec<4, T, Q> Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
   vec<4, T, Q> Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);

   vec<4, T, Q> Inv0(Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
   vec<4, T, Q> Inv1(Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
   vec<4, T, Q> Inv2(Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
   vec<4, T, Q> Inv3(Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);

   vec<4, T, Q> SignA(+1, -1, +1, -1);
   vec<4, T, Q> SignB(-1, +1, -1, +1);
   mat<4, 4, T, Q> Inverse(Inv0 * SignA, Inv1 * SignB, Inv2 * SignA, Inv3 * SignB);

   vec<4, T, Q> Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);

   vec<4, T, Q> Dot0(m[0] * Row0);
   T Dot1 = (Dot0.x + Dot0.y) + (Dot0.z + Dot0.w);

   T OneOverDeterminant = static_cast<T>(1) / Dot1;

   return Inverse * OneOverDeterminant;
  }
 };
}

 template<length_t C, length_t R, typename T, qualifier Q>
 inline mat<C, R, T, Q> matrixCompMult(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
 {
  return detail::compute_matrixCompMult_type<C, R, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x, y);
 }

 template<length_t DA, length_t DB, typename T, qualifier Q>
 inline typename detail::outerProduct_trait<DA, DB, T, Q>::type outerProduct(vec<DA, T, Q> const& c, vec<DB, T, Q> const& r)
 {
  return detail::compute_outerProduct_type<DA, DB, T, Q, std::numeric_limits<T>::is_iec559>::call(c, r);
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline typename mat<C, R, T, Q>::transpose_type transpose(mat<C, R, T, Q> const& m)
 {
  return detail::compute_transpose_type<C, R, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(m);
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline T determinant(mat<C, R, T, Q> const& m)
 {
  return detail::compute_determinant_type<C, R, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(m);
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline mat<C, R, T, Q> inverse(mat<C, R, T, Q> const& m)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_matrix.inl", 435, "std::numeric_limits<T>::is_iec559 || 0") : (void)0);
  return detail::compute_inverse<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
 }
}
# 162 "/opt/homebrew/include/glm/./ext/../detail/../matrix.hpp" 2
# 2 "/opt/homebrew/include/glm/./ext/../detail/type_mat2x2.inl" 2

namespace glm
{



  template<typename T, qualifier Q>
  inline mat<2, 2, T, Q>::mat()



  {




  }


 template<typename T, qualifier Q>
 template<qualifier P>
 inline mat<2, 2, T, Q>::mat(mat<2, 2, T, P> const& m)



 {

   this->value[0] = m[0];
   this->value[1] = m[1];

 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q>::mat(T scalar)



 {

   this->value[0] = col_type(scalar, 0);
   this->value[1] = col_type(0, scalar);

 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q>::mat
 (
  T const& x0, T const& y0,
  T const& x1, T const& y1
 )



 {

   this->value[0] = col_type(x0, y0);
   this->value[1] = col_type(x1, y1);

 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q>::mat(col_type const& v0, col_type const& v1)



 {

   this->value[0] = v0;
   this->value[1] = v1;

 }



 template<typename T, qualifier Q>
 template<typename X1, typename Y1, typename X2, typename Y2>
 inline mat<2, 2, T, Q>::mat
 (
  X1 const& x1, Y1 const& y1,
  X2 const& x2, Y2 const& y2
 )



 {

   this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
   this->value[1] = col_type(static_cast<T>(x2), value_type(y2));

 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2>
 inline mat<2, 2, T, Q>::mat(vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2)



 {

   this->value[0] = col_type(v1);
   this->value[1] = col_type(v2);

 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline mat<2, 2, T, Q>::mat(mat<2, 2, U, P> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);

 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);

 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);

 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);

 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q>::mat(mat<3, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);

 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);

 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q>::mat(mat<4, 2, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);

 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);

 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)



 {

   this->value[0] = col_type(m[0]);
   this->value[1] = col_type(m[1]);

 }



 template<typename T, qualifier Q>
 inline typename mat<2, 2, T, Q>::col_type& mat<2, 2, T, Q>::operator[](typename mat<2, 2, T, Q>::length_type i)
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_mat2x2.inl", 222, "(i) >= 0 && (i) < (this->length())") : (void)0));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline typename mat<2, 2, T, Q>::col_type const& mat<2, 2, T, Q>::operator[](typename mat<2, 2, T, Q>::length_type i) const
 {
  ((__builtin_expect(!((i) >= 0 && (i) < (this->length())), 0) ? __assert_rtn(__func__, "type_mat2x2.inl", 229, "(i) >= 0 && (i) < (this->length())") : (void)0));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator=(mat<2, 2, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator+=(U scalar)
 {
  this->value[0] += scalar;
  this->value[1] += scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator+=(mat<2, 2, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator-=(U scalar)
 {
  this->value[0] -= scalar;
  this->value[1] -= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator-=(mat<2, 2, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator*=(U scalar)
 {
  this->value[0] *= scalar;
  this->value[1] *= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator*=(mat<2, 2, U, Q> const& m)
 {
  return (*this = *this * m);
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator/=(U scalar)
 {
  this->value[0] /= scalar;
  this->value[1] /= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator/=(mat<2, 2, U, Q> const& m)
 {
  return *this *= inverse(m);
 }



 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q> mat<2, 2, T, Q>::operator++(int)
 {
  mat<2, 2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q> mat<2, 2, T, Q>::operator--(int)
 {
  mat<2, 2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   -m[0],
   -m[1]);
 }



 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m, T scalar)
 {
  return mat<2, 2, T, Q>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q> operator+(T scalar, mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 2, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m, T scalar)
 {
  return mat<2, 2, T, Q>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q> operator-(T scalar, mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   scalar - m[0],
   scalar - m[1]);
 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 2, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m, T scalar)
 {
  return mat<2, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q> operator*(T scalar, mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline typename mat<2, 2, T, Q>::col_type operator*
 (
  mat<2, 2, T, Q> const& m,
  typename mat<2, 2, T, Q>::row_type const& v
 )
 {
  return vec<2, T, Q>(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y);
 }

 template<typename T, qualifier Q>
 inline typename mat<2, 2, T, Q>::row_type operator*
 (
  typename mat<2, 2, T, Q>::col_type const& v,
  mat<2, 2, T, Q> const& m
 )
 {
  return vec<2, T, Q>(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1]);
 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1]);
 }

 template<typename T, qualifier Q>
 inline mat<3, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1]);
 }

 template<typename T, qualifier Q>
 inline mat<4, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1]);
 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m, T scalar)
 {
  return mat<2, 2, T, Q>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q> operator/(T scalar, mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   scalar / m[0],
   scalar / m[1]);
 }

 template<typename T, qualifier Q>
 inline typename mat<2, 2, T, Q>::col_type operator/(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v)
 {
  return inverse(m) * v;
 }

 template<typename T, qualifier Q>
 inline typename mat<2, 2, T, Q>::row_type operator/(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m)
 {
  return v * inverse(m);
 }

 template<typename T, qualifier Q>
 inline mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  mat<2, 2, T, Q> m1_copy(m1);
  return m1_copy /= m2;
 }



 template<typename T, qualifier Q>
 inline bool operator==(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template<typename T, qualifier Q>
 inline bool operator!=(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 177 "/opt/homebrew/include/glm/./ext/../detail/type_mat2x2.hpp" 2
# 6 "/opt/homebrew/include/glm/./ext/matrix_double2x2.hpp" 2

namespace glm
{






 typedef mat<2, 2, double, defaultp> dmat2x2;




 typedef mat<2, 2, double, defaultp> dmat2;


}
# 6 "/opt/homebrew/include/glm/mat2x2.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/matrix_double2x2_precision.hpp" 1






namespace glm
{







 typedef mat<2, 2, double, lowp> lowp_dmat2;





 typedef mat<2, 2, double, mediump> mediump_dmat2;





 typedef mat<2, 2, double, highp> highp_dmat2;





 typedef mat<2, 2, double, lowp> lowp_dmat2x2;





 typedef mat<2, 2, double, mediump> mediump_dmat2x2;





 typedef mat<2, 2, double, highp> highp_dmat2x2;


}
# 7 "/opt/homebrew/include/glm/mat2x2.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/matrix_float2x2.hpp" 1






namespace glm
{






 typedef mat<2, 2, float, defaultp> mat2x2;




 typedef mat<2, 2, float, defaultp> mat2;


}
# 8 "/opt/homebrew/include/glm/mat2x2.hpp" 2
# 1 "/opt/homebrew/include/glm/./ext/matrix_float2x2_precision.hpp" 1






namespace glm
{







 typedef mat<2, 2, float, lowp> lowp_mat2;





 typedef mat<2, 2, float, mediump> mediump_mat2;





 typedef mat<2, 2, float, highp> highp_mat2;





 typedef mat<2, 2, float, lowp> lowp_mat2x2;





 typedef mat<2, 2, float, mediump> mediump_mat2x2;





 typedef mat<2, 2, float, highp> highp_mat2x2;


}
# 9 "/opt/homebrew/include/glm/mat2x2.hpp" 2
# 121 "/opt/homebrew/include/glm/glm.hpp" 2
# 130 "/opt/homebrew/include/glm/glm.hpp"
# 1 "/opt/homebrew/include/glm/trigonometric.hpp" 1
# 21 "/opt/homebrew/include/glm/trigonometric.hpp"
# 1 "/opt/homebrew/include/glm/detail/setup.hpp" 1
# 22 "/opt/homebrew/include/glm/trigonometric.hpp" 2


namespace glm
{
# 37 "/opt/homebrew/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
                             vec<L, T, Q> radians(vec<L, T, Q> const& degrees);
# 48 "/opt/homebrew/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
                             vec<L, T, Q> degrees(vec<L, T, Q> const& radians);
# 60 "/opt/homebrew/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> sin(vec<L, T, Q> const& angle);
# 72 "/opt/homebrew/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> cos(vec<L, T, Q> const& angle);
# 83 "/opt/homebrew/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> tan(vec<L, T, Q> const& angle);
# 96 "/opt/homebrew/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> asin(vec<L, T, Q> const& x);
# 109 "/opt/homebrew/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> acos(vec<L, T, Q> const& x);
# 124 "/opt/homebrew/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> atan(vec<L, T, Q> const& y, vec<L, T, Q> const& x);
# 136 "/opt/homebrew/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> atan(vec<L, T, Q> const& y_over_x);
# 147 "/opt/homebrew/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> sinh(vec<L, T, Q> const& angle);
# 158 "/opt/homebrew/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> cosh(vec<L, T, Q> const& angle);
# 169 "/opt/homebrew/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> tanh(vec<L, T, Q> const& angle);
# 180 "/opt/homebrew/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> asinh(vec<L, T, Q> const& x);
# 192 "/opt/homebrew/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> acosh(vec<L, T, Q> const& x);
# 204 "/opt/homebrew/include/glm/trigonometric.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> atanh(vec<L, T, Q> const& x);


}

# 1 "/opt/homebrew/include/glm/detail/func_trigonometric.inl" 1




namespace glm
{

 template<typename genType>
 inline genType radians(genType degrees)
 {
  (__builtin_expect(!(std::numeric_limits<genType>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_trigonometric.inl", 11, "std::numeric_limits<genType>::is_iec559 || 0") : (void)0);

  return degrees * static_cast<genType>(0.01745329251994329576923690768489);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> radians(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(radians, v);
 }


 template<typename genType>
 inline genType degrees(genType radians)
 {
  (__builtin_expect(!(std::numeric_limits<genType>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_trigonometric.inl", 26, "std::numeric_limits<genType>::is_iec559 || 0") : (void)0);

  return radians * static_cast<genType>(57.295779513082320876798154814105);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> degrees(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(degrees, v);
 }


 using ::std::sin;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> sin(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(sin, v);
 }


 using std::cos;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> cos(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(cos, v);
 }


 using std::tan;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> tan(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(tan, v);
 }


 using std::asin;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> asin(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(asin, v);
 }


 using std::acos;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> acos(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(acos, v);
 }


 template<typename genType>
 inline genType atan(genType y, genType x)
 {
  (__builtin_expect(!(std::numeric_limits<genType>::is_iec559 || 0), 0) ? __assert_rtn(__func__, "func_trigonometric.inl", 86, "std::numeric_limits<genType>::is_iec559 || 0") : (void)0);

  return ::std::atan2(y, x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> atan(vec<L, T, Q> const& y, vec<L, T, Q> const& x)
 {
  return detail::functor2<vec, L, T, Q>::call(::std::atan2, y, x);
 }

 using std::atan;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> atan(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(atan, v);
 }


 using std::sinh;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> sinh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(sinh, v);
 }


 using std::cosh;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> cosh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(cosh, v);
 }


 using std::tanh;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> tanh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(tanh, v);
 }



  using std::asinh;
# 145 "/opt/homebrew/include/glm/detail/func_trigonometric.inl"
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> asinh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(asinh, v);
 }



  using std::acosh;
# 166 "/opt/homebrew/include/glm/detail/func_trigonometric.inl"
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> acosh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(acosh, v);
 }



  using std::atanh;
# 187 "/opt/homebrew/include/glm/detail/func_trigonometric.inl"
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> atanh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(atanh, v);
 }
}
# 211 "/opt/homebrew/include/glm/trigonometric.hpp" 2
# 131 "/opt/homebrew/include/glm/glm.hpp" 2


# 1 "/opt/homebrew/include/glm/packing.hpp" 1
# 22 "/opt/homebrew/include/glm/packing.hpp"
namespace glm
{
# 38 "/opt/homebrew/include/glm/packing.hpp"
               uint packUnorm2x16(vec2 const& v);
# 51 "/opt/homebrew/include/glm/packing.hpp"
               uint packSnorm2x16(vec2 const& v);
# 64 "/opt/homebrew/include/glm/packing.hpp"
               uint packUnorm4x8(vec4 const& v);
# 77 "/opt/homebrew/include/glm/packing.hpp"
               uint packSnorm4x8(vec4 const& v);
# 90 "/opt/homebrew/include/glm/packing.hpp"
               vec2 unpackUnorm2x16(uint p);
# 103 "/opt/homebrew/include/glm/packing.hpp"
               vec2 unpackSnorm2x16(uint p);
# 116 "/opt/homebrew/include/glm/packing.hpp"
               vec4 unpackUnorm4x8(uint p);
# 129 "/opt/homebrew/include/glm/packing.hpp"
               vec4 unpackSnorm4x8(uint p);
# 139 "/opt/homebrew/include/glm/packing.hpp"
               double packDouble2x32(uvec2 const& v);
# 148 "/opt/homebrew/include/glm/packing.hpp"
               uvec2 unpackDouble2x32(double v);
# 158 "/opt/homebrew/include/glm/packing.hpp"
               uint packHalf2x16(vec2 const& v);
# 168 "/opt/homebrew/include/glm/packing.hpp"
               vec2 unpackHalf2x16(uint v);


}

# 1 "/opt/homebrew/include/glm/detail/func_packing.inl" 1




# 1 "/opt/homebrew/include/glm/detail/type_half.hpp" 1


# 1 "/opt/homebrew/include/glm/detail/setup.hpp" 1
# 4 "/opt/homebrew/include/glm/detail/type_half.hpp" 2

namespace glm{
namespace detail
{
 typedef short hdata;

               float toFloat32(hdata value);
               hdata toFloat16(float const& value);

}
}

# 1 "/opt/homebrew/include/glm/detail/type_half.inl" 1
namespace glm{
namespace detail
{
 inline float overflow()
 {
  volatile float f = 1e10;

  for(int i = 0; i < 10; ++i)
   f = f * f;
  return f;
 }

 union uif32
 {
  inline uif32() :
   i(0)
  {}

  inline uif32(float f_) :
   f(f_)
  {}

  inline uif32(unsigned int i_) :
   i(i_)
  {}

  float f;
  unsigned int i;
 };

 inline float toFloat32(hdata value)
 {
  int s = (value >> 15) & 0x00000001;
  int e = (value >> 10) & 0x0000001f;
  int m = value & 0x000003ff;

  if(e == 0)
  {
   if(m == 0)
   {




    detail::uif32 result;
    result.i = static_cast<unsigned int>(s << 31);
    return result.f;
   }
   else
   {




    while(!(m & 0x00000400))
    {
     m <<= 1;
     e -= 1;
    }

    e += 1;
    m &= ~0x00000400;
   }
  }
  else if(e == 31)
  {
   if(m == 0)
   {




    uif32 result;
    result.i = static_cast<unsigned int>((s << 31) | 0x7f800000);
    return result.f;
   }
   else
   {




    uif32 result;
    result.i = static_cast<unsigned int>((s << 31) | 0x7f800000 | (m << 13));
    return result.f;
   }
  }





  e = e + (127 - 15);
  m = m << 13;





  uif32 Result;
  Result.i = static_cast<unsigned int>((s << 31) | (e << 23) | m);
  return Result.f;
 }

 inline hdata toFloat16(float const& f)
 {
  uif32 Entry;
  Entry.f = f;
  int i = static_cast<int>(Entry.i);
# 121 "/opt/homebrew/include/glm/detail/type_half.inl"
  int s = (i >> 16) & 0x00008000;
  int e = ((i >> 23) & 0x000000ff) - (127 - 15);
  int m = i & 0x007fffff;





  if(e <= 0)
  {
   if(e < -10)
   {
# 141 "/opt/homebrew/include/glm/detail/type_half.inl"
    return hdata(s);
   }
# 151 "/opt/homebrew/include/glm/detail/type_half.inl"
   m = (m | 0x00800000) >> (1 - e);
# 162 "/opt/homebrew/include/glm/detail/type_half.inl"
   if(m & 0x00001000)
    m += 0x00002000;





   return hdata(s | (m >> 13));
  }
  else if(e == 0xff - (127 - 15))
  {
   if(m == 0)
   {





    return hdata(s | 0x7c00);
   }
   else
   {
# 193 "/opt/homebrew/include/glm/detail/type_half.inl"
    m >>= 13;

    return hdata(s | 0x7c00 | m | (m == 0));
   }
  }
  else
  {
# 209 "/opt/homebrew/include/glm/detail/type_half.inl"
   if(m & 0x00001000)
   {
    m += 0x00002000;

    if(m & 0x00800000)
    {
     m = 0;
     e += 1;
    }
   }





   if (e > 30)
   {
    overflow();

    return hdata(s | 0x7c00);

   }





   return hdata(s | (e << 10) | (m >> 13));
  }
 }

}
}
# 17 "/opt/homebrew/include/glm/detail/type_half.hpp" 2
# 6 "/opt/homebrew/include/glm/detail/func_packing.inl" 2

namespace glm
{
 inline uint packUnorm2x16(vec2 const& v)
 {
  union
  {
   unsigned short in[2];
   uint out;
  } u;

  vec<2, unsigned short, defaultp> result(round(clamp(v, 0.0f, 1.0f) * 65535.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];

  return u.out;
 }

 inline vec2 unpackUnorm2x16(uint p)
 {
  union
  {
   uint in;
   unsigned short out[2];
  } u;

  u.in = p;

  return vec2(u.out[0], u.out[1]) * 1.5259021896696421759365224689097e-5f;
 }

 inline uint packSnorm2x16(vec2 const& v)
 {
  union
  {
   signed short in[2];
   uint out;
  } u;

  vec<2, short, defaultp> result(round(clamp(v, -1.0f, 1.0f) * 32767.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];

  return u.out;
 }

 inline vec2 unpackSnorm2x16(uint p)
 {
  union
  {
   uint in;
   signed short out[2];
  } u;

  u.in = p;

  return clamp(vec2(u.out[0], u.out[1]) * 3.0518509475997192297128208258309e-5f, -1.0f, 1.0f);
 }

 inline uint packUnorm4x8(vec4 const& v)
 {
  union
  {
   unsigned char in[4];
   uint out;
  } u;

  vec<4, unsigned char, defaultp> result(round(clamp(v, 0.0f, 1.0f) * 255.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];
  u.in[2] = result[2];
  u.in[3] = result[3];

  return u.out;
 }

 inline vec4 unpackUnorm4x8(uint p)
 {
  union
  {
   uint in;
   unsigned char out[4];
  } u;

  u.in = p;

  return vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0039215686274509803921568627451f;
 }

 inline uint packSnorm4x8(vec4 const& v)
 {
  union
  {
   signed char in[4];
   uint out;
  } u;

  vec<4, signed char, defaultp> result(round(clamp(v, -1.0f, 1.0f) * 127.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];
  u.in[2] = result[2];
  u.in[3] = result[3];

  return u.out;
 }

 inline glm::vec4 unpackSnorm4x8(uint p)
 {
  union
  {
   uint in;
   signed char out[4];
  } u;

  u.in = p;

  return clamp(vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0078740157480315f, -1.0f, 1.0f);
 }

 inline double packDouble2x32(uvec2 const& v)
 {
  union
  {
   uint in[2];
   double out;
  } u;

  u.in[0] = v[0];
  u.in[1] = v[1];

  return u.out;
 }

 inline uvec2 unpackDouble2x32(double v)
 {
  union
  {
   double in;
   uint out[2];
  } u;

  u.in = v;

  return uvec2(u.out[0], u.out[1]);
 }

 inline uint packHalf2x16(vec2 const& v)
 {
  union
  {
   signed short in[2];
   uint out;
  } u;

  u.in[0] = detail::toFloat16(v.x);
  u.in[1] = detail::toFloat16(v.y);

  return u.out;
 }

 inline vec2 unpackHalf2x16(uint v)
 {
  union
  {
   uint in;
   signed short out[2];
  } u;

  u.in = v;

  return vec2(
   detail::toFloat32(u.out[0]),
   detail::toFloat32(u.out[1]));
 }
}
# 174 "/opt/homebrew/include/glm/packing.hpp" 2
# 134 "/opt/homebrew/include/glm/glm.hpp" 2



# 1 "/opt/homebrew/include/glm/integer.hpp" 1
# 23 "/opt/homebrew/include/glm/integer.hpp"
namespace glm
{
# 36 "/opt/homebrew/include/glm/integer.hpp"
 template<length_t L, qualifier Q>
               vec<L, uint, Q> uaddCarry(
  vec<L, uint, Q> const& x,
  vec<L, uint, Q> const& y,
  vec<L, uint, Q> & carry);
# 50 "/opt/homebrew/include/glm/integer.hpp"
 template<length_t L, qualifier Q>
               vec<L, uint, Q> usubBorrow(
  vec<L, uint, Q> const& x,
  vec<L, uint, Q> const& y,
  vec<L, uint, Q> & borrow);
# 64 "/opt/homebrew/include/glm/integer.hpp"
 template<length_t L, qualifier Q>
                       void umulExtended(
  vec<L, uint, Q> const& x,
  vec<L, uint, Q> const& y,
  vec<L, uint, Q> & msb,
  vec<L, uint, Q> & lsb);
# 79 "/opt/homebrew/include/glm/integer.hpp"
 template<length_t L, qualifier Q>
                       void imulExtended(
  vec<L, int, Q> const& x,
  vec<L, int, Q> const& y,
  vec<L, int, Q> & msb,
  vec<L, int, Q> & lsb);
# 102 "/opt/homebrew/include/glm/integer.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> bitfieldExtract(
  vec<L, T, Q> const& Value,
  int Offset,
  int Bits);
# 123 "/opt/homebrew/include/glm/integer.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> bitfieldInsert(
  vec<L, T, Q> const& Base,
  vec<L, T, Q> const& Insert,
  int Offset,
  int Bits);
# 139 "/opt/homebrew/include/glm/integer.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, T, Q> bitfieldReverse(vec<L, T, Q> const& v);







 template<typename genType>
               int bitCount(genType v);
# 158 "/opt/homebrew/include/glm/integer.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, int, Q> bitCount(vec<L, T, Q> const& v);
# 169 "/opt/homebrew/include/glm/integer.hpp"
 template<typename genIUType>
               int findLSB(genIUType x);
# 181 "/opt/homebrew/include/glm/integer.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, int, Q> findLSB(vec<L, T, Q> const& v);
# 193 "/opt/homebrew/include/glm/integer.hpp"
 template<typename genIUType>
               int findMSB(genIUType x);
# 206 "/opt/homebrew/include/glm/integer.hpp"
 template<length_t L, typename T, qualifier Q>
               vec<L, int, Q> findMSB(vec<L, T, Q> const& v);


}

# 1 "/opt/homebrew/include/glm/detail/func_integer.inl" 1
# 16 "/opt/homebrew/include/glm/detail/func_integer.inl"
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wc++11-long-long"



namespace glm{
namespace detail
{
 template<typename T>
 inline T mask(T Bits)
 {
  return Bits >= static_cast<T>(sizeof(T) * 8) ? ~static_cast<T>(0) : (static_cast<T>(1) << Bits) - static_cast<T>(1);
 }

 template<length_t L, typename T, qualifier Q, bool Aligned, bool EXEC>
 struct compute_bitfieldReverseStep
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T, T)
  {
   return v;
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_bitfieldReverseStep<L, T, Q, Aligned, true>
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T Mask, T Shift)
  {
   return (v & Mask) << Shift | (v & (~Mask)) >> Shift;
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned, bool EXEC>
 struct compute_bitfieldBitCountStep
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T, T)
  {
   return v;
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_bitfieldBitCountStep<L, T, Q, Aligned, true>
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T Mask, T Shift)
  {
   return (v & Mask) + ((v >> Shift) & Mask);
  }
 };

 template<typename genIUType, size_t Bits>
 struct compute_findLSB
 {
  inline static int call(genIUType Value)
  {
   if(Value == 0)
    return -1;

   return glm::bitCount(~Value & (Value - static_cast<genIUType>(1)));
  }
 };
# 104 "/opt/homebrew/include/glm/detail/func_integer.inl"
 template<length_t L, typename T, qualifier Q, bool EXEC = true>
 struct compute_findMSB_step_vec
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, T Shift)
  {
   return x | (x >> Shift);
  }
 };

 template<length_t L, typename T, qualifier Q>
 struct compute_findMSB_step_vec<L, T, Q, false>
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, T)
  {
   return x;
  }
 };

 template<length_t L, typename T, qualifier Q, int>
 struct compute_findMSB_vec
 {
  inline static vec<L, int, Q> call(vec<L, T, Q> const& v)
  {
   vec<L, T, Q> x(v);
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 1));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 2));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 4));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 16>::call(x, static_cast<T>( 8));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 32>::call(x, static_cast<T>(16));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 64>::call(x, static_cast<T>(32));
   return vec<L, int, Q>(sizeof(T) * 8 - 1) - glm::bitCount(~x);
  }
 };
# 175 "/opt/homebrew/include/glm/detail/func_integer.inl"
}


 inline uint uaddCarry(uint const& x, uint const& y, uint & Carry)
 {
  detail::uint64 const Value64(static_cast<detail::uint64>(x) + static_cast<detail::uint64>(y));
  detail::uint64 const Max32((static_cast<detail::uint64>(1) << static_cast<detail::uint64>(32)) - static_cast<detail::uint64>(1));
  Carry = Value64 > Max32 ? 1u : 0u;
  return static_cast<uint>(Value64 % (Max32 + static_cast<detail::uint64>(1)));
 }

 template<length_t L, qualifier Q>
 inline vec<L, uint, Q> uaddCarry(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& Carry)
 {
  vec<L, detail::uint64, Q> Value64(vec<L, detail::uint64, Q>(x) + vec<L, detail::uint64, Q>(y));
  vec<L, detail::uint64, Q> Max32((static_cast<detail::uint64>(1) << static_cast<detail::uint64>(32)) - static_cast<detail::uint64>(1));
  Carry = mix(vec<L, uint, Q>(0), vec<L, uint, Q>(1), greaterThan(Value64, Max32));
  return vec<L, uint, Q>(Value64 % (Max32 + static_cast<detail::uint64>(1)));
 }


 inline uint usubBorrow(uint const& x, uint const& y, uint & Borrow)
 {
  Borrow = x >= y ? static_cast<uint>(0) : static_cast<uint>(1);
  if(y >= x)
   return y - x;
  else
   return static_cast<uint>((static_cast<detail::int64>(1) << static_cast<detail::int64>(32)) + (static_cast<detail::int64>(y) - static_cast<detail::int64>(x)));
 }

 template<length_t L, qualifier Q>
 inline vec<L, uint, Q> usubBorrow(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& Borrow)
 {
  Borrow = mix(vec<L, uint, Q>(1), vec<L, uint, Q>(0), greaterThanEqual(x, y));
  vec<L, uint, Q> const YgeX(y - x);
  vec<L, uint, Q> const XgeY(vec<L, uint, Q>((static_cast<detail::int64>(1) << static_cast<detail::int64>(32)) + (vec<L, detail::int64, Q>(y) - vec<L, detail::int64, Q>(x))));
  return mix(XgeY, YgeX, greaterThanEqual(y, x));
 }


 inline void umulExtended(uint const& x, uint const& y, uint & msb, uint & lsb)
 {
  detail::uint64 Value64 = static_cast<detail::uint64>(x) * static_cast<detail::uint64>(y);
  msb = static_cast<uint>(Value64 >> static_cast<detail::uint64>(32));
  lsb = static_cast<uint>(Value64);
 }

 template<length_t L, qualifier Q>
 inline void umulExtended(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& msb, vec<L, uint, Q>& lsb)
 {
  vec<L, detail::uint64, Q> Value64(vec<L, detail::uint64, Q>(x) * vec<L, detail::uint64, Q>(y));
  msb = vec<L, uint, Q>(Value64 >> static_cast<detail::uint64>(32));
  lsb = vec<L, uint, Q>(Value64);
 }


 inline void imulExtended(int x, int y, int& msb, int& lsb)
 {
  detail::int64 Value64 = static_cast<detail::int64>(x) * static_cast<detail::int64>(y);
  msb = static_cast<int>(Value64 >> static_cast<detail::int64>(32));
  lsb = static_cast<int>(Value64);
 }

 template<length_t L, qualifier Q>
 inline void imulExtended(vec<L, int, Q> const& x, vec<L, int, Q> const& y, vec<L, int, Q>& msb, vec<L, int, Q>& lsb)
 {
  vec<L, detail::int64, Q> Value64(vec<L, detail::int64, Q>(x) * vec<L, detail::int64, Q>(y));
  lsb = vec<L, int, Q>(Value64 & static_cast<detail::int64>(0xFFFFFFFF));
  msb = vec<L, int, Q>((Value64 >> static_cast<detail::int64>(32)) & static_cast<detail::int64>(0xFFFFFFFF));
 }


 template<typename genIUType>
 inline genIUType bitfieldExtract(genIUType Value, int Offset, int Bits)
 {
  return bitfieldExtract(vec<1, genIUType>(Value), Offset, Bits).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> bitfieldExtract(vec<L, T, Q> const& Value, int Offset, int Bits)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_integer), 0) ? __assert_rtn(__func__, "func_integer.inl", 256, "std::numeric_limits<T>::is_integer") : (void)0);

  return (Value >> static_cast<T>(Offset)) & static_cast<T>(detail::mask(Bits));
 }


 template<typename genIUType>
 inline genIUType bitfieldInsert(genIUType const& Base, genIUType const& Insert, int Offset, int Bits)
 {
  (__builtin_expect(!(std::numeric_limits<genIUType>::is_integer), 0) ? __assert_rtn(__func__, "func_integer.inl", 265, "std::numeric_limits<genIUType>::is_integer") : (void)0);

  return bitfieldInsert(vec<1, genIUType>(Base), vec<1, genIUType>(Insert), Offset, Bits).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> bitfieldInsert(vec<L, T, Q> const& Base, vec<L, T, Q> const& Insert, int Offset, int Bits)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_integer), 0) ? __assert_rtn(__func__, "func_integer.inl", 273, "std::numeric_limits<T>::is_integer") : (void)0);

  T const Mask = detail::mask(static_cast<T>(Bits)) << Offset;
  return (Base & ~Mask) | ((Insert << static_cast<T>(Offset)) & Mask);
 }







 template<typename genIUType>
 inline genIUType bitfieldReverse(genIUType x)
 {
  (__builtin_expect(!(std::numeric_limits<genIUType>::is_integer), 0) ? __assert_rtn(__func__, "func_integer.inl", 288, "std::numeric_limits<genIUType>::is_integer") : (void)0);

  return bitfieldReverse(glm::vec<1, genIUType, glm::defaultp>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> bitfieldReverse(vec<L, T, Q> const& v)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_integer), 0) ? __assert_rtn(__func__, "func_integer.inl", 296, "std::numeric_limits<T>::is_integer") : (void)0);

  vec<L, T, Q> x(v);
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 2>::call(x, static_cast<T>(0x5555555555555555ull), static_cast<T>( 1));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 4>::call(x, static_cast<T>(0x3333333333333333ull), static_cast<T>( 2));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 8>::call(x, static_cast<T>(0x0F0F0F0F0F0F0F0Full), static_cast<T>( 4));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 16>::call(x, static_cast<T>(0x00FF00FF00FF00FFull), static_cast<T>( 8));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 32>::call(x, static_cast<T>(0x0000FFFF0000FFFFull), static_cast<T>(16));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 64>::call(x, static_cast<T>(0x00000000FFFFFFFFull), static_cast<T>(32));
  return x;
 }






 template<typename genIUType>
 inline int bitCount(genIUType x)
 {
  (__builtin_expect(!(std::numeric_limits<genIUType>::is_integer), 0) ? __assert_rtn(__func__, "func_integer.inl", 316, "std::numeric_limits<genIUType>::is_integer") : (void)0);

  return bitCount(glm::vec<1, genIUType, glm::defaultp>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, int, Q> bitCount(vec<L, T, Q> const& v)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_integer), 0) ? __assert_rtn(__func__, "func_integer.inl", 324, "std::numeric_limits<T>::is_integer") : (void)0);






  vec<L, typename detail::make_unsigned<T>::type, Q> x(v);
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 2>::call(x, typename detail::make_unsigned<T>::type(0x5555555555555555ull), typename detail::make_unsigned<T>::type( 1));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 4>::call(x, typename detail::make_unsigned<T>::type(0x3333333333333333ull), typename detail::make_unsigned<T>::type( 2));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 8>::call(x, typename detail::make_unsigned<T>::type(0x0F0F0F0F0F0F0F0Full), typename detail::make_unsigned<T>::type( 4));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 16>::call(x, typename detail::make_unsigned<T>::type(0x00FF00FF00FF00FFull), typename detail::make_unsigned<T>::type( 8));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 32>::call(x, typename detail::make_unsigned<T>::type(0x0000FFFF0000FFFFull), typename detail::make_unsigned<T>::type(16));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 64>::call(x, typename detail::make_unsigned<T>::type(0x00000000FFFFFFFFull), typename detail::make_unsigned<T>::type(32));
  return vec<L, int, Q>(x);




 }


 template<typename genIUType>
 inline int findLSB(genIUType Value)
 {
  (__builtin_expect(!(std::numeric_limits<genIUType>::is_integer), 0) ? __assert_rtn(__func__, "func_integer.inl", 349, "std::numeric_limits<genIUType>::is_integer") : (void)0);

  return detail::compute_findLSB<genIUType, sizeof(genIUType) * 8>::call(Value);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, int, Q> findLSB(vec<L, T, Q> const& x)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_integer), 0) ? __assert_rtn(__func__, "func_integer.inl", 357, "std::numeric_limits<T>::is_integer") : (void)0);

  return detail::functor1<vec, L, int, T, Q>::call(findLSB, x);
 }


 template<typename genIUType>
 inline int findMSB(genIUType v)
 {
  (__builtin_expect(!(std::numeric_limits<genIUType>::is_integer), 0) ? __assert_rtn(__func__, "func_integer.inl", 366, "std::numeric_limits<genIUType>::is_integer") : (void)0);

  return findMSB(vec<1, genIUType>(v)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, int, Q> findMSB(vec<L, T, Q> const& v)
 {
  (__builtin_expect(!(std::numeric_limits<T>::is_integer), 0) ? __assert_rtn(__func__, "func_integer.inl", 374, "std::numeric_limits<T>::is_integer") : (void)0);

  return detail::compute_findMSB_vec<L, T, Q, static_cast<int>(sizeof(T) * 8)>::call(v);
 }
}






#pragma clang diagnostic pop
# 213 "/opt/homebrew/include/glm/integer.hpp" 2
# 138 "/opt/homebrew/include/glm/glm.hpp" 2
# 6 "src/core/WindowManager.h" 2

class WindowManager {
public:
    static GLFWwindow* createWindow(int width, int height, const char* title);
    static void processInput(GLFWwindow* window, glm::vec3& cameraPos, glm::vec3& cameraFront);
    static void mouseCallback(GLFWwindow* window, double xpos, double ypos);
};
# 5 "src/core/Application.h" 2
# 1 "src/core/Camera.h" 1





class Camera {
public:
    Camera(glm::vec3 position);
    void processMouseMovement(float xOffset, float yOffset);
    glm::mat4 getViewMatrix();

    glm::vec3 position;
    glm::vec3 front;
    glm::vec3 up;

private:
    float yaw;
    float pitch;
};
# 6 "src/core/Application.h" 2
# 1 "src/core/Renderer.h" 1



# 1 "/opt/homebrew/include/GL/glew.h" 1
# 282 "/opt/homebrew/include/GL/glew.h"
extern "C" {
# 1217 "/opt/homebrew/include/GL/glew.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 3
extern "C" {
# 219 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 3
class GLUnurbs;
class GLUquadric;
class GLUtesselator;

typedef class GLUnurbs GLUnurbsObj __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
typedef class GLUquadric GLUquadricObj __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
typedef class GLUtesselator GLUtesselatorObj __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
typedef class GLUtesselator GLUtriangulatorObj __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
# 240 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 3
extern void gluBeginCurve (GLUnurbs* nurb) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluBeginPolygon (GLUtesselator* tess) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluBeginSurface (GLUnurbs* nurb) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluBeginTrim (GLUnurbs* nurb) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLint gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data) __attribute__((availability(macos,introduced=10_2,deprecated=10_9,message="" "\"Use glGenerateMipmap\"" "")));
extern GLint gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data) __attribute__((availability(macos,introduced=10_0,deprecated=10_9,message="" "\"Use glGenerateMipmap\"" "")));
extern GLint gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data) __attribute__((availability(macos,introduced=10_2,deprecated=10_9,message="" "\"Use glGenerateMipmap\"" "")));
extern GLint gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data) __attribute__((availability(macos,introduced=10_0,deprecated=10_9,message="" "\"Use glGenerateMipmap\"" "")));
extern GLint gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data) __attribute__((availability(macos,introduced=10_2,deprecated=10_9,message="" "\"Use glGenerateMipmap\"" "")));
extern GLint gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data) __attribute__((availability(macos,introduced=10_2,deprecated=10_9,message="" "\"Use glGenerateMipmap\"" "")));
extern GLboolean gluCheckExtension (const GLubyte *extName, const GLubyte *extString) __attribute__((availability(macos,introduced=10.2,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluCylinder (GLUquadric* quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluDeleteNurbsRenderer (GLUnurbs* nurb) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluDeleteQuadric (GLUquadric* quad) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluDeleteTess (GLUtesselator* tess) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluEndCurve (GLUnurbs* nurb) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluEndPolygon (GLUtesselator* tess) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluEndSurface (GLUnurbs* nurb) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluEndTrim (GLUnurbs* nurb) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern const GLubyte * gluErrorString (GLenum error) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluGetNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat* data) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern const GLubyte * gluGetString (GLenum name) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluGetTessProperty (GLUtesselator* tess, GLenum which, GLdouble* data) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluLoadSamplingMatrices (GLUnurbs* nurb, const GLfloat *model, const GLfloat *perspective, const GLint *view) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluLookAt (GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ) __attribute__((availability(macos,introduced=10_0,deprecated=10_9,message="" "\"Use GLKMatrix4MakeLookAt\"" "")));
extern GLUnurbs* gluNewNurbsRenderer (void) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLUquadric* gluNewQuadric (void) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLUtesselator* gluNewTess (void) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluNextContour (GLUtesselator* tess, GLenum type) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluNurbsCallback (GLUnurbs* nurb, GLenum which, GLvoid (*CallBackFunc)()) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluNurbsCallbackData (GLUnurbs* nurb, GLvoid* userData) __attribute__((availability(macos,introduced=10.2,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluNurbsCurve (GLUnurbs* nurb, GLint knotCount, GLfloat *knots, GLint stride, GLfloat *control, GLint order, GLenum type) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat value) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluNurbsSurface (GLUnurbs* nurb, GLint sKnotCount, GLfloat* sKnots, GLint tKnotCount, GLfloat* tKnots, GLint sStride, GLint tStride, GLfloat* control, GLint sOrder, GLint tOrder, GLenum type) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluOrtho2D (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top) __attribute__((availability(macos,introduced=10_0,deprecated=10_9,message="" "\"Use GLKMatrix4MakeOrtho\"" "")));
extern void gluPartialDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluPerspective (GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar) __attribute__((availability(macos,introduced=10_0,deprecated=10_9,message="" "\"Use GLKMatrix4MakePerspective\"" "")));
extern void gluPickMatrix (GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint *viewport) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLint gluProject (GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* winX, GLdouble* winY, GLdouble* winZ) __attribute__((availability(macos,introduced=10_0,deprecated=10_9,message="" "\"Use GLKMathProject\"" "")));
extern void gluPwlCurve (GLUnurbs* nurb, GLint count, GLfloat* data, GLint stride, GLenum type) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluQuadricCallback (GLUquadric* quad, GLenum which, GLvoid (*CallBackFunc)()) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluQuadricDrawStyle (GLUquadric* quad, GLenum draw) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluQuadricNormals (GLUquadric* quad, GLenum normal) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluQuadricOrientation (GLUquadric* quad, GLenum orientation) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluQuadricTexture (GLUquadric* quad, GLboolean texture) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLint gluScaleImage (GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void *dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid* dataOut) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluSphere (GLUquadric* quad, GLdouble radius, GLint slices, GLint stacks) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluTessBeginContour (GLUtesselator* tess) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluTessBeginPolygon (GLUtesselator* tess, GLvoid* data) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluTessCallback (GLUtesselator* tess, GLenum which, GLvoid (*CallBackFunc)()) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluTessEndContour (GLUtesselator* tess) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluTessEndPolygon (GLUtesselator* tess) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluTessNormal (GLUtesselator* tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluTessProperty (GLUtesselator* tess, GLenum which, GLdouble data) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern void gluTessVertex (GLUtesselator* tess, GLdouble *location, GLvoid* data) __attribute__((availability(macos,introduced=10.0,deprecated=10.9,message="OpenGL API deprecated. (Define GL_SILENCE_DEPRECATION to silence these warnings)")));
extern GLint gluUnProject (GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* objX, GLdouble* objY, GLdouble* objZ) __attribute__((availability(macos,introduced=10_0,deprecated=10_9,message="" "\"Use GLKMathUnproject\"" "")));
extern GLint gluUnProject4 (GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble nearPlane, GLdouble farPlane, GLdouble* objX, GLdouble* objY, GLdouble* objZ, GLdouble* objW) __attribute__((availability(macos,introduced=10_2,deprecated=10_9,message="" "\"Use GLKMathUnproject\"" "")));


}
# 1218 "/opt/homebrew/include/GL/glew.h" 2
# 2180 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBEGINCONDITIONALRENDERPROC) (GLuint id, GLenum mode);
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKPROC) (GLenum primitiveMode);
typedef void ( * PFNGLBINDFRAGDATALOCATIONPROC) (GLuint program, GLuint colorNumber, const GLchar* name);
typedef void ( * PFNGLCLAMPCOLORPROC) (GLenum target, GLenum clamp);
typedef void ( * PFNGLCLEARBUFFERFIPROC) (GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil);
typedef void ( * PFNGLCLEARBUFFERFVPROC) (GLenum buffer, GLint drawBuffer, const GLfloat* value);
typedef void ( * PFNGLCLEARBUFFERIVPROC) (GLenum buffer, GLint drawBuffer, const GLint* value);
typedef void ( * PFNGLCLEARBUFFERUIVPROC) (GLenum buffer, GLint drawBuffer, const GLuint* value);
typedef void ( * PFNGLCOLORMASKIPROC) (GLuint buf, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
typedef void ( * PFNGLDISABLEIPROC) (GLenum cap, GLuint index);
typedef void ( * PFNGLENABLEIPROC) (GLenum cap, GLuint index);
typedef void ( * PFNGLENDCONDITIONALRENDERPROC) (void);
typedef void ( * PFNGLENDTRANSFORMFEEDBACKPROC) (void);
typedef void ( * PFNGLGETBOOLEANI_VPROC) (GLenum pname, GLuint index, GLboolean* data);
typedef GLint ( * PFNGLGETFRAGDATALOCATIONPROC) (GLuint program, const GLchar* name);
typedef const GLubyte* ( * PFNGLGETSTRINGIPROC) (GLenum name, GLuint index);
typedef void ( * PFNGLGETTEXPARAMETERIIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXPARAMETERIUIVPROC) (GLenum target, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);
typedef void ( * PFNGLGETUNIFORMUIVPROC) (GLuint program, GLint location, GLuint* params);
typedef void ( * PFNGLGETVERTEXATTRIBIIVPROC) (GLuint index, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVERTEXATTRIBIUIVPROC) (GLuint index, GLenum pname, GLuint* params);
typedef GLboolean ( * PFNGLISENABLEDIPROC) (GLenum cap, GLuint index);
typedef void ( * PFNGLTEXPARAMETERIIVPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLTEXPARAMETERIUIVPROC) (GLenum target, GLenum pname, const GLuint* params);
typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSPROC) (GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode);
typedef void ( * PFNGLUNIFORM1UIPROC) (GLint location, GLuint v0);
typedef void ( * PFNGLUNIFORM1UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLUNIFORM2UIPROC) (GLint location, GLuint v0, GLuint v1);
typedef void ( * PFNGLUNIFORM2UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLUNIFORM3UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLUNIFORM3UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLUNIFORM4UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLUNIFORM4UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLVERTEXATTRIBI1IPROC) (GLuint index, GLint v0);
typedef void ( * PFNGLVERTEXATTRIBI1IVPROC) (GLuint index, const GLint* v0);
typedef void ( * PFNGLVERTEXATTRIBI1UIPROC) (GLuint index, GLuint v0);
typedef void ( * PFNGLVERTEXATTRIBI1UIVPROC) (GLuint index, const GLuint* v0);
typedef void ( * PFNGLVERTEXATTRIBI2IPROC) (GLuint index, GLint v0, GLint v1);
typedef void ( * PFNGLVERTEXATTRIBI2IVPROC) (GLuint index, const GLint* v0);
typedef void ( * PFNGLVERTEXATTRIBI2UIPROC) (GLuint index, GLuint v0, GLuint v1);
typedef void ( * PFNGLVERTEXATTRIBI2UIVPROC) (GLuint index, const GLuint* v0);
typedef void ( * PFNGLVERTEXATTRIBI3IPROC) (GLuint index, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLVERTEXATTRIBI3IVPROC) (GLuint index, const GLint* v0);
typedef void ( * PFNGLVERTEXATTRIBI3UIPROC) (GLuint index, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLVERTEXATTRIBI3UIVPROC) (GLuint index, const GLuint* v0);
typedef void ( * PFNGLVERTEXATTRIBI4BVPROC) (GLuint index, const GLbyte* v0);
typedef void ( * PFNGLVERTEXATTRIBI4IPROC) (GLuint index, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLVERTEXATTRIBI4IVPROC) (GLuint index, const GLint* v0);
typedef void ( * PFNGLVERTEXATTRIBI4SVPROC) (GLuint index, const GLshort* v0);
typedef void ( * PFNGLVERTEXATTRIBI4UBVPROC) (GLuint index, const GLubyte* v0);
typedef void ( * PFNGLVERTEXATTRIBI4UIPROC) (GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLVERTEXATTRIBI4UIVPROC) (GLuint index, const GLuint* v0);
typedef void ( * PFNGLVERTEXATTRIBI4USVPROC) (GLuint index, const GLushort* v0);
typedef void ( * PFNGLVERTEXATTRIBIPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void*pointer);
# 2336 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWARRAYSINSTANCEDPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
typedef void ( * PFNGLPRIMITIVERESTARTINDEXPROC) (GLuint buffer);
typedef void ( * PFNGLTEXBUFFERPROC) (GLenum target, GLenum internalFormat, GLuint buffer);
# 2378 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERTEXTUREPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLGETBUFFERPARAMETERI64VPROC) (GLenum target, GLenum value, GLint64 * data);
typedef void ( * PFNGLGETINTEGER64I_VPROC) (GLenum pname, GLuint index, GLint64 * data);
# 2398 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLVERTEXATTRIBDIVISORPROC) (GLuint index, GLuint divisor);
# 2424 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBLENDEQUATIONSEPARATEIPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDEQUATIONIPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDFUNCSEPARATEIPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void ( * PFNGLBLENDFUNCIPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void ( * PFNGLMINSAMPLESHADINGPROC) (GLclampf value);
# 2499 "/opt/homebrew/include/GL/glew.h"
typedef GLenum ( * PFNGLGETGRAPHICSRESETSTATUSPROC) (void);
typedef void ( * PFNGLGETNCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint lod, GLsizei bufSize, GLvoid *pixels);
typedef void ( * PFNGLGETNTEXIMAGEPROC) (GLenum tex, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *pixels);
typedef void ( * PFNGLGETNUNIFORMDVPROC) (GLuint program, GLint location, GLsizei bufSize, GLdouble *params);
# 2541 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC) (GLenum mode, const GLvoid *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC) (GLenum mode, GLenum type, const GLvoid *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void ( * PFNGLSPECIALIZESHADERPROC) (GLuint shader, const GLchar *pEntryPoint, GLuint numSpecializationConstants, const GLuint *pConstantIndex, const GLuint *pConstantValue);
# 2572 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTBUFFERMASK3DFXPROC) (GLuint mask);
# 2658 "/opt/homebrew/include/GL/glew.h"
typedef void ( *GLDEBUGPROCAMD)(GLuint id, GLenum category, GLenum severity, GLsizei length, const GLchar* message, void* userParam);

typedef void ( * PFNGLDEBUGMESSAGECALLBACKAMDPROC) (GLDEBUGPROCAMD callback, void *userParam);
typedef void ( * PFNGLDEBUGMESSAGEENABLEAMDPROC) (GLenum category, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void ( * PFNGLDEBUGMESSAGEINSERTAMDPROC) (GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar* buf);
typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGAMDPROC) (GLuint count, GLsizei bufsize, GLenum* categories, GLuint* severities, GLuint* ids, GLsizei* lengths, GLchar* message);
# 2691 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBLENDEQUATIONINDEXEDAMDPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDFUNCINDEXEDAMDPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void ( * PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
# 2717 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC) (GLuint renderbuffer, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC) (GLenum target, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height);
# 2737 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC) (GLenum target, GLuint numsamples, GLuint pixelindex, const GLfloat* values);
typedef void ( * PFNGLGETFRAMEBUFFERPARAMETERFVAMDPROC) (GLenum target, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat* values);
typedef void ( * PFNGLGETNAMEDFRAMEBUFFERPARAMETERFVAMDPROC) (GLuint framebuffer, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat* values);
typedef void ( * PFNGLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC) (GLuint framebuffer, GLuint numsamples, GLuint pixelindex, const GLfloat* values);
# 2855 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLVERTEXATTRIBPARAMETERIAMDPROC) (GLuint index, GLenum pname, GLint param);
# 2868 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC) (GLenum mode, const void *indirect, GLsizei primcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei primcount, GLsizei stride);
# 2889 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDELETENAMESAMDPROC) (GLenum identifier, GLuint num, const GLuint* names);
typedef void ( * PFNGLGENNAMESAMDPROC) (GLenum identifier, GLuint num, GLuint* names);
typedef GLboolean ( * PFNGLISNAMEAMDPROC) (GLenum identifier, GLuint name);
# 2913 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLQUERYOBJECTPARAMETERUIAMDPROC) (GLenum target, GLuint id, GLenum pname, GLuint param);
# 2934 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBEGINPERFMONITORAMDPROC) (GLuint monitor);
typedef void ( * PFNGLDELETEPERFMONITORSAMDPROC) (GLsizei n, GLuint* monitors);
typedef void ( * PFNGLENDPERFMONITORAMDPROC) (GLuint monitor);
typedef void ( * PFNGLGENPERFMONITORSAMDPROC) (GLsizei n, GLuint* monitors);
typedef void ( * PFNGLGETPERFMONITORCOUNTERDATAAMDPROC) (GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint *bytesWritten);
typedef void ( * PFNGLGETPERFMONITORCOUNTERINFOAMDPROC) (GLuint group, GLuint counter, GLenum pname, void *data);
typedef void ( * PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC) (GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, GLchar *counterString);
typedef void ( * PFNGLGETPERFMONITORCOUNTERSAMDPROC) (GLuint group, GLint* numCounters, GLint *maxActiveCounters, GLsizei countersSize, GLuint *counters);
typedef void ( * PFNGLGETPERFMONITORGROUPSTRINGAMDPROC) (GLuint group, GLsizei bufSize, GLsizei* length, GLchar *groupString);
typedef void ( * PFNGLGETPERFMONITORGROUPSAMDPROC) (GLint* numGroups, GLsizei groupsSize, GLuint *groups);
typedef void ( * PFNGLSELECTPERFMONITORCOUNTERSAMDPROC) (GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* counterList);
# 3004 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLSETMULTISAMPLEFVAMDPROC) (GLenum pname, GLuint index, const GLfloat* val);
# 3101 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXSTORAGESPARSEAMDPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);
typedef void ( * PFNGLTEXTURESTORAGESPARSEAMDPROC) (GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);
# 3121 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLSTENCILOPVALUEAMDPROC) (GLenum face, GLuint value);
# 3189 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTESSELLATIONFACTORAMDPROC) (GLfloat factor);
typedef void ( * PFNGLTESSELLATIONMODEAMDPROC) (GLenum mode);
# 3236 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBLITFRAMEBUFFERANGLEPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
# 3253 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEANGLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 3268 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWARRAYSINSTANCEDANGLEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDANGLEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
typedef void ( * PFNGLVERTEXATTRIBDIVISORANGLEPROC) (GLuint index, GLuint divisor);
# 3368 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBEGINQUERYANGLEPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETEQUERIESANGLEPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLENDQUERYANGLEPROC) (GLenum target);
typedef void ( * PFNGLGENQUERIESANGLEPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETQUERYOBJECTI64VANGLEPROC) (GLuint id, GLenum pname, GLint64* params);
typedef void ( * PFNGLGETQUERYOBJECTIVANGLEPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETQUERYOBJECTUI64VANGLEPROC) (GLuint id, GLenum pname, GLuint64* params);
typedef void ( * PFNGLGETQUERYOBJECTUIVANGLEPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETQUERYIVANGLEPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISQUERYANGLEPROC) (GLuint id);
typedef void ( * PFNGLQUERYCOUNTERANGLEPROC) (GLuint id, GLenum target);
# 3403 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC) (GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source);
# 3466 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOPYTEXTURELEVELSAPPLEPROC) (GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount);
# 3483 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, GLint first, GLsizei count);
typedef void ( * PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
typedef void ( * PFNGLELEMENTPOINTERAPPLEPROC) (GLenum type, const void *pointer);
typedef void ( * PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, const GLint* first, const GLsizei *count, GLsizei primcount);
typedef void ( * PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, const GLint* first, const GLsizei *count, GLsizei primcount);
# 3507 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDELETEFENCESAPPLEPROC) (GLsizei n, const GLuint* fences);
typedef void ( * PFNGLFINISHFENCEAPPLEPROC) (GLuint fence);
typedef void ( * PFNGLFINISHOBJECTAPPLEPROC) (GLenum object, GLint name);
typedef void ( * PFNGLGENFENCESAPPLEPROC) (GLsizei n, GLuint* fences);
typedef GLboolean ( * PFNGLISFENCEAPPLEPROC) (GLuint fence);
typedef void ( * PFNGLSETFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean ( * PFNGLTESTFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean ( * PFNGLTESTOBJECTAPPLEPROC) (GLenum object, GLuint name);
# 3561 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBUFFERPARAMETERIAPPLEPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC) (GLenum target, GLintptr offset, GLsizeiptr size);
# 3584 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEAPPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLRESOLVEMULTISAMPLEFRAMEBUFFERAPPLEPROC) (void);
# 3606 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETOBJECTPARAMETERIVAPPLEPROC) (GLenum objectType, GLuint name, GLenum pname, GLint* params);
typedef GLenum ( * PFNGLOBJECTPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);
typedef GLenum ( * PFNGLOBJECTUNPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);
# 3688 "/opt/homebrew/include/GL/glew.h"
typedef GLenum ( * PFNGLCLIENTWAITSYNCAPPLEPROC) (GLsync GLsync, GLbitfield flags, GLuint64 timeout);
typedef void ( * PFNGLDELETESYNCAPPLEPROC) (GLsync GLsync);
typedef GLsync ( * PFNGLFENCESYNCAPPLEPROC) (GLenum condition, GLbitfield flags);
typedef void ( * PFNGLGETINTEGER64VAPPLEPROC) (GLenum pname, GLint64* params);
typedef void ( * PFNGLGETSYNCIVAPPLEPROC) (GLsync GLsync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint *values);
typedef GLboolean ( * PFNGLISSYNCAPPLEPROC) (GLsync GLsync);
typedef void ( * PFNGLWAITSYNCAPPLEPROC) (GLsync GLsync, GLbitfield flags, GLuint64 timeout);
# 3766 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC) (GLenum target, GLenum pname, void **params);
typedef void ( * PFNGLTEXTURERANGEAPPLEPROC) (GLenum target, GLsizei length, void *pointer);
# 3794 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDVERTEXARRAYAPPLEPROC) (GLuint array);
typedef void ( * PFNGLDELETEVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint* arrays);
typedef void ( * PFNGLGENVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint* arrays);
typedef GLboolean ( * PFNGLISVERTEXARRAYAPPLEPROC) (GLuint array);
# 3822 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, void *pointer);
typedef void ( * PFNGLVERTEXARRAYPARAMETERIAPPLEPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, void *pointer);
# 3850 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDISABLEVERTEXATTRIBAPPLEPROC) (GLuint index, GLenum pname);
typedef void ( * PFNGLENABLEVERTEXATTRIBAPPLEPROC) (GLuint index, GLenum pname);
typedef GLboolean ( * PFNGLISVERTEXATTRIBENABLEDAPPLEPROC) (GLuint index, GLenum pname);
typedef void ( * PFNGLMAPVERTEXATTRIB1DAPPLEPROC) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble* points);
typedef void ( * PFNGLMAPVERTEXATTRIB1FAPPLEPROC) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat* points);
typedef void ( * PFNGLMAPVERTEXATTRIB2DAPPLEPROC) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble* points);
typedef void ( * PFNGLMAPVERTEXATTRIB2FAPPLEPROC) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat* points);
# 3903 "/opt/homebrew/include/GL/glew.h"
typedef int GLfixed;

typedef void ( * PFNGLCLEARDEPTHFPROC) (GLclampf d);
typedef void ( * PFNGLDEPTHRANGEFPROC) (GLclampf n, GLclampf f);
typedef void ( * PFNGLGETSHADERPRECISIONFORMATPROC) (GLenum shadertype, GLenum precisiontype, GLint* range, GLint *precision);
typedef void ( * PFNGLRELEASESHADERCOMPILERPROC) (void);
typedef void ( * PFNGLSHADERBINARYPROC) (GLsizei count, const GLuint* shaders, GLenum binaryformat, const void*binary, GLsizei length);
# 3926 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLMEMORYBARRIERBYREGIONPROC) (GLbitfield barriers);
# 3943 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLPRIMITIVEBOUNDINGBOXARBPROC) (GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW);
# 3989 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, GLuint baseinstance);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance);
# 4008 "/opt/homebrew/include/GL/glew.h"
typedef GLuint64 ( * PFNGLGETIMAGEHANDLEARBPROC) (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef GLuint64 ( * PFNGLGETTEXTUREHANDLEARBPROC) (GLuint texture);
typedef GLuint64 ( * PFNGLGETTEXTURESAMPLERHANDLEARBPROC) (GLuint texture, GLuint sampler);
typedef void ( * PFNGLGETVERTEXATTRIBLUI64VARBPROC) (GLuint index, GLenum pname, GLuint64EXT* params);
typedef GLboolean ( * PFNGLISIMAGEHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef GLboolean ( * PFNGLISTEXTUREHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKEIMAGEHANDLERESIDENTARBPROC) (GLuint64 handle, GLenum access);
typedef void ( * PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKETEXTUREHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC) (GLuint program, GLint location, GLuint64 value);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
typedef void ( * PFNGLUNIFORMHANDLEUI64ARBPROC) (GLint location, GLuint64 value);
typedef void ( * PFNGLUNIFORMHANDLEUI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLVERTEXATTRIBL1UI64ARBPROC) (GLuint index, GLuint64EXT x);
typedef void ( * PFNGLVERTEXATTRIBL1UI64VARBPROC) (GLuint index, const GLuint64EXT* v);
# 4056 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDFRAGDATALOCATIONINDEXEDPROC) (GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
typedef GLint ( * PFNGLGETFRAGDATAINDEXPROC) (GLuint program, const GLchar * name);
# 4081 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBUFFERSTORAGEPROC) (GLenum target, GLsizeiptr size, const void *data, GLbitfield flags);
# 4097 "/opt/homebrew/include/GL/glew.h"
typedef struct _cl_context *cl_context;
typedef struct _cl_event *cl_event;

typedef GLsync ( * PFNGLCREATESYNCFROMCLEVENTARBPROC) (cl_context context, cl_event event, GLbitfield flags);
# 4113 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCLEARBUFFERDATAPROC) (GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCLEARBUFFERSUBDATAPROC) (GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCLEARNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
# 4134 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCLEARTEXIMAGEPROC) (GLuint texture, GLint level, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCLEARTEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
# 4156 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCLIPCONTROLPROC) (GLenum origin, GLenum depth);
# 4175 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCLAMPCOLORARBPROC) (GLenum target, GLenum clamp);
# 4234 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDISPATCHCOMPUTEPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
typedef void ( * PFNGLDISPATCHCOMPUTEINDIRECTPROC) (GLintptr indirect);
# 4254 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z);
# 4293 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOPYBUFFERSUBDATAPROC) (GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);
# 4306 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOPYIMAGESUBDATAPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
# 4354 "/opt/homebrew/include/GL/glew.h"
typedef void ( *GLDEBUGPROCARB)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);

typedef void ( * PFNGLDEBUGMESSAGECALLBACKARBPROC) (GLDEBUGPROCARB callback, const void *userParam);
typedef void ( * PFNGLDEBUGMESSAGECONTROLARBPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void ( * PFNGLDEBUGMESSAGEINSERTARBPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGARBPROC) (GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);
# 4426 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDTEXTUREUNITPROC) (GLuint unit, GLuint texture);
typedef void ( * PFNGLBLITNAMEDFRAMEBUFFERPROC) (GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef GLenum ( * PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC) (GLuint framebuffer, GLenum target);
typedef void ( * PFNGLCLEARNAMEDBUFFERDATAPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCLEARNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCLEARNAMEDFRAMEBUFFERFIPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
typedef void ( * PFNGLCLEARNAMEDFRAMEBUFFERFVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat* value);
typedef void ( * PFNGLCLEARNAMEDFRAMEBUFFERIVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint* value);
typedef void ( * PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint* value);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOPYNAMEDBUFFERSUBDATAPROC) (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCREATEBUFFERSPROC) (GLsizei n, GLuint* buffers);
typedef void ( * PFNGLCREATEFRAMEBUFFERSPROC) (GLsizei n, GLuint* framebuffers);
typedef void ( * PFNGLCREATEPROGRAMPIPELINESPROC) (GLsizei n, GLuint* pipelines);
typedef void ( * PFNGLCREATEQUERIESPROC) (GLenum target, GLsizei n, GLuint* ids);
typedef void ( * PFNGLCREATERENDERBUFFERSPROC) (GLsizei n, GLuint* renderbuffers);
typedef void ( * PFNGLCREATESAMPLERSPROC) (GLsizei n, GLuint* samplers);
typedef void ( * PFNGLCREATETEXTURESPROC) (GLenum target, GLsizei n, GLuint* textures);
typedef void ( * PFNGLCREATETRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLCREATEVERTEXARRAYSPROC) (GLsizei n, GLuint* arrays);
typedef void ( * PFNGLDISABLEVERTEXARRAYATTRIBPROC) (GLuint vaobj, GLuint index);
typedef void ( * PFNGLENABLEVERTEXARRAYATTRIBPROC) (GLuint vaobj, GLuint index);
typedef void ( * PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void ( * PFNGLGENERATETEXTUREMIPMAPPROC) (GLuint texture);
typedef void ( * PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC) (GLuint texture, GLint level, GLsizei bufSize, void *pixels);
typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERI64VPROC) (GLuint buffer, GLenum pname, GLint64* params);
typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERIVPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDBUFFERPOINTERVPROC) (GLuint buffer, GLenum pname, void** params);
typedef void ( * PFNGLGETNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, void *data);
typedef void ( * PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC) (GLuint framebuffer, GLenum pname, GLint* param);
typedef void ( * PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC) (GLuint renderbuffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETQUERYBUFFEROBJECTI64VPROC) (GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void ( * PFNGLGETQUERYBUFFEROBJECTIVPROC) (GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void ( * PFNGLGETQUERYBUFFEROBJECTUI64VPROC) (GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void ( * PFNGLGETQUERYBUFFEROBJECTUIVPROC) (GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void ( * PFNGLGETTEXTUREIMAGEPROC) (GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
typedef void ( * PFNGLGETTEXTURELEVELPARAMETERFVPROC) (GLuint texture, GLint level, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETTEXTURELEVELPARAMETERIVPROC) (GLuint texture, GLint level, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIIVPROC) (GLuint texture, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIUIVPROC) (GLuint texture, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERFVPROC) (GLuint texture, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIVPROC) (GLuint texture, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKI64_VPROC) (GLuint xfb, GLenum pname, GLuint index, GLint64* param);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKI_VPROC) (GLuint xfb, GLenum pname, GLuint index, GLint* param);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKIVPROC) (GLuint xfb, GLenum pname, GLint* param);
typedef void ( * PFNGLGETVERTEXARRAYINDEXED64IVPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint64* param);
typedef void ( * PFNGLGETVERTEXARRAYINDEXEDIVPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint* param);
typedef void ( * PFNGLGETVERTEXARRAYIVPROC) (GLuint vaobj, GLenum pname, GLint* param);
typedef void ( * PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC) (GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments);
typedef void ( * PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC) (GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void * ( * PFNGLMAPNAMEDBUFFERPROC) (GLuint buffer, GLenum access);
typedef void * ( * PFNGLMAPNAMEDBUFFERRANGEPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void ( * PFNGLNAMEDBUFFERDATAPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
typedef void ( * PFNGLNAMEDBUFFERSTORAGEPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags);
typedef void ( * PFNGLNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
typedef void ( * PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC) (GLuint framebuffer, GLenum mode);
typedef void ( * PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC) (GLuint framebuffer, GLsizei n, const GLenum* bufs);
typedef void ( * PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC) (GLuint framebuffer, GLenum pname, GLint param);
typedef void ( * PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC) (GLuint framebuffer, GLenum mode);
typedef void ( * PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC) (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEPROC) (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLTEXTUREBUFFERPROC) (GLuint texture, GLenum internalformat, GLuint buffer);
typedef void ( * PFNGLTEXTUREBUFFERRANGEPROC) (GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLTEXTUREPARAMETERIIVPROC) (GLuint texture, GLenum pname, const GLint* params);
typedef void ( * PFNGLTEXTUREPARAMETERIUIVPROC) (GLuint texture, GLenum pname, const GLuint* params);
typedef void ( * PFNGLTEXTUREPARAMETERFPROC) (GLuint texture, GLenum pname, GLfloat param);
typedef void ( * PFNGLTEXTUREPARAMETERFVPROC) (GLuint texture, GLenum pname, const GLfloat* param);
typedef void ( * PFNGLTEXTUREPARAMETERIPROC) (GLuint texture, GLenum pname, GLint param);
typedef void ( * PFNGLTEXTUREPARAMETERIVPROC) (GLuint texture, GLenum pname, const GLint* param);
typedef void ( * PFNGLTEXTURESTORAGE1DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void ( * PFNGLTEXTURESTORAGE2DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC) (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXTURESTORAGE3DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void ( * PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC) (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC) (GLuint xfb, GLuint index, GLuint buffer);
typedef void ( * PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC) (GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef GLboolean ( * PFNGLUNMAPNAMEDBUFFERPROC) (GLuint buffer);
typedef void ( * PFNGLVERTEXARRAYATTRIBBINDINGPROC) (GLuint vaobj, GLuint attribindex, GLuint bindingindex);
typedef void ( * PFNGLVERTEXARRAYATTRIBFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXARRAYATTRIBIFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXARRAYATTRIBLFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXARRAYBINDINGDIVISORPROC) (GLuint vaobj, GLuint bindingindex, GLuint divisor);
typedef void ( * PFNGLVERTEXARRAYELEMENTBUFFERPROC) (GLuint vaobj, GLuint buffer);
typedef void ( * PFNGLVERTEXARRAYVERTEXBUFFERPROC) (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void ( * PFNGLVERTEXARRAYVERTEXBUFFERSPROC) (GLuint vaobj, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizei *strides);
# 4649 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWBUFFERSARBPROC) (GLsizei n, const GLenum* bufs);
# 4662 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBLENDEQUATIONSEPARATEIARBPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDEQUATIONIARBPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDFUNCSEPARATEIARBPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void ( * PFNGLBLENDFUNCIARBPROC) (GLuint buf, GLenum src, GLenum dst);
# 4681 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex);
typedef void ( * PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex);
typedef void ( * PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, const GLsizei* count, GLenum type, const void*const *indices, GLsizei drawcount, const GLint *basevertex);
# 4703 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWARRAYSINDIRECTPROC) (GLenum mode, const void *indirect);
typedef void ( * PFNGLDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const void *indirect);
# 4844 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERPARAMETERIPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLGETFRAMEBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint* params);
typedef void ( * PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC) (GLuint framebuffer, GLenum pname, GLint param);
# 4938 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDFRAMEBUFFERPROC) (GLenum target, GLuint framebuffer);
typedef void ( * PFNGLBINDRENDERBUFFERPROC) (GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLBLITFRAMEBUFFERPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef GLenum ( * PFNGLCHECKFRAMEBUFFERSTATUSPROC) (GLenum target);
typedef void ( * PFNGLDELETEFRAMEBUFFERSPROC) (GLsizei n, const GLuint* framebuffers);
typedef void ( * PFNGLDELETERENDERBUFFERSPROC) (GLsizei n, const GLuint* renderbuffers);
typedef void ( * PFNGLFRAMEBUFFERRENDERBUFFERPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE1DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE3DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYERPROC) (GLenum target,GLenum attachment, GLuint texture,GLint level,GLint layer);
typedef void ( * PFNGLGENFRAMEBUFFERSPROC) (GLsizei n, GLuint* framebuffers);
typedef void ( * PFNGLGENRENDERBUFFERSPROC) (GLsizei n, GLuint* renderbuffers);
typedef void ( * PFNGLGENERATEMIPMAPPROC) (GLenum target);
typedef void ( * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
typedef void ( * PFNGLGETRENDERBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISFRAMEBUFFERPROC) (GLuint framebuffer);
typedef GLboolean ( * PFNGLISRENDERBUFFERPROC) (GLuint renderbuffer);
typedef void ( * PFNGLRENDERBUFFERSTORAGEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 5020 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERTEXTUREARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTUREFACEARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYERARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLPROGRAMPARAMETERIARBPROC) (GLuint program, GLenum pname, GLint value);
# 5044 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETPROGRAMBINARYPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLenum *binaryFormat, void*binary);
typedef void ( * PFNGLPROGRAMBINARYPROC) (GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);
typedef void ( * PFNGLPROGRAMPARAMETERIPROC) (GLuint program, GLenum pname, GLint value);
# 5061 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels);
typedef void ( * PFNGLGETTEXTURESUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
# 5079 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLSPECIALIZESHADERARBPROC) (GLuint shader, const GLchar* pEntryPoint, GLuint numSpecializationConstants, const GLuint* pConstantIndex, const GLuint* pConstantValue);
# 5121 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETUNIFORMDVPROC) (GLuint program, GLint location, GLdouble* params);
typedef void ( * PFNGLUNIFORM1DPROC) (GLint location, GLdouble x);
typedef void ( * PFNGLUNIFORM1DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLUNIFORM2DPROC) (GLint location, GLdouble x, GLdouble y);
typedef void ( * PFNGLUNIFORM2DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLUNIFORM3DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLUNIFORM3DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLUNIFORM4DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLUNIFORM4DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX2X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX2X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX3X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX3X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX4X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX4X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
# 5177 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETUNIFORMI64VARBPROC) (GLuint program, GLint location, GLint64* params);
typedef void ( * PFNGLGETUNIFORMUI64VARBPROC) (GLuint program, GLint location, GLuint64* params);
typedef void ( * PFNGLGETNUNIFORMI64VARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLint64* params);
typedef void ( * PFNGLGETNUNIFORMUI64VARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint64* params);
typedef void ( * PFNGLPROGRAMUNIFORM1I64ARBPROC) (GLuint program, GLint location, GLint64 x);
typedef void ( * PFNGLPROGRAMUNIFORM1I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM1UI64ARBPROC) (GLuint program, GLint location, GLuint64 x);
typedef void ( * PFNGLPROGRAMUNIFORM1UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM2I64ARBPROC) (GLuint program, GLint location, GLint64 x, GLint64 y);
typedef void ( * PFNGLPROGRAMUNIFORM2I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM2UI64ARBPROC) (GLuint program, GLint location, GLuint64 x, GLuint64 y);
typedef void ( * PFNGLPROGRAMUNIFORM2UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM3I64ARBPROC) (GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z);
typedef void ( * PFNGLPROGRAMUNIFORM3I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM3UI64ARBPROC) (GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z);
typedef void ( * PFNGLPROGRAMUNIFORM3UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM4I64ARBPROC) (GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
typedef void ( * PFNGLPROGRAMUNIFORM4I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM4UI64ARBPROC) (GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
typedef void ( * PFNGLPROGRAMUNIFORM4UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLUNIFORM1I64ARBPROC) (GLint location, GLint64 x);
typedef void ( * PFNGLUNIFORM1I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLUNIFORM1UI64ARBPROC) (GLint location, GLuint64 x);
typedef void ( * PFNGLUNIFORM1UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLUNIFORM2I64ARBPROC) (GLint location, GLint64 x, GLint64 y);
typedef void ( * PFNGLUNIFORM2I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLUNIFORM2UI64ARBPROC) (GLint location, GLuint64 x, GLuint64 y);
typedef void ( * PFNGLUNIFORM2UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLUNIFORM3I64ARBPROC) (GLint location, GLint64 x, GLint64 y, GLint64 z);
typedef void ( * PFNGLUNIFORM3I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLUNIFORM3UI64ARBPROC) (GLint location, GLuint64 x, GLuint64 y, GLuint64 z);
typedef void ( * PFNGLUNIFORM3UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLUNIFORM4I64ARBPROC) (GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
typedef void ( * PFNGLUNIFORM4I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLUNIFORM4UI64ARBPROC) (GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
typedef void ( * PFNGLUNIFORM4UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
# 5360 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table);
typedef void ( * PFNGLCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image);
typedef void ( * PFNGLCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFPROC) (GLenum target, GLenum pname, GLfloat params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIPROC) (GLenum target, GLenum pname, GLint params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCOPYCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETCOLORTABLEPROC) (GLenum target, GLenum format, GLenum type, void *table);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETCONVOLUTIONFILTERPROC) (GLenum target, GLenum format, GLenum type, void *image);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETHISTOGRAMPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETMINMAXPROC) (GLenum target, GLboolean reset, GLenum format, GLenum types, void *values);
typedef void ( * PFNGLGETMINMAXPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETMINMAXPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETSEPARABLEFILTERPROC) (GLenum target, GLenum format, GLenum type, void *row, void *column, void *span);
typedef void ( * PFNGLHISTOGRAMPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLMINMAXPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLRESETHISTOGRAMPROC) (GLenum target);
typedef void ( * PFNGLRESETMINMAXPROC) (GLenum target);
typedef void ( * PFNGLSEPARABLEFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column);
# 5438 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC) (GLenum mode, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC) (GLenum mode, GLenum type, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
# 5455 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWARRAYSINSTANCEDARBPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDARBPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
typedef void ( * PFNGLVERTEXATTRIBDIVISORARBPROC) (GLuint index, GLuint divisor);
# 5474 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETINTERNALFORMATIVPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* params);
# 5587 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETINTERNALFORMATI64VPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64* params);
# 5600 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLINVALIDATEBUFFERDATAPROC) (GLuint buffer);
typedef void ( * PFNGLINVALIDATEBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void ( * PFNGLINVALIDATEFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments);
typedef void ( * PFNGLINVALIDATESUBFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLINVALIDATETEXIMAGEPROC) (GLuint texture, GLint level);
typedef void ( * PFNGLINVALIDATETEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
# 5641 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFLUSHMAPPEDBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length);
typedef void * ( * PFNGLMAPBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
# 5667 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCURRENTPALETTEMATRIXARBPROC) (GLint index);
typedef void ( * PFNGLMATRIXINDEXPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
typedef void ( * PFNGLMATRIXINDEXUBVARBPROC) (GLint size, GLubyte *indices);
typedef void ( * PFNGLMATRIXINDEXUIVARBPROC) (GLint size, GLuint *indices);
typedef void ( * PFNGLMATRIXINDEXUSVARBPROC) (GLint size, GLushort *indices);
# 5688 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDBUFFERSBASEPROC) (GLenum target, GLuint first, GLsizei count, const GLuint* buffers);
typedef void ( * PFNGLBINDBUFFERSRANGEPROC) (GLenum target, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizeiptr *sizes);
typedef void ( * PFNGLBINDIMAGETEXTURESPROC) (GLuint first, GLsizei count, const GLuint* textures);
typedef void ( * PFNGLBINDSAMPLERSPROC) (GLuint first, GLsizei count, const GLuint* samplers);
typedef void ( * PFNGLBINDTEXTURESPROC) (GLuint first, GLsizei count, const GLuint* textures);
typedef void ( * PFNGLBINDVERTEXBUFFERSPROC) (GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizei *strides);
# 5711 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTPROC) (GLenum mode, const void *indirect, GLsizei primcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei primcount, GLsizei stride);
# 5736 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLSAMPLECOVERAGEARBPROC) (GLclampf value, GLboolean invert);
# 5785 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLACTIVETEXTUREARBPROC) (GLenum texture);
typedef void ( * PFNGLCLIENTACTIVETEXTUREARBPROC) (GLenum texture);
typedef void ( * PFNGLMULTITEXCOORD1DARBPROC) (GLenum target, GLdouble s);
typedef void ( * PFNGLMULTITEXCOORD1DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD1FARBPROC) (GLenum target, GLfloat s);
typedef void ( * PFNGLMULTITEXCOORD1FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD1IARBPROC) (GLenum target, GLint s);
typedef void ( * PFNGLMULTITEXCOORD1IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD1SARBPROC) (GLenum target, GLshort s);
typedef void ( * PFNGLMULTITEXCOORD1SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD2DARBPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void ( * PFNGLMULTITEXCOORD2DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD2FARBPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void ( * PFNGLMULTITEXCOORD2FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD2IARBPROC) (GLenum target, GLint s, GLint t);
typedef void ( * PFNGLMULTITEXCOORD2IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD2SARBPROC) (GLenum target, GLshort s, GLshort t);
typedef void ( * PFNGLMULTITEXCOORD2SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD3DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void ( * PFNGLMULTITEXCOORD3DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD3FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void ( * PFNGLMULTITEXCOORD3FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD3IARBPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void ( * PFNGLMULTITEXCOORD3IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD3SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void ( * PFNGLMULTITEXCOORD3SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD4DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void ( * PFNGLMULTITEXCOORD4DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD4FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void ( * PFNGLMULTITEXCOORD4FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD4IARBPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void ( * PFNGLMULTITEXCOORD4IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD4SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void ( * PFNGLMULTITEXCOORD4SVARBPROC) (GLenum target, const GLshort *v);
# 5870 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBEGINQUERYARBPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETEQUERIESARBPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLENDQUERYARBPROC) (GLenum target);
typedef void ( * PFNGLGENQUERIESARBPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETQUERYOBJECTIVARBPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETQUERYOBJECTUIVARBPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETQUERYIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISQUERYARBPROC) (GLuint id);
# 5911 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLMAXSHADERCOMPILERTHREADSARBPROC) (GLuint count);
# 5964 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLPOINTPARAMETERFARBPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVARBPROC) (GLenum pname, const GLfloat* params);
# 5993 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLPOLYGONOFFSETCLAMPPROC) (GLfloat factor, GLfloat units, GLfloat clamp);
# 6063 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETPROGRAMINTERFACEIVPROC) (GLuint program, GLenum programInterface, GLenum pname, GLint* params);
typedef GLuint ( * PFNGLGETPROGRAMRESOURCEINDEXPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef GLint ( * PFNGLGETPROGRAMRESOURCELOCATIONPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef GLint ( * PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef void ( * PFNGLGETPROGRAMRESOURCENAMEPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, GLchar *name);
typedef void ( * PFNGLGETPROGRAMRESOURCEIVPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei *length, GLint *params);
# 6091 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLPROVOKINGVERTEXPROC) (GLenum mode);
# 6135 "/opt/homebrew/include/GL/glew.h"
typedef GLenum ( * PFNGLGETGRAPHICSRESETSTATUSARBPROC) (void);
typedef void ( * PFNGLGETNCOLORTABLEARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* table);
typedef void ( * PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, GLsizei bufSize, void* img);
typedef void ( * PFNGLGETNCONVOLUTIONFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* image);
typedef void ( * PFNGLGETNHISTOGRAMARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values);
typedef void ( * PFNGLGETNMAPDVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLdouble* v);
typedef void ( * PFNGLGETNMAPFVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLfloat* v);
typedef void ( * PFNGLGETNMAPIVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLint* v);
typedef void ( * PFNGLGETNMINMAXARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values);
typedef void ( * PFNGLGETNPIXELMAPFVARBPROC) (GLenum map, GLsizei bufSize, GLfloat* values);
typedef void ( * PFNGLGETNPIXELMAPUIVARBPROC) (GLenum map, GLsizei bufSize, GLuint* values);
typedef void ( * PFNGLGETNPIXELMAPUSVARBPROC) (GLenum map, GLsizei bufSize, GLushort* values);
typedef void ( * PFNGLGETNPOLYGONSTIPPLEARBPROC) (GLsizei bufSize, GLubyte* pattern);
typedef void ( * PFNGLGETNSEPARABLEFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void* row, GLsizei columnBufSize, void*column, void*span);
typedef void ( * PFNGLGETNTEXIMAGEARBPROC) (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* img);
typedef void ( * PFNGLGETNUNIFORMDVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLdouble* params);
typedef void ( * PFNGLGETNUNIFORMFVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
typedef void ( * PFNGLGETNUNIFORMIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLint* params);
typedef void ( * PFNGLGETNUNIFORMUIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint* params);
typedef void ( * PFNGLREADNPIXELSARBPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data);
# 6213 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC) (GLenum target, GLuint start, GLsizei count, const GLfloat* v);
typedef void ( * PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC) (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);
# 6231 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLMINSAMPLESHADINGARBPROC) (GLclampf value);
# 6246 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDSAMPLERPROC) (GLuint unit, GLuint sampler);
typedef void ( * PFNGLDELETESAMPLERSPROC) (GLsizei count, const GLuint * samplers);
typedef void ( * PFNGLGENSAMPLERSPROC) (GLsizei count, GLuint* samplers);
typedef void ( * PFNGLGETSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef void ( * PFNGLGETSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISSAMPLERPROC) (GLuint sampler);
typedef void ( * PFNGLSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, const GLint* params);
typedef void ( * PFNGLSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, const GLuint* params);
typedef void ( * PFNGLSAMPLERPARAMETERFPROC) (GLuint sampler, GLenum pname, GLfloat param);
typedef void ( * PFNGLSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLSAMPLERPARAMETERIPROC) (GLuint sampler, GLenum pname, GLint param);
typedef void ( * PFNGLSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, const GLint* params);
# 6317 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLACTIVESHADERPROGRAMPROC) (GLuint pipeline, GLuint program);
typedef void ( * PFNGLBINDPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef GLuint ( * PFNGLCREATESHADERPROGRAMVPROC) (GLenum type, GLsizei count, const GLchar * const * strings);
typedef void ( * PFNGLDELETEPROGRAMPIPELINESPROC) (GLsizei n, const GLuint* pipelines);
typedef void ( * PFNGLGENPROGRAMPIPELINESPROC) (GLsizei n, GLuint* pipelines);
typedef void ( * PFNGLGETPROGRAMPIPELINEINFOLOGPROC) (GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar *infoLog);
typedef void ( * PFNGLGETPROGRAMPIPELINEIVPROC) (GLuint pipeline, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef void ( * PFNGLPROGRAMUNIFORM1DPROC) (GLuint program, GLint location, GLdouble x);
typedef void ( * PFNGLPROGRAMUNIFORM1DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORM1FPROC) (GLuint program, GLint location, GLfloat x);
typedef void ( * PFNGLPROGRAMUNIFORM1FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM1IPROC) (GLuint program, GLint location, GLint x);
typedef void ( * PFNGLPROGRAMUNIFORM1IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM1UIPROC) (GLuint program, GLint location, GLuint x);
typedef void ( * PFNGLPROGRAMUNIFORM1UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM2DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y);
typedef void ( * PFNGLPROGRAMUNIFORM2DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORM2FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y);
typedef void ( * PFNGLPROGRAMUNIFORM2FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM2IPROC) (GLuint program, GLint location, GLint x, GLint y);
typedef void ( * PFNGLPROGRAMUNIFORM2IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM2UIPROC) (GLuint program, GLint location, GLuint x, GLuint y);
typedef void ( * PFNGLPROGRAMUNIFORM2UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM3DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLPROGRAMUNIFORM3DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORM3FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLPROGRAMUNIFORM3FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM3IPROC) (GLuint program, GLint location, GLint x, GLint y, GLint z);
typedef void ( * PFNGLPROGRAMUNIFORM3IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM3UIPROC) (GLuint program, GLint location, GLuint x, GLuint y, GLuint z);
typedef void ( * PFNGLPROGRAMUNIFORM3UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM4DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMUNIFORM4DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORM4FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMUNIFORM4FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM4IPROC) (GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMUNIFORM4IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM4UIPROC) (GLuint program, GLint location, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMUNIFORM4UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUSEPROGRAMSTAGESPROC) (GLuint pipeline, GLbitfield stages, GLuint program);
typedef void ( * PFNGLVALIDATEPROGRAMPIPELINEPROC) (GLuint pipeline);
# 6487 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC) (GLuint program, GLuint bufferIndex, GLenum pname, GLint* params);
# 6610 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDIMAGETEXTUREPROC) (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
typedef void ( * PFNGLMEMORYBARRIERPROC) (GLbitfield barriers);
# 6669 "/opt/homebrew/include/GL/glew.h"
typedef char GLcharARB;
typedef unsigned int GLhandleARB;

typedef void ( * PFNGLATTACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB obj);
typedef void ( * PFNGLCOMPILESHADERARBPROC) (GLhandleARB shaderObj);
typedef GLhandleARB ( * PFNGLCREATEPROGRAMOBJECTARBPROC) (void);
typedef GLhandleARB ( * PFNGLCREATESHADEROBJECTARBPROC) (GLenum shaderType);
typedef void ( * PFNGLDELETEOBJECTARBPROC) (GLhandleARB obj);
typedef void ( * PFNGLDETACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB attachedObj);
typedef void ( * PFNGLGETACTIVEUNIFORMARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint *size, GLenum *type, GLcharARB *name);
typedef void ( * PFNGLGETATTACHEDOBJECTSARBPROC) (GLhandleARB containerObj, GLsizei maxCount, GLsizei* count, GLhandleARB *obj);
typedef GLhandleARB ( * PFNGLGETHANDLEARBPROC) (GLenum pname);
typedef void ( * PFNGLGETINFOLOGARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB *infoLog);
typedef void ( * PFNGLGETOBJECTPARAMETERFVARBPROC) (GLhandleARB obj, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETOBJECTPARAMETERIVARBPROC) (GLhandleARB obj, GLenum pname, GLint* params);
typedef void ( * PFNGLGETSHADERSOURCEARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB *source);
typedef GLint ( * PFNGLGETUNIFORMLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB* name);
typedef void ( * PFNGLGETUNIFORMFVARBPROC) (GLhandleARB programObj, GLint location, GLfloat* params);
typedef void ( * PFNGLGETUNIFORMIVARBPROC) (GLhandleARB programObj, GLint location, GLint* params);
typedef void ( * PFNGLLINKPROGRAMARBPROC) (GLhandleARB programObj);
typedef void ( * PFNGLSHADERSOURCEARBPROC) (GLhandleARB shaderObj, GLsizei count, const GLcharARB ** string, const GLint *length);
typedef void ( * PFNGLUNIFORM1FARBPROC) (GLint location, GLfloat v0);
typedef void ( * PFNGLUNIFORM1FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM1IARBPROC) (GLint location, GLint v0);
typedef void ( * PFNGLUNIFORM1IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM2FARBPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLUNIFORM2FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM2IARBPROC) (GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLUNIFORM2IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM3FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLUNIFORM3FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM3IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLUNIFORM3IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM4FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLUNIFORM4FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM4IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLUNIFORM4IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORMMATRIX2FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX3FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX4FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUSEPROGRAMOBJECTARBPROC) (GLhandleARB programObj);
typedef void ( * PFNGLVALIDATEPROGRAMARBPROC) (GLhandleARB programObj);
# 6796 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLSHADERSTORAGEBLOCKBINDINGPROC) (GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
# 6819 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETACTIVESUBROUTINENAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar *name);
typedef void ( * PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar *name);
typedef void ( * PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) (GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint* values);
typedef void ( * PFNGLGETPROGRAMSTAGEIVPROC) (GLuint program, GLenum shadertype, GLenum pname, GLint* values);
typedef GLuint ( * PFNGLGETSUBROUTINEINDEXPROC) (GLuint program, GLenum shadertype, const GLchar* name);
typedef GLint ( * PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) (GLuint program, GLenum shadertype, const GLchar* name);
typedef void ( * PFNGLGETUNIFORMSUBROUTINEUIVPROC) (GLenum shadertype, GLint location, GLuint* params);
typedef void ( * PFNGLUNIFORMSUBROUTINESUIVPROC) (GLenum shadertype, GLsizei count, const GLuint* indices);
# 6897 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOMPILESHADERINCLUDEARBPROC) (GLuint shader, GLsizei count, const GLchar* const *path, const GLint *length);
typedef void ( * PFNGLDELETENAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name);
typedef void ( * PFNGLGETNAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name, GLsizei bufSize, GLint *stringlen, GLchar *string);
typedef void ( * PFNGLGETNAMEDSTRINGIVARBPROC) (GLint namelen, const GLchar* name, GLenum pname, GLint *params);
typedef GLboolean ( * PFNGLISNAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name);
typedef void ( * PFNGLNAMEDSTRINGARBPROC) (GLenum type, GLint namelen, const GLchar* name, GLint stringlen, const GLchar *string);
# 6956 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBUFFERPAGECOMMITMENTARBPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit);
# 6981 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXPAGECOMMITMENTARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
# 7051 "/opt/homebrew/include/GL/glew.h"
typedef GLenum ( * PFNGLCLIENTWAITSYNCPROC) (GLsync GLsync,GLbitfield flags,GLuint64 timeout);
typedef void ( * PFNGLDELETESYNCPROC) (GLsync GLsync);
typedef GLsync ( * PFNGLFENCESYNCPROC) (GLenum condition,GLbitfield flags);
typedef void ( * PFNGLGETINTEGER64VPROC) (GLenum pname, GLint64* params);
typedef void ( * PFNGLGETSYNCIVPROC) (GLsync GLsync,GLenum pname,GLsizei bufSize,GLsizei* length, GLint *values);
typedef GLboolean ( * PFNGLISSYNCPROC) (GLsync GLsync);
typedef void ( * PFNGLWAITSYNCPROC) (GLsync GLsync,GLbitfield flags,GLuint64 timeout);
# 7109 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLPATCHPARAMETERFVPROC) (GLenum pname, const GLfloat* values);
typedef void ( * PFNGLPATCHPARAMETERIPROC) (GLenum pname, GLint value);
# 7124 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXTUREBARRIERPROC) (void);
# 7154 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXBUFFERARBPROC) (GLenum target, GLenum internalformat, GLuint buffer);
# 7180 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXBUFFERRANGEPROC) (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLTEXTUREBUFFERRANGEEXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
# 7207 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE1DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE2DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLGETCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, void *img);
# 7472 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETMULTISAMPLEFVPROC) (GLenum pname, GLuint index, GLfloat* val);
typedef void ( * PFNGLSAMPLEMASKIPROC) (GLuint index, GLbitfield mask);
typedef void ( * PFNGLTEXIMAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXIMAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
# 7593 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXSTORAGE1DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void ( * PFNGLTEXSTORAGE2DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLTEXSTORAGE3DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
# 7610 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXSTORAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXSTORAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
# 7650 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXTUREVIEWPROC) (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
# 7666 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETQUERYOBJECTI64VPROC) (GLuint id, GLenum pname, GLint64* params);
typedef void ( * PFNGLGETQUERYOBJECTUI64VPROC) (GLuint id, GLenum pname, GLuint64* params);
typedef void ( * PFNGLQUERYCOUNTERPROC) (GLuint id, GLenum target);
# 7688 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDTRANSFORMFEEDBACKPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETETRANSFORMFEEDBACKSPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKPROC) (GLenum mode, GLuint id);
typedef void ( * PFNGLGENTRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint* ids);
typedef GLboolean ( * PFNGLISTRANSFORMFEEDBACKPROC) (GLuint id);
typedef void ( * PFNGLPAUSETRANSFORMFEEDBACKPROC) (void);
typedef void ( * PFNGLRESUMETRANSFORMFEEDBACKPROC) (void);
# 7716 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBEGINQUERYINDEXEDPROC) (GLenum target, GLuint index, GLuint id);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) (GLenum mode, GLuint id, GLuint stream);
typedef void ( * PFNGLENDQUERYINDEXEDPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLGETQUERYINDEXEDIVPROC) (GLenum target, GLuint index, GLenum pname, GLint* params);
# 7735 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC) (GLenum mode, GLuint id, GLsizei primcount);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC) (GLenum mode, GLuint id, GLuint stream, GLsizei primcount);
# 7767 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLLOADTRANSPOSEMATRIXDARBPROC) (GLdouble m[16]);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXFARBPROC) (GLfloat m[16]);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXDARBPROC) (GLdouble m[16]);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXFARBPROC) (GLfloat m[16]);
# 7820 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDBUFFERBASEPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void ( * PFNGLBINDBUFFERRANGEPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName);
typedef void ( * PFNGLGETACTIVEUNIFORMBLOCKIVPROC) (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params);
typedef void ( * PFNGLGETACTIVEUNIFORMNAMEPROC) (GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName);
typedef void ( * PFNGLGETACTIVEUNIFORMSIVPROC) (GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params);
typedef void ( * PFNGLGETINTEGERI_VPROC) (GLenum target, GLuint index, GLint* data);
typedef GLuint ( * PFNGLGETUNIFORMBLOCKINDEXPROC) (GLuint program, const GLchar* uniformBlockName);
typedef void ( * PFNGLGETUNIFORMINDICESPROC) (GLuint program, GLsizei uniformCount, const GLchar* const * uniformNames, GLuint* uniformIndices);
typedef void ( * PFNGLUNIFORMBLOCKBINDINGPROC) (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
# 7864 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDVERTEXARRAYPROC) (GLuint array);
typedef void ( * PFNGLDELETEVERTEXARRAYSPROC) (GLsizei n, const GLuint* arrays);
typedef void ( * PFNGLGENVERTEXARRAYSPROC) (GLsizei n, GLuint* arrays);
typedef GLboolean ( * PFNGLISVERTEXARRAYPROC) (GLuint array);
# 7883 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETVERTEXATTRIBLDVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLVERTEXATTRIBL1DPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIBL1DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIBL2DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIBL3DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIBL4DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBLPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer);
# 7923 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDVERTEXBUFFERPROC) (GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void ( * PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC) (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC) (GLuint vaobj, GLuint attribindex, GLuint bindingindex);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC) (GLuint vaobj, GLuint bindingindex, GLuint divisor);
typedef void ( * PFNGLVERTEXATTRIBBINDINGPROC) (GLuint attribindex, GLuint bindingindex);
typedef void ( * PFNGLVERTEXATTRIBFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXATTRIBIFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXATTRIBLFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXBINDINGDIVISORPROC) (GLuint bindingindex, GLuint divisor);
# 8001 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLVERTEXBLENDARBPROC) (GLint count);
typedef void ( * PFNGLWEIGHTPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
typedef void ( * PFNGLWEIGHTBVARBPROC) (GLint size, GLbyte *weights);
typedef void ( * PFNGLWEIGHTDVARBPROC) (GLint size, GLdouble *weights);
typedef void ( * PFNGLWEIGHTFVARBPROC) (GLint size, GLfloat *weights);
typedef void ( * PFNGLWEIGHTIVARBPROC) (GLint size, GLint *weights);
typedef void ( * PFNGLWEIGHTSVARBPROC) (GLint size, GLshort *weights);
typedef void ( * PFNGLWEIGHTUBVARBPROC) (GLint size, GLubyte *weights);
typedef void ( * PFNGLWEIGHTUIVARBPROC) (GLint size, GLuint *weights);
typedef void ( * PFNGLWEIGHTUSVARBPROC) (GLint size, GLushort *weights);
# 8064 "/opt/homebrew/include/GL/glew.h"
typedef ptrdiff_t GLintptrARB;
typedef ptrdiff_t GLsizeiptrARB;

typedef void ( * PFNGLBINDBUFFERARBPROC) (GLenum target, GLuint buffer);
typedef void ( * PFNGLBUFFERDATAARBPROC) (GLenum target, GLsizeiptrARB size, const void *data, GLenum usage);
typedef void ( * PFNGLBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void *data);
typedef void ( * PFNGLDELETEBUFFERSARBPROC) (GLsizei n, const GLuint* buffers);
typedef void ( * PFNGLGENBUFFERSARBPROC) (GLsizei n, GLuint* buffers);
typedef void ( * PFNGLGETBUFFERPARAMETERIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETBUFFERPOINTERVARBPROC) (GLenum target, GLenum pname, void** params);
typedef void ( * PFNGLGETBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, void *data);
typedef GLboolean ( * PFNGLISBUFFERARBPROC) (GLuint buffer);
typedef void * ( * PFNGLMAPBUFFERARBPROC) (GLenum target, GLenum access);
typedef GLboolean ( * PFNGLUNMAPBUFFERARBPROC) (GLenum target);
# 8180 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDPROGRAMARBPROC) (GLenum target, GLuint program);
typedef void ( * PFNGLDELETEPROGRAMSARBPROC) (GLsizei n, const GLuint* programs);
typedef void ( * PFNGLDISABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void ( * PFNGLENABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void ( * PFNGLGENPROGRAMSARBPROC) (GLsizei n, GLuint* programs);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETPROGRAMSTRINGARBPROC) (GLenum target, GLenum pname, void *string);
typedef void ( * PFNGLGETPROGRAMIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVARBPROC) (GLuint index, GLenum pname, void** pointer);
typedef void ( * PFNGLGETVERTEXATTRIBDVARBPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETVERTEXATTRIBFVARBPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVERTEXATTRIBIVARBPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISPROGRAMARBPROC) (GLuint program);
typedef void ( * PFNGLPROGRAMENVPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMENVPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void ( * PFNGLPROGRAMENVPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMENVPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void ( * PFNGLPROGRAMSTRINGARBPROC) (GLenum target, GLenum format, GLsizei len, const void *string);
typedef void ( * PFNGLVERTEXATTRIB1DARBPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVARBPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB1FARBPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVARBPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB1SARBPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB2DARBPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVARBPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB2FARBPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVARBPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB2SARBPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB3DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVARBPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB3FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVARBPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB3SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4NBVARBPROC) (GLuint index, const GLbyte* v);
typedef void ( * PFNGLVERTEXATTRIB4NIVARBPROC) (GLuint index, const GLint* v);
typedef void ( * PFNGLVERTEXATTRIB4NSVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4NUBARBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4NUBVARBPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIB4NUIVARBPROC) (GLuint index, const GLuint* v);
typedef void ( * PFNGLVERTEXATTRIB4NUSVARBPROC) (GLuint index, const GLushort* v);
typedef void ( * PFNGLVERTEXATTRIB4BVARBPROC) (GLuint index, const GLbyte* v);
typedef void ( * PFNGLVERTEXATTRIB4DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVARBPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB4FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVARBPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB4IVARBPROC) (GLuint index, const GLint* v);
typedef void ( * PFNGLVERTEXATTRIB4SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4UBVARBPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIB4UIVARBPROC) (GLuint index, const GLuint* v);
typedef void ( * PFNGLVERTEXATTRIB4USVARBPROC) (GLuint index, const GLushort* v);
typedef void ( * PFNGLVERTEXATTRIBPOINTERARBPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);
# 8323 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDATTRIBLOCATIONARBPROC) (GLhandleARB programObj, GLuint index, const GLcharARB* name);
typedef void ( * PFNGLGETACTIVEATTRIBARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint *size, GLenum *type, GLcharARB *name);
typedef GLint ( * PFNGLGETATTRIBLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB* name);
# 8354 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOLORP3UIPROC) (GLenum type, GLuint color);
typedef void ( * PFNGLCOLORP3UIVPROC) (GLenum type, const GLuint* color);
typedef void ( * PFNGLCOLORP4UIPROC) (GLenum type, GLuint color);
typedef void ( * PFNGLCOLORP4UIVPROC) (GLenum type, const GLuint* color);
typedef void ( * PFNGLMULTITEXCOORDP1UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP1UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void ( * PFNGLMULTITEXCOORDP2UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP2UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void ( * PFNGLMULTITEXCOORDP3UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP3UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void ( * PFNGLMULTITEXCOORDP4UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP4UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void ( * PFNGLNORMALP3UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLNORMALP3UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLSECONDARYCOLORP3UIPROC) (GLenum type, GLuint color);
typedef void ( * PFNGLSECONDARYCOLORP3UIVPROC) (GLenum type, const GLuint* color);
typedef void ( * PFNGLTEXCOORDP1UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP1UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLTEXCOORDP2UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP2UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLTEXCOORDP3UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP3UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLTEXCOORDP4UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP4UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLVERTEXATTRIBP1UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP1UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void ( * PFNGLVERTEXATTRIBP2UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP2UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void ( * PFNGLVERTEXATTRIBP3UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP3UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void ( * PFNGLVERTEXATTRIBP4UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP4UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void ( * PFNGLVERTEXP2UIPROC) (GLenum type, GLuint value);
typedef void ( * PFNGLVERTEXP2UIVPROC) (GLenum type, const GLuint* value);
typedef void ( * PFNGLVERTEXP3UIPROC) (GLenum type, GLuint value);
typedef void ( * PFNGLVERTEXP3UIVPROC) (GLenum type, const GLuint* value);
typedef void ( * PFNGLVERTEXP4UIPROC) (GLenum type, GLuint value);
typedef void ( * PFNGLVERTEXP4UIVPROC) (GLenum type, const GLuint* value);
# 8455 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDEPTHRANGEARRAYVPROC) (GLuint first, GLsizei count, const GLclampd * v);
typedef void ( * PFNGLDEPTHRANGEINDEXEDPROC) (GLuint index, GLclampd n, GLclampd f);
typedef void ( * PFNGLGETDOUBLEI_VPROC) (GLenum target, GLuint index, GLdouble* data);
typedef void ( * PFNGLGETFLOATI_VPROC) (GLenum target, GLuint index, GLfloat* data);
typedef void ( * PFNGLSCISSORARRAYVPROC) (GLuint first, GLsizei count, const GLint * v);
typedef void ( * PFNGLSCISSORINDEXEDPROC) (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
typedef void ( * PFNGLSCISSORINDEXEDVPROC) (GLuint index, const GLint * v);
typedef void ( * PFNGLVIEWPORTARRAYVPROC) (GLuint first, GLsizei count, const GLfloat * v);
typedef void ( * PFNGLVIEWPORTINDEXEDFPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
typedef void ( * PFNGLVIEWPORTINDEXEDFVPROC) (GLuint index, const GLfloat * v);
# 8486 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLWINDOWPOS2DARBPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVARBPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS2FARBPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVARBPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS2IARBPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVARBPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS2SARBPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVARBPROC) (const GLshort* p);
typedef void ( * PFNGLWINDOWPOS3DARBPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVARBPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS3FARBPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVARBPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS3IARBPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVARBPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS3SARBPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVARBPROC) (const GLshort* p);
# 8665 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWBUFFERSATIPROC) (GLsizei n, const GLenum* bufs);
# 8682 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWELEMENTARRAYATIPROC) (GLenum mode, GLsizei count);
typedef void ( * PFNGLDRAWRANGEELEMENTARRAYATIPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count);
typedef void ( * PFNGLELEMENTPOINTERATIPROC) (GLenum type, const void *pointer);
# 8708 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
typedef void ( * PFNGLGETTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);
typedef void ( * PFNGLTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
typedef void ( * PFNGLTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);
# 8782 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLALPHAFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void ( * PFNGLALPHAFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void ( * PFNGLALPHAFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void ( * PFNGLBEGINFRAGMENTSHADERATIPROC) (void);
typedef void ( * PFNGLBINDFRAGMENTSHADERATIPROC) (GLuint id);
typedef void ( * PFNGLCOLORFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void ( * PFNGLCOLORFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void ( * PFNGLCOLORFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void ( * PFNGLDELETEFRAGMENTSHADERATIPROC) (GLuint id);
typedef void ( * PFNGLENDFRAGMENTSHADERATIPROC) (void);
typedef GLuint ( * PFNGLGENFRAGMENTSHADERSATIPROC) (GLuint range);
typedef void ( * PFNGLPASSTEXCOORDATIPROC) (GLuint dst, GLuint coord, GLenum swizzle);
typedef void ( * PFNGLSAMPLEMAPATIPROC) (GLuint dst, GLuint interp, GLenum swizzle);
typedef void ( * PFNGLSETFRAGMENTSHADERCONSTANTATIPROC) (GLuint dst, const GLfloat* value);
# 8821 "/opt/homebrew/include/GL/glew.h"
typedef void * ( * PFNGLMAPOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void ( * PFNGLUNMAPOBJECTBUFFERATIPROC) (GLuint buffer);
# 8859 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLPNTRIANGLESFATIPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPNTRIANGLESIATIPROC) (GLenum pname, GLint param);
# 8879 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLSTENCILFUNCSEPARATEATIPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
typedef void ( * PFNGLSTENCILOPSEPARATEATIPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
# 8981 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLARRAYOBJECTATIPROC) (GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
typedef void ( * PFNGLFREEOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void ( * PFNGLGETARRAYOBJECTFVATIPROC) (GLenum array, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETARRAYOBJECTIVATIPROC) (GLenum array, GLenum pname, GLint* params);
typedef void ( * PFNGLGETOBJECTBUFFERFVATIPROC) (GLuint buffer, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETOBJECTBUFFERIVATIPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVARIANTARRAYOBJECTFVATIPROC) (GLuint id, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVARIANTARRAYOBJECTIVATIPROC) (GLuint id, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISOBJECTBUFFERATIPROC) (GLuint buffer);
typedef GLuint ( * PFNGLNEWOBJECTBUFFERATIPROC) (GLsizei size, const void *pointer, GLenum usage);
typedef void ( * PFNGLUPDATEOBJECTBUFFERATIPROC) (GLuint buffer, GLuint offset, GLsizei size, const void *pointer, GLenum preserve);
typedef void ( * PFNGLVARIANTARRAYOBJECTATIPROC) (GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
# 9016 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC) (GLuint index, GLenum pname, GLint* params);
typedef void ( * PFNGLVERTEXATTRIBARRAYOBJECTATIPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);
# 9044 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC) (GLenum stream);
typedef void ( * PFNGLNORMALSTREAM3BATIPROC) (GLenum stream, GLbyte x, GLbyte y, GLbyte z);
typedef void ( * PFNGLNORMALSTREAM3BVATIPROC) (GLenum stream, const GLbyte *coords);
typedef void ( * PFNGLNORMALSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLNORMALSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLNORMALSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLNORMALSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLNORMALSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void ( * PFNGLNORMALSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLNORMALSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLNORMALSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXBLENDENVFATIPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLVERTEXBLENDENVIATIPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLVERTEXSTREAM1DATIPROC) (GLenum stream, GLdouble x);
typedef void ( * PFNGLVERTEXSTREAM1DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM1FATIPROC) (GLenum stream, GLfloat x);
typedef void ( * PFNGLVERTEXSTREAM1FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM1IATIPROC) (GLenum stream, GLint x);
typedef void ( * PFNGLVERTEXSTREAM1IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM1SATIPROC) (GLenum stream, GLshort x);
typedef void ( * PFNGLVERTEXSTREAM1SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM2DATIPROC) (GLenum stream, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXSTREAM2DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM2FATIPROC) (GLenum stream, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXSTREAM2FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM2IATIPROC) (GLenum stream, GLint x, GLint y);
typedef void ( * PFNGLVERTEXSTREAM2IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM2SATIPROC) (GLenum stream, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXSTREAM2SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void ( * PFNGLVERTEXSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM4DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXSTREAM4DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM4FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXSTREAM4FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM4IATIPROC) (GLenum stream, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLVERTEXSTREAM4IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM4SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXSTREAM4SVATIPROC) (GLenum stream, const GLshort *coords);
# 9213 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLEGLIMAGETARGETTEXSTORAGEEXTPROC) (GLenum target, GLeglImageOES image, const GLint* attrib_list);
typedef void ( * PFNGLEGLIMAGETARGETTEXTURESTORAGEEXTPROC) (GLuint texture, GLeglImageOES image, const GLint* attrib_list);
# 9259 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEEXTPROC) (GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);
# 9295 "/opt/homebrew/include/GL/glew.h"
typedef GLint ( * PFNGLGETUNIFORMBUFFERSIZEEXTPROC) (GLuint program, GLint location);
typedef GLintptr ( * PFNGLGETUNIFORMOFFSETEXTPROC) (GLuint program, GLint location);
typedef void ( * PFNGLUNIFORMBUFFEREXTPROC) (GLuint program, GLint location, GLuint buffer);
# 9318 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBLENDCOLOREXTPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
# 9334 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBLENDEQUATIONSEPARATEEXTPROC) (GLenum modeRGB, GLenum modeAlpha);
# 9355 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDFRAGDATALOCATIONINDEXEDEXTPROC) (GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
typedef GLint ( * PFNGLGETFRAGDATAINDEXEXTPROC) (GLuint program, const GLchar * name);
typedef GLint ( * PFNGLGETPROGRAMRESOURCELOCATIONINDEXEXTPROC) (GLuint program, GLenum programInterface, const GLchar* name);
# 9377 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBLENDFUNCSEPARATEEXTPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
# 9404 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBLENDEQUATIONEXTPROC) (GLenum mode);
# 9439 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBUFFERSTORAGEEXTPROC) (GLenum target, GLsizeiptr size, const void *data, GLbitfield flags);
typedef void ( * PFNGLNAMEDBUFFERSTORAGEEXTPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags);
# 9454 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCLEARTEXIMAGEEXTPROC) (GLuint texture, GLint level, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCLEARTEXSUBIMAGEEXTPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
# 9476 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCLIPCONTROLEXTPROC) (GLenum origin, GLenum depth);
# 9560 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCOPYCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
# 9578 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLLOCKARRAYSEXTPROC) (GLint first, GLsizei count);
typedef void ( * PFNGLUNLOCKARRAYSEXTPROC) (void);
# 9632 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image);
typedef void ( * PFNGLCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFEXTPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIEXTPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETCONVOLUTIONFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, void *image);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETSEPARABLEFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, void *row, void *column, void *span);
typedef void ( * PFNGLSEPARABLEFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column);
# 9684 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, void *pointer);
typedef void ( * PFNGLTANGENTPOINTEREXTPROC) (GLenum type, GLsizei stride, void *pointer);
# 9699 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOPYIMAGESUBDATAEXTPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
# 9712 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOPYTEXIMAGE1DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void ( * PFNGLCOPYTEXIMAGE2DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void ( * PFNGLCOPYTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
# 9737 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCULLPARAMETERDVEXTPROC) (GLenum pname, GLdouble* params);
typedef void ( * PFNGLCULLPARAMETERFVEXTPROC) (GLenum pname, GLfloat* params);
# 9759 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETOBJECTLABELEXTPROC) (GLenum type, GLuint object, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void ( * PFNGLLABELOBJECTEXTPROC) (GLenum type, GLuint object, GLsizei length, const GLchar* label);
# 9774 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLINSERTEVENTMARKEREXTPROC) (GLsizei length, const GLchar* marker);
typedef void ( * PFNGLPOPGROUPMARKEREXTPROC) (void);
typedef void ( * PFNGLPUSHGROUPMARKEREXTPROC) (GLsizei length, const GLchar* marker);
# 9794 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDEPTHBOUNDSEXTPROC) (GLclampd zmin, GLclampd zmax);
# 9822 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDMULTITEXTUREEXTPROC) (GLenum texunit, GLenum target, GLuint texture);
typedef GLenum ( * PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC) (GLuint framebuffer, GLenum target);
typedef void ( * PFNGLCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOPYMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void ( * PFNGLCOPYMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void ( * PFNGLCOPYTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLDISABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
typedef void ( * PFNGLDISABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum array);
typedef void ( * PFNGLENABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLENABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLENABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
typedef void ( * PFNGLENABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum array);
typedef void ( * PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void ( * PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
typedef void ( * PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC) (GLuint framebuffer, GLsizei n, const GLenum* bufs);
typedef void ( * PFNGLFRAMEBUFFERREADBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
typedef void ( * PFNGLGENERATEMULTITEXMIPMAPEXTPROC) (GLenum texunit, GLenum target);
typedef void ( * PFNGLGENERATETEXTUREMIPMAPEXTPROC) (GLuint texture, GLenum target);
typedef void ( * PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, void *img);
typedef void ( * PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, void *img);
typedef void ( * PFNGLGETDOUBLEINDEXEDVEXTPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETDOUBLEI_VEXTPROC) (GLenum pname, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETFLOATINDEXEDVEXTPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETFLOATI_VEXTPROC) (GLenum pname, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint* param);
typedef void ( * PFNGLGETMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
typedef void ( * PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDBUFFERPOINTERVEXTPROC) (GLuint buffer, GLenum pname, void** params);
typedef void ( * PFNGLGETNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, void *data);
typedef void ( * PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLint* params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint* params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum pname, void *string);
typedef void ( * PFNGLGETNAMEDPROGRAMIVEXTPROC) (GLuint program, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC) (GLuint renderbuffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETPOINTERINDEXEDVEXTPROC) (GLenum target, GLuint index, void** params);
typedef void ( * PFNGLGETPOINTERI_VEXTPROC) (GLenum pname, GLuint index, void** params);
typedef void ( * PFNGLGETTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
typedef void ( * PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint* param);
typedef void ( * PFNGLGETVERTEXARRAYINTEGERVEXTPROC) (GLuint vaobj, GLenum pname, GLint* param);
typedef void ( * PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, void** param);
typedef void ( * PFNGLGETVERTEXARRAYPOINTERVEXTPROC) (GLuint vaobj, GLenum pname, void** param);
typedef void * ( * PFNGLMAPNAMEDBUFFEREXTPROC) (GLuint buffer, GLenum access);
typedef void * ( * PFNGLMAPNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void ( * PFNGLMATRIXFRUSTUMEXTPROC) (GLenum matrixMode, GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f);
typedef void ( * PFNGLMATRIXLOADIDENTITYEXTPROC) (GLenum matrixMode);
typedef void ( * PFNGLMATRIXLOADTRANSPOSEDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void ( * PFNGLMATRIXLOADTRANSPOSEFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXLOADDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void ( * PFNGLMATRIXLOADFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXMULTTRANSPOSEDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void ( * PFNGLMATRIXMULTTRANSPOSEFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXMULTDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void ( * PFNGLMATRIXMULTFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXORTHOEXTPROC) (GLenum matrixMode, GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f);
typedef void ( * PFNGLMATRIXPOPEXTPROC) (GLenum matrixMode);
typedef void ( * PFNGLMATRIXPUSHEXTPROC) (GLenum matrixMode);
typedef void ( * PFNGLMATRIXROTATEDEXTPROC) (GLenum matrixMode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLMATRIXROTATEFEXTPROC) (GLenum matrixMode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLMATRIXSCALEDEXTPROC) (GLenum matrixMode, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLMATRIXSCALEFEXTPROC) (GLenum matrixMode, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLMATRIXTRANSLATEDEXTPROC) (GLenum matrixMode, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLMATRIXTRANSLATEFEXTPROC) (GLenum matrixMode, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLMULTITEXBUFFEREXTPROC) (GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer);
typedef void ( * PFNGLMULTITEXCOORDPOINTEREXTPROC) (GLenum texunit, GLint size, GLenum type, GLsizei stride, const void *pointer);
typedef void ( * PFNGLMULTITEXENVFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLMULTITEXENVIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLMULTITEXGENDEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble param);
typedef void ( * PFNGLMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLdouble* params);
typedef void ( * PFNGLMULTITEXGENFEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat param);
typedef void ( * PFNGLMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLMULTITEXGENIEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint param);
typedef void ( * PFNGLMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLint* params);
typedef void ( * PFNGLMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLuint* params);
typedef void ( * PFNGLMULTITEXPARAMETERFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat* param);
typedef void ( * PFNGLMULTITEXPARAMETERIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* param);
typedef void ( * PFNGLMULTITEXRENDERBUFFEREXTPROC) (GLenum texunit, GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
typedef void ( * PFNGLNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
typedef void ( * PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC) (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void ( * PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC) (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLdouble* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLfloat* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC) (GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLint* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLuint* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLint* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint* params);
typedef void ( * PFNGLNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum format, GLsizei len, const void *string);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC) (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC) (GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLPROGRAMUNIFORM1FEXTPROC) (GLuint program, GLint location, GLfloat v0);
typedef void ( * PFNGLPROGRAMUNIFORM1FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM1IEXTPROC) (GLuint program, GLint location, GLint v0);
typedef void ( * PFNGLPROGRAMUNIFORM1IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM1UIEXTPROC) (GLuint program, GLint location, GLuint v0);
typedef void ( * PFNGLPROGRAMUNIFORM1UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM2FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLPROGRAMUNIFORM2FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM2IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLPROGRAMUNIFORM2IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM2UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1);
typedef void ( * PFNGLPROGRAMUNIFORM2UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM3FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLPROGRAMUNIFORM3FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM3IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLPROGRAMUNIFORM3IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM3UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLPROGRAMUNIFORM3UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM4FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLPROGRAMUNIFORM4FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM4IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLPROGRAMUNIFORM4IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM4UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLPROGRAMUNIFORM4UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
typedef void ( * PFNGLTEXTUREBUFFEREXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer);
typedef void ( * PFNGLTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLuint* params);
typedef void ( * PFNGLTEXTUREPARAMETERFEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLfloat* param);
typedef void ( * PFNGLTEXTUREPARAMETERIEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint* param);
typedef void ( * PFNGLTEXTURERENDERBUFFEREXTPROC) (GLuint texture, GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
typedef GLboolean ( * PFNGLUNMAPNAMEDBUFFEREXTPROC) (GLuint buffer);
typedef void ( * PFNGLVERTEXARRAYCOLOROFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYINDEXOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYNORMALOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC) (GLuint vaobj, GLuint index, GLuint divisor);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
# 10265 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDISCARDFRAMEBUFFEREXTPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments);
# 10286 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBEGINQUERYEXTPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETEQUERIESEXTPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLENDQUERYEXTPROC) (GLenum target);
typedef void ( * PFNGLGENQUERIESEXTPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETINTEGER64VEXTPROC) (GLenum pname, GLint64* data);
typedef void ( * PFNGLGETQUERYOBJECTIVEXTPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETQUERYOBJECTUIVEXTPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETQUERYIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISQUERYEXTPROC) (GLuint id);
typedef void ( * PFNGLQUERYCOUNTEREXTPROC) (GLuint id, GLenum target);
# 10352 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWBUFFERSEXTPROC) (GLsizei n, const GLenum* bufs);
# 10365 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOLORMASKINDEXEDEXTPROC) (GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void ( * PFNGLDISABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLENABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLGETBOOLEANINDEXEDVEXTPROC) (GLenum value, GLuint index, GLboolean* data);
typedef void ( * PFNGLGETINTEGERINDEXEDVEXTPROC) (GLenum value, GLuint index, GLint* data);
typedef GLboolean ( * PFNGLISENABLEDINDEXEDEXTPROC) (GLenum target, GLuint index);
# 10388 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBLENDEQUATIONSEPARATEIEXTPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDEQUATIONIEXTPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDFUNCSEPARATEIEXTPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void ( * PFNGLBLENDFUNCIEXTPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void ( * PFNGLCOLORMASKIEXTPROC) (GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void ( * PFNGLDISABLEIEXTPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLENABLEIEXTPROC) (GLenum target, GLuint index);
typedef GLboolean ( * PFNGLISENABLEDIEXTPROC) (GLenum target, GLuint index);
# 10415 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWELEMENTSBASEVERTEXEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex);
typedef void ( * PFNGLDRAWRANGEELEMENTSBASEVERTEXEXTPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex);
typedef void ( * PFNGLMULTIDRAWELEMENTSBASEVERTEXEXTPROC) (GLenum mode, const GLsizei* count, GLenum type, const void *const *indices, GLsizei primcount, const GLint *basevertex);
# 10434 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWARRAYSINSTANCEDEXTPROC) (GLenum mode, GLint start, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
# 10452 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWRANGEELEMENTSEXTPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
# 10465 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKEXTPROC) (GLenum mode, GLuint id);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDEXTPROC) (GLenum mode, GLuint id, GLsizei instancecount);
# 10480 "/opt/homebrew/include/GL/glew.h"
typedef void* GLeglClientBufferEXT;

typedef void ( * PFNGLBUFFERSTORAGEEXTERNALEXTPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags);
typedef void ( * PFNGLNAMEDBUFFERSTORAGEEXTERNALEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags);
# 10515 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFOGCOORDPOINTEREXTPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void ( * PFNGLFOGCOORDDEXTPROC) (GLdouble coord);
typedef void ( * PFNGLFOGCOORDDVEXTPROC) (const GLdouble *coord);
typedef void ( * PFNGLFOGCOORDFEXTPROC) (GLfloat coord);
typedef void ( * PFNGLFOGCOORDFVEXTPROC) (const GLfloat *coord);
# 10560 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAGMENTCOLORMATERIALEXTPROC) (GLenum face, GLenum mode);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFEXTPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFVEXTPROC) (GLenum pname, GLfloat* params);
typedef void ( * PFNGLFRAGMENTLIGHTMODELIEXTPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELIVEXTPROC) (GLenum pname, GLint* params);
typedef void ( * PFNGLFRAGMENTLIGHTFEXTPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTFVEXTPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void ( * PFNGLFRAGMENTLIGHTIEXTPROC) (GLenum light, GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTIVEXTPROC) (GLenum light, GLenum pname, GLint* params);
typedef void ( * PFNGLFRAGMENTMATERIALFEXTPROC) (GLenum face, GLenum pname, const GLfloat param);
typedef void ( * PFNGLFRAGMENTMATERIALFVEXTPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLFRAGMENTMATERIALIEXTPROC) (GLenum face, GLenum pname, const GLint param);
typedef void ( * PFNGLFRAGMENTMATERIALIVEXTPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void ( * PFNGLGETFRAGMENTLIGHTFVEXTPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETFRAGMENTLIGHTIVEXTPROC) (GLenum light, GLenum pname, GLint* params);
typedef void ( * PFNGLGETFRAGMENTMATERIALFVEXTPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLGETFRAGMENTMATERIALIVEXTPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void ( * PFNGLLIGHTENVIEXTPROC) (GLenum pname, GLint param);
# 10612 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBLITFRAMEBUFFEREXTPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
# 10629 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 10706 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDFRAMEBUFFEREXTPROC) (GLenum target, GLuint framebuffer);
typedef void ( * PFNGLBINDRENDERBUFFEREXTPROC) (GLenum target, GLuint renderbuffer);
typedef GLenum ( * PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC) (GLenum target);
typedef void ( * PFNGLDELETEFRAMEBUFFERSEXTPROC) (GLsizei n, const GLuint* framebuffers);
typedef void ( * PFNGLDELETERENDERBUFFERSEXTPROC) (GLsizei n, const GLuint* renderbuffers);
typedef void ( * PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE1DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE3DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void ( * PFNGLGENFRAMEBUFFERSEXTPROC) (GLsizei n, GLuint* framebuffers);
typedef void ( * PFNGLGENRENDERBUFFERSEXTPROC) (GLsizei n, GLuint* renderbuffers);
typedef void ( * PFNGLGENERATEMIPMAPEXTPROC) (GLenum target);
typedef void ( * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
typedef void ( * PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISFRAMEBUFFEREXTPROC) (GLuint framebuffer);
typedef GLboolean ( * PFNGLISRENDERBUFFEREXTPROC) (GLuint renderbuffer);
typedef void ( * PFNGLRENDERBUFFERSTORAGEEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
# 10870 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERTEXTUREEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void ( * PFNGLPROGRAMPARAMETERIEXTPROC) (GLuint program, GLenum pname, GLint value);
# 10887 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLPROGRAMENVPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat* params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat* params);
# 10929 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDFRAGDATALOCATIONEXTPROC) (GLuint program, GLuint color, const GLchar *name);
typedef GLint ( * PFNGLGETFRAGDATALOCATIONEXTPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLGETUNIFORMUIVEXTPROC) (GLuint program, GLint location, GLuint *params);
typedef void ( * PFNGLGETVERTEXATTRIBIIVEXTPROC) (GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBIUIVEXTPROC) (GLuint index, GLenum pname, GLuint *params);
typedef void ( * PFNGLUNIFORM1UIEXTPROC) (GLint location, GLuint v0);
typedef void ( * PFNGLUNIFORM1UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM2UIEXTPROC) (GLint location, GLuint v0, GLuint v1);
typedef void ( * PFNGLUNIFORM2UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM3UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLUNIFORM3UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM4UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLUNIFORM4UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLVERTEXATTRIBI1IEXTPROC) (GLuint index, GLint x);
typedef void ( * PFNGLVERTEXATTRIBI1IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI1UIEXTPROC) (GLuint index, GLuint x);
typedef void ( * PFNGLVERTEXATTRIBI1UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI2IEXTPROC) (GLuint index, GLint x, GLint y);
typedef void ( * PFNGLVERTEXATTRIBI2IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI2UIEXTPROC) (GLuint index, GLuint x, GLuint y);
typedef void ( * PFNGLVERTEXATTRIBI2UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI3IEXTPROC) (GLuint index, GLint x, GLint y, GLint z);
typedef void ( * PFNGLVERTEXATTRIBI3IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI3UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z);
typedef void ( * PFNGLVERTEXATTRIBI3UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI4BVEXTPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIBI4IEXTPROC) (GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLVERTEXATTRIBI4IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI4SVEXTPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBI4UBVEXTPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIBI4UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLVERTEXATTRIBI4UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI4USVEXTPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLVERTEXATTRIBIPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
# 11031 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETHISTOGRAMEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMINMAXEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
typedef void ( * PFNGLGETMINMAXPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMINMAXPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLHISTOGRAMEXTPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLMINMAXEXTPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLRESETHISTOGRAMEXTPROC) (GLenum target);
typedef void ( * PFNGLRESETMINMAXEXTPROC) (GLenum target);
# 11071 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLINDEXFUNCEXTPROC) (GLenum func, GLfloat ref);
# 11084 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLINDEXMATERIALEXTPROC) (GLenum face, GLenum mode);
# 11108 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLVERTEXATTRIBDIVISOREXTPROC) (GLuint index, GLuint divisor);
# 11131 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLAPPLYTEXTUREEXTPROC) (GLenum mode);
typedef void ( * PFNGLTEXTURELIGHTEXTPROC) (GLenum pname);
typedef void ( * PFNGLTEXTUREMATERIALEXTPROC) (GLenum face, GLenum mode);
# 11155 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFLUSHMAPPEDBUFFERRANGEEXTPROC) (GLenum target, GLintptr offset, GLsizeiptr length);
typedef void * ( * PFNGLMAPBUFFERRANGEEXTPROC) (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
# 11182 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBUFFERSTORAGEMEMEXTPROC) (GLenum target, GLsizeiptr size, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLCREATEMEMORYOBJECTSEXTPROC) (GLsizei n, GLuint* memoryObjects);
typedef void ( * PFNGLDELETEMEMORYOBJECTSEXTPROC) (GLsizei n, const GLuint* memoryObjects);
typedef void ( * PFNGLGETMEMORYOBJECTPARAMETERIVEXTPROC) (GLuint memoryObject, GLenum pname, GLint* params);
typedef void ( * PFNGLGETUNSIGNEDBYTEI_VEXTPROC) (GLenum target, GLuint index, GLubyte* data);
typedef void ( * PFNGLGETUNSIGNEDBYTEVEXTPROC) (GLenum pname, GLubyte* data);
typedef GLboolean ( * PFNGLISMEMORYOBJECTEXTPROC) (GLuint memoryObject);
typedef void ( * PFNGLMEMORYOBJECTPARAMETERIVEXTPROC) (GLuint memoryObject, GLenum pname, const GLint* params);
typedef void ( * PFNGLNAMEDBUFFERSTORAGEMEMEXTPROC) (GLuint buffer, GLsizeiptr size, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXSTORAGEMEM1DEXTPROC) (GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXSTORAGEMEM2DEXTPROC) (GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXSTORAGEMEM2DMULTISAMPLEEXTPROC) (GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXSTORAGEMEM3DEXTPROC) (GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXSTORAGEMEM3DMULTISAMPLEEXTPROC) (GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXTURESTORAGEMEM1DEXTPROC) (GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXTURESTORAGEMEM2DEXTPROC) (GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXTURESTORAGEMEM2DMULTISAMPLEEXTPROC) (GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXTURESTORAGEMEM3DEXTPROC) (GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXTURESTORAGEMEM3DMULTISAMPLEEXTPROC) (GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
# 11233 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLIMPORTMEMORYFDEXTPROC) (GLuint memory, GLuint64 size, GLenum handleType, GLint fd);
# 11258 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLIMPORTMEMORYWIN32HANDLEEXTPROC) (GLuint memory, GLuint64 size, GLenum handleType, void *handle);
typedef void ( * PFNGLIMPORTMEMORYWIN32NAMEEXTPROC) (GLuint memory, GLuint64 size, GLenum handleType, const void *name);
# 11282 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLMULTIDRAWARRAYSEXTPROC) (GLenum mode, const GLint* first, const GLsizei *count, GLsizei primcount);
typedef void ( * PFNGLMULTIDRAWELEMENTSEXTPROC) (GLenum mode, GLsizei* count, GLenum type, const void *const *indices, GLsizei primcount);
# 11297 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTEXTPROC) (GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTEXTPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride);
# 11339 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLSAMPLEMASKEXTPROC) (GLclampf value, GLboolean invert);
typedef void ( * PFNGLSAMPLEPATTERNEXTPROC) (GLenum pattern);
# 11371 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DMULTISAMPLEEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples);
# 11399 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWBUFFERSINDEXEDEXTPROC) (GLint n, const GLenum* location, const GLint *indices);
typedef void ( * PFNGLGETINTEGERI_VEXTPROC) (GLenum target, GLuint index, GLint* data);
typedef void ( * PFNGLREADBUFFERINDEXEDEXTPROC) (GLenum src, GLint index);
# 11522 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOLORTABLEEXTPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLGETCOLORTABLEEXTPROC) (GLenum target, GLenum format, GLenum type, void *data);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
# 11565 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFEXTPROC) (GLenum target, GLenum pname, const GLfloat param);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERIEXTPROC) (GLenum target, GLenum pname, const GLint param);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
# 11602 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLPOINTPARAMETERFEXTPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVEXTPROC) (GLenum pname, const GLfloat* params);
# 11621 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLPOLYGONOFFSETEXTPROC) (GLfloat factor, GLfloat bias);
# 11636 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLPOLYGONOFFSETCLAMPEXTPROC) (GLfloat factor, GLfloat units, GLfloat clamp);
# 11660 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLPRIMITIVEBOUNDINGBOXEXTPROC) (GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW);
# 11690 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLPROVOKINGVERTEXEXTPROC) (GLenum mode);
# 11732 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOVERAGEMODULATIONNVPROC) (GLenum components);
typedef void ( * PFNGLCOVERAGEMODULATIONTABLENVPROC) (GLsizei n, const GLfloat* v);
typedef void ( * PFNGLGETCOVERAGEMODULATIONTABLENVPROC) (GLsizei bufsize, GLfloat* v);
typedef void ( * PFNGLRASTERSAMPLESEXTPROC) (GLuint samples, GLboolean fixedsamplelocations);
# 11801 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETNUNIFORMFVEXTPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
typedef void ( * PFNGLGETNUNIFORMIVEXTPROC) (GLuint program, GLint location, GLsizei bufSize, GLint* params);
typedef void ( * PFNGLREADNPIXELSEXTPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);
# 11843 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBEGINSCENEEXTPROC) (void);
typedef void ( * PFNGLENDSCENEEXTPROC) (void);
# 11866 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLSECONDARYCOLOR3BEXTPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3BVEXTPROC) (const GLbyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3DEXTPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void ( * PFNGLSECONDARYCOLOR3DVEXTPROC) (const GLdouble *v);
typedef void ( * PFNGLSECONDARYCOLOR3FEXTPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void ( * PFNGLSECONDARYCOLOR3FVEXTPROC) (const GLfloat *v);
typedef void ( * PFNGLSECONDARYCOLOR3IEXTPROC) (GLint red, GLint green, GLint blue);
typedef void ( * PFNGLSECONDARYCOLOR3IVEXTPROC) (const GLint *v);
typedef void ( * PFNGLSECONDARYCOLOR3SEXTPROC) (GLshort red, GLshort green, GLshort blue);
typedef void ( * PFNGLSECONDARYCOLOR3SVEXTPROC) (const GLshort *v);
typedef void ( * PFNGLSECONDARYCOLOR3UBEXTPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3UBVEXTPROC) (const GLubyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3UIEXTPROC) (GLuint red, GLuint green, GLuint blue);
typedef void ( * PFNGLSECONDARYCOLOR3UIVEXTPROC) (const GLuint *v);
typedef void ( * PFNGLSECONDARYCOLOR3USEXTPROC) (GLushort red, GLushort green, GLushort blue);
typedef void ( * PFNGLSECONDARYCOLOR3USVEXTPROC) (const GLushort *v);
typedef void ( * PFNGLSECONDARYCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, const void *pointer);
# 11921 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDELETESEMAPHORESEXTPROC) (GLsizei n, const GLuint* semaphores);
typedef void ( * PFNGLGENSEMAPHORESEXTPROC) (GLsizei n, GLuint* semaphores);
typedef void ( * PFNGLGETSEMAPHOREPARAMETERUI64VEXTPROC) (GLuint semaphore, GLenum pname, GLuint64* params);
typedef GLboolean ( * PFNGLISSEMAPHOREEXTPROC) (GLuint semaphore);
typedef void ( * PFNGLSEMAPHOREPARAMETERUI64VEXTPROC) (GLuint semaphore, GLenum pname, const GLuint64* params);
typedef void ( * PFNGLSIGNALSEMAPHOREEXTPROC) (GLuint semaphore, GLuint numBufferBarriers, const GLuint* buffers, GLuint numTextureBarriers, const GLuint *textures, const GLenum *dstLayouts);
typedef void ( * PFNGLWAITSEMAPHOREEXTPROC) (GLuint semaphore, GLuint numBufferBarriers, const GLuint* buffers, GLuint numTextureBarriers, const GLuint *textures, const GLenum *srcLayouts);
# 11946 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLIMPORTSEMAPHOREFDEXTPROC) (GLuint semaphore, GLenum handleType, GLint fd);
# 11959 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLIMPORTSEMAPHOREWIN32HANDLEEXTPROC) (GLuint semaphore, GLenum handleType, void *handle);
typedef void ( * PFNGLIMPORTSEMAPHOREWIN32NAMEEXTPROC) (GLuint semaphore, GLenum handleType, const void *name);
# 11976 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLACTIVEPROGRAMEXTPROC) (GLuint program);
typedef GLuint ( * PFNGLCREATESHADERPROGRAMEXTPROC) (GLenum type, const GLchar* string);
typedef void ( * PFNGLUSESHADERPROGRAMEXTPROC) (GLenum type, GLuint program);
# 12008 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERFETCHBARRIEREXTPROC) (void);
# 12106 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDIMAGETEXTUREEXTPROC) (GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format);
typedef void ( * PFNGLMEMORYBARRIEREXTPROC) (GLbitfield barriers);
# 12174 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCLEARPIXELLOCALSTORAGEUIEXTPROC) (GLsizei offset, GLsizei n, const GLuint* values);
typedef void ( * PFNGLFRAMEBUFFERPIXELLOCALSTORAGESIZEEXTPROC) (GLuint target, GLsizei size);
typedef GLsizei ( * PFNGLGETFRAMEBUFFERPIXELLOCALSTORAGESIZEEXTPROC) (GLuint target);
# 12251 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXPAGECOMMITMENTEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
typedef void ( * PFNGLTEXTUREPAGECOMMITMENTEXTPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
# 12299 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLACTIVESTENCILFACEEXTPROC) (GLenum face);
# 12324 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
# 12385 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLPATCHPARAMETERIEXTPROC) (GLenum pname, GLint value);
# 12513 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXIMAGE3DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
# 12535 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
# 12551 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETSAMPLERPARAMETERIIVEXTPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef void ( * PFNGLGETSAMPLERPARAMETERIUIVEXTPROC) (GLuint sampler, GLenum pname, GLuint* params);
typedef void ( * PFNGLSAMPLERPARAMETERIIVEXTPROC) (GLuint sampler, GLenum pname, const GLint* params);
typedef void ( * PFNGLSAMPLERPARAMETERIUIVEXTPROC) (GLuint sampler, GLenum pname, const GLuint* params);
# 12600 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXBUFFEREXTPROC) (GLenum target, GLenum internalformat, GLuint buffer);
# 12921 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCLEARCOLORIIEXTPROC) (GLint red, GLint green, GLint blue, GLint alpha);
typedef void ( * PFNGLCLEARCOLORIUIEXTPROC) (GLuint red, GLuint green, GLuint blue, GLuint alpha);
typedef void ( * PFNGLGETTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, GLuint *params);
typedef void ( * PFNGLTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, const GLuint *params);
# 13005 "/opt/homebrew/include/GL/glew.h"
typedef GLboolean ( * PFNGLARETEXTURESRESIDENTEXTPROC) (GLsizei n, const GLuint* textures, GLboolean* residences);
typedef void ( * PFNGLBINDTEXTUREEXTPROC) (GLenum target, GLuint texture);
typedef void ( * PFNGLDELETETEXTURESEXTPROC) (GLsizei n, const GLuint* textures);
typedef void ( * PFNGLGENTEXTURESEXTPROC) (GLsizei n, GLuint* textures);
typedef GLboolean ( * PFNGLISTEXTUREEXTPROC) (GLuint texture);
typedef void ( * PFNGLPRIORITIZETEXTURESEXTPROC) (GLsizei n, const GLuint* textures, const GLclampf* priorities);
# 13031 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXTURENORMALEXTPROC) (GLenum mode);
# 13224 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXSTORAGE1DEXTPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void ( * PFNGLTEXSTORAGE2DEXTPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLTEXSTORAGE3DEXTPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void ( * PFNGLTEXTURESTORAGE1DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void ( * PFNGLTEXTURESTORAGE2DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLTEXTURESTORAGE3DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
# 13279 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXTUREVIEWEXTPROC) (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
# 13294 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETQUERYOBJECTI64VEXTPROC) (GLuint id, GLenum pname, GLint64EXT *params);
typedef void ( * PFNGLGETQUERYOBJECTUI64VEXTPROC) (GLuint id, GLenum pname, GLuint64EXT *params);
# 13325 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKEXTPROC) (GLenum primitiveMode);
typedef void ( * PFNGLBINDBUFFERBASEEXTPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void ( * PFNGLBINDBUFFEROFFSETEXTPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void ( * PFNGLBINDBUFFERRANGEEXTPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLENDTRANSFORMFEEDBACKEXTPROC) (void);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei *size, GLenum *type, GLchar *name);
typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC) (GLuint program, GLsizei count, const GLchar * const* varyings, GLenum bufferMode);
# 13397 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLARRAYELEMENTEXTPROC) (GLint i);
typedef void ( * PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void ( * PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
typedef void ( * PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean* pointer);
typedef void ( * PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void ( * PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void ( * PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void ( * PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
# 13435 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDARRAYSETEXTPROC) (const void *arrayset);
typedef const void * ( * PFNGLCREATEARRAYSETEXTPROC) (void);
typedef void ( * PFNGLDELETEARRAYSETSEXTPROC) (GLsizei n, const void *arrayset[]);
# 13465 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETVERTEXATTRIBLDVEXTPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXATTRIBL1DEXTPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIBL1DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL2DEXTPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIBL2DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL3DEXTPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIBL3DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL4DEXTPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIBL4DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBLPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
# 13609 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBEGINVERTEXSHADEREXTPROC) (void);
typedef GLuint ( * PFNGLBINDLIGHTPARAMETEREXTPROC) (GLenum light, GLenum value);
typedef GLuint ( * PFNGLBINDMATERIALPARAMETEREXTPROC) (GLenum face, GLenum value);
typedef GLuint ( * PFNGLBINDPARAMETEREXTPROC) (GLenum value);
typedef GLuint ( * PFNGLBINDTEXGENPARAMETEREXTPROC) (GLenum unit, GLenum coord, GLenum value);
typedef GLuint ( * PFNGLBINDTEXTUREUNITPARAMETEREXTPROC) (GLenum unit, GLenum value);
typedef void ( * PFNGLBINDVERTEXSHADEREXTPROC) (GLuint id);
typedef void ( * PFNGLDELETEVERTEXSHADEREXTPROC) (GLuint id);
typedef void ( * PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void ( * PFNGLENABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void ( * PFNGLENDVERTEXSHADEREXTPROC) (void);
typedef void ( * PFNGLEXTRACTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLuint ( * PFNGLGENSYMBOLSEXTPROC) (GLenum dataType, GLenum storageType, GLenum range, GLuint components);
typedef GLuint ( * PFNGLGENVERTEXSHADERSEXTPROC) (GLuint range);
typedef void ( * PFNGLGETINVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETINVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETINVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETLOCALCONSTANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETLOCALCONSTANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETVARIANTPOINTERVEXTPROC) (GLuint id, GLenum value, void **data);
typedef void ( * PFNGLINSERTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLboolean ( * PFNGLISVARIANTENABLEDEXTPROC) (GLuint id, GLenum cap);
typedef void ( * PFNGLSETINVARIANTEXTPROC) (GLuint id, GLenum type, void *addr);
typedef void ( * PFNGLSETLOCALCONSTANTEXTPROC) (GLuint id, GLenum type, void *addr);
typedef void ( * PFNGLSHADEROP1EXTPROC) (GLenum op, GLuint res, GLuint arg1);
typedef void ( * PFNGLSHADEROP2EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2);
typedef void ( * PFNGLSHADEROP3EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
typedef void ( * PFNGLSWIZZLEEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
typedef void ( * PFNGLVARIANTPOINTEREXTPROC) (GLuint id, GLenum type, GLuint stride, void *addr);
typedef void ( * PFNGLVARIANTBVEXTPROC) (GLuint id, GLbyte *addr);
typedef void ( * PFNGLVARIANTDVEXTPROC) (GLuint id, GLdouble *addr);
typedef void ( * PFNGLVARIANTFVEXTPROC) (GLuint id, GLfloat *addr);
typedef void ( * PFNGLVARIANTIVEXTPROC) (GLuint id, GLint *addr);
typedef void ( * PFNGLVARIANTSVEXTPROC) (GLuint id, GLshort *addr);
typedef void ( * PFNGLVARIANTUBVEXTPROC) (GLuint id, GLubyte *addr);
typedef void ( * PFNGLVARIANTUIVEXTPROC) (GLuint id, GLuint *addr);
typedef void ( * PFNGLVARIANTUSVEXTPROC) (GLuint id, GLushort *addr);
typedef void ( * PFNGLWRITEMASKEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
# 13718 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLVERTEXWEIGHTPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
typedef void ( * PFNGLVERTEXWEIGHTFEXTPROC) (GLfloat weight);
typedef void ( * PFNGLVERTEXWEIGHTFVEXTPROC) (GLfloat* weight);
# 13735 "/opt/homebrew/include/GL/glew.h"
typedef GLboolean ( * PFNGLACQUIREKEYEDMUTEXWIN32EXTPROC) (GLuint memory, GLuint64 key, GLuint timeout);
typedef GLboolean ( * PFNGLRELEASEKEYEDMUTEXWIN32EXTPROC) (GLuint memory, GLuint64 key);
# 13757 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLWINDOWRECTANGLESEXTPROC) (GLenum mode, GLsizei count, const GLint box[]);
# 13772 "/opt/homebrew/include/GL/glew.h"
typedef GLsync ( * PFNGLIMPORTSYNCEXTPROC) (GLenum external_sync_type, GLintptr external_sync, GLbitfield flags);
# 13796 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAMETERMINATORGREMEDYPROC) (void);
# 13809 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLSTRINGMARKERGREMEDYPROC) (GLsizei len, const void *string);
# 13831 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERFHPPROC) (GLenum target, GLenum pname, const GLfloat param);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERIHPPROC) (GLenum target, GLenum pname, const GLint param);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint* params);
# 13883 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLMULTIMODEDRAWARRAYSIBMPROC) (const GLenum* mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride);
typedef void ( * PFNGLMULTIMODEDRAWELEMENTSIBMPROC) (const GLenum* mode, const GLsizei *count, GLenum type, const void *const *indices, GLsizei primcount, GLint modestride);
# 13949 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void ( * PFNGLEDGEFLAGPOINTERLISTIBMPROC) (GLint stride, const GLboolean ** pointer, GLint ptrstride);
typedef void ( * PFNGLFOGCOORDPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void ( * PFNGLINDEXPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void ( * PFNGLNORMALPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void ( * PFNGLSECONDARYCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void ( * PFNGLTEXCOORDPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void ( * PFNGLVERTEXPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
# 13976 "/opt/homebrew/include/GL/glew.h"
typedef GLuint64 ( * PFNGLGETTEXTUREHANDLEIMGPROC) (GLuint texture);
typedef GLuint64 ( * PFNGLGETTEXTURESAMPLERHANDLEIMGPROC) (GLuint texture, GLuint sampler);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64IMGPROC) (GLuint program, GLint location, GLuint64 value);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64VIMGPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
typedef void ( * PFNGLUNIFORMHANDLEUI64IMGPROC) (GLint location, GLuint64 value);
typedef void ( * PFNGLUNIFORMHANDLEUI64VIMGPROC) (GLint location, GLsizei count, const GLuint64* value);
# 14004 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DDOWNSAMPLEIMGPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint xscale, GLint yscale);
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYERDOWNSAMPLEIMGPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer, GLint xscale, GLint yscale);
# 14024 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DMULTISAMPLEIMGPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples);
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEIMGPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 14203 "/opt/homebrew/include/GL/glew.h"
typedef void * ( * PFNGLMAPTEXTURE2DINTELPROC) (GLuint texture, GLint level, GLbitfield access, GLint* stride, GLenum *layout);
typedef void ( * PFNGLSYNCTEXTUREINTELPROC) (GLuint texture);
typedef void ( * PFNGLUNMAPTEXTURE2DINTELPROC) (GLuint texture, GLint level);
# 14226 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOLORPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
typedef void ( * PFNGLNORMALPOINTERVINTELPROC) (GLenum type, const void** pointer);
typedef void ( * PFNGLTEXCOORDPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
typedef void ( * PFNGLVERTEXPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
# 14266 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBEGINPERFQUERYINTELPROC) (GLuint queryHandle);
typedef void ( * PFNGLCREATEPERFQUERYINTELPROC) (GLuint queryId, GLuint* queryHandle);
typedef void ( * PFNGLDELETEPERFQUERYINTELPROC) (GLuint queryHandle);
typedef void ( * PFNGLENDPERFQUERYINTELPROC) (GLuint queryHandle);
typedef void ( * PFNGLGETFIRSTPERFQUERYIDINTELPROC) (GLuint* queryId);
typedef void ( * PFNGLGETNEXTPERFQUERYIDINTELPROC) (GLuint queryId, GLuint* nextQueryId);
typedef void ( * PFNGLGETPERFCOUNTERINFOINTELPROC) (GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar* counterName, GLuint counterDescLength, GLchar *counterDesc, GLuint *counterOffset, GLuint *counterDataSize, GLuint *counterTypeEnum, GLuint *counterDataTypeEnum, GLuint64 *rawCounterMaxValue);
typedef void ( * PFNGLGETPERFQUERYDATAINTELPROC) (GLuint queryHandle, GLuint flags, GLsizei dataSize, void *data, GLuint *bytesWritten);
typedef void ( * PFNGLGETPERFQUERYIDBYNAMEINTELPROC) (GLchar* queryName, GLuint *queryId);
typedef void ( * PFNGLGETPERFQUERYINFOINTELPROC) (GLuint queryId, GLuint queryNameLength, GLchar* queryName, GLuint *dataSize, GLuint *noCounters, GLuint *noInstances, GLuint *capsMask);
# 14306 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXSCISSORFUNCINTELPROC) (GLenum target, GLenum lfunc, GLenum hfunc);
typedef void ( * PFNGLTEXSCISSORINTELPROC) (GLenum target, GLclampf tlow, GLclampf thigh);
# 14338 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBLENDBARRIERKHRPROC) (void);
# 14413 "/opt/homebrew/include/GL/glew.h"
typedef void ( *GLDEBUGPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);

typedef void ( * PFNGLDEBUGMESSAGECALLBACKPROC) (GLDEBUGPROC callback, const void *userParam);
typedef void ( * PFNGLDEBUGMESSAGECONTROLPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void ( * PFNGLDEBUGMESSAGEINSERTPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGPROC) (GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);
typedef void ( * PFNGLGETOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void ( * PFNGLGETOBJECTPTRLABELPROC) (void* ptr, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void ( * PFNGLOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei length, const GLchar* label);
typedef void ( * PFNGLOBJECTPTRLABELPROC) (void* ptr, GLsizei length, const GLchar* label);
typedef void ( * PFNGLPOPDEBUGGROUPPROC) (void);
typedef void ( * PFNGLPUSHDEBUGGROUPPROC) (GLenum source, GLuint id, GLsizei length, const GLchar * message);
# 14460 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLMAXSHADERCOMPILERTHREADSKHRPROC) (GLuint count);
# 14491 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETNUNIFORMFVPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
typedef void ( * PFNGLGETNUNIFORMIVPROC) (GLuint program, GLint location, GLsizei bufSize, GLint* params);
typedef void ( * PFNGLGETNUNIFORMUIVPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint* params);
typedef void ( * PFNGLREADNPIXELSPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);
# 14662 "/opt/homebrew/include/GL/glew.h"
typedef GLuint ( * PFNGLBUFFERREGIONENABLEDPROC) (void);
typedef void ( * PFNGLDELETEBUFFERREGIONPROC) (GLenum region);
typedef void ( * PFNGLDRAWBUFFERREGIONPROC) (GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest);
typedef GLuint ( * PFNGLNEWBUFFERREGIONPROC) (GLenum region);
typedef void ( * PFNGLREADBUFFERREGIONPROC) (GLuint region, GLint x, GLint y, GLsizei width, GLsizei height);
# 14701 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERPARAMETERIMESAPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLGETFRAMEBUFFERPARAMETERIVMESAPROC) (GLenum target, GLenum pname, GLint* params);
# 14738 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLRESIZEBUFFERSMESAPROC) (void);
# 14769 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLWINDOWPOS2DMESAPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVMESAPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS2FMESAPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVMESAPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS2IMESAPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVMESAPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS2SMESAPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVMESAPROC) (const GLshort* p);
typedef void ( * PFNGLWINDOWPOS3DMESAPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVMESAPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS3FMESAPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVMESAPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS3IMESAPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVMESAPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS3SMESAPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVMESAPROC) (const GLshort* p);
typedef void ( * PFNGLWINDOWPOS4DMESAPROC) (GLdouble x, GLdouble y, GLdouble z, GLdouble);
typedef void ( * PFNGLWINDOWPOS4DVMESAPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS4FMESAPROC) (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLWINDOWPOS4FVMESAPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS4IMESAPROC) (GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLWINDOWPOS4IVMESAPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS4SMESAPROC) (GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLWINDOWPOS4SVMESAPROC) (const GLshort* p);
# 14850 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBEGINCONDITIONALRENDERNVXPROC) (GLuint id);
typedef void ( * PFNGLENDCONDITIONALRENDERNVXPROC) (void);
# 14882 "/opt/homebrew/include/GL/glew.h"
typedef GLsync ( * PFNGLASYNCCOPYBUFFERSUBDATANVXPROC) (GLsizei waitSemaphoreCount, const GLuint* waitSemaphoreArray, const GLuint64 *fenceValueArray, GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, GLsizei signalSemaphoreCount, const GLuint *signalSemaphoreArray, const GLuint64 *signalValueArray);
typedef GLuint ( * PFNGLASYNCCOPYIMAGESUBDATANVXPROC) (GLsizei waitSemaphoreCount, const GLuint* waitSemaphoreArray, const GLuint64 *waitValueArray, GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, GLsizei signalSemaphoreCount, const GLuint *signalSemaphoreArray, const GLuint64 *signalValueArray);
typedef void ( * PFNGLMULTICASTSCISSORARRAYVNVXPROC) (GLuint gpu, GLuint first, GLsizei count, const GLint* v);
typedef void ( * PFNGLMULTICASTVIEWPORTARRAYVNVXPROC) (GLuint gpu, GLuint first, GLsizei count, const GLfloat* v);
typedef void ( * PFNGLMULTICASTVIEWPORTPOSITIONWSCALENVXPROC) (GLuint gpu, GLuint index, GLfloat xcoeff, GLfloat ycoeff);
typedef void ( * PFNGLUPLOADGPUMASKNVXPROC) (GLbitfield mask);
# 14908 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLLGPUCOPYIMAGESUBDATANVXPROC) (GLuint sourceGpu, GLbitfield destinationGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srxY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
typedef void ( * PFNGLLGPUINTERLOCKNVXPROC) (void);
typedef void ( * PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC) (GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
# 14925 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCLIENTWAITSEMAPHOREUI64NVXPROC) (GLsizei fenceObjectCount, const GLuint* semaphoreArray, const GLuint64 *fenceValueArray);
typedef void ( * PFNGLSIGNALSEMAPHOREUI64NVXPROC) (GLuint signalGpu, GLsizei fenceObjectCount, const GLuint* semaphoreArray, const GLuint64 *fenceValueArray);
typedef void ( * PFNGLWAITSEMAPHOREUI64NVXPROC) (GLuint waitGpu, GLsizei fenceObjectCount, const GLuint* semaphoreArray, const GLuint64 *fenceValueArray);
# 14950 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLSTEREOPARAMETERFNVPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLSTEREOPARAMETERINVPROC) (GLenum pname, GLint param);
# 14984 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLALPHATOCOVERAGEDITHERCONTROLNVPROC) (GLenum mode);
# 15008 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC) (GLenum mode, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
# 15023 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC) (GLenum mode, const void *indirect, GLintptr drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC) (GLenum mode, GLenum type, const void *indirect, GLintptr drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);
# 15038 "/opt/homebrew/include/GL/glew.h"
typedef GLuint64 ( * PFNGLGETIMAGEHANDLENVPROC) (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef GLuint64 ( * PFNGLGETTEXTUREHANDLENVPROC) (GLuint texture);
typedef GLuint64 ( * PFNGLGETTEXTURESAMPLERHANDLENVPROC) (GLuint texture, GLuint sampler);
typedef GLboolean ( * PFNGLISIMAGEHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef GLboolean ( * PFNGLISTEXTUREHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKEIMAGEHANDLERESIDENTNVPROC) (GLuint64 handle, GLenum access);
typedef void ( * PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKETEXTUREHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC) (GLuint program, GLint location, GLuint64 value);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
typedef void ( * PFNGLUNIFORMHANDLEUI64NVPROC) (GLint location, GLuint64 value);
typedef void ( * PFNGLUNIFORMHANDLEUI64VNVPROC) (GLint location, GLsizei count, const GLuint64* value);
# 15126 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBLENDBARRIERNVPROC) (void);
typedef void ( * PFNGLBLENDPARAMETERINVPROC) (GLenum pname, GLint value);
# 15175 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLVIEWPORTPOSITIONWSCALENVPROC) (GLuint index, GLfloat xcoeff, GLfloat ycoeff);
# 15208 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCALLCOMMANDLISTNVPROC) (GLuint list);
typedef void ( * PFNGLCOMMANDLISTSEGMENTSNVPROC) (GLuint list, GLuint segments);
typedef void ( * PFNGLCOMPILECOMMANDLISTNVPROC) (GLuint list);
typedef void ( * PFNGLCREATECOMMANDLISTSNVPROC) (GLsizei n, GLuint* lists);
typedef void ( * PFNGLCREATESTATESNVPROC) (GLsizei n, GLuint* states);
typedef void ( * PFNGLDELETECOMMANDLISTSNVPROC) (GLsizei n, const GLuint* lists);
typedef void ( * PFNGLDELETESTATESNVPROC) (GLsizei n, const GLuint* states);
typedef void ( * PFNGLDRAWCOMMANDSADDRESSNVPROC) (GLenum primitiveMode, const GLuint64* indirects, const GLsizei* sizes, GLuint count);
typedef void ( * PFNGLDRAWCOMMANDSNVPROC) (GLenum primitiveMode, GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, GLuint count);
typedef void ( * PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC) (const GLuint64* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
typedef void ( * PFNGLDRAWCOMMANDSSTATESNVPROC) (GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
typedef GLuint ( * PFNGLGETCOMMANDHEADERNVPROC) (GLenum tokenID, GLuint size);
typedef GLushort ( * PFNGLGETSTAGEINDEXNVPROC) (GLenum shadertype);
typedef GLboolean ( * PFNGLISCOMMANDLISTNVPROC) (GLuint list);
typedef GLboolean ( * PFNGLISSTATENVPROC) (GLuint state);
typedef void ( * PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC) (GLuint list, GLuint segment, const void** indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
typedef void ( * PFNGLSTATECAPTURENVPROC) (GLuint state, GLenum mode);
# 15279 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBEGINCONDITIONALRENDERNVPROC) (GLuint id, GLenum mode);
typedef void ( * PFNGLENDCONDITIONALRENDERNVPROC) (void);
# 15299 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLSUBPIXELPRECISIONBIASNVPROC) (GLuint xbits, GLuint ybits);
# 15316 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCONSERVATIVERASTERPARAMETERFNVPROC) (GLenum pname, GLfloat value);
# 15344 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCONSERVATIVERASTERPARAMETERINVPROC) (GLenum pname, GLint param);
# 15369 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOPYBUFFERSUBDATANVPROC) (GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);
# 15394 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOPYIMAGESUBDATANVPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
# 15424 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCLEARDEPTHDNVPROC) (GLdouble depth);
typedef void ( * PFNGLDEPTHBOUNDSDNVPROC) (GLdouble zmin, GLdouble zmax);
typedef void ( * PFNGLDEPTHRANGEDNVPROC) (GLdouble zNear, GLdouble zFar);
# 15512 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWBUFFERSNVPROC) (GLsizei n, const GLenum* bufs);
# 15525 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWARRAYSINSTANCEDNVPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDNVPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
# 15540 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWTEXTURENVPROC) (GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);
# 15553 "/opt/homebrew/include/GL/glew.h"
typedef void ( *GLVULKANPROCNV)(void);

typedef void ( * PFNGLDRAWVKIMAGENVPROC) (GLuint64 vkImage, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);
typedef GLVULKANPROCNV ( * PFNGLGETVKPROCADDRNVPROC) (const GLchar* name);
typedef void ( * PFNGLSIGNALVKFENCENVPROC) (GLuint64 vkFence);
typedef void ( * PFNGLSIGNALVKSEMAPHORENVPROC) (GLuint64 vkSemaphore);
typedef void ( * PFNGLWAITVKSEMAPHORENVPROC) (GLuint64 vkSemaphore);
# 15601 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLEVALMAPSNVPROC) (GLenum target, GLenum mode);
typedef void ( * PFNGLGETMAPATTRIBPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMAPATTRIBPARAMETERIVNVPROC) (GLenum target, GLuint index, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void *points);
typedef void ( * PFNGLGETMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void *points);
typedef void ( * PFNGLMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, const GLint* params);
# 15650 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETMULTISAMPLEFVNVPROC) (GLenum pname, GLuint index, GLfloat* val);
typedef void ( * PFNGLSAMPLEMASKINDEXEDNVPROC) (GLuint index, GLbitfield mask);
typedef void ( * PFNGLTEXRENDERBUFFERNVPROC) (GLenum target, GLuint renderbuffer);
# 15698 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDELETEFENCESNVPROC) (GLsizei n, const GLuint* fences);
typedef void ( * PFNGLFINISHFENCENVPROC) (GLuint fence);
typedef void ( * PFNGLGENFENCESNVPROC) (GLsizei n, GLuint* fences);
typedef void ( * PFNGLGETFENCEIVNVPROC) (GLuint fence, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISFENCENVPROC) (GLuint fence);
typedef void ( * PFNGLSETFENCENVPROC) (GLuint fence, GLenum condition);
typedef GLboolean ( * PFNGLTESTFENCENVPROC) (GLuint fence);
# 15775 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAGMENTCOVERAGECOLORNVPROC) (GLuint color);
# 15795 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLdouble *params);
typedef void ( * PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLfloat *params);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4DNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, const GLdouble v[]);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4FNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, const GLfloat v[]);
# 15874 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBLITFRAMEBUFFERNVPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
# 15915 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLENVPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 15933 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
# 15959 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLPROGRAMVERTEXLIMITNVPROC) (GLenum target, GLint limit);
# 15996 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLMULTICASTBARRIERNVPROC) (void);
typedef void ( * PFNGLMULTICASTBLITFRAMEBUFFERNVPROC) (GLuint srcGpu, GLuint dstGpu, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void ( * PFNGLMULTICASTBUFFERSUBDATANVPROC) (GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
typedef void ( * PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC) (GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void ( * PFNGLMULTICASTCOPYIMAGESUBDATANVPROC) (GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
typedef void ( * PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) (GLuint gpu, GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);
typedef void ( * PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC) (GLuint gpu, GLuint id, GLenum pname, GLint64* params);
typedef void ( * PFNGLMULTICASTGETQUERYOBJECTIVNVPROC) (GLuint gpu, GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC) (GLuint gpu, GLuint id, GLenum pname, GLuint64* params);
typedef void ( * PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC) (GLuint gpu, GLuint id, GLenum pname, GLuint* params);
typedef void ( * PFNGLMULTICASTWAITSYNCNVPROC) (GLuint signalGpu, GLbitfield waitGpuMask);
typedef void ( * PFNGLRENDERGPUMASKNVPROC) (GLbitfield mask);
# 16040 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLPROGRAMENVPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
# 16138 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETUNIFORMI64VNVPROC) (GLuint program, GLint location, GLint64EXT* params);
typedef void ( * PFNGLGETUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLuint64EXT* params);
typedef void ( * PFNGLPROGRAMUNIFORM1I64NVPROC) (GLuint program, GLint location, GLint64EXT x);
typedef void ( * PFNGLPROGRAMUNIFORM1I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM1UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x);
typedef void ( * PFNGLPROGRAMUNIFORM1UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM2I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
typedef void ( * PFNGLPROGRAMUNIFORM2I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM2UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void ( * PFNGLPROGRAMUNIFORM2UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM3I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void ( * PFNGLPROGRAMUNIFORM3I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM3UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void ( * PFNGLPROGRAMUNIFORM3UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM4I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void ( * PFNGLPROGRAMUNIFORM4I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM4UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void ( * PFNGLPROGRAMUNIFORM4UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORM1I64NVPROC) (GLint location, GLint64EXT x);
typedef void ( * PFNGLUNIFORM1I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLUNIFORM1UI64NVPROC) (GLint location, GLuint64EXT x);
typedef void ( * PFNGLUNIFORM1UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORM2I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y);
typedef void ( * PFNGLUNIFORM2I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLUNIFORM2UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void ( * PFNGLUNIFORM2UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORM3I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void ( * PFNGLUNIFORM3I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLUNIFORM3UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void ( * PFNGLUNIFORM3UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORM4I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void ( * PFNGLUNIFORM4I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLUNIFORM4UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void ( * PFNGLUNIFORM4UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
# 16219 "/opt/homebrew/include/GL/glew.h"
typedef unsigned short GLhalf;

typedef void ( * PFNGLCOLOR3HNVPROC) (GLhalf red, GLhalf green, GLhalf blue);
typedef void ( * PFNGLCOLOR3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLCOLOR4HNVPROC) (GLhalf red, GLhalf green, GLhalf blue, GLhalf alpha);
typedef void ( * PFNGLCOLOR4HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLFOGCOORDHNVPROC) (GLhalf fog);
typedef void ( * PFNGLFOGCOORDHVNVPROC) (const GLhalf* fog);
typedef void ( * PFNGLMULTITEXCOORD1HNVPROC) (GLenum target, GLhalf s);
typedef void ( * PFNGLMULTITEXCOORD1HVNVPROC) (GLenum target, const GLhalf* v);
typedef void ( * PFNGLMULTITEXCOORD2HNVPROC) (GLenum target, GLhalf s, GLhalf t);
typedef void ( * PFNGLMULTITEXCOORD2HVNVPROC) (GLenum target, const GLhalf* v);
typedef void ( * PFNGLMULTITEXCOORD3HNVPROC) (GLenum target, GLhalf s, GLhalf t, GLhalf r);
typedef void ( * PFNGLMULTITEXCOORD3HVNVPROC) (GLenum target, const GLhalf* v);
typedef void ( * PFNGLMULTITEXCOORD4HNVPROC) (GLenum target, GLhalf s, GLhalf t, GLhalf r, GLhalf q);
typedef void ( * PFNGLMULTITEXCOORD4HVNVPROC) (GLenum target, const GLhalf* v);
typedef void ( * PFNGLNORMAL3HNVPROC) (GLhalf nx, GLhalf ny, GLhalf nz);
typedef void ( * PFNGLNORMAL3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLSECONDARYCOLOR3HNVPROC) (GLhalf red, GLhalf green, GLhalf blue);
typedef void ( * PFNGLSECONDARYCOLOR3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLTEXCOORD1HNVPROC) (GLhalf s);
typedef void ( * PFNGLTEXCOORD1HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLTEXCOORD2HNVPROC) (GLhalf s, GLhalf t);
typedef void ( * PFNGLTEXCOORD2HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLTEXCOORD3HNVPROC) (GLhalf s, GLhalf t, GLhalf r);
typedef void ( * PFNGLTEXCOORD3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLTEXCOORD4HNVPROC) (GLhalf s, GLhalf t, GLhalf r, GLhalf q);
typedef void ( * PFNGLTEXCOORD4HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLVERTEX2HNVPROC) (GLhalf x, GLhalf y);
typedef void ( * PFNGLVERTEX2HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLVERTEX3HNVPROC) (GLhalf x, GLhalf y, GLhalf z);
typedef void ( * PFNGLVERTEX3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLVERTEX4HNVPROC) (GLhalf x, GLhalf y, GLhalf z, GLhalf w);
typedef void ( * PFNGLVERTEX4HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIB1HNVPROC) (GLuint index, GLhalf x);
typedef void ( * PFNGLVERTEXATTRIB1HVNVPROC) (GLuint index, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIB2HNVPROC) (GLuint index, GLhalf x, GLhalf y);
typedef void ( * PFNGLVERTEXATTRIB2HVNVPROC) (GLuint index, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIB3HNVPROC) (GLuint index, GLhalf x, GLhalf y, GLhalf z);
typedef void ( * PFNGLVERTEXATTRIB3HVNVPROC) (GLuint index, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIB4HNVPROC) (GLuint index, GLhalf x, GLhalf y, GLhalf z, GLhalf w);
typedef void ( * PFNGLVERTEXATTRIB4HVNVPROC) (GLuint index, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIBS1HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIBS2HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIBS3HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIBS4HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void ( * PFNGLVERTEXWEIGHTHNVPROC) (GLhalf weight);
typedef void ( * PFNGLVERTEXWEIGHTHVNVPROC) (const GLhalf* weight);
# 16335 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLVERTEXATTRIBDIVISORNVPROC) (GLuint index, GLuint divisor);
# 16353 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETINTERNALFORMATSAMPLEIVNVPROC) (GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei bufSize, GLint* params);
# 16389 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBUFFERATTACHMEMORYNVPROC) (GLenum target, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLGETMEMORYOBJECTDETACHEDRESOURCESUIVNVPROC) (GLuint memory, GLenum pname, GLint first, GLsizei count, GLuint* params);
typedef void ( * PFNGLNAMEDBUFFERATTACHMEMORYNVPROC) (GLuint buffer, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLRESETMEMORYOBJECTPARAMETERNVPROC) (GLuint memory, GLenum pname);
typedef void ( * PFNGLTEXATTACHMEMORYNVPROC) (GLenum target, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXTUREATTACHMEMORYNVPROC) (GLuint texture, GLuint memory, GLuint64 offset);
# 16461 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDRAWMESHTASKSINDIRECTNVPROC) (GLintptr indirect);
typedef void ( * PFNGLDRAWMESHTASKSNVPROC) (GLuint first, GLuint count);
typedef void ( * PFNGLMULTIDRAWMESHTASKSINDIRECTCOUNTNVPROC) (GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWMESHTASKSINDIRECTNVPROC) (GLintptr indirect, GLsizei drawcount, GLsizei stride);
# 16509 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLUNIFORMMATRIX2X3FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX2X4FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX3X2FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX3X4FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX4X2FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX4X3FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
# 16537 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBEGINOCCLUSIONQUERYNVPROC) (GLuint id);
typedef void ( * PFNGLDELETEOCCLUSIONQUERIESNVPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLENDOCCLUSIONQUERYNVPROC) (void);
typedef void ( * PFNGLGENOCCLUSIONQUERIESNVPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETOCCLUSIONQUERYIVNVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETOCCLUSIONQUERYUIVNVPROC) (GLuint id, GLenum pname, GLuint* params);
typedef GLboolean ( * PFNGLISOCCLUSIONQUERYNVPROC) (GLuint id);
# 16617 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params);
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params);
# 16793 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOPYPATHNVPROC) (GLuint resultPath, GLuint srcPath);
typedef void ( * PFNGLCOVERFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLCOVERFILLPATHNVPROC) (GLuint path, GLenum coverMode);
typedef void ( * PFNGLCOVERSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLCOVERSTROKEPATHNVPROC) (GLuint path, GLenum coverMode);
typedef void ( * PFNGLDELETEPATHSNVPROC) (GLuint path, GLsizei range);
typedef GLuint ( * PFNGLGENPATHSNVPROC) (GLsizei range);
typedef void ( * PFNGLGETPATHCOLORGENFVNVPROC) (GLenum color, GLenum pname, GLfloat* value);
typedef void ( * PFNGLGETPATHCOLORGENIVNVPROC) (GLenum color, GLenum pname, GLint* value);
typedef void ( * PFNGLGETPATHCOMMANDSNVPROC) (GLuint path, GLubyte* commands);
typedef void ( * PFNGLGETPATHCOORDSNVPROC) (GLuint path, GLfloat* coords);
typedef void ( * PFNGLGETPATHDASHARRAYNVPROC) (GLuint path, GLfloat* dashArray);
typedef GLfloat ( * PFNGLGETPATHLENGTHNVPROC) (GLuint path, GLsizei startSegment, GLsizei numSegments);
typedef void ( * PFNGLGETPATHMETRICRANGENVPROC) (GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat* metrics);
typedef void ( * PFNGLGETPATHMETRICSNVPROC) (GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics);
typedef void ( * PFNGLGETPATHPARAMETERFVNVPROC) (GLuint path, GLenum pname, GLfloat* value);
typedef void ( * PFNGLGETPATHPARAMETERIVNVPROC) (GLuint path, GLenum pname, GLint* value);
typedef void ( * PFNGLGETPATHSPACINGNVPROC) (GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing);
typedef void ( * PFNGLGETPATHTEXGENFVNVPROC) (GLenum texCoordSet, GLenum pname, GLfloat* value);
typedef void ( * PFNGLGETPATHTEXGENIVNVPROC) (GLenum texCoordSet, GLenum pname, GLint* value);
typedef void ( * PFNGLGETPROGRAMRESOURCEFVNVPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei *length, GLfloat *params);
typedef void ( * PFNGLINTERPOLATEPATHSNVPROC) (GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight);
typedef GLboolean ( * PFNGLISPATHNVPROC) (GLuint path);
typedef GLboolean ( * PFNGLISPOINTINFILLPATHNVPROC) (GLuint path, GLuint mask, GLfloat x, GLfloat y);
typedef GLboolean ( * PFNGLISPOINTINSTROKEPATHNVPROC) (GLuint path, GLfloat x, GLfloat y);
typedef void ( * PFNGLMATRIXLOAD3X2FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXLOAD3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXMULT3X2FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXMULT3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLPATHCOLORGENNVPROC) (GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat* coeffs);
typedef void ( * PFNGLPATHCOMMANDSNVPROC) (GLuint path, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const void*coords);
typedef void ( * PFNGLPATHCOORDSNVPROC) (GLuint path, GLsizei numCoords, GLenum coordType, const void *coords);
typedef void ( * PFNGLPATHCOVERDEPTHFUNCNVPROC) (GLenum zfunc);
typedef void ( * PFNGLPATHDASHARRAYNVPROC) (GLuint path, GLsizei dashCount, const GLfloat* dashArray);
typedef void ( * PFNGLPATHFOGGENNVPROC) (GLenum genMode);
typedef GLenum ( * PFNGLPATHGLYPHINDEXARRAYNVPROC) (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef GLenum ( * PFNGLPATHGLYPHINDEXRANGENVPROC) (GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint baseAndCount[2]);
typedef void ( * PFNGLPATHGLYPHRANGENVPROC) (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void ( * PFNGLPATHGLYPHSNVPROC) (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void*charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef GLenum ( * PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC) (GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void *fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void ( * PFNGLPATHPARAMETERFNVPROC) (GLuint path, GLenum pname, GLfloat value);
typedef void ( * PFNGLPATHPARAMETERFVNVPROC) (GLuint path, GLenum pname, const GLfloat* value);
typedef void ( * PFNGLPATHPARAMETERINVPROC) (GLuint path, GLenum pname, GLint value);
typedef void ( * PFNGLPATHPARAMETERIVNVPROC) (GLuint path, GLenum pname, const GLint* value);
typedef void ( * PFNGLPATHSTENCILDEPTHOFFSETNVPROC) (GLfloat factor, GLfloat units);
typedef void ( * PFNGLPATHSTENCILFUNCNVPROC) (GLenum func, GLint ref, GLuint mask);
typedef void ( * PFNGLPATHSTRINGNVPROC) (GLuint path, GLenum format, GLsizei length, const void *pathString);
typedef void ( * PFNGLPATHSUBCOMMANDSNVPROC) (GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const void*coords);
typedef void ( * PFNGLPATHSUBCOORDSNVPROC) (GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void *coords);
typedef void ( * PFNGLPATHTEXGENNVPROC) (GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat* coeffs);
typedef GLboolean ( * PFNGLPOINTALONGPATHNVPROC) (GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat* x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY);
typedef void ( * PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC) (GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat* coeffs);
typedef void ( * PFNGLSTENCILFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLSTENCILFILLPATHNVPROC) (GLuint path, GLenum fillMode, GLuint mask);
typedef void ( * PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLSTENCILSTROKEPATHNVPROC) (GLuint path, GLint reference, GLuint mask);
typedef void ( * PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLSTENCILTHENCOVERFILLPATHNVPROC) (GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode);
typedef void ( * PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC) (GLuint path, GLint reference, GLuint mask, GLenum coverMode);
typedef void ( * PFNGLTRANSFORMPATHNVPROC) (GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat* transformValues);
typedef void ( * PFNGLWEIGHTPATHSNVPROC) (GLuint resultPath, GLsizei numPaths, const GLuint paths[], const GLfloat weights[]);
# 16964 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFLUSHPIXELDATARANGENVPROC) (GLenum target);
typedef void ( * PFNGLPIXELDATARANGENVPROC) (GLenum target, GLsizei length, void *pointer);
# 16994 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLPOINTPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPOINTPARAMETERIVNVPROC) (GLenum pname, const GLint* params);
# 17016 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLPOLYGONMODENVPROC) (GLenum face, GLenum mode);
# 17036 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETVIDEOI64VNVPROC) (GLuint video_slot, GLenum pname, GLint64EXT* params);
typedef void ( * PFNGLGETVIDEOIVNVPROC) (GLuint video_slot, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVIDEOUI64VNVPROC) (GLuint video_slot, GLenum pname, GLuint64EXT* params);
typedef void ( * PFNGLGETVIDEOUIVNVPROC) (GLuint video_slot, GLenum pname, GLuint* params);
typedef void ( * PFNGLPRESENTFRAMEDUALFILLNVPROC) (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3);
typedef void ( * PFNGLPRESENTFRAMEKEYEDNVPROC) (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1);
# 17062 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLPRIMITIVERESTARTINDEXNVPROC) (GLuint index);
typedef void ( * PFNGLPRIMITIVERESTARTNVPROC) (void);
# 17088 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLREADBUFFERNVPROC) (GLenum mode);
# 17191 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOMBINERINPUTNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void ( * PFNGLCOMBINEROUTPUTNVPROC) (GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
typedef void ( * PFNGLCOMBINERPARAMETERFNVPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLCOMBINERPARAMETERFVNVPROC) (GLenum pname, const GLfloat* params);
typedef void ( * PFNGLCOMBINERPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLCOMBINERPARAMETERIVNVPROC) (GLenum pname, const GLint* params);
typedef void ( * PFNGLFINALCOMBINERINPUTNVPROC) (GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void ( * PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint* params);
typedef void ( * PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLint* params);
typedef void ( * PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC) (GLenum variable, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC) (GLenum variable, GLenum pname, GLint* params);
# 17230 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, GLfloat* params);
# 17296 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) (GLenum target, GLuint start, GLsizei count, const GLfloat* v);
typedef void ( * PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);
typedef void ( * PFNGLRESOLVEDEPTHVALUESNVPROC) (void);
# 17325 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLSCISSOREXCLUSIVEARRAYVNVPROC) (GLuint first, GLsizei count, const GLint* v);
typedef void ( * PFNGLSCISSOREXCLUSIVENVPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
# 17389 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETBUFFERPARAMETERUI64VNVPROC) (GLenum target, GLenum pname, GLuint64EXT* params);
typedef void ( * PFNGLGETINTEGERUI64VNVPROC) (GLenum value, GLuint64EXT* result);
typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC) (GLuint buffer, GLenum pname, GLuint64EXT* params);
typedef GLboolean ( * PFNGLISBUFFERRESIDENTNVPROC) (GLenum target);
typedef GLboolean ( * PFNGLISNAMEDBUFFERRESIDENTNVPROC) (GLuint buffer);
typedef void ( * PFNGLMAKEBUFFERNONRESIDENTNVPROC) (GLenum target);
typedef void ( * PFNGLMAKEBUFFERRESIDENTNVPROC) (GLenum target, GLenum access);
typedef void ( * PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC) (GLuint buffer);
typedef void ( * PFNGLMAKENAMEDBUFFERRESIDENTNVPROC) (GLuint buffer, GLenum access);
typedef void ( * PFNGLPROGRAMUNIFORMUI64NVPROC) (GLuint program, GLint location, GLuint64EXT value);
typedef void ( * PFNGLPROGRAMUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORMUI64NVPROC) (GLint location, GLuint64EXT value);
typedef void ( * PFNGLUNIFORMUI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
# 17508 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDSHADINGRATEIMAGENVPROC) (GLuint texture);
typedef void ( * PFNGLGETSHADINGRATEIMAGEPALETTENVPROC) (GLuint viewport, GLuint entry, GLenum* rate);
typedef void ( * PFNGLGETSHADINGRATESAMPLELOCATIONIVNVPROC) (GLenum rate, GLuint samples, GLuint index, GLint* location);
typedef void ( * PFNGLSHADINGRATEIMAGEBARRIERNVPROC) (GLenum order);
typedef void ( * PFNGLSHADINGRATEIMAGEPALETTENVPROC) (GLuint viewport, GLuint first, GLsizei count, const GLenum* rates);
typedef void ( * PFNGLSHADINGRATESAMPLEORDERCUSTOMNVPROC) (GLenum rate, GLuint samples, const GLint* locations);
# 17610 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DNVPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DNVPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOPYTEXSUBIMAGE3DNVPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYERNVPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLTEXIMAGE3DNVPROC) (GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXSUBIMAGE3DNVPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
# 17633 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXTUREBARRIERNVPROC) (void);
# 17733 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC) (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC) (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC) (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC) (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
# 17962 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLACTIVEVARYINGNVPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKNVPROC) (GLenum primitiveMode);
typedef void ( * PFNGLBINDBUFFERBASENVPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void ( * PFNGLBINDBUFFEROFFSETNVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void ( * PFNGLBINDBUFFERRANGENVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLENDTRANSFORMFEEDBACKNVPROC) (void);
typedef void ( * PFNGLGETACTIVEVARYINGNVPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC) (GLuint program, GLuint index, GLint *location);
typedef GLint ( * PFNGLGETVARYINGLOCATIONNVPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC) (GLuint count, const GLint *attribs, GLenum bufferMode);
typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC) (GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode);
# 18000 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDTRANSFORMFEEDBACKNVPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETETRANSFORMFEEDBACKSNVPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKNVPROC) (GLenum mode, GLuint id);
typedef void ( * PFNGLGENTRANSFORMFEEDBACKSNVPROC) (GLsizei n, GLuint* ids);
typedef GLboolean ( * PFNGLISTRANSFORMFEEDBACKNVPROC) (GLuint id);
typedef void ( * PFNGLPAUSETRANSFORMFEEDBACKNVPROC) (void);
typedef void ( * PFNGLRESUMETRANSFORMFEEDBACKNVPROC) (void);
# 18043 "/opt/homebrew/include/GL/glew.h"
typedef GLintptr GLvdpauSurfaceNV;

typedef void ( * PFNGLVDPAUFININVPROC) (void);
typedef void ( * PFNGLVDPAUGETSURFACEIVNVPROC) (GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei* length, GLint *values);
typedef void ( * PFNGLVDPAUINITNVPROC) (const void* vdpDevice, const void*getProcAddress);
typedef void ( * PFNGLVDPAUISSURFACENVPROC) (GLvdpauSurfaceNV surface);
typedef void ( * PFNGLVDPAUMAPSURFACESNVPROC) (GLsizei numSurfaces, const GLvdpauSurfaceNV* surfaces);
typedef GLvdpauSurfaceNV ( * PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC) (const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
typedef GLvdpauSurfaceNV ( * PFNGLVDPAUREGISTERVIDEOSURFACENVPROC) (const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
typedef void ( * PFNGLVDPAUSURFACEACCESSNVPROC) (GLvdpauSurfaceNV surface, GLenum access);
typedef void ( * PFNGLVDPAUUNMAPSURFACESNVPROC) (GLsizei numSurface, const GLvdpauSurfaceNV* surfaces);
typedef void ( * PFNGLVDPAUUNREGISTERSURFACENVPROC) (GLvdpauSurfaceNV surface);
# 18076 "/opt/homebrew/include/GL/glew.h"
typedef GLvdpauSurfaceNV ( * PFNGLVDPAUREGISTERVIDEOSURFACEWITHPICTURESTRUCTURENVPROC) (const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames, GLboolean isFrameStructure);
# 18095 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFLUSHVERTEXARRAYRANGENVPROC) (void);
typedef void ( * PFNGLVERTEXARRAYRANGENVPROC) (GLsizei length, void *pointer);
# 18124 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETVERTEXATTRIBLI64VNVPROC) (GLuint index, GLenum pname, GLint64EXT* params);
typedef void ( * PFNGLGETVERTEXATTRIBLUI64VNVPROC) (GLuint index, GLenum pname, GLuint64EXT* params);
typedef void ( * PFNGLVERTEXATTRIBL1I64NVPROC) (GLuint index, GLint64EXT x);
typedef void ( * PFNGLVERTEXATTRIBL1I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL1UI64NVPROC) (GLuint index, GLuint64EXT x);
typedef void ( * PFNGLVERTEXATTRIBL1UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL2I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y);
typedef void ( * PFNGLVERTEXATTRIBL2I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL2UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y);
typedef void ( * PFNGLVERTEXATTRIBL2UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL3I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void ( * PFNGLVERTEXATTRIBL3I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL3UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void ( * PFNGLVERTEXATTRIBL3UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL4I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void ( * PFNGLVERTEXATTRIBL4I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL4UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void ( * PFNGLVERTEXATTRIBL4UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBLFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);
# 18199 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBUFFERADDRESSRANGENVPROC) (GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
typedef void ( * PFNGLCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLEDGEFLAGFORMATNVPROC) (GLsizei stride);
typedef void ( * PFNGLFOGCOORDFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void ( * PFNGLGETINTEGERUI64I_VNVPROC) (GLenum value, GLuint index, GLuint64EXT result[]);
typedef void ( * PFNGLINDEXFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void ( * PFNGLNORMALFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void ( * PFNGLSECONDARYCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLTEXCOORDFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLVERTEXATTRIBFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);
typedef void ( * PFNGLVERTEXATTRIBIFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLVERTEXFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
# 18318 "/opt/homebrew/include/GL/glew.h"
typedef GLboolean ( * PFNGLAREPROGRAMSRESIDENTNVPROC) (GLsizei n, const GLuint* ids, GLboolean *residences);
typedef void ( * PFNGLBINDPROGRAMNVPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETEPROGRAMSNVPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLEXECUTEPROGRAMNVPROC) (GLenum target, GLuint id, const GLfloat* params);
typedef void ( * PFNGLGENPROGRAMSNVPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETPROGRAMPARAMETERDVNVPROC) (GLenum target, GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETPROGRAMPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETPROGRAMSTRINGNVPROC) (GLuint id, GLenum pname, GLubyte* program);
typedef void ( * PFNGLGETPROGRAMIVNVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTRACKMATRIXIVNVPROC) (GLenum target, GLuint address, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVNVPROC) (GLuint index, GLenum pname, void** pointer);
typedef void ( * PFNGLGETVERTEXATTRIBDVNVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETVERTEXATTRIBFVNVPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVERTEXATTRIBIVNVPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISPROGRAMNVPROC) (GLuint id);
typedef void ( * PFNGLLOADPROGRAMNVPROC) (GLenum target, GLuint id, GLsizei len, const GLubyte* program);
typedef void ( * PFNGLPROGRAMPARAMETER4DNVPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMPARAMETER4DVNVPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void ( * PFNGLPROGRAMPARAMETER4FNVPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMPARAMETER4FVNVPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void ( * PFNGLPROGRAMPARAMETERS4DVNVPROC) (GLenum target, GLuint index, GLsizei num, const GLdouble* params);
typedef void ( * PFNGLPROGRAMPARAMETERS4FVNVPROC) (GLenum target, GLuint index, GLsizei num, const GLfloat* params);
typedef void ( * PFNGLREQUESTRESIDENTPROGRAMSNVPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLTRACKMATRIXNVPROC) (GLenum target, GLuint address, GLenum matrix, GLenum transform);
typedef void ( * PFNGLVERTEXATTRIB1DNVPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVNVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB1FNVPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVNVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB1SNVPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVNVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB2DNVPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVNVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB2FNVPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVNVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB2SNVPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVNVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB3DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVNVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB3FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVNVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB3SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVNVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVNVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB4FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVNVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB4SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVNVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4UBNVPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4UBVNVPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIBPOINTERNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
typedef void ( * PFNGLVERTEXATTRIBS1DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBS1FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIBS1SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIBS2DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBS2FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIBS2SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIBS3DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBS3FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIBS3SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIBS4DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBS4FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIBS4SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIBS4UBVNVPROC) (GLuint index, GLsizei n, const GLubyte* v);
# 18539 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBEGINVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
typedef void ( * PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset);
typedef void ( * PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture);
typedef void ( * PFNGLENDVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
typedef void ( * PFNGLGETVIDEOCAPTURESTREAMDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETVIDEOCAPTURESTREAMFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVIDEOCAPTURESTREAMIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVIDEOCAPTUREIVNVPROC) (GLuint video_capture_slot, GLenum pname, GLint* params);
typedef GLenum ( * PFNGLVIDEOCAPTURENVPROC) (GLuint video_capture_slot, GLuint* sequence_num, GLuint64EXT *capture_time);
typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble* params);
typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint* params);
# 18583 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDEPTHRANGEARRAYFVNVPROC) (GLuint first, GLsizei count, const GLfloat * v);
typedef void ( * PFNGLDEPTHRANGEINDEXEDFNVPROC) (GLuint index, GLfloat n, GLfloat f);
typedef void ( * PFNGLDISABLEINVPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLENABLEINVPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLGETFLOATI_VNVPROC) (GLenum target, GLuint index, GLfloat* data);
typedef GLboolean ( * PFNGLISENABLEDINVPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLSCISSORARRAYVNVPROC) (GLuint first, GLsizei count, const GLint * v);
typedef void ( * PFNGLSCISSORINDEXEDNVPROC) (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
typedef void ( * PFNGLSCISSORINDEXEDVNVPROC) (GLuint index, const GLint * v);
typedef void ( * PFNGLVIEWPORTARRAYVNVPROC) (GLuint first, GLsizei count, const GLfloat * v);
typedef void ( * PFNGLVIEWPORTINDEXEDFNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
typedef void ( * PFNGLVIEWPORTINDEXEDFVNVPROC) (GLuint index, const GLfloat * v);
# 18640 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLVIEWPORTSWIZZLENVPROC) (GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew);
# 18653 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLEGLIMAGETARGETRENDERBUFFERSTORAGEOESPROC) (GLenum target, GLeglImageOES image);
typedef void ( * PFNGLEGLIMAGETARGETTEXTURE2DOESPROC) (GLenum target, GLeglImageOES image);
# 18694 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBLENDEQUATIONSEPARATEOESPROC) (GLenum modeRGB, GLenum modeAlpha);
# 18712 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBLENDFUNCSEPARATEOESPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
# 18730 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBLENDEQUATIONOESPROC) (GLenum mode);
# 18783 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOPYIMAGESUBDATAOESPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
# 18846 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBLENDEQUATIONSEPARATEIOESPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDEQUATIONIOESPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDFUNCSEPARATEIOESPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void ( * PFNGLBLENDFUNCIOESPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void ( * PFNGLCOLORMASKIOESPROC) (GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void ( * PFNGLDISABLEIOESPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLENABLEIOESPROC) (GLenum target, GLuint index);
typedef GLboolean ( * PFNGLISENABLEDIOESPROC) (GLenum target, GLuint index);
# 18962 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDFRAMEBUFFEROESPROC) (GLenum target, GLuint framebuffer);
typedef void ( * PFNGLBINDRENDERBUFFEROESPROC) (GLenum target, GLuint renderbuffer);
typedef GLenum ( * PFNGLCHECKFRAMEBUFFERSTATUSOESPROC) (GLenum target);
typedef void ( * PFNGLDELETEFRAMEBUFFERSOESPROC) (GLsizei n, const GLuint* framebuffers);
typedef void ( * PFNGLDELETERENDERBUFFERSOESPROC) (GLsizei n, const GLuint* renderbuffers);
typedef void ( * PFNGLFRAMEBUFFERRENDERBUFFEROESPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DOESPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLGENFRAMEBUFFERSOESPROC) (GLsizei n, GLuint* framebuffers);
typedef void ( * PFNGLGENRENDERBUFFERSOESPROC) (GLsizei n, GLuint* renderbuffers);
typedef void ( * PFNGLGENERATEMIPMAPOESPROC) (GLenum target);
typedef void ( * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVOESPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
typedef void ( * PFNGLGETRENDERBUFFERPARAMETERIVOESPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISFRAMEBUFFEROESPROC) (GLuint framebuffer);
typedef GLboolean ( * PFNGLISRENDERBUFFEROESPROC) (GLuint renderbuffer);
typedef void ( * PFNGLRENDERBUFFERSTORAGEOESPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
# 19093 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETPROGRAMBINARYOESPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLenum *binaryFormat, void*binary);
typedef void ( * PFNGLPROGRAMBINARYOESPROC) (GLuint program, GLenum binaryFormat, const void *binary, GLint length);
# 19122 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETBUFFERPOINTERVOESPROC) (GLenum target, GLenum pname, void** params);
typedef void * ( * PFNGLMAPBUFFEROESPROC) (GLenum target, GLenum access);
typedef GLboolean ( * PFNGLUNMAPBUFFEROESPROC) (GLenum target);
# 19169 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCURRENTPALETTEMATRIXOESPROC) (GLuint index);
typedef void ( * PFNGLMATRIXINDEXPOINTEROESPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
typedef void ( * PFNGLWEIGHTPOINTEROESPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
# 19278 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLMINSAMPLESHADINGOESPROC) (GLfloat value);
# 19331 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCLEARDEPTHFOESPROC) (GLclampf depth);
typedef void ( * PFNGLCLIPPLANEFOESPROC) (GLenum plane, const GLfloat* equation);
typedef void ( * PFNGLDEPTHRANGEFOESPROC) (GLclampf n, GLclampf f);
typedef void ( * PFNGLFRUSTUMFOESPROC) (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);
typedef void ( * PFNGLGETCLIPPLANEFOESPROC) (GLenum plane, GLfloat* equation);
typedef void ( * PFNGLORTHOFOESPROC) (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);
# 19520 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DOESPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DOESPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOPYTEXSUBIMAGE3DOESPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE3DOESPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void ( * PFNGLTEXIMAGE3DOESPROC) (GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXSUBIMAGE3DOESPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
# 19546 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETSAMPLERPARAMETERIIVOESPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef void ( * PFNGLGETSAMPLERPARAMETERIUIVOESPROC) (GLuint sampler, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETTEXPARAMETERIIVOESPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXPARAMETERIUIVOESPROC) (GLenum target, GLenum pname, GLuint* params);
typedef void ( * PFNGLSAMPLERPARAMETERIIVOESPROC) (GLuint sampler, GLenum pname, const GLint* params);
typedef void ( * PFNGLSAMPLERPARAMETERIUIVOESPROC) (GLuint sampler, GLenum pname, const GLuint* params);
typedef void ( * PFNGLTEXPARAMETERIIVOESPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLTEXPARAMETERIUIVOESPROC) (GLenum target, GLenum pname, const GLuint* params);
# 19588 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXBUFFEROESPROC) (GLenum target, GLenum internalformat, GLuint buffer);
typedef void ( * PFNGLTEXBUFFERRANGEOESPROC) (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
# 19675 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETTEXGENFVOESPROC) (GLenum coord, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETTEXGENIVOESPROC) (GLenum coord, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXGENXVOESPROC) (GLenum coord, GLenum pname, GLfixed* params);
typedef void ( * PFNGLTEXGENFOESPROC) (GLenum coord, GLenum pname, GLfloat param);
typedef void ( * PFNGLTEXGENFVOESPROC) (GLenum coord, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLTEXGENIOESPROC) (GLenum coord, GLenum pname, GLint param);
typedef void ( * PFNGLTEXGENIVOESPROC) (GLenum coord, GLenum pname, const GLint* params);
typedef void ( * PFNGLTEXGENXOESPROC) (GLenum coord, GLenum pname, GLfixed param);
typedef void ( * PFNGLTEXGENXVOESPROC) (GLenum coord, GLenum pname, const GLfixed* params);
# 19770 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXSTORAGE3DMULTISAMPLEOESPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
# 19789 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXTUREVIEWOESPROC) (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
# 19804 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLBINDVERTEXARRAYOESPROC) (GLuint array);
typedef void ( * PFNGLDELETEVERTEXARRAYSOESPROC) (GLsizei n, const GLuint* arrays);
typedef void ( * PFNGLGENVERTEXARRAYSOESPROC) (GLsizei n, GLuint* arrays);
typedef GLboolean ( * PFNGLISVERTEXARRAYOESPROC) (GLuint array);
# 19891 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews);
# 19915 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERTEXTUREMULTISAMPLEMULTIVIEWOVRPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLsizei samples, GLint baseViewIndex, GLsizei numViews);
# 20003 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLALPHAFUNCQCOMPROC) (GLenum func, GLclampf ref);
# 20031 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDISABLEDRIVERCONTROLQCOMPROC) (GLuint driverControl);
typedef void ( * PFNGLENABLEDRIVERCONTROLQCOMPROC) (GLuint driverControl);
typedef void ( * PFNGLGETDRIVERCONTROLSTRINGQCOMPROC) (GLuint driverControl, GLsizei bufSize, GLsizei* length, GLchar *driverControlString);
typedef void ( * PFNGLGETDRIVERCONTROLSQCOMPROC) (GLint* num, GLsizei size, GLuint *driverControls);
# 20062 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLEXTGETBUFFERPOINTERVQCOMPROC) (GLenum target, void** params);
typedef void ( * PFNGLEXTGETBUFFERSQCOMPROC) (GLuint* buffers, GLint maxBuffers, GLint* numBuffers);
typedef void ( * PFNGLEXTGETFRAMEBUFFERSQCOMPROC) (GLuint* framebuffers, GLint maxFramebuffers, GLint* numFramebuffers);
typedef void ( * PFNGLEXTGETRENDERBUFFERSQCOMPROC) (GLuint* renderbuffers, GLint maxRenderbuffers, GLint* numRenderbuffers);
typedef void ( * PFNGLEXTGETTEXLEVELPARAMETERIVQCOMPROC) (GLuint texture, GLenum face, GLint level, GLenum pname, GLint* params);
typedef void ( * PFNGLEXTGETTEXSUBIMAGEQCOMPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void *texels);
typedef void ( * PFNGLEXTGETTEXTURESQCOMPROC) (GLuint* textures, GLint maxTextures, GLint* numTextures);
typedef void ( * PFNGLEXTTEXOBJECTSTATEOVERRIDEIQCOMPROC) (GLenum target, GLenum pname, GLint param);
# 20089 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLEXTGETPROGRAMBINARYSOURCEQCOMPROC) (GLuint program, GLenum shadertype, GLchar* source, GLint* length);
typedef void ( * PFNGLEXTGETPROGRAMSQCOMPROC) (GLuint* programs, GLint maxPrograms, GLint* numPrograms);
typedef void ( * PFNGLEXTGETSHADERSQCOMPROC) (GLuint* shaders, GLint maxShaders, GLint* numShaders);
typedef GLboolean ( * PFNGLEXTISPROGRAMBINARYQCOMPROC) (GLuint program);
# 20111 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERFOVEATIONCONFIGQCOMPROC) (GLuint fbo, GLuint numLayers, GLuint focalPointsPerLayer, GLuint requestedFeatures, GLuint* providedFeatures);
typedef void ( * PFNGLFRAMEBUFFERFOVEATIONPARAMETERSQCOMPROC) (GLuint fbo, GLuint layer, GLuint focalPoint, GLfloat focalX, GLfloat focalY, GLfloat gainX, GLfloat gainY, GLfloat foveaArea);
# 20139 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERFETCHBARRIERQCOMPROC) (void);
# 20169 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXTUREFOVEATIONPARAMETERSQCOMPROC) (GLuint texture, GLuint layer, GLuint focalPoint, GLfloat focalX, GLfloat focalY, GLfloat gainX, GLfloat gainY, GLfloat foveaArea);
# 20227 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLENDTILINGQCOMPROC) (GLbitfield preserveMask);
typedef void ( * PFNGLSTARTTILINGQCOMPROC) (GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask);
# 20253 "/opt/homebrew/include/GL/glew.h"
typedef int GLclampx;

typedef void ( * PFNGLALPHAFUNCXPROC) (GLenum func, GLclampx ref);
typedef void ( * PFNGLCLEARCOLORXPROC) (GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
typedef void ( * PFNGLCLEARDEPTHXPROC) (GLclampx depth);
typedef void ( * PFNGLCOLOR4XPROC) (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
typedef void ( * PFNGLDEPTHRANGEXPROC) (GLclampx zNear, GLclampx zFar);
typedef void ( * PFNGLFOGXPROC) (GLenum pname, GLfixed param);
typedef void ( * PFNGLFOGXVPROC) (GLenum pname, const GLfixed* params);
typedef void ( * PFNGLFRUSTUMFPROC) (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
typedef void ( * PFNGLFRUSTUMXPROC) (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
typedef void ( * PFNGLLIGHTMODELXPROC) (GLenum pname, GLfixed param);
typedef void ( * PFNGLLIGHTMODELXVPROC) (GLenum pname, const GLfixed* params);
typedef void ( * PFNGLLIGHTXPROC) (GLenum light, GLenum pname, GLfixed param);
typedef void ( * PFNGLLIGHTXVPROC) (GLenum light, GLenum pname, const GLfixed* params);
typedef void ( * PFNGLLINEWIDTHXPROC) (GLfixed width);
typedef void ( * PFNGLLOADMATRIXXPROC) (const GLfixed* m);
typedef void ( * PFNGLMATERIALXPROC) (GLenum face, GLenum pname, GLfixed param);
typedef void ( * PFNGLMATERIALXVPROC) (GLenum face, GLenum pname, const GLfixed* params);
typedef void ( * PFNGLMULTMATRIXXPROC) (const GLfixed* m);
typedef void ( * PFNGLMULTITEXCOORD4XPROC) (GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
typedef void ( * PFNGLNORMAL3XPROC) (GLfixed nx, GLfixed ny, GLfixed nz);
typedef void ( * PFNGLORTHOFPROC) (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
typedef void ( * PFNGLORTHOXPROC) (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
typedef void ( * PFNGLPOINTSIZEXPROC) (GLfixed size);
typedef void ( * PFNGLPOLYGONOFFSETXPROC) (GLfixed factor, GLfixed units);
typedef void ( * PFNGLROTATEXPROC) (GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
typedef void ( * PFNGLSAMPLECOVERAGEXPROC) (GLclampx value, GLboolean invert);
typedef void ( * PFNGLSCALEXPROC) (GLfixed x, GLfixed y, GLfixed z);
typedef void ( * PFNGLTEXENVXPROC) (GLenum target, GLenum pname, GLfixed param);
typedef void ( * PFNGLTEXENVXVPROC) (GLenum target, GLenum pname, const GLfixed* params);
typedef void ( * PFNGLTEXPARAMETERXPROC) (GLenum target, GLenum pname, GLfixed param);
typedef void ( * PFNGLTRANSLATEXPROC) (GLfixed x, GLfixed y, GLfixed z);
# 20328 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCLIPPLANEFPROC) (GLenum plane, const GLfloat* equation);
typedef void ( * PFNGLCLIPPLANEXPROC) (GLenum plane, const GLfixed* equation);
typedef void ( * PFNGLGETCLIPPLANEFPROC) (GLenum pname, GLfloat eqn[4]);
typedef void ( * PFNGLGETCLIPPLANEXPROC) (GLenum pname, GLfixed eqn[4]);
typedef void ( * PFNGLGETFIXEDVPROC) (GLenum pname, GLfixed* params);
typedef void ( * PFNGLGETLIGHTXVPROC) (GLenum light, GLenum pname, GLfixed* params);
typedef void ( * PFNGLGETMATERIALXVPROC) (GLenum face, GLenum pname, GLfixed* params);
typedef void ( * PFNGLGETTEXENVXVPROC) (GLenum env, GLenum pname, GLfixed* params);
typedef void ( * PFNGLGETTEXPARAMETERXVPROC) (GLenum target, GLenum pname, GLfixed* params);
typedef void ( * PFNGLPOINTPARAMETERXPROC) (GLenum pname, GLfixed param);
typedef void ( * PFNGLPOINTPARAMETERXVPROC) (GLenum pname, const GLfixed* params);
typedef void ( * PFNGLPOINTSIZEPOINTEROESPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void ( * PFNGLTEXPARAMETERXVPROC) (GLenum target, GLenum pname, const GLfixed* params);
# 20385 "/opt/homebrew/include/GL/glew.h"
typedef const GLchar* ( * PFNGLERRORSTRINGREGALPROC) (GLenum error);
# 20398 "/opt/homebrew/include/GL/glew.h"
typedef GLboolean ( * PFNGLGETEXTENSIONREGALPROC) (const GLchar* ext);
typedef GLboolean ( * PFNGLISSUPPORTEDREGALPROC) (const GLchar* ext);
# 20423 "/opt/homebrew/include/GL/glew.h"
typedef void ( *GLLOGPROCREGAL)(GLenum stream, GLsizei length, const GLchar *message, void *context);

typedef void ( * PFNGLLOGMESSAGECALLBACKREGALPROC) (GLLOGPROCREGAL callback);
# 20438 "/opt/homebrew/include/GL/glew.h"
typedef void * ( * PFNGLGETPROCADDRESSREGALPROC) (const GLchar *name);
# 20507 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDETAILTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat* points);
typedef void ( * PFNGLGETDETAILTEXFUNCSGISPROC) (GLenum target, GLfloat* points);
# 20522 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFOGFUNCSGISPROC) (GLsizei n, const GLfloat* points);
typedef void ( * PFNGLGETFOGFUNCSGISPROC) (GLfloat* points);
# 20575 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLSAMPLEMASKSGISPROC) (GLclampf value, GLboolean invert);
typedef void ( * PFNGLSAMPLEPATTERNSGISPROC) (GLenum pattern);
# 20602 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLINTERLEAVEDTEXTURECOORDSETSSGISPROC) (GLint factor);
typedef void ( * PFNGLSELECTTEXTURECOORDSETSGISPROC) (GLenum target);
typedef void ( * PFNGLSELECTTEXTURESGISPROC) (GLenum target);
typedef void ( * PFNGLSELECTTEXTURETRANSFORMSGISPROC) (GLenum target);
# 20648 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLMULTISAMPLESUBRECTPOSSGISPROC) (GLint x, GLint y);
# 20661 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETSHARPENTEXFUNCSGISPROC) (GLenum target, GLfloat* points);
typedef void ( * PFNGLSHARPENTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat* points);
# 20676 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXIMAGE4DSGISPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXSUBIMAGE4DSGISPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLenum format, GLenum type, const void *pixels);
# 20713 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLfloat* weights);
typedef void ( * PFNGLTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLsizei n, const GLfloat* weights);
# 20753 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLASYNCMARKERSGIXPROC) (GLuint marker);
typedef void ( * PFNGLDELETEASYNCMARKERSSGIXPROC) (GLuint marker, GLsizei range);
typedef GLint ( * PFNGLFINISHASYNCSGIXPROC) (GLuint* markerp);
typedef GLuint ( * PFNGLGENASYNCMARKERSSGIXPROC) (GLsizei range);
typedef GLboolean ( * PFNGLISASYNCMARKERSGIXPROC) (GLuint marker);
typedef GLint ( * PFNGLPOLLASYNCSGIXPROC) (GLuint* markerp);
# 20963 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLADDRESSSPACEPROC) (GLenum space, GLbitfield mask);
typedef GLint ( * PFNGLDATAPIPEPROC) (GLenum space);
# 21022 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFLUSHRASTERSGIXPROC) (void);
# 21063 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFOGLAYERSSGIXPROC) (GLsizei n, const GLfloat* points);
typedef void ( * PFNGLGETFOGLAYERSSGIXPROC) (GLfloat* points);
# 21111 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTEXTUREFOGSGIXPROC) (GLenum pname);
# 21138 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAGMENTCOLORMATERIALSGIXPROC) (GLenum face, GLenum mode);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFSGIXPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFVSGIXPROC) (GLenum pname, GLfloat* params);
typedef void ( * PFNGLFRAGMENTLIGHTMODELISGIXPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELIVSGIXPROC) (GLenum pname, GLint* params);
typedef void ( * PFNGLFRAGMENTLIGHTFSGIXPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void ( * PFNGLFRAGMENTLIGHTISGIXPROC) (GLenum light, GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum pname, GLint* params);
typedef void ( * PFNGLFRAGMENTMATERIALFSGIXPROC) (GLenum face, GLenum pname, const GLfloat param);
typedef void ( * PFNGLFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLFRAGMENTMATERIALISGIXPROC) (GLenum face, GLenum pname, const GLint param);
typedef void ( * PFNGLFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void ( * PFNGLGETFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum value, GLfloat* data);
typedef void ( * PFNGLGETFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum value, GLint* data);
typedef void ( * PFNGLGETFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, GLfloat* data);
typedef void ( * PFNGLGETFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, GLint* data);
# 21196 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFRAMEZOOMSGIXPROC) (GLint factor);
# 21240 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLIGLOOINTERFACESGIXPROC) (GLenum pname, void *param);
# 21320 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLALLOCMPEGPREDICTORSSGIXPROC) (GLsizei width, GLsizei height, GLsizei n, GLuint* predictors);
typedef void ( * PFNGLDELETEMPEGPREDICTORSSGIXPROC) (GLsizei n, GLuint* predictors);
typedef void ( * PFNGLGENMPEGPREDICTORSSGIXPROC) (GLsizei n, GLuint* predictors);
typedef void ( * PFNGLGETMPEGPARAMETERFVSGIXPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMPEGPARAMETERIVSGIXPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMPEGPREDICTORSGIXPROC) (GLenum target, GLenum format, GLenum type, void *pixels);
typedef void ( * PFNGLGETMPEGQUANTTABLEUBVPROC) (GLenum target, GLubyte* values);
typedef GLboolean ( * PFNGLISMPEGPREDICTORSGIXPROC) (GLuint predictor);
typedef void ( * PFNGLMPEGPREDICTORSGIXPROC) (GLenum target, GLenum format, GLenum type, void *pixels);
typedef void ( * PFNGLMPEGQUANTTABLEUBVPROC) (GLenum target, GLubyte* values);
typedef void ( * PFNGLSWAPMPEGPREDICTORSSGIXPROC) (GLenum target0, GLenum target1);
# 21362 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETNONLINLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLint* terms, GLfloat *data);
typedef void ( * PFNGLGETNONLINMATERIALFVSGIXPROC) (GLenum face, GLenum pname, GLint* terms, const GLfloat *data);
typedef void ( * PFNGLNONLINLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLint terms, GLfloat* params);
typedef void ( * PFNGLNONLINMATERIALFVSGIXPROC) (GLenum face, GLenum pname, GLint terms, const GLfloat* params);
# 21431 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLPIXELTEXGENSGIXPROC) (GLenum mode);
# 21474 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLDEFORMSGIXPROC) (GLbitfield mask);
typedef void ( * PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC) (GLbitfield mask);
# 21489 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLMESHBREADTHSGIXPROC) (GLint breadth);
typedef void ( * PFNGLMESHSTRIDESGIXPROC) (GLint stride);
# 21504 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLREFERENCEPLANESGIXPROC) (const GLdouble* equation);
# 21593 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLSPRITEPARAMETERFSGIXPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLSPRITEPARAMETERFVSGIXPROC) (GLenum pname, GLfloat* params);
typedef void ( * PFNGLSPRITEPARAMETERISGIXPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLSPRITEPARAMETERIVSGIXPROC) (GLenum pname, GLint* params);
# 21636 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLTAGSAMPLEBUFFERSGIXPROC) (void);
# 21775 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETVECTOROPERATIONSGIXPROC) (GLenum operation);
typedef void ( * PFNGLVECTOROPERATIONSGIXPROC) (GLenum operation);
# 21790 "/opt/homebrew/include/GL/glew.h"
typedef GLboolean ( * PFNGLAREVERTEXARRAYSRESIDENTSGIXPROC) (GLsizei n, const GLuint* arrays, GLboolean* residences);
typedef void ( * PFNGLBINDVERTEXARRAYSGIXPROC) (GLuint array);
typedef void ( * PFNGLDELETEVERTEXARRAYSSGIXPROC) (GLsizei n, const GLuint* arrays);
typedef void ( * PFNGLGENVERTEXARRAYSSGIXPROC) (GLsizei n, GLuint* arrays);
typedef GLboolean ( * PFNGLISVERTEXARRAYSGIXPROC) (GLuint array);
typedef void ( * PFNGLPRIORITIZEVERTEXARRAYSSGIXPROC) (GLsizei n, const GLuint* arrays, const GLclampf* priorities);
# 21905 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table);
typedef void ( * PFNGLCOPYCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETCOLORTABLESGIPROC) (GLenum target, GLenum format, GLenum type, void *table);
# 21962 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGETPIXELTRANSFORMPARAMETERFVSGIPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETPIXELTRANSFORMPARAMETERIVSGIPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFSGIPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFVSGIPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERISGIPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERIVSGIPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLPIXELTRANSFORMSGIPROC) (GLenum target);
# 22002 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLFINISHTEXTURESUNXPROC) (void);
# 22029 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLGLOBALALPHAFACTORBSUNPROC) (GLbyte factor);
typedef void ( * PFNGLGLOBALALPHAFACTORDSUNPROC) (GLdouble factor);
typedef void ( * PFNGLGLOBALALPHAFACTORFSUNPROC) (GLfloat factor);
typedef void ( * PFNGLGLOBALALPHAFACTORISUNPROC) (GLint factor);
typedef void ( * PFNGLGLOBALALPHAFACTORSSUNPROC) (GLshort factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUBSUNPROC) (GLubyte factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUISUNPROC) (GLuint factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUSSUNPROC) (GLushort factor);
# 22068 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLREADVIDEOPIXELSSUNPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels);
# 22110 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLREPLACEMENTCODEPOINTERSUNPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void ( * PFNGLREPLACEMENTCODEUBSUNPROC) (GLubyte code);
typedef void ( * PFNGLREPLACEMENTCODEUBVSUNPROC) (const GLubyte* code);
typedef void ( * PFNGLREPLACEMENTCODEUISUNPROC) (GLuint code);
typedef void ( * PFNGLREPLACEMENTCODEUIVSUNPROC) (const GLuint* code);
typedef void ( * PFNGLREPLACEMENTCODEUSSUNPROC) (GLushort code);
typedef void ( * PFNGLREPLACEMENTCODEUSVSUNPROC) (const GLushort* code);
# 22135 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLCOLOR3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR3FVERTEX3FVSUNPROC) (const GLfloat* c, const GLfloat *v);
typedef void ( * PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLCOLOR4UBVERTEX2FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
typedef void ( * PFNGLCOLOR4UBVERTEX2FVSUNPROC) (const GLubyte* c, const GLfloat *v);
typedef void ( * PFNGLCOLOR4UBVERTEX3FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR4UBVERTEX3FVSUNPROC) (const GLubyte* c, const GLfloat *v);
typedef void ( * PFNGLNORMAL3FVERTEX3FSUNPROC) (GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *c, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC) (GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC) (const GLuint* rc, const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC) (GLuint rc, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC) (const GLfloat* tc, const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD4FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLTEXCOORD4FVERTEX4FVSUNPROC) (const GLfloat* tc, const GLfloat *v);
# 22269 "/opt/homebrew/include/GL/glew.h"
typedef void ( * PFNGLADDSWAPHINTRECTWINPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
# 22281 "/opt/homebrew/include/GL/glew.h"
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXSUBIMAGE3DPROC __glewCopyTexSubImage3D;
extern __attribute__ ((visibility("default"))) PFNGLDRAWRANGEELEMENTSPROC __glewDrawRangeElements;
extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE3DPROC __glewTexImage3D;
extern __attribute__ ((visibility("default"))) PFNGLTEXSUBIMAGE3DPROC __glewTexSubImage3D;

extern __attribute__ ((visibility("default"))) PFNGLACTIVETEXTUREPROC __glewActiveTexture;
extern __attribute__ ((visibility("default"))) PFNGLCLIENTACTIVETEXTUREPROC __glewClientActiveTexture;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE1DPROC __glewCompressedTexImage1D;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE2DPROC __glewCompressedTexImage2D;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE3DPROC __glewCompressedTexImage3D;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC __glewCompressedTexSubImage1D;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC __glewCompressedTexSubImage2D;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC __glewCompressedTexSubImage3D;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMPRESSEDTEXIMAGEPROC __glewGetCompressedTexImage;
extern __attribute__ ((visibility("default"))) PFNGLLOADTRANSPOSEMATRIXDPROC __glewLoadTransposeMatrixd;
extern __attribute__ ((visibility("default"))) PFNGLLOADTRANSPOSEMATRIXFPROC __glewLoadTransposeMatrixf;
extern __attribute__ ((visibility("default"))) PFNGLMULTTRANSPOSEMATRIXDPROC __glewMultTransposeMatrixd;
extern __attribute__ ((visibility("default"))) PFNGLMULTTRANSPOSEMATRIXFPROC __glewMultTransposeMatrixf;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1DPROC __glewMultiTexCoord1d;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1DVPROC __glewMultiTexCoord1dv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1FPROC __glewMultiTexCoord1f;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1FVPROC __glewMultiTexCoord1fv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1IPROC __glewMultiTexCoord1i;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1IVPROC __glewMultiTexCoord1iv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1SPROC __glewMultiTexCoord1s;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1SVPROC __glewMultiTexCoord1sv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2DPROC __glewMultiTexCoord2d;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2DVPROC __glewMultiTexCoord2dv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2FPROC __glewMultiTexCoord2f;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2FVPROC __glewMultiTexCoord2fv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2IPROC __glewMultiTexCoord2i;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2IVPROC __glewMultiTexCoord2iv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2SPROC __glewMultiTexCoord2s;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2SVPROC __glewMultiTexCoord2sv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3DPROC __glewMultiTexCoord3d;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3DVPROC __glewMultiTexCoord3dv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3FPROC __glewMultiTexCoord3f;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3FVPROC __glewMultiTexCoord3fv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3IPROC __glewMultiTexCoord3i;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3IVPROC __glewMultiTexCoord3iv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3SPROC __glewMultiTexCoord3s;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3SVPROC __glewMultiTexCoord3sv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4DPROC __glewMultiTexCoord4d;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4DVPROC __glewMultiTexCoord4dv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4FPROC __glewMultiTexCoord4f;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4FVPROC __glewMultiTexCoord4fv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4IPROC __glewMultiTexCoord4i;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4IVPROC __glewMultiTexCoord4iv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4SPROC __glewMultiTexCoord4s;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4SVPROC __glewMultiTexCoord4sv;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLECOVERAGEPROC __glewSampleCoverage;

extern __attribute__ ((visibility("default"))) PFNGLBLENDCOLORPROC __glewBlendColor;
extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONPROC __glewBlendEquation;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEPROC __glewBlendFuncSeparate;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDPOINTERPROC __glewFogCoordPointer;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDDPROC __glewFogCoordd;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDDVPROC __glewFogCoorddv;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDFPROC __glewFogCoordf;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDFVPROC __glewFogCoordfv;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSPROC __glewMultiDrawArrays;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSPROC __glewMultiDrawElements;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERFPROC __glewPointParameterf;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERFVPROC __glewPointParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERIPROC __glewPointParameteri;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERIVPROC __glewPointParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3BPROC __glewSecondaryColor3b;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3BVPROC __glewSecondaryColor3bv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3DPROC __glewSecondaryColor3d;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3DVPROC __glewSecondaryColor3dv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3FPROC __glewSecondaryColor3f;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3FVPROC __glewSecondaryColor3fv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3IPROC __glewSecondaryColor3i;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3IVPROC __glewSecondaryColor3iv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3SPROC __glewSecondaryColor3s;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3SVPROC __glewSecondaryColor3sv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UBPROC __glewSecondaryColor3ub;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UBVPROC __glewSecondaryColor3ubv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UIPROC __glewSecondaryColor3ui;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UIVPROC __glewSecondaryColor3uiv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3USPROC __glewSecondaryColor3us;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3USVPROC __glewSecondaryColor3usv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLORPOINTERPROC __glewSecondaryColorPointer;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2DPROC __glewWindowPos2d;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2DVPROC __glewWindowPos2dv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2FPROC __glewWindowPos2f;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2FVPROC __glewWindowPos2fv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2IPROC __glewWindowPos2i;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2IVPROC __glewWindowPos2iv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2SPROC __glewWindowPos2s;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2SVPROC __glewWindowPos2sv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3DPROC __glewWindowPos3d;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3DVPROC __glewWindowPos3dv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3FPROC __glewWindowPos3f;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3FVPROC __glewWindowPos3fv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3IPROC __glewWindowPos3i;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3IVPROC __glewWindowPos3iv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3SPROC __glewWindowPos3s;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3SVPROC __glewWindowPos3sv;

extern __attribute__ ((visibility("default"))) PFNGLBEGINQUERYPROC __glewBeginQuery;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERPROC __glewBindBuffer;
extern __attribute__ ((visibility("default"))) PFNGLBUFFERDATAPROC __glewBufferData;
extern __attribute__ ((visibility("default"))) PFNGLBUFFERSUBDATAPROC __glewBufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLDELETEBUFFERSPROC __glewDeleteBuffers;
extern __attribute__ ((visibility("default"))) PFNGLDELETEQUERIESPROC __glewDeleteQueries;
extern __attribute__ ((visibility("default"))) PFNGLENDQUERYPROC __glewEndQuery;
extern __attribute__ ((visibility("default"))) PFNGLGENBUFFERSPROC __glewGenBuffers;
extern __attribute__ ((visibility("default"))) PFNGLGENQUERIESPROC __glewGenQueries;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERPARAMETERIVPROC __glewGetBufferParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERPOINTERVPROC __glewGetBufferPointerv;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERSUBDATAPROC __glewGetBufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTIVPROC __glewGetQueryObjectiv;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTUIVPROC __glewGetQueryObjectuiv;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYIVPROC __glewGetQueryiv;
extern __attribute__ ((visibility("default"))) PFNGLISBUFFERPROC __glewIsBuffer;
extern __attribute__ ((visibility("default"))) PFNGLISQUERYPROC __glewIsQuery;
extern __attribute__ ((visibility("default"))) PFNGLMAPBUFFERPROC __glewMapBuffer;
extern __attribute__ ((visibility("default"))) PFNGLUNMAPBUFFERPROC __glewUnmapBuffer;

extern __attribute__ ((visibility("default"))) PFNGLATTACHSHADERPROC __glewAttachShader;
extern __attribute__ ((visibility("default"))) PFNGLBINDATTRIBLOCATIONPROC __glewBindAttribLocation;
extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEPROC __glewBlendEquationSeparate;
extern __attribute__ ((visibility("default"))) PFNGLCOMPILESHADERPROC __glewCompileShader;
extern __attribute__ ((visibility("default"))) PFNGLCREATEPROGRAMPROC __glewCreateProgram;
extern __attribute__ ((visibility("default"))) PFNGLCREATESHADERPROC __glewCreateShader;
extern __attribute__ ((visibility("default"))) PFNGLDELETEPROGRAMPROC __glewDeleteProgram;
extern __attribute__ ((visibility("default"))) PFNGLDELETESHADERPROC __glewDeleteShader;
extern __attribute__ ((visibility("default"))) PFNGLDETACHSHADERPROC __glewDetachShader;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEVERTEXATTRIBARRAYPROC __glewDisableVertexAttribArray;
extern __attribute__ ((visibility("default"))) PFNGLDRAWBUFFERSPROC __glewDrawBuffers;
extern __attribute__ ((visibility("default"))) PFNGLENABLEVERTEXATTRIBARRAYPROC __glewEnableVertexAttribArray;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEATTRIBPROC __glewGetActiveAttrib;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEUNIFORMPROC __glewGetActiveUniform;
extern __attribute__ ((visibility("default"))) PFNGLGETATTACHEDSHADERSPROC __glewGetAttachedShaders;
extern __attribute__ ((visibility("default"))) PFNGLGETATTRIBLOCATIONPROC __glewGetAttribLocation;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMINFOLOGPROC __glewGetProgramInfoLog;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMIVPROC __glewGetProgramiv;
extern __attribute__ ((visibility("default"))) PFNGLGETSHADERINFOLOGPROC __glewGetShaderInfoLog;
extern __attribute__ ((visibility("default"))) PFNGLGETSHADERSOURCEPROC __glewGetShaderSource;
extern __attribute__ ((visibility("default"))) PFNGLGETSHADERIVPROC __glewGetShaderiv;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMLOCATIONPROC __glewGetUniformLocation;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMFVPROC __glewGetUniformfv;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMIVPROC __glewGetUniformiv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBPOINTERVPROC __glewGetVertexAttribPointerv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBDVPROC __glewGetVertexAttribdv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBFVPROC __glewGetVertexAttribfv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIVPROC __glewGetVertexAttribiv;
extern __attribute__ ((visibility("default"))) PFNGLISPROGRAMPROC __glewIsProgram;
extern __attribute__ ((visibility("default"))) PFNGLISSHADERPROC __glewIsShader;
extern __attribute__ ((visibility("default"))) PFNGLLINKPROGRAMPROC __glewLinkProgram;
extern __attribute__ ((visibility("default"))) PFNGLSHADERSOURCEPROC __glewShaderSource;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILFUNCSEPARATEPROC __glewStencilFuncSeparate;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILMASKSEPARATEPROC __glewStencilMaskSeparate;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILOPSEPARATEPROC __glewStencilOpSeparate;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1FPROC __glewUniform1f;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1FVPROC __glewUniform1fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1IPROC __glewUniform1i;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1IVPROC __glewUniform1iv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2FPROC __glewUniform2f;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2FVPROC __glewUniform2fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2IPROC __glewUniform2i;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2IVPROC __glewUniform2iv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3FPROC __glewUniform3f;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3FVPROC __glewUniform3fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3IPROC __glewUniform3i;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3IVPROC __glewUniform3iv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4FPROC __glewUniform4f;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4FVPROC __glewUniform4fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4IPROC __glewUniform4i;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4IVPROC __glewUniform4iv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2FVPROC __glewUniformMatrix2fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3FVPROC __glewUniformMatrix3fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4FVPROC __glewUniformMatrix4fv;
extern __attribute__ ((visibility("default"))) PFNGLUSEPROGRAMPROC __glewUseProgram;
extern __attribute__ ((visibility("default"))) PFNGLVALIDATEPROGRAMPROC __glewValidateProgram;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1DPROC __glewVertexAttrib1d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1DVPROC __glewVertexAttrib1dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1FPROC __glewVertexAttrib1f;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1FVPROC __glewVertexAttrib1fv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1SPROC __glewVertexAttrib1s;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1SVPROC __glewVertexAttrib1sv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2DPROC __glewVertexAttrib2d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2DVPROC __glewVertexAttrib2dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2FPROC __glewVertexAttrib2f;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2FVPROC __glewVertexAttrib2fv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2SPROC __glewVertexAttrib2s;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2SVPROC __glewVertexAttrib2sv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3DPROC __glewVertexAttrib3d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3DVPROC __glewVertexAttrib3dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3FPROC __glewVertexAttrib3f;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3FVPROC __glewVertexAttrib3fv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3SPROC __glewVertexAttrib3s;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3SVPROC __glewVertexAttrib3sv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NBVPROC __glewVertexAttrib4Nbv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NIVPROC __glewVertexAttrib4Niv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NSVPROC __glewVertexAttrib4Nsv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUBPROC __glewVertexAttrib4Nub;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUBVPROC __glewVertexAttrib4Nubv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUIVPROC __glewVertexAttrib4Nuiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUSVPROC __glewVertexAttrib4Nusv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4BVPROC __glewVertexAttrib4bv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4DPROC __glewVertexAttrib4d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4DVPROC __glewVertexAttrib4dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4FPROC __glewVertexAttrib4f;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4FVPROC __glewVertexAttrib4fv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4IVPROC __glewVertexAttrib4iv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4SPROC __glewVertexAttrib4s;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4SVPROC __glewVertexAttrib4sv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4UBVPROC __glewVertexAttrib4ubv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4UIVPROC __glewVertexAttrib4uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4USVPROC __glewVertexAttrib4usv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBPOINTERPROC __glewVertexAttribPointer;

extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2X3FVPROC __glewUniformMatrix2x3fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2X4FVPROC __glewUniformMatrix2x4fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3X2FVPROC __glewUniformMatrix3x2fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3X4FVPROC __glewUniformMatrix3x4fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4X2FVPROC __glewUniformMatrix4x2fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4X3FVPROC __glewUniformMatrix4x3fv;

extern __attribute__ ((visibility("default"))) PFNGLBEGINCONDITIONALRENDERPROC __glewBeginConditionalRender;
extern __attribute__ ((visibility("default"))) PFNGLBEGINTRANSFORMFEEDBACKPROC __glewBeginTransformFeedback;
extern __attribute__ ((visibility("default"))) PFNGLBINDFRAGDATALOCATIONPROC __glewBindFragDataLocation;
extern __attribute__ ((visibility("default"))) PFNGLCLAMPCOLORPROC __glewClampColor;
extern __attribute__ ((visibility("default"))) PFNGLCLEARBUFFERFIPROC __glewClearBufferfi;
extern __attribute__ ((visibility("default"))) PFNGLCLEARBUFFERFVPROC __glewClearBufferfv;
extern __attribute__ ((visibility("default"))) PFNGLCLEARBUFFERIVPROC __glewClearBufferiv;
extern __attribute__ ((visibility("default"))) PFNGLCLEARBUFFERUIVPROC __glewClearBufferuiv;
extern __attribute__ ((visibility("default"))) PFNGLCOLORMASKIPROC __glewColorMaski;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEIPROC __glewDisablei;
extern __attribute__ ((visibility("default"))) PFNGLENABLEIPROC __glewEnablei;
extern __attribute__ ((visibility("default"))) PFNGLENDCONDITIONALRENDERPROC __glewEndConditionalRender;
extern __attribute__ ((visibility("default"))) PFNGLENDTRANSFORMFEEDBACKPROC __glewEndTransformFeedback;
extern __attribute__ ((visibility("default"))) PFNGLGETBOOLEANI_VPROC __glewGetBooleani_v;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGDATALOCATIONPROC __glewGetFragDataLocation;
extern __attribute__ ((visibility("default"))) PFNGLGETSTRINGIPROC __glewGetStringi;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERIIVPROC __glewGetTexParameterIiv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERIUIVPROC __glewGetTexParameterIuiv;
extern __attribute__ ((visibility("default"))) PFNGLGETTRANSFORMFEEDBACKVARYINGPROC __glewGetTransformFeedbackVarying;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMUIVPROC __glewGetUniformuiv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIIVPROC __glewGetVertexAttribIiv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIUIVPROC __glewGetVertexAttribIuiv;
extern __attribute__ ((visibility("default"))) PFNGLISENABLEDIPROC __glewIsEnabledi;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERIIVPROC __glewTexParameterIiv;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERIUIVPROC __glewTexParameterIuiv;
extern __attribute__ ((visibility("default"))) PFNGLTRANSFORMFEEDBACKVARYINGSPROC __glewTransformFeedbackVaryings;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UIPROC __glewUniform1ui;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UIVPROC __glewUniform1uiv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UIPROC __glewUniform2ui;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UIVPROC __glewUniform2uiv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UIPROC __glewUniform3ui;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UIVPROC __glewUniform3uiv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UIPROC __glewUniform4ui;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UIVPROC __glewUniform4uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1IPROC __glewVertexAttribI1i;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1IVPROC __glewVertexAttribI1iv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1UIPROC __glewVertexAttribI1ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1UIVPROC __glewVertexAttribI1uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2IPROC __glewVertexAttribI2i;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2IVPROC __glewVertexAttribI2iv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2UIPROC __glewVertexAttribI2ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2UIVPROC __glewVertexAttribI2uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3IPROC __glewVertexAttribI3i;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3IVPROC __glewVertexAttribI3iv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3UIPROC __glewVertexAttribI3ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3UIVPROC __glewVertexAttribI3uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4BVPROC __glewVertexAttribI4bv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4IPROC __glewVertexAttribI4i;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4IVPROC __glewVertexAttribI4iv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4SVPROC __glewVertexAttribI4sv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4UBVPROC __glewVertexAttribI4ubv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4UIPROC __glewVertexAttribI4ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4UIVPROC __glewVertexAttribI4uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4USVPROC __glewVertexAttribI4usv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBIPOINTERPROC __glewVertexAttribIPointer;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINSTANCEDPROC __glewDrawArraysInstanced;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDPROC __glewDrawElementsInstanced;
extern __attribute__ ((visibility("default"))) PFNGLPRIMITIVERESTARTINDEXPROC __glewPrimitiveRestartIndex;
extern __attribute__ ((visibility("default"))) PFNGLTEXBUFFERPROC __glewTexBuffer;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTUREPROC __glewFramebufferTexture;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERPARAMETERI64VPROC __glewGetBufferParameteri64v;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGER64I_VPROC __glewGetInteger64i_v;

extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBDIVISORPROC __glewVertexAttribDivisor;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEIPROC __glewBlendEquationSeparatei;
extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONIPROC __glewBlendEquationi;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEIPROC __glewBlendFuncSeparatei;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCIPROC __glewBlendFunci;
extern __attribute__ ((visibility("default"))) PFNGLMINSAMPLESHADINGPROC __glewMinSampleShading;

extern __attribute__ ((visibility("default"))) PFNGLGETGRAPHICSRESETSTATUSPROC __glewGetGraphicsResetStatus;
extern __attribute__ ((visibility("default"))) PFNGLGETNCOMPRESSEDTEXIMAGEPROC __glewGetnCompressedTexImage;
extern __attribute__ ((visibility("default"))) PFNGLGETNTEXIMAGEPROC __glewGetnTexImage;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMDVPROC __glewGetnUniformdv;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC __glewMultiDrawArraysIndirectCount;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC __glewMultiDrawElementsIndirectCount;
extern __attribute__ ((visibility("default"))) PFNGLSPECIALIZESHADERPROC __glewSpecializeShader;

extern __attribute__ ((visibility("default"))) PFNGLTBUFFERMASK3DFXPROC __glewTbufferMask3DFX;

extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGECALLBACKAMDPROC __glewDebugMessageCallbackAMD;
extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGEENABLEAMDPROC __glewDebugMessageEnableAMD;
extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGEINSERTAMDPROC __glewDebugMessageInsertAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETDEBUGMESSAGELOGAMDPROC __glewGetDebugMessageLogAMD;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONINDEXEDAMDPROC __glewBlendEquationIndexedAMD;
extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC __glewBlendEquationSeparateIndexedAMD;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCINDEXEDAMDPROC __glewBlendFuncIndexedAMD;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC __glewBlendFuncSeparateIndexedAMD;

extern __attribute__ ((visibility("default"))) PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC __glewNamedRenderbufferStorageMultisampleAdvancedAMD;
extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC __glewRenderbufferStorageMultisampleAdvancedAMD;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC __glewFramebufferSamplePositionsfvAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAMEBUFFERPARAMETERFVAMDPROC __glewGetFramebufferParameterfvAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDFRAMEBUFFERPARAMETERFVAMDPROC __glewGetNamedFramebufferParameterfvAMD;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC __glewNamedFramebufferSamplePositionsfvAMD;

extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBPARAMETERIAMDPROC __glewVertexAttribParameteriAMD;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC __glewMultiDrawArraysIndirectAMD;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC __glewMultiDrawElementsIndirectAMD;

extern __attribute__ ((visibility("default"))) PFNGLDELETENAMESAMDPROC __glewDeleteNamesAMD;
extern __attribute__ ((visibility("default"))) PFNGLGENNAMESAMDPROC __glewGenNamesAMD;
extern __attribute__ ((visibility("default"))) PFNGLISNAMEAMDPROC __glewIsNameAMD;

extern __attribute__ ((visibility("default"))) PFNGLQUERYOBJECTPARAMETERUIAMDPROC __glewQueryObjectParameteruiAMD;

extern __attribute__ ((visibility("default"))) PFNGLBEGINPERFMONITORAMDPROC __glewBeginPerfMonitorAMD;
extern __attribute__ ((visibility("default"))) PFNGLDELETEPERFMONITORSAMDPROC __glewDeletePerfMonitorsAMD;
extern __attribute__ ((visibility("default"))) PFNGLENDPERFMONITORAMDPROC __glewEndPerfMonitorAMD;
extern __attribute__ ((visibility("default"))) PFNGLGENPERFMONITORSAMDPROC __glewGenPerfMonitorsAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFMONITORCOUNTERDATAAMDPROC __glewGetPerfMonitorCounterDataAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFMONITORCOUNTERINFOAMDPROC __glewGetPerfMonitorCounterInfoAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC __glewGetPerfMonitorCounterStringAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFMONITORCOUNTERSAMDPROC __glewGetPerfMonitorCountersAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFMONITORGROUPSTRINGAMDPROC __glewGetPerfMonitorGroupStringAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFMONITORGROUPSAMDPROC __glewGetPerfMonitorGroupsAMD;
extern __attribute__ ((visibility("default"))) PFNGLSELECTPERFMONITORCOUNTERSAMDPROC __glewSelectPerfMonitorCountersAMD;

extern __attribute__ ((visibility("default"))) PFNGLSETMULTISAMPLEFVAMDPROC __glewSetMultisamplefvAMD;

extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGESPARSEAMDPROC __glewTexStorageSparseAMD;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGESPARSEAMDPROC __glewTextureStorageSparseAMD;

extern __attribute__ ((visibility("default"))) PFNGLSTENCILOPVALUEAMDPROC __glewStencilOpValueAMD;

extern __attribute__ ((visibility("default"))) PFNGLTESSELLATIONFACTORAMDPROC __glewTessellationFactorAMD;
extern __attribute__ ((visibility("default"))) PFNGLTESSELLATIONMODEAMDPROC __glewTessellationModeAMD;

extern __attribute__ ((visibility("default"))) PFNGLBLITFRAMEBUFFERANGLEPROC __glewBlitFramebufferANGLE;

extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEANGLEPROC __glewRenderbufferStorageMultisampleANGLE;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINSTANCEDANGLEPROC __glewDrawArraysInstancedANGLE;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDANGLEPROC __glewDrawElementsInstancedANGLE;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBDIVISORANGLEPROC __glewVertexAttribDivisorANGLE;

extern __attribute__ ((visibility("default"))) PFNGLBEGINQUERYANGLEPROC __glewBeginQueryANGLE;
extern __attribute__ ((visibility("default"))) PFNGLDELETEQUERIESANGLEPROC __glewDeleteQueriesANGLE;
extern __attribute__ ((visibility("default"))) PFNGLENDQUERYANGLEPROC __glewEndQueryANGLE;
extern __attribute__ ((visibility("default"))) PFNGLGENQUERIESANGLEPROC __glewGenQueriesANGLE;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTI64VANGLEPROC __glewGetQueryObjecti64vANGLE;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTIVANGLEPROC __glewGetQueryObjectivANGLE;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTUI64VANGLEPROC __glewGetQueryObjectui64vANGLE;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTUIVANGLEPROC __glewGetQueryObjectuivANGLE;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYIVANGLEPROC __glewGetQueryivANGLE;
extern __attribute__ ((visibility("default"))) PFNGLISQUERYANGLEPROC __glewIsQueryANGLE;
extern __attribute__ ((visibility("default"))) PFNGLQUERYCOUNTERANGLEPROC __glewQueryCounterANGLE;

extern __attribute__ ((visibility("default"))) PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC __glewGetTranslatedShaderSourceANGLE;

extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTURELEVELSAPPLEPROC __glewCopyTextureLevelsAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTARRAYAPPLEPROC __glewDrawElementArrayAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC __glewDrawRangeElementArrayAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLELEMENTPOINTERAPPLEPROC __glewElementPointerAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC __glewMultiDrawElementArrayAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC __glewMultiDrawRangeElementArrayAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLDELETEFENCESAPPLEPROC __glewDeleteFencesAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLFINISHFENCEAPPLEPROC __glewFinishFenceAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLFINISHOBJECTAPPLEPROC __glewFinishObjectAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLGENFENCESAPPLEPROC __glewGenFencesAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLISFENCEAPPLEPROC __glewIsFenceAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLSETFENCEAPPLEPROC __glewSetFenceAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLTESTFENCEAPPLEPROC __glewTestFenceAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLTESTOBJECTAPPLEPROC __glewTestObjectAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERPARAMETERIAPPLEPROC __glewBufferParameteriAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC __glewFlushMappedBufferRangeAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEAPPLEPROC __glewRenderbufferStorageMultisampleAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLRESOLVEMULTISAMPLEFRAMEBUFFERAPPLEPROC __glewResolveMultisampleFramebufferAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTPARAMETERIVAPPLEPROC __glewGetObjectParameterivAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLOBJECTPURGEABLEAPPLEPROC __glewObjectPurgeableAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLOBJECTUNPURGEABLEAPPLEPROC __glewObjectUnpurgeableAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLCLIENTWAITSYNCAPPLEPROC __glewClientWaitSyncAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLDELETESYNCAPPLEPROC __glewDeleteSyncAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLFENCESYNCAPPLEPROC __glewFenceSyncAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGER64VAPPLEPROC __glewGetInteger64vAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLGETSYNCIVAPPLEPROC __glewGetSyncivAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLISSYNCAPPLEPROC __glewIsSyncAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLWAITSYNCAPPLEPROC __glewWaitSyncAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC __glewGetTexParameterPointervAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURERANGEAPPLEPROC __glewTextureRangeAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLBINDVERTEXARRAYAPPLEPROC __glewBindVertexArrayAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLDELETEVERTEXARRAYSAPPLEPROC __glewDeleteVertexArraysAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLGENVERTEXARRAYSAPPLEPROC __glewGenVertexArraysAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLISVERTEXARRAYAPPLEPROC __glewIsVertexArrayAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC __glewFlushVertexArrayRangeAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYPARAMETERIAPPLEPROC __glewVertexArrayParameteriAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYRANGEAPPLEPROC __glewVertexArrayRangeAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLDISABLEVERTEXATTRIBAPPLEPROC __glewDisableVertexAttribAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLENABLEVERTEXATTRIBAPPLEPROC __glewEnableVertexAttribAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLISVERTEXATTRIBENABLEDAPPLEPROC __glewIsVertexAttribEnabledAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLMAPVERTEXATTRIB1DAPPLEPROC __glewMapVertexAttrib1dAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLMAPVERTEXATTRIB1FAPPLEPROC __glewMapVertexAttrib1fAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLMAPVERTEXATTRIB2DAPPLEPROC __glewMapVertexAttrib2dAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLMAPVERTEXATTRIB2FAPPLEPROC __glewMapVertexAttrib2fAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLCLEARDEPTHFPROC __glewClearDepthf;
extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEFPROC __glewDepthRangef;
extern __attribute__ ((visibility("default"))) PFNGLGETSHADERPRECISIONFORMATPROC __glewGetShaderPrecisionFormat;
extern __attribute__ ((visibility("default"))) PFNGLRELEASESHADERCOMPILERPROC __glewReleaseShaderCompiler;
extern __attribute__ ((visibility("default"))) PFNGLSHADERBINARYPROC __glewShaderBinary;

extern __attribute__ ((visibility("default"))) PFNGLMEMORYBARRIERBYREGIONPROC __glewMemoryBarrierByRegion;

extern __attribute__ ((visibility("default"))) PFNGLPRIMITIVEBOUNDINGBOXARBPROC __glewPrimitiveBoundingBoxARB;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC __glewDrawArraysInstancedBaseInstance;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC __glewDrawElementsInstancedBaseInstance;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC __glewDrawElementsInstancedBaseVertexBaseInstance;

extern __attribute__ ((visibility("default"))) PFNGLGETIMAGEHANDLEARBPROC __glewGetImageHandleARB;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREHANDLEARBPROC __glewGetTextureHandleARB;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTURESAMPLERHANDLEARBPROC __glewGetTextureSamplerHandleARB;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBLUI64VARBPROC __glewGetVertexAttribLui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLISIMAGEHANDLERESIDENTARBPROC __glewIsImageHandleResidentARB;
extern __attribute__ ((visibility("default"))) PFNGLISTEXTUREHANDLERESIDENTARBPROC __glewIsTextureHandleResidentARB;
extern __attribute__ ((visibility("default"))) PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC __glewMakeImageHandleNonResidentARB;
extern __attribute__ ((visibility("default"))) PFNGLMAKEIMAGEHANDLERESIDENTARBPROC __glewMakeImageHandleResidentARB;
extern __attribute__ ((visibility("default"))) PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC __glewMakeTextureHandleNonResidentARB;
extern __attribute__ ((visibility("default"))) PFNGLMAKETEXTUREHANDLERESIDENTARBPROC __glewMakeTextureHandleResidentARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC __glewProgramUniformHandleui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC __glewProgramUniformHandleui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMHANDLEUI64ARBPROC __glewUniformHandleui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMHANDLEUI64VARBPROC __glewUniformHandleui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1UI64ARBPROC __glewVertexAttribL1ui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1UI64VARBPROC __glewVertexAttribL1ui64vARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDFRAGDATALOCATIONINDEXEDPROC __glewBindFragDataLocationIndexed;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGDATAINDEXPROC __glewGetFragDataIndex;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERSTORAGEPROC __glewBufferStorage;

extern __attribute__ ((visibility("default"))) PFNGLCREATESYNCFROMCLEVENTARBPROC __glewCreateSyncFromCLeventARB;

extern __attribute__ ((visibility("default"))) PFNGLCLEARBUFFERDATAPROC __glewClearBufferData;
extern __attribute__ ((visibility("default"))) PFNGLCLEARBUFFERSUBDATAPROC __glewClearBufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLCLEARNAMEDBUFFERDATAEXTPROC __glewClearNamedBufferDataEXT;
extern __attribute__ ((visibility("default"))) PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC __glewClearNamedBufferSubDataEXT;

extern __attribute__ ((visibility("default"))) PFNGLCLEARTEXIMAGEPROC __glewClearTexImage;
extern __attribute__ ((visibility("default"))) PFNGLCLEARTEXSUBIMAGEPROC __glewClearTexSubImage;

extern __attribute__ ((visibility("default"))) PFNGLCLIPCONTROLPROC __glewClipControl;

extern __attribute__ ((visibility("default"))) PFNGLCLAMPCOLORARBPROC __glewClampColorARB;

extern __attribute__ ((visibility("default"))) PFNGLDISPATCHCOMPUTEPROC __glewDispatchCompute;
extern __attribute__ ((visibility("default"))) PFNGLDISPATCHCOMPUTEINDIRECTPROC __glewDispatchComputeIndirect;

extern __attribute__ ((visibility("default"))) PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC __glewDispatchComputeGroupSizeARB;

extern __attribute__ ((visibility("default"))) PFNGLCOPYBUFFERSUBDATAPROC __glewCopyBufferSubData;

extern __attribute__ ((visibility("default"))) PFNGLCOPYIMAGESUBDATAPROC __glewCopyImageSubData;

extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGECALLBACKARBPROC __glewDebugMessageCallbackARB;
extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGECONTROLARBPROC __glewDebugMessageControlARB;
extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGEINSERTARBPROC __glewDebugMessageInsertARB;
extern __attribute__ ((visibility("default"))) PFNGLGETDEBUGMESSAGELOGARBPROC __glewGetDebugMessageLogARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDTEXTUREUNITPROC __glewBindTextureUnit;
extern __attribute__ ((visibility("default"))) PFNGLBLITNAMEDFRAMEBUFFERPROC __glewBlitNamedFramebuffer;
extern __attribute__ ((visibility("default"))) PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC __glewCheckNamedFramebufferStatus;
extern __attribute__ ((visibility("default"))) PFNGLCLEARNAMEDBUFFERDATAPROC __glewClearNamedBufferData;
extern __attribute__ ((visibility("default"))) PFNGLCLEARNAMEDBUFFERSUBDATAPROC __glewClearNamedBufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLCLEARNAMEDFRAMEBUFFERFIPROC __glewClearNamedFramebufferfi;
extern __attribute__ ((visibility("default"))) PFNGLCLEARNAMEDFRAMEBUFFERFVPROC __glewClearNamedFramebufferfv;
extern __attribute__ ((visibility("default"))) PFNGLCLEARNAMEDFRAMEBUFFERIVPROC __glewClearNamedFramebufferiv;
extern __attribute__ ((visibility("default"))) PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC __glewClearNamedFramebufferuiv;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC __glewCompressedTextureSubImage1D;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC __glewCompressedTextureSubImage2D;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC __glewCompressedTextureSubImage3D;
extern __attribute__ ((visibility("default"))) PFNGLCOPYNAMEDBUFFERSUBDATAPROC __glewCopyNamedBufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTURESUBIMAGE1DPROC __glewCopyTextureSubImage1D;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTURESUBIMAGE2DPROC __glewCopyTextureSubImage2D;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTURESUBIMAGE3DPROC __glewCopyTextureSubImage3D;
extern __attribute__ ((visibility("default"))) PFNGLCREATEBUFFERSPROC __glewCreateBuffers;
extern __attribute__ ((visibility("default"))) PFNGLCREATEFRAMEBUFFERSPROC __glewCreateFramebuffers;
extern __attribute__ ((visibility("default"))) PFNGLCREATEPROGRAMPIPELINESPROC __glewCreateProgramPipelines;
extern __attribute__ ((visibility("default"))) PFNGLCREATEQUERIESPROC __glewCreateQueries;
extern __attribute__ ((visibility("default"))) PFNGLCREATERENDERBUFFERSPROC __glewCreateRenderbuffers;
extern __attribute__ ((visibility("default"))) PFNGLCREATESAMPLERSPROC __glewCreateSamplers;
extern __attribute__ ((visibility("default"))) PFNGLCREATETEXTURESPROC __glewCreateTextures;
extern __attribute__ ((visibility("default"))) PFNGLCREATETRANSFORMFEEDBACKSPROC __glewCreateTransformFeedbacks;
extern __attribute__ ((visibility("default"))) PFNGLCREATEVERTEXARRAYSPROC __glewCreateVertexArrays;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEVERTEXARRAYATTRIBPROC __glewDisableVertexArrayAttrib;
extern __attribute__ ((visibility("default"))) PFNGLENABLEVERTEXARRAYATTRIBPROC __glewEnableVertexArrayAttrib;
extern __attribute__ ((visibility("default"))) PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC __glewFlushMappedNamedBufferRange;
extern __attribute__ ((visibility("default"))) PFNGLGENERATETEXTUREMIPMAPPROC __glewGenerateTextureMipmap;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC __glewGetCompressedTextureImage;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDBUFFERPARAMETERI64VPROC __glewGetNamedBufferParameteri64v;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDBUFFERPARAMETERIVPROC __glewGetNamedBufferParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDBUFFERPOINTERVPROC __glewGetNamedBufferPointerv;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDBUFFERSUBDATAPROC __glewGetNamedBufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC __glewGetNamedFramebufferAttachmentParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC __glewGetNamedFramebufferParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC __glewGetNamedRenderbufferParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYBUFFEROBJECTI64VPROC __glewGetQueryBufferObjecti64v;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYBUFFEROBJECTIVPROC __glewGetQueryBufferObjectiv;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYBUFFEROBJECTUI64VPROC __glewGetQueryBufferObjectui64v;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYBUFFEROBJECTUIVPROC __glewGetQueryBufferObjectuiv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREIMAGEPROC __glewGetTextureImage;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTURELEVELPARAMETERFVPROC __glewGetTextureLevelParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTURELEVELPARAMETERIVPROC __glewGetTextureLevelParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREPARAMETERIIVPROC __glewGetTextureParameterIiv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREPARAMETERIUIVPROC __glewGetTextureParameterIuiv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREPARAMETERFVPROC __glewGetTextureParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREPARAMETERIVPROC __glewGetTextureParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETTRANSFORMFEEDBACKI64_VPROC __glewGetTransformFeedbacki64_v;
extern __attribute__ ((visibility("default"))) PFNGLGETTRANSFORMFEEDBACKI_VPROC __glewGetTransformFeedbacki_v;
extern __attribute__ ((visibility("default"))) PFNGLGETTRANSFORMFEEDBACKIVPROC __glewGetTransformFeedbackiv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXARRAYINDEXED64IVPROC __glewGetVertexArrayIndexed64iv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXARRAYINDEXEDIVPROC __glewGetVertexArrayIndexediv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXARRAYIVPROC __glewGetVertexArrayiv;
extern __attribute__ ((visibility("default"))) PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC __glewInvalidateNamedFramebufferData;
extern __attribute__ ((visibility("default"))) PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC __glewInvalidateNamedFramebufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLMAPNAMEDBUFFERPROC __glewMapNamedBuffer;
extern __attribute__ ((visibility("default"))) PFNGLMAPNAMEDBUFFERRANGEPROC __glewMapNamedBufferRange;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERDATAPROC __glewNamedBufferData;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERSTORAGEPROC __glewNamedBufferStorage;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERSUBDATAPROC __glewNamedBufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC __glewNamedFramebufferDrawBuffer;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC __glewNamedFramebufferDrawBuffers;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC __glewNamedFramebufferParameteri;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC __glewNamedFramebufferReadBuffer;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC __glewNamedFramebufferRenderbuffer;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTUREPROC __glewNamedFramebufferTexture;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC __glewNamedFramebufferTextureLayer;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDRENDERBUFFERSTORAGEPROC __glewNamedRenderbufferStorage;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC __glewNamedRenderbufferStorageMultisample;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREBUFFERPROC __glewTextureBuffer;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREBUFFERRANGEPROC __glewTextureBufferRange;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERIIVPROC __glewTextureParameterIiv;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERIUIVPROC __glewTextureParameterIuiv;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERFPROC __glewTextureParameterf;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERFVPROC __glewTextureParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERIPROC __glewTextureParameteri;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERIVPROC __glewTextureParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE1DPROC __glewTextureStorage1D;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE2DPROC __glewTextureStorage2D;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC __glewTextureStorage2DMultisample;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE3DPROC __glewTextureStorage3D;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC __glewTextureStorage3DMultisample;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESUBIMAGE1DPROC __glewTextureSubImage1D;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESUBIMAGE2DPROC __glewTextureSubImage2D;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESUBIMAGE3DPROC __glewTextureSubImage3D;
extern __attribute__ ((visibility("default"))) PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC __glewTransformFeedbackBufferBase;
extern __attribute__ ((visibility("default"))) PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC __glewTransformFeedbackBufferRange;
extern __attribute__ ((visibility("default"))) PFNGLUNMAPNAMEDBUFFERPROC __glewUnmapNamedBuffer;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYATTRIBBINDINGPROC __glewVertexArrayAttribBinding;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYATTRIBFORMATPROC __glewVertexArrayAttribFormat;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYATTRIBIFORMATPROC __glewVertexArrayAttribIFormat;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYATTRIBLFORMATPROC __glewVertexArrayAttribLFormat;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYBINDINGDIVISORPROC __glewVertexArrayBindingDivisor;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYELEMENTBUFFERPROC __glewVertexArrayElementBuffer;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXBUFFERPROC __glewVertexArrayVertexBuffer;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXBUFFERSPROC __glewVertexArrayVertexBuffers;

extern __attribute__ ((visibility("default"))) PFNGLDRAWBUFFERSARBPROC __glewDrawBuffersARB;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEIARBPROC __glewBlendEquationSeparateiARB;
extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONIARBPROC __glewBlendEquationiARB;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEIARBPROC __glewBlendFuncSeparateiARB;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCIARBPROC __glewBlendFunciARB;

extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSBASEVERTEXPROC __glewDrawElementsBaseVertex;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC __glewDrawElementsInstancedBaseVertex;
extern __attribute__ ((visibility("default"))) PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC __glewDrawRangeElementsBaseVertex;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC __glewMultiDrawElementsBaseVertex;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINDIRECTPROC __glewDrawArraysIndirect;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINDIRECTPROC __glewDrawElementsIndirect;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERPARAMETERIPROC __glewFramebufferParameteri;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAMEBUFFERPARAMETERIVPROC __glewGetFramebufferParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC __glewGetNamedFramebufferParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC __glewNamedFramebufferParameteriEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINDFRAMEBUFFERPROC __glewBindFramebuffer;
extern __attribute__ ((visibility("default"))) PFNGLBINDRENDERBUFFERPROC __glewBindRenderbuffer;
extern __attribute__ ((visibility("default"))) PFNGLBLITFRAMEBUFFERPROC __glewBlitFramebuffer;
extern __attribute__ ((visibility("default"))) PFNGLCHECKFRAMEBUFFERSTATUSPROC __glewCheckFramebufferStatus;
extern __attribute__ ((visibility("default"))) PFNGLDELETEFRAMEBUFFERSPROC __glewDeleteFramebuffers;
extern __attribute__ ((visibility("default"))) PFNGLDELETERENDERBUFFERSPROC __glewDeleteRenderbuffers;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERRENDERBUFFERPROC __glewFramebufferRenderbuffer;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE1DPROC __glewFramebufferTexture1D;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE2DPROC __glewFramebufferTexture2D;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE3DPROC __glewFramebufferTexture3D;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURELAYERPROC __glewFramebufferTextureLayer;
extern __attribute__ ((visibility("default"))) PFNGLGENFRAMEBUFFERSPROC __glewGenFramebuffers;
extern __attribute__ ((visibility("default"))) PFNGLGENRENDERBUFFERSPROC __glewGenRenderbuffers;
extern __attribute__ ((visibility("default"))) PFNGLGENERATEMIPMAPPROC __glewGenerateMipmap;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC __glewGetFramebufferAttachmentParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETRENDERBUFFERPARAMETERIVPROC __glewGetRenderbufferParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLISFRAMEBUFFERPROC __glewIsFramebuffer;
extern __attribute__ ((visibility("default"))) PFNGLISRENDERBUFFERPROC __glewIsRenderbuffer;
extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEPROC __glewRenderbufferStorage;
extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC __glewRenderbufferStorageMultisample;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTUREARBPROC __glewFramebufferTextureARB;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTUREFACEARBPROC __glewFramebufferTextureFaceARB;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURELAYERARBPROC __glewFramebufferTextureLayerARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETERIARBPROC __glewProgramParameteriARB;

extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMBINARYPROC __glewGetProgramBinary;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMBINARYPROC __glewProgramBinary;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETERIPROC __glewProgramParameteri;

extern __attribute__ ((visibility("default"))) PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC __glewGetCompressedTextureSubImage;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTURESUBIMAGEPROC __glewGetTextureSubImage;

extern __attribute__ ((visibility("default"))) PFNGLSPECIALIZESHADERARBPROC __glewSpecializeShaderARB;

extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMDVPROC __glewGetUniformdv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1DPROC __glewUniform1d;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1DVPROC __glewUniform1dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2DPROC __glewUniform2d;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2DVPROC __glewUniform2dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3DPROC __glewUniform3d;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3DVPROC __glewUniform3dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4DPROC __glewUniform4d;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4DVPROC __glewUniform4dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2DVPROC __glewUniformMatrix2dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2X3DVPROC __glewUniformMatrix2x3dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2X4DVPROC __glewUniformMatrix2x4dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3DVPROC __glewUniformMatrix3dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3X2DVPROC __glewUniformMatrix3x2dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3X4DVPROC __glewUniformMatrix3x4dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4DVPROC __glewUniformMatrix4dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4X2DVPROC __glewUniformMatrix4x2dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4X3DVPROC __glewUniformMatrix4x3dv;

extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMI64VARBPROC __glewGetUniformi64vARB;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMUI64VARBPROC __glewGetUniformui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMI64VARBPROC __glewGetnUniformi64vARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMUI64VARBPROC __glewGetnUniformui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1I64ARBPROC __glewProgramUniform1i64ARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1I64VARBPROC __glewProgramUniform1i64vARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UI64ARBPROC __glewProgramUniform1ui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UI64VARBPROC __glewProgramUniform1ui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2I64ARBPROC __glewProgramUniform2i64ARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2I64VARBPROC __glewProgramUniform2i64vARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UI64ARBPROC __glewProgramUniform2ui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UI64VARBPROC __glewProgramUniform2ui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3I64ARBPROC __glewProgramUniform3i64ARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3I64VARBPROC __glewProgramUniform3i64vARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UI64ARBPROC __glewProgramUniform3ui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UI64VARBPROC __glewProgramUniform3ui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4I64ARBPROC __glewProgramUniform4i64ARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4I64VARBPROC __glewProgramUniform4i64vARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UI64ARBPROC __glewProgramUniform4ui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UI64VARBPROC __glewProgramUniform4ui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1I64ARBPROC __glewUniform1i64ARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1I64VARBPROC __glewUniform1i64vARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UI64ARBPROC __glewUniform1ui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UI64VARBPROC __glewUniform1ui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2I64ARBPROC __glewUniform2i64ARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2I64VARBPROC __glewUniform2i64vARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UI64ARBPROC __glewUniform2ui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UI64VARBPROC __glewUniform2ui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3I64ARBPROC __glewUniform3i64ARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3I64VARBPROC __glewUniform3i64vARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UI64ARBPROC __glewUniform3ui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UI64VARBPROC __glewUniform3ui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4I64ARBPROC __glewUniform4i64ARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4I64VARBPROC __glewUniform4i64vARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UI64ARBPROC __glewUniform4ui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UI64VARBPROC __glewUniform4ui64vARB;

extern __attribute__ ((visibility("default"))) PFNGLCOLORSUBTABLEPROC __glewColorSubTable;
extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLEPROC __glewColorTable;
extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLEPARAMETERFVPROC __glewColorTableParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLEPARAMETERIVPROC __glewColorTableParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONFILTER1DPROC __glewConvolutionFilter1D;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONFILTER2DPROC __glewConvolutionFilter2D;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERFPROC __glewConvolutionParameterf;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERFVPROC __glewConvolutionParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERIPROC __glewConvolutionParameteri;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERIVPROC __glewConvolutionParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCOLORSUBTABLEPROC __glewCopyColorSubTable;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCOLORTABLEPROC __glewCopyColorTable;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCONVOLUTIONFILTER1DPROC __glewCopyConvolutionFilter1D;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCONVOLUTIONFILTER2DPROC __glewCopyConvolutionFilter2D;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPROC __glewGetColorTable;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPARAMETERFVPROC __glewGetColorTableParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPARAMETERIVPROC __glewGetColorTableParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETCONVOLUTIONFILTERPROC __glewGetConvolutionFilter;
extern __attribute__ ((visibility("default"))) PFNGLGETCONVOLUTIONPARAMETERFVPROC __glewGetConvolutionParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLGETCONVOLUTIONPARAMETERIVPROC __glewGetConvolutionParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETHISTOGRAMPROC __glewGetHistogram;
extern __attribute__ ((visibility("default"))) PFNGLGETHISTOGRAMPARAMETERFVPROC __glewGetHistogramParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLGETHISTOGRAMPARAMETERIVPROC __glewGetHistogramParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETMINMAXPROC __glewGetMinmax;
extern __attribute__ ((visibility("default"))) PFNGLGETMINMAXPARAMETERFVPROC __glewGetMinmaxParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLGETMINMAXPARAMETERIVPROC __glewGetMinmaxParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETSEPARABLEFILTERPROC __glewGetSeparableFilter;
extern __attribute__ ((visibility("default"))) PFNGLHISTOGRAMPROC __glewHistogram;
extern __attribute__ ((visibility("default"))) PFNGLMINMAXPROC __glewMinmax;
extern __attribute__ ((visibility("default"))) PFNGLRESETHISTOGRAMPROC __glewResetHistogram;
extern __attribute__ ((visibility("default"))) PFNGLRESETMINMAXPROC __glewResetMinmax;
extern __attribute__ ((visibility("default"))) PFNGLSEPARABLEFILTER2DPROC __glewSeparableFilter2D;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC __glewMultiDrawArraysIndirectCountARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC __glewMultiDrawElementsIndirectCountARB;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINSTANCEDARBPROC __glewDrawArraysInstancedARB;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDARBPROC __glewDrawElementsInstancedARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBDIVISORARBPROC __glewVertexAttribDivisorARB;

extern __attribute__ ((visibility("default"))) PFNGLGETINTERNALFORMATIVPROC __glewGetInternalformativ;

extern __attribute__ ((visibility("default"))) PFNGLGETINTERNALFORMATI64VPROC __glewGetInternalformati64v;

extern __attribute__ ((visibility("default"))) PFNGLINVALIDATEBUFFERDATAPROC __glewInvalidateBufferData;
extern __attribute__ ((visibility("default"))) PFNGLINVALIDATEBUFFERSUBDATAPROC __glewInvalidateBufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLINVALIDATEFRAMEBUFFERPROC __glewInvalidateFramebuffer;
extern __attribute__ ((visibility("default"))) PFNGLINVALIDATESUBFRAMEBUFFERPROC __glewInvalidateSubFramebuffer;
extern __attribute__ ((visibility("default"))) PFNGLINVALIDATETEXIMAGEPROC __glewInvalidateTexImage;
extern __attribute__ ((visibility("default"))) PFNGLINVALIDATETEXSUBIMAGEPROC __glewInvalidateTexSubImage;

extern __attribute__ ((visibility("default"))) PFNGLFLUSHMAPPEDBUFFERRANGEPROC __glewFlushMappedBufferRange;
extern __attribute__ ((visibility("default"))) PFNGLMAPBUFFERRANGEPROC __glewMapBufferRange;

extern __attribute__ ((visibility("default"))) PFNGLCURRENTPALETTEMATRIXARBPROC __glewCurrentPaletteMatrixARB;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXINDEXPOINTERARBPROC __glewMatrixIndexPointerARB;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXINDEXUBVARBPROC __glewMatrixIndexubvARB;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXINDEXUIVARBPROC __glewMatrixIndexuivARB;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXINDEXUSVARBPROC __glewMatrixIndexusvARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERSBASEPROC __glewBindBuffersBase;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERSRANGEPROC __glewBindBuffersRange;
extern __attribute__ ((visibility("default"))) PFNGLBINDIMAGETEXTURESPROC __glewBindImageTextures;
extern __attribute__ ((visibility("default"))) PFNGLBINDSAMPLERSPROC __glewBindSamplers;
extern __attribute__ ((visibility("default"))) PFNGLBINDTEXTURESPROC __glewBindTextures;
extern __attribute__ ((visibility("default"))) PFNGLBINDVERTEXBUFFERSPROC __glewBindVertexBuffers;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSINDIRECTPROC __glewMultiDrawArraysIndirect;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSINDIRECTPROC __glewMultiDrawElementsIndirect;

extern __attribute__ ((visibility("default"))) PFNGLSAMPLECOVERAGEARBPROC __glewSampleCoverageARB;

extern __attribute__ ((visibility("default"))) PFNGLACTIVETEXTUREARBPROC __glewActiveTextureARB;
extern __attribute__ ((visibility("default"))) PFNGLCLIENTACTIVETEXTUREARBPROC __glewClientActiveTextureARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1DARBPROC __glewMultiTexCoord1dARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1DVARBPROC __glewMultiTexCoord1dvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1FARBPROC __glewMultiTexCoord1fARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1FVARBPROC __glewMultiTexCoord1fvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1IARBPROC __glewMultiTexCoord1iARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1IVARBPROC __glewMultiTexCoord1ivARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1SARBPROC __glewMultiTexCoord1sARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1SVARBPROC __glewMultiTexCoord1svARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2DARBPROC __glewMultiTexCoord2dARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2DVARBPROC __glewMultiTexCoord2dvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2FARBPROC __glewMultiTexCoord2fARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2FVARBPROC __glewMultiTexCoord2fvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2IARBPROC __glewMultiTexCoord2iARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2IVARBPROC __glewMultiTexCoord2ivARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2SARBPROC __glewMultiTexCoord2sARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2SVARBPROC __glewMultiTexCoord2svARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3DARBPROC __glewMultiTexCoord3dARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3DVARBPROC __glewMultiTexCoord3dvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3FARBPROC __glewMultiTexCoord3fARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3FVARBPROC __glewMultiTexCoord3fvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3IARBPROC __glewMultiTexCoord3iARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3IVARBPROC __glewMultiTexCoord3ivARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3SARBPROC __glewMultiTexCoord3sARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3SVARBPROC __glewMultiTexCoord3svARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4DARBPROC __glewMultiTexCoord4dARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4DVARBPROC __glewMultiTexCoord4dvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4FARBPROC __glewMultiTexCoord4fARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4FVARBPROC __glewMultiTexCoord4fvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4IARBPROC __glewMultiTexCoord4iARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4IVARBPROC __glewMultiTexCoord4ivARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4SARBPROC __glewMultiTexCoord4sARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4SVARBPROC __glewMultiTexCoord4svARB;

extern __attribute__ ((visibility("default"))) PFNGLBEGINQUERYARBPROC __glewBeginQueryARB;
extern __attribute__ ((visibility("default"))) PFNGLDELETEQUERIESARBPROC __glewDeleteQueriesARB;
extern __attribute__ ((visibility("default"))) PFNGLENDQUERYARBPROC __glewEndQueryARB;
extern __attribute__ ((visibility("default"))) PFNGLGENQUERIESARBPROC __glewGenQueriesARB;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTIVARBPROC __glewGetQueryObjectivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTUIVARBPROC __glewGetQueryObjectuivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYIVARBPROC __glewGetQueryivARB;
extern __attribute__ ((visibility("default"))) PFNGLISQUERYARBPROC __glewIsQueryARB;

extern __attribute__ ((visibility("default"))) PFNGLMAXSHADERCOMPILERTHREADSARBPROC __glewMaxShaderCompilerThreadsARB;

extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERFARBPROC __glewPointParameterfARB;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERFVARBPROC __glewPointParameterfvARB;

extern __attribute__ ((visibility("default"))) PFNGLPOLYGONOFFSETCLAMPPROC __glewPolygonOffsetClamp;

extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMINTERFACEIVPROC __glewGetProgramInterfaceiv;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMRESOURCEINDEXPROC __glewGetProgramResourceIndex;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMRESOURCELOCATIONPROC __glewGetProgramResourceLocation;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC __glewGetProgramResourceLocationIndex;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMRESOURCENAMEPROC __glewGetProgramResourceName;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMRESOURCEIVPROC __glewGetProgramResourceiv;

extern __attribute__ ((visibility("default"))) PFNGLPROVOKINGVERTEXPROC __glewProvokingVertex;

extern __attribute__ ((visibility("default"))) PFNGLGETGRAPHICSRESETSTATUSARBPROC __glewGetGraphicsResetStatusARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNCOLORTABLEARBPROC __glewGetnColorTableARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC __glewGetnCompressedTexImageARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNCONVOLUTIONFILTERARBPROC __glewGetnConvolutionFilterARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNHISTOGRAMARBPROC __glewGetnHistogramARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNMAPDVARBPROC __glewGetnMapdvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNMAPFVARBPROC __glewGetnMapfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNMAPIVARBPROC __glewGetnMapivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNMINMAXARBPROC __glewGetnMinmaxARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNPIXELMAPFVARBPROC __glewGetnPixelMapfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNPIXELMAPUIVARBPROC __glewGetnPixelMapuivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNPIXELMAPUSVARBPROC __glewGetnPixelMapusvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNPOLYGONSTIPPLEARBPROC __glewGetnPolygonStippleARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNSEPARABLEFILTERARBPROC __glewGetnSeparableFilterARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNTEXIMAGEARBPROC __glewGetnTexImageARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMDVARBPROC __glewGetnUniformdvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMFVARBPROC __glewGetnUniformfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMIVARBPROC __glewGetnUniformivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMUIVARBPROC __glewGetnUniformuivARB;
extern __attribute__ ((visibility("default"))) PFNGLREADNPIXELSARBPROC __glewReadnPixelsARB;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC __glewFramebufferSampleLocationsfvARB;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC __glewNamedFramebufferSampleLocationsfvARB;

extern __attribute__ ((visibility("default"))) PFNGLMINSAMPLESHADINGARBPROC __glewMinSampleShadingARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDSAMPLERPROC __glewBindSampler;
extern __attribute__ ((visibility("default"))) PFNGLDELETESAMPLERSPROC __glewDeleteSamplers;
extern __attribute__ ((visibility("default"))) PFNGLGENSAMPLERSPROC __glewGenSamplers;
extern __attribute__ ((visibility("default"))) PFNGLGETSAMPLERPARAMETERIIVPROC __glewGetSamplerParameterIiv;
extern __attribute__ ((visibility("default"))) PFNGLGETSAMPLERPARAMETERIUIVPROC __glewGetSamplerParameterIuiv;
extern __attribute__ ((visibility("default"))) PFNGLGETSAMPLERPARAMETERFVPROC __glewGetSamplerParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLGETSAMPLERPARAMETERIVPROC __glewGetSamplerParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLISSAMPLERPROC __glewIsSampler;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERIIVPROC __glewSamplerParameterIiv;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERIUIVPROC __glewSamplerParameterIuiv;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERFPROC __glewSamplerParameterf;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERFVPROC __glewSamplerParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERIPROC __glewSamplerParameteri;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERIVPROC __glewSamplerParameteriv;

extern __attribute__ ((visibility("default"))) PFNGLACTIVESHADERPROGRAMPROC __glewActiveShaderProgram;
extern __attribute__ ((visibility("default"))) PFNGLBINDPROGRAMPIPELINEPROC __glewBindProgramPipeline;
extern __attribute__ ((visibility("default"))) PFNGLCREATESHADERPROGRAMVPROC __glewCreateShaderProgramv;
extern __attribute__ ((visibility("default"))) PFNGLDELETEPROGRAMPIPELINESPROC __glewDeleteProgramPipelines;
extern __attribute__ ((visibility("default"))) PFNGLGENPROGRAMPIPELINESPROC __glewGenProgramPipelines;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMPIPELINEINFOLOGPROC __glewGetProgramPipelineInfoLog;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMPIPELINEIVPROC __glewGetProgramPipelineiv;
extern __attribute__ ((visibility("default"))) PFNGLISPROGRAMPIPELINEPROC __glewIsProgramPipeline;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1DPROC __glewProgramUniform1d;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1DVPROC __glewProgramUniform1dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1FPROC __glewProgramUniform1f;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1FVPROC __glewProgramUniform1fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1IPROC __glewProgramUniform1i;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1IVPROC __glewProgramUniform1iv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UIPROC __glewProgramUniform1ui;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UIVPROC __glewProgramUniform1uiv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2DPROC __glewProgramUniform2d;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2DVPROC __glewProgramUniform2dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2FPROC __glewProgramUniform2f;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2FVPROC __glewProgramUniform2fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2IPROC __glewProgramUniform2i;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2IVPROC __glewProgramUniform2iv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UIPROC __glewProgramUniform2ui;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UIVPROC __glewProgramUniform2uiv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3DPROC __glewProgramUniform3d;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3DVPROC __glewProgramUniform3dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3FPROC __glewProgramUniform3f;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3FVPROC __glewProgramUniform3fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3IPROC __glewProgramUniform3i;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3IVPROC __glewProgramUniform3iv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UIPROC __glewProgramUniform3ui;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UIVPROC __glewProgramUniform3uiv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4DPROC __glewProgramUniform4d;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4DVPROC __glewProgramUniform4dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4FPROC __glewProgramUniform4f;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4FVPROC __glewProgramUniform4fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4IPROC __glewProgramUniform4i;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4IVPROC __glewProgramUniform4iv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UIPROC __glewProgramUniform4ui;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UIVPROC __glewProgramUniform4uiv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2DVPROC __glewProgramUniformMatrix2dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2FVPROC __glewProgramUniformMatrix2fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC __glewProgramUniformMatrix2x3dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC __glewProgramUniformMatrix2x3fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC __glewProgramUniformMatrix2x4dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC __glewProgramUniformMatrix2x4fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3DVPROC __glewProgramUniformMatrix3dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3FVPROC __glewProgramUniformMatrix3fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC __glewProgramUniformMatrix3x2dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC __glewProgramUniformMatrix3x2fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC __glewProgramUniformMatrix3x4dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC __glewProgramUniformMatrix3x4fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4DVPROC __glewProgramUniformMatrix4dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4FVPROC __glewProgramUniformMatrix4fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC __glewProgramUniformMatrix4x2dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC __glewProgramUniformMatrix4x2fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC __glewProgramUniformMatrix4x3dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC __glewProgramUniformMatrix4x3fv;
extern __attribute__ ((visibility("default"))) PFNGLUSEPROGRAMSTAGESPROC __glewUseProgramStages;
extern __attribute__ ((visibility("default"))) PFNGLVALIDATEPROGRAMPIPELINEPROC __glewValidateProgramPipeline;

extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC __glewGetActiveAtomicCounterBufferiv;

extern __attribute__ ((visibility("default"))) PFNGLBINDIMAGETEXTUREPROC __glewBindImageTexture;
extern __attribute__ ((visibility("default"))) PFNGLMEMORYBARRIERPROC __glewMemoryBarrier;

extern __attribute__ ((visibility("default"))) PFNGLATTACHOBJECTARBPROC __glewAttachObjectARB;
extern __attribute__ ((visibility("default"))) PFNGLCOMPILESHADERARBPROC __glewCompileShaderARB;
extern __attribute__ ((visibility("default"))) PFNGLCREATEPROGRAMOBJECTARBPROC __glewCreateProgramObjectARB;
extern __attribute__ ((visibility("default"))) PFNGLCREATESHADEROBJECTARBPROC __glewCreateShaderObjectARB;
extern __attribute__ ((visibility("default"))) PFNGLDELETEOBJECTARBPROC __glewDeleteObjectARB;
extern __attribute__ ((visibility("default"))) PFNGLDETACHOBJECTARBPROC __glewDetachObjectARB;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEUNIFORMARBPROC __glewGetActiveUniformARB;
extern __attribute__ ((visibility("default"))) PFNGLGETATTACHEDOBJECTSARBPROC __glewGetAttachedObjectsARB;
extern __attribute__ ((visibility("default"))) PFNGLGETHANDLEARBPROC __glewGetHandleARB;
extern __attribute__ ((visibility("default"))) PFNGLGETINFOLOGARBPROC __glewGetInfoLogARB;
extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTPARAMETERFVARBPROC __glewGetObjectParameterfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTPARAMETERIVARBPROC __glewGetObjectParameterivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETSHADERSOURCEARBPROC __glewGetShaderSourceARB;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMLOCATIONARBPROC __glewGetUniformLocationARB;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMFVARBPROC __glewGetUniformfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMIVARBPROC __glewGetUniformivARB;
extern __attribute__ ((visibility("default"))) PFNGLLINKPROGRAMARBPROC __glewLinkProgramARB;
extern __attribute__ ((visibility("default"))) PFNGLSHADERSOURCEARBPROC __glewShaderSourceARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1FARBPROC __glewUniform1fARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1FVARBPROC __glewUniform1fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1IARBPROC __glewUniform1iARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1IVARBPROC __glewUniform1ivARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2FARBPROC __glewUniform2fARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2FVARBPROC __glewUniform2fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2IARBPROC __glewUniform2iARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2IVARBPROC __glewUniform2ivARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3FARBPROC __glewUniform3fARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3FVARBPROC __glewUniform3fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3IARBPROC __glewUniform3iARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3IVARBPROC __glewUniform3ivARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4FARBPROC __glewUniform4fARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4FVARBPROC __glewUniform4fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4IARBPROC __glewUniform4iARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4IVARBPROC __glewUniform4ivARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2FVARBPROC __glewUniformMatrix2fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3FVARBPROC __glewUniformMatrix3fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4FVARBPROC __glewUniformMatrix4fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUSEPROGRAMOBJECTARBPROC __glewUseProgramObjectARB;
extern __attribute__ ((visibility("default"))) PFNGLVALIDATEPROGRAMARBPROC __glewValidateProgramARB;

extern __attribute__ ((visibility("default"))) PFNGLSHADERSTORAGEBLOCKBINDINGPROC __glewShaderStorageBlockBinding;

extern __attribute__ ((visibility("default"))) PFNGLGETACTIVESUBROUTINENAMEPROC __glewGetActiveSubroutineName;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC __glewGetActiveSubroutineUniformName;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC __glewGetActiveSubroutineUniformiv;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMSTAGEIVPROC __glewGetProgramStageiv;
extern __attribute__ ((visibility("default"))) PFNGLGETSUBROUTINEINDEXPROC __glewGetSubroutineIndex;
extern __attribute__ ((visibility("default"))) PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC __glewGetSubroutineUniformLocation;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMSUBROUTINEUIVPROC __glewGetUniformSubroutineuiv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMSUBROUTINESUIVPROC __glewUniformSubroutinesuiv;

extern __attribute__ ((visibility("default"))) PFNGLCOMPILESHADERINCLUDEARBPROC __glewCompileShaderIncludeARB;
extern __attribute__ ((visibility("default"))) PFNGLDELETENAMEDSTRINGARBPROC __glewDeleteNamedStringARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDSTRINGARBPROC __glewGetNamedStringARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDSTRINGIVARBPROC __glewGetNamedStringivARB;
extern __attribute__ ((visibility("default"))) PFNGLISNAMEDSTRINGARBPROC __glewIsNamedStringARB;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDSTRINGARBPROC __glewNamedStringARB;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERPAGECOMMITMENTARBPROC __glewBufferPageCommitmentARB;

extern __attribute__ ((visibility("default"))) PFNGLTEXPAGECOMMITMENTARBPROC __glewTexPageCommitmentARB;

extern __attribute__ ((visibility("default"))) PFNGLCLIENTWAITSYNCPROC __glewClientWaitSync;
extern __attribute__ ((visibility("default"))) PFNGLDELETESYNCPROC __glewDeleteSync;
extern __attribute__ ((visibility("default"))) PFNGLFENCESYNCPROC __glewFenceSync;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGER64VPROC __glewGetInteger64v;
extern __attribute__ ((visibility("default"))) PFNGLGETSYNCIVPROC __glewGetSynciv;
extern __attribute__ ((visibility("default"))) PFNGLISSYNCPROC __glewIsSync;
extern __attribute__ ((visibility("default"))) PFNGLWAITSYNCPROC __glewWaitSync;

extern __attribute__ ((visibility("default"))) PFNGLPATCHPARAMETERFVPROC __glewPatchParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLPATCHPARAMETERIPROC __glewPatchParameteri;

extern __attribute__ ((visibility("default"))) PFNGLTEXTUREBARRIERPROC __glewTextureBarrier;

extern __attribute__ ((visibility("default"))) PFNGLTEXBUFFERARBPROC __glewTexBufferARB;

extern __attribute__ ((visibility("default"))) PFNGLTEXBUFFERRANGEPROC __glewTexBufferRange;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREBUFFERRANGEEXTPROC __glewTextureBufferRangeEXT;

extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE1DARBPROC __glewCompressedTexImage1DARB;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE2DARBPROC __glewCompressedTexImage2DARB;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE3DARBPROC __glewCompressedTexImage3DARB;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC __glewCompressedTexSubImage1DARB;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC __glewCompressedTexSubImage2DARB;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC __glewCompressedTexSubImage3DARB;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMPRESSEDTEXIMAGEARBPROC __glewGetCompressedTexImageARB;

extern __attribute__ ((visibility("default"))) PFNGLGETMULTISAMPLEFVPROC __glewGetMultisamplefv;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLEMASKIPROC __glewSampleMaski;
extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE2DMULTISAMPLEPROC __glewTexImage2DMultisample;
extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE3DMULTISAMPLEPROC __glewTexImage3DMultisample;

extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE1DPROC __glewTexStorage1D;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE2DPROC __glewTexStorage2D;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE3DPROC __glewTexStorage3D;

extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE2DMULTISAMPLEPROC __glewTexStorage2DMultisample;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE3DMULTISAMPLEPROC __glewTexStorage3DMultisample;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC __glewTextureStorage2DMultisampleEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC __glewTextureStorage3DMultisampleEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXTUREVIEWPROC __glewTextureView;

extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTI64VPROC __glewGetQueryObjecti64v;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTUI64VPROC __glewGetQueryObjectui64v;
extern __attribute__ ((visibility("default"))) PFNGLQUERYCOUNTERPROC __glewQueryCounter;

extern __attribute__ ((visibility("default"))) PFNGLBINDTRANSFORMFEEDBACKPROC __glewBindTransformFeedback;
extern __attribute__ ((visibility("default"))) PFNGLDELETETRANSFORMFEEDBACKSPROC __glewDeleteTransformFeedbacks;
extern __attribute__ ((visibility("default"))) PFNGLDRAWTRANSFORMFEEDBACKPROC __glewDrawTransformFeedback;
extern __attribute__ ((visibility("default"))) PFNGLGENTRANSFORMFEEDBACKSPROC __glewGenTransformFeedbacks;
extern __attribute__ ((visibility("default"))) PFNGLISTRANSFORMFEEDBACKPROC __glewIsTransformFeedback;
extern __attribute__ ((visibility("default"))) PFNGLPAUSETRANSFORMFEEDBACKPROC __glewPauseTransformFeedback;
extern __attribute__ ((visibility("default"))) PFNGLRESUMETRANSFORMFEEDBACKPROC __glewResumeTransformFeedback;

extern __attribute__ ((visibility("default"))) PFNGLBEGINQUERYINDEXEDPROC __glewBeginQueryIndexed;
extern __attribute__ ((visibility("default"))) PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC __glewDrawTransformFeedbackStream;
extern __attribute__ ((visibility("default"))) PFNGLENDQUERYINDEXEDPROC __glewEndQueryIndexed;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYINDEXEDIVPROC __glewGetQueryIndexediv;

extern __attribute__ ((visibility("default"))) PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC __glewDrawTransformFeedbackInstanced;
extern __attribute__ ((visibility("default"))) PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC __glewDrawTransformFeedbackStreamInstanced;

extern __attribute__ ((visibility("default"))) PFNGLLOADTRANSPOSEMATRIXDARBPROC __glewLoadTransposeMatrixdARB;
extern __attribute__ ((visibility("default"))) PFNGLLOADTRANSPOSEMATRIXFARBPROC __glewLoadTransposeMatrixfARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTTRANSPOSEMATRIXDARBPROC __glewMultTransposeMatrixdARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTTRANSPOSEMATRIXFARBPROC __glewMultTransposeMatrixfARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERBASEPROC __glewBindBufferBase;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERRANGEPROC __glewBindBufferRange;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC __glewGetActiveUniformBlockName;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEUNIFORMBLOCKIVPROC __glewGetActiveUniformBlockiv;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEUNIFORMNAMEPROC __glewGetActiveUniformName;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEUNIFORMSIVPROC __glewGetActiveUniformsiv;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGERI_VPROC __glewGetIntegeri_v;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMBLOCKINDEXPROC __glewGetUniformBlockIndex;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMINDICESPROC __glewGetUniformIndices;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMBLOCKBINDINGPROC __glewUniformBlockBinding;

extern __attribute__ ((visibility("default"))) PFNGLBINDVERTEXARRAYPROC __glewBindVertexArray;
extern __attribute__ ((visibility("default"))) PFNGLDELETEVERTEXARRAYSPROC __glewDeleteVertexArrays;
extern __attribute__ ((visibility("default"))) PFNGLGENVERTEXARRAYSPROC __glewGenVertexArrays;
extern __attribute__ ((visibility("default"))) PFNGLISVERTEXARRAYPROC __glewIsVertexArray;

extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBLDVPROC __glewGetVertexAttribLdv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1DPROC __glewVertexAttribL1d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1DVPROC __glewVertexAttribL1dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2DPROC __glewVertexAttribL2d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2DVPROC __glewVertexAttribL2dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3DPROC __glewVertexAttribL3d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3DVPROC __glewVertexAttribL3dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4DPROC __glewVertexAttribL4d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4DVPROC __glewVertexAttribL4dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBLPOINTERPROC __glewVertexAttribLPointer;

extern __attribute__ ((visibility("default"))) PFNGLBINDVERTEXBUFFERPROC __glewBindVertexBuffer;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC __glewVertexArrayBindVertexBufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC __glewVertexArrayVertexAttribBindingEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC __glewVertexArrayVertexAttribFormatEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC __glewVertexArrayVertexAttribIFormatEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC __glewVertexArrayVertexAttribLFormatEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC __glewVertexArrayVertexBindingDivisorEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBBINDINGPROC __glewVertexAttribBinding;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBFORMATPROC __glewVertexAttribFormat;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBIFORMATPROC __glewVertexAttribIFormat;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBLFORMATPROC __glewVertexAttribLFormat;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXBINDINGDIVISORPROC __glewVertexBindingDivisor;

extern __attribute__ ((visibility("default"))) PFNGLVERTEXBLENDARBPROC __glewVertexBlendARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTPOINTERARBPROC __glewWeightPointerARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTBVARBPROC __glewWeightbvARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTDVARBPROC __glewWeightdvARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTFVARBPROC __glewWeightfvARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTIVARBPROC __glewWeightivARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTSVARBPROC __glewWeightsvARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTUBVARBPROC __glewWeightubvARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTUIVARBPROC __glewWeightuivARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTUSVARBPROC __glewWeightusvARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERARBPROC __glewBindBufferARB;
extern __attribute__ ((visibility("default"))) PFNGLBUFFERDATAARBPROC __glewBufferDataARB;
extern __attribute__ ((visibility("default"))) PFNGLBUFFERSUBDATAARBPROC __glewBufferSubDataARB;
extern __attribute__ ((visibility("default"))) PFNGLDELETEBUFFERSARBPROC __glewDeleteBuffersARB;
extern __attribute__ ((visibility("default"))) PFNGLGENBUFFERSARBPROC __glewGenBuffersARB;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERPARAMETERIVARBPROC __glewGetBufferParameterivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERPOINTERVARBPROC __glewGetBufferPointervARB;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERSUBDATAARBPROC __glewGetBufferSubDataARB;
extern __attribute__ ((visibility("default"))) PFNGLISBUFFERARBPROC __glewIsBufferARB;
extern __attribute__ ((visibility("default"))) PFNGLMAPBUFFERARBPROC __glewMapBufferARB;
extern __attribute__ ((visibility("default"))) PFNGLUNMAPBUFFERARBPROC __glewUnmapBufferARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDPROGRAMARBPROC __glewBindProgramARB;
extern __attribute__ ((visibility("default"))) PFNGLDELETEPROGRAMSARBPROC __glewDeleteProgramsARB;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEVERTEXATTRIBARRAYARBPROC __glewDisableVertexAttribArrayARB;
extern __attribute__ ((visibility("default"))) PFNGLENABLEVERTEXATTRIBARRAYARBPROC __glewEnableVertexAttribArrayARB;
extern __attribute__ ((visibility("default"))) PFNGLGENPROGRAMSARBPROC __glewGenProgramsARB;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMENVPARAMETERDVARBPROC __glewGetProgramEnvParameterdvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMENVPARAMETERFVARBPROC __glewGetProgramEnvParameterfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC __glewGetProgramLocalParameterdvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC __glewGetProgramLocalParameterfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMSTRINGARBPROC __glewGetProgramStringARB;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMIVARBPROC __glewGetProgramivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBPOINTERVARBPROC __glewGetVertexAttribPointervARB;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBDVARBPROC __glewGetVertexAttribdvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBFVARBPROC __glewGetVertexAttribfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIVARBPROC __glewGetVertexAttribivARB;
extern __attribute__ ((visibility("default"))) PFNGLISPROGRAMARBPROC __glewIsProgramARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETER4DARBPROC __glewProgramEnvParameter4dARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETER4DVARBPROC __glewProgramEnvParameter4dvARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETER4FARBPROC __glewProgramEnvParameter4fARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETER4FVARBPROC __glewProgramEnvParameter4fvARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETER4DARBPROC __glewProgramLocalParameter4dARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETER4DVARBPROC __glewProgramLocalParameter4dvARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETER4FARBPROC __glewProgramLocalParameter4fARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETER4FVARBPROC __glewProgramLocalParameter4fvARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMSTRINGARBPROC __glewProgramStringARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1DARBPROC __glewVertexAttrib1dARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1DVARBPROC __glewVertexAttrib1dvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1FARBPROC __glewVertexAttrib1fARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1FVARBPROC __glewVertexAttrib1fvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1SARBPROC __glewVertexAttrib1sARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1SVARBPROC __glewVertexAttrib1svARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2DARBPROC __glewVertexAttrib2dARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2DVARBPROC __glewVertexAttrib2dvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2FARBPROC __glewVertexAttrib2fARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2FVARBPROC __glewVertexAttrib2fvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2SARBPROC __glewVertexAttrib2sARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2SVARBPROC __glewVertexAttrib2svARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3DARBPROC __glewVertexAttrib3dARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3DVARBPROC __glewVertexAttrib3dvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3FARBPROC __glewVertexAttrib3fARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3FVARBPROC __glewVertexAttrib3fvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3SARBPROC __glewVertexAttrib3sARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3SVARBPROC __glewVertexAttrib3svARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NBVARBPROC __glewVertexAttrib4NbvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NIVARBPROC __glewVertexAttrib4NivARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NSVARBPROC __glewVertexAttrib4NsvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUBARBPROC __glewVertexAttrib4NubARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUBVARBPROC __glewVertexAttrib4NubvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUIVARBPROC __glewVertexAttrib4NuivARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUSVARBPROC __glewVertexAttrib4NusvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4BVARBPROC __glewVertexAttrib4bvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4DARBPROC __glewVertexAttrib4dARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4DVARBPROC __glewVertexAttrib4dvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4FARBPROC __glewVertexAttrib4fARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4FVARBPROC __glewVertexAttrib4fvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4IVARBPROC __glewVertexAttrib4ivARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4SARBPROC __glewVertexAttrib4sARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4SVARBPROC __glewVertexAttrib4svARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4UBVARBPROC __glewVertexAttrib4ubvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4UIVARBPROC __glewVertexAttrib4uivARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4USVARBPROC __glewVertexAttrib4usvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBPOINTERARBPROC __glewVertexAttribPointerARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDATTRIBLOCATIONARBPROC __glewBindAttribLocationARB;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEATTRIBARBPROC __glewGetActiveAttribARB;
extern __attribute__ ((visibility("default"))) PFNGLGETATTRIBLOCATIONARBPROC __glewGetAttribLocationARB;

extern __attribute__ ((visibility("default"))) PFNGLCOLORP3UIPROC __glewColorP3ui;
extern __attribute__ ((visibility("default"))) PFNGLCOLORP3UIVPROC __glewColorP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLCOLORP4UIPROC __glewColorP4ui;
extern __attribute__ ((visibility("default"))) PFNGLCOLORP4UIVPROC __glewColorP4uiv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP1UIPROC __glewMultiTexCoordP1ui;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP1UIVPROC __glewMultiTexCoordP1uiv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP2UIPROC __glewMultiTexCoordP2ui;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP2UIVPROC __glewMultiTexCoordP2uiv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP3UIPROC __glewMultiTexCoordP3ui;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP3UIVPROC __glewMultiTexCoordP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP4UIPROC __glewMultiTexCoordP4ui;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP4UIVPROC __glewMultiTexCoordP4uiv;
extern __attribute__ ((visibility("default"))) PFNGLNORMALP3UIPROC __glewNormalP3ui;
extern __attribute__ ((visibility("default"))) PFNGLNORMALP3UIVPROC __glewNormalP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLORP3UIPROC __glewSecondaryColorP3ui;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLORP3UIVPROC __glewSecondaryColorP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP1UIPROC __glewTexCoordP1ui;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP1UIVPROC __glewTexCoordP1uiv;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP2UIPROC __glewTexCoordP2ui;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP2UIVPROC __glewTexCoordP2uiv;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP3UIPROC __glewTexCoordP3ui;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP3UIVPROC __glewTexCoordP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP4UIPROC __glewTexCoordP4ui;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP4UIVPROC __glewTexCoordP4uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP1UIPROC __glewVertexAttribP1ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP1UIVPROC __glewVertexAttribP1uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP2UIPROC __glewVertexAttribP2ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP2UIVPROC __glewVertexAttribP2uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP3UIPROC __glewVertexAttribP3ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP3UIVPROC __glewVertexAttribP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP4UIPROC __glewVertexAttribP4ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP4UIVPROC __glewVertexAttribP4uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXP2UIPROC __glewVertexP2ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXP2UIVPROC __glewVertexP2uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXP3UIPROC __glewVertexP3ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXP3UIVPROC __glewVertexP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXP4UIPROC __glewVertexP4ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXP4UIVPROC __glewVertexP4uiv;

extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEARRAYVPROC __glewDepthRangeArrayv;
extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEINDEXEDPROC __glewDepthRangeIndexed;
extern __attribute__ ((visibility("default"))) PFNGLGETDOUBLEI_VPROC __glewGetDoublei_v;
extern __attribute__ ((visibility("default"))) PFNGLGETFLOATI_VPROC __glewGetFloati_v;
extern __attribute__ ((visibility("default"))) PFNGLSCISSORARRAYVPROC __glewScissorArrayv;
extern __attribute__ ((visibility("default"))) PFNGLSCISSORINDEXEDPROC __glewScissorIndexed;
extern __attribute__ ((visibility("default"))) PFNGLSCISSORINDEXEDVPROC __glewScissorIndexedv;
extern __attribute__ ((visibility("default"))) PFNGLVIEWPORTARRAYVPROC __glewViewportArrayv;
extern __attribute__ ((visibility("default"))) PFNGLVIEWPORTINDEXEDFPROC __glewViewportIndexedf;
extern __attribute__ ((visibility("default"))) PFNGLVIEWPORTINDEXEDFVPROC __glewViewportIndexedfv;

extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2DARBPROC __glewWindowPos2dARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2DVARBPROC __glewWindowPos2dvARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2FARBPROC __glewWindowPos2fARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2FVARBPROC __glewWindowPos2fvARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2IARBPROC __glewWindowPos2iARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2IVARBPROC __glewWindowPos2ivARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2SARBPROC __glewWindowPos2sARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2SVARBPROC __glewWindowPos2svARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3DARBPROC __glewWindowPos3dARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3DVARBPROC __glewWindowPos3dvARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3FARBPROC __glewWindowPos3fARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3FVARBPROC __glewWindowPos3fvARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3IARBPROC __glewWindowPos3iARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3IVARBPROC __glewWindowPos3ivARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3SARBPROC __glewWindowPos3sARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3SVARBPROC __glewWindowPos3svARB;

extern __attribute__ ((visibility("default"))) PFNGLDRAWBUFFERSATIPROC __glewDrawBuffersATI;

extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTARRAYATIPROC __glewDrawElementArrayATI;
extern __attribute__ ((visibility("default"))) PFNGLDRAWRANGEELEMENTARRAYATIPROC __glewDrawRangeElementArrayATI;
extern __attribute__ ((visibility("default"))) PFNGLELEMENTPOINTERATIPROC __glewElementPointerATI;

extern __attribute__ ((visibility("default"))) PFNGLGETTEXBUMPPARAMETERFVATIPROC __glewGetTexBumpParameterfvATI;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXBUMPPARAMETERIVATIPROC __glewGetTexBumpParameterivATI;
extern __attribute__ ((visibility("default"))) PFNGLTEXBUMPPARAMETERFVATIPROC __glewTexBumpParameterfvATI;
extern __attribute__ ((visibility("default"))) PFNGLTEXBUMPPARAMETERIVATIPROC __glewTexBumpParameterivATI;

extern __attribute__ ((visibility("default"))) PFNGLALPHAFRAGMENTOP1ATIPROC __glewAlphaFragmentOp1ATI;
extern __attribute__ ((visibility("default"))) PFNGLALPHAFRAGMENTOP2ATIPROC __glewAlphaFragmentOp2ATI;
extern __attribute__ ((visibility("default"))) PFNGLALPHAFRAGMENTOP3ATIPROC __glewAlphaFragmentOp3ATI;
extern __attribute__ ((visibility("default"))) PFNGLBEGINFRAGMENTSHADERATIPROC __glewBeginFragmentShaderATI;
extern __attribute__ ((visibility("default"))) PFNGLBINDFRAGMENTSHADERATIPROC __glewBindFragmentShaderATI;
extern __attribute__ ((visibility("default"))) PFNGLCOLORFRAGMENTOP1ATIPROC __glewColorFragmentOp1ATI;
extern __attribute__ ((visibility("default"))) PFNGLCOLORFRAGMENTOP2ATIPROC __glewColorFragmentOp2ATI;
extern __attribute__ ((visibility("default"))) PFNGLCOLORFRAGMENTOP3ATIPROC __glewColorFragmentOp3ATI;
extern __attribute__ ((visibility("default"))) PFNGLDELETEFRAGMENTSHADERATIPROC __glewDeleteFragmentShaderATI;
extern __attribute__ ((visibility("default"))) PFNGLENDFRAGMENTSHADERATIPROC __glewEndFragmentShaderATI;
extern __attribute__ ((visibility("default"))) PFNGLGENFRAGMENTSHADERSATIPROC __glewGenFragmentShadersATI;
extern __attribute__ ((visibility("default"))) PFNGLPASSTEXCOORDATIPROC __glewPassTexCoordATI;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLEMAPATIPROC __glewSampleMapATI;
extern __attribute__ ((visibility("default"))) PFNGLSETFRAGMENTSHADERCONSTANTATIPROC __glewSetFragmentShaderConstantATI;

extern __attribute__ ((visibility("default"))) PFNGLMAPOBJECTBUFFERATIPROC __glewMapObjectBufferATI;
extern __attribute__ ((visibility("default"))) PFNGLUNMAPOBJECTBUFFERATIPROC __glewUnmapObjectBufferATI;

extern __attribute__ ((visibility("default"))) PFNGLPNTRIANGLESFATIPROC __glewPNTrianglesfATI;
extern __attribute__ ((visibility("default"))) PFNGLPNTRIANGLESIATIPROC __glewPNTrianglesiATI;

extern __attribute__ ((visibility("default"))) PFNGLSTENCILFUNCSEPARATEATIPROC __glewStencilFuncSeparateATI;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILOPSEPARATEATIPROC __glewStencilOpSeparateATI;

extern __attribute__ ((visibility("default"))) PFNGLARRAYOBJECTATIPROC __glewArrayObjectATI;
extern __attribute__ ((visibility("default"))) PFNGLFREEOBJECTBUFFERATIPROC __glewFreeObjectBufferATI;
extern __attribute__ ((visibility("default"))) PFNGLGETARRAYOBJECTFVATIPROC __glewGetArrayObjectfvATI;
extern __attribute__ ((visibility("default"))) PFNGLGETARRAYOBJECTIVATIPROC __glewGetArrayObjectivATI;
extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTBUFFERFVATIPROC __glewGetObjectBufferfvATI;
extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTBUFFERIVATIPROC __glewGetObjectBufferivATI;
extern __attribute__ ((visibility("default"))) PFNGLGETVARIANTARRAYOBJECTFVATIPROC __glewGetVariantArrayObjectfvATI;
extern __attribute__ ((visibility("default"))) PFNGLGETVARIANTARRAYOBJECTIVATIPROC __glewGetVariantArrayObjectivATI;
extern __attribute__ ((visibility("default"))) PFNGLISOBJECTBUFFERATIPROC __glewIsObjectBufferATI;
extern __attribute__ ((visibility("default"))) PFNGLNEWOBJECTBUFFERATIPROC __glewNewObjectBufferATI;
extern __attribute__ ((visibility("default"))) PFNGLUPDATEOBJECTBUFFERATIPROC __glewUpdateObjectBufferATI;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTARRAYOBJECTATIPROC __glewVariantArrayObjectATI;

extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC __glewGetVertexAttribArrayObjectfvATI;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC __glewGetVertexAttribArrayObjectivATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBARRAYOBJECTATIPROC __glewVertexAttribArrayObjectATI;

extern __attribute__ ((visibility("default"))) PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC __glewClientActiveVertexStreamATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3BATIPROC __glewNormalStream3bATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3BVATIPROC __glewNormalStream3bvATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3DATIPROC __glewNormalStream3dATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3DVATIPROC __glewNormalStream3dvATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3FATIPROC __glewNormalStream3fATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3FVATIPROC __glewNormalStream3fvATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3IATIPROC __glewNormalStream3iATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3IVATIPROC __glewNormalStream3ivATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3SATIPROC __glewNormalStream3sATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3SVATIPROC __glewNormalStream3svATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXBLENDENVFATIPROC __glewVertexBlendEnvfATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXBLENDENVIATIPROC __glewVertexBlendEnviATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1DATIPROC __glewVertexStream1dATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1DVATIPROC __glewVertexStream1dvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1FATIPROC __glewVertexStream1fATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1FVATIPROC __glewVertexStream1fvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1IATIPROC __glewVertexStream1iATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1IVATIPROC __glewVertexStream1ivATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1SATIPROC __glewVertexStream1sATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1SVATIPROC __glewVertexStream1svATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2DATIPROC __glewVertexStream2dATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2DVATIPROC __glewVertexStream2dvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2FATIPROC __glewVertexStream2fATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2FVATIPROC __glewVertexStream2fvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2IATIPROC __glewVertexStream2iATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2IVATIPROC __glewVertexStream2ivATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2SATIPROC __glewVertexStream2sATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2SVATIPROC __glewVertexStream2svATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3DATIPROC __glewVertexStream3dATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3DVATIPROC __glewVertexStream3dvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3FATIPROC __glewVertexStream3fATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3FVATIPROC __glewVertexStream3fvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3IATIPROC __glewVertexStream3iATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3IVATIPROC __glewVertexStream3ivATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3SATIPROC __glewVertexStream3sATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3SVATIPROC __glewVertexStream3svATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4DATIPROC __glewVertexStream4dATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4DVATIPROC __glewVertexStream4dvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4FATIPROC __glewVertexStream4fATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4FVATIPROC __glewVertexStream4fvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4IATIPROC __glewVertexStream4iATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4IVATIPROC __glewVertexStream4ivATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4SATIPROC __glewVertexStream4sATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4SVATIPROC __glewVertexStream4svATI;

extern __attribute__ ((visibility("default"))) PFNGLEGLIMAGETARGETTEXSTORAGEEXTPROC __glewEGLImageTargetTexStorageEXT;
extern __attribute__ ((visibility("default"))) PFNGLEGLIMAGETARGETTEXTURESTORAGEEXTPROC __glewEGLImageTargetTextureStorageEXT;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEEXTPROC __glewDrawArraysInstancedBaseInstanceEXT;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEEXTPROC __glewDrawElementsInstancedBaseInstanceEXT;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEEXTPROC __glewDrawElementsInstancedBaseVertexBaseInstanceEXT;

extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMBUFFERSIZEEXTPROC __glewGetUniformBufferSizeEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMOFFSETEXTPROC __glewGetUniformOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMBUFFEREXTPROC __glewUniformBufferEXT;

extern __attribute__ ((visibility("default"))) PFNGLBLENDCOLOREXTPROC __glewBlendColorEXT;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEEXTPROC __glewBlendEquationSeparateEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINDFRAGDATALOCATIONINDEXEDEXTPROC __glewBindFragDataLocationIndexedEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGDATAINDEXEXTPROC __glewGetFragDataIndexEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMRESOURCELOCATIONINDEXEXTPROC __glewGetProgramResourceLocationIndexEXT;

extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEEXTPROC __glewBlendFuncSeparateEXT;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONEXTPROC __glewBlendEquationEXT;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERSTORAGEEXTPROC __glewBufferStorageEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERSTORAGEEXTPROC __glewNamedBufferStorageEXT;

extern __attribute__ ((visibility("default"))) PFNGLCLEARTEXIMAGEEXTPROC __glewClearTexImageEXT;
extern __attribute__ ((visibility("default"))) PFNGLCLEARTEXSUBIMAGEEXTPROC __glewClearTexSubImageEXT;

extern __attribute__ ((visibility("default"))) PFNGLCLIPCONTROLEXTPROC __glewClipControlEXT;

extern __attribute__ ((visibility("default"))) PFNGLCOLORSUBTABLEEXTPROC __glewColorSubTableEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCOLORSUBTABLEEXTPROC __glewCopyColorSubTableEXT;

extern __attribute__ ((visibility("default"))) PFNGLLOCKARRAYSEXTPROC __glewLockArraysEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNLOCKARRAYSEXTPROC __glewUnlockArraysEXT;

extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONFILTER1DEXTPROC __glewConvolutionFilter1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONFILTER2DEXTPROC __glewConvolutionFilter2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERFEXTPROC __glewConvolutionParameterfEXT;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERFVEXTPROC __glewConvolutionParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERIEXTPROC __glewConvolutionParameteriEXT;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERIVEXTPROC __glewConvolutionParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC __glewCopyConvolutionFilter1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC __glewCopyConvolutionFilter2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCONVOLUTIONFILTEREXTPROC __glewGetConvolutionFilterEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC __glewGetConvolutionParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC __glewGetConvolutionParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETSEPARABLEFILTEREXTPROC __glewGetSeparableFilterEXT;
extern __attribute__ ((visibility("default"))) PFNGLSEPARABLEFILTER2DEXTPROC __glewSeparableFilter2DEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINORMALPOINTEREXTPROC __glewBinormalPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLTANGENTPOINTEREXTPROC __glewTangentPointerEXT;

extern __attribute__ ((visibility("default"))) PFNGLCOPYIMAGESUBDATAEXTPROC __glewCopyImageSubDataEXT;

extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXIMAGE1DEXTPROC __glewCopyTexImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXIMAGE2DEXTPROC __glewCopyTexImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXSUBIMAGE1DEXTPROC __glewCopyTexSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXSUBIMAGE2DEXTPROC __glewCopyTexSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXSUBIMAGE3DEXTPROC __glewCopyTexSubImage3DEXT;

extern __attribute__ ((visibility("default"))) PFNGLCULLPARAMETERDVEXTPROC __glewCullParameterdvEXT;
extern __attribute__ ((visibility("default"))) PFNGLCULLPARAMETERFVEXTPROC __glewCullParameterfvEXT;

extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTLABELEXTPROC __glewGetObjectLabelEXT;
extern __attribute__ ((visibility("default"))) PFNGLLABELOBJECTEXTPROC __glewLabelObjectEXT;

extern __attribute__ ((visibility("default"))) PFNGLINSERTEVENTMARKEREXTPROC __glewInsertEventMarkerEXT;
extern __attribute__ ((visibility("default"))) PFNGLPOPGROUPMARKEREXTPROC __glewPopGroupMarkerEXT;
extern __attribute__ ((visibility("default"))) PFNGLPUSHGROUPMARKEREXTPROC __glewPushGroupMarkerEXT;

extern __attribute__ ((visibility("default"))) PFNGLDEPTHBOUNDSEXTPROC __glewDepthBoundsEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINDMULTITEXTUREEXTPROC __glewBindMultiTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC __glewCheckNamedFramebufferStatusEXT;
extern __attribute__ ((visibility("default"))) PFNGLCLIENTATTRIBDEFAULTEXTPROC __glewClientAttribDefaultEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC __glewCompressedMultiTexImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC __glewCompressedMultiTexImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC __glewCompressedMultiTexImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC __glewCompressedMultiTexSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC __glewCompressedMultiTexSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC __glewCompressedMultiTexSubImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC __glewCompressedTextureImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC __glewCompressedTextureImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC __glewCompressedTextureImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC __glewCompressedTextureSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC __glewCompressedTextureSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC __glewCompressedTextureSubImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYMULTITEXIMAGE1DEXTPROC __glewCopyMultiTexImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYMULTITEXIMAGE2DEXTPROC __glewCopyMultiTexImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC __glewCopyMultiTexSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC __glewCopyMultiTexSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC __glewCopyMultiTexSubImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTUREIMAGE1DEXTPROC __glewCopyTextureImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTUREIMAGE2DEXTPROC __glewCopyTextureImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC __glewCopyTextureSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC __glewCopyTextureSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC __glewCopyTextureSubImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC __glewDisableClientStateIndexedEXT;
extern __attribute__ ((visibility("default"))) PFNGLDISABLECLIENTSTATEIEXTPROC __glewDisableClientStateiEXT;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC __glewDisableVertexArrayAttribEXT;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEVERTEXARRAYEXTPROC __glewDisableVertexArrayEXT;
extern __attribute__ ((visibility("default"))) PFNGLENABLECLIENTSTATEINDEXEDEXTPROC __glewEnableClientStateIndexedEXT;
extern __attribute__ ((visibility("default"))) PFNGLENABLECLIENTSTATEIEXTPROC __glewEnableClientStateiEXT;
extern __attribute__ ((visibility("default"))) PFNGLENABLEVERTEXARRAYATTRIBEXTPROC __glewEnableVertexArrayAttribEXT;
extern __attribute__ ((visibility("default"))) PFNGLENABLEVERTEXARRAYEXTPROC __glewEnableVertexArrayEXT;
extern __attribute__ ((visibility("default"))) PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC __glewFlushMappedNamedBufferRangeEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC __glewFramebufferDrawBufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC __glewFramebufferDrawBuffersEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERREADBUFFEREXTPROC __glewFramebufferReadBufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENERATEMULTITEXMIPMAPEXTPROC __glewGenerateMultiTexMipmapEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENERATETEXTUREMIPMAPEXTPROC __glewGenerateTextureMipmapEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC __glewGetCompressedMultiTexImageEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC __glewGetCompressedTextureImageEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETDOUBLEINDEXEDVEXTPROC __glewGetDoubleIndexedvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETDOUBLEI_VEXTPROC __glewGetDoublei_vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFLOATINDEXEDVEXTPROC __glewGetFloatIndexedvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFLOATI_VEXTPROC __glewGetFloati_vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC __glewGetFramebufferParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXENVFVEXTPROC __glewGetMultiTexEnvfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXENVIVEXTPROC __glewGetMultiTexEnvivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXGENDVEXTPROC __glewGetMultiTexGendvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXGENFVEXTPROC __glewGetMultiTexGenfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXGENIVEXTPROC __glewGetMultiTexGenivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXIMAGEEXTPROC __glewGetMultiTexImageEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC __glewGetMultiTexLevelParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC __glewGetMultiTexLevelParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXPARAMETERIIVEXTPROC __glewGetMultiTexParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXPARAMETERIUIVEXTPROC __glewGetMultiTexParameterIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXPARAMETERFVEXTPROC __glewGetMultiTexParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXPARAMETERIVEXTPROC __glewGetMultiTexParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC __glewGetNamedBufferParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDBUFFERPOINTERVEXTPROC __glewGetNamedBufferPointervEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDBUFFERSUBDATAEXTPROC __glewGetNamedBufferSubDataEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetNamedFramebufferAttachmentParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC __glewGetNamedProgramLocalParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC __glewGetNamedProgramLocalParameterIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC __glewGetNamedProgramLocalParameterdvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC __glewGetNamedProgramLocalParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDPROGRAMSTRINGEXTPROC __glewGetNamedProgramStringEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDPROGRAMIVEXTPROC __glewGetNamedProgramivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC __glewGetNamedRenderbufferParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETPOINTERINDEXEDVEXTPROC __glewGetPointerIndexedvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETPOINTERI_VEXTPROC __glewGetPointeri_vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREIMAGEEXTPROC __glewGetTextureImageEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC __glewGetTextureLevelParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC __glewGetTextureLevelParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREPARAMETERIIVEXTPROC __glewGetTextureParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREPARAMETERIUIVEXTPROC __glewGetTextureParameterIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREPARAMETERFVEXTPROC __glewGetTextureParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREPARAMETERIVEXTPROC __glewGetTextureParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC __glewGetVertexArrayIntegeri_vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXARRAYINTEGERVEXTPROC __glewGetVertexArrayIntegervEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC __glewGetVertexArrayPointeri_vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXARRAYPOINTERVEXTPROC __glewGetVertexArrayPointervEXT;
extern __attribute__ ((visibility("default"))) PFNGLMAPNAMEDBUFFEREXTPROC __glewMapNamedBufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLMAPNAMEDBUFFERRANGEEXTPROC __glewMapNamedBufferRangeEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXFRUSTUMEXTPROC __glewMatrixFrustumEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOADIDENTITYEXTPROC __glewMatrixLoadIdentityEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOADTRANSPOSEDEXTPROC __glewMatrixLoadTransposedEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOADTRANSPOSEFEXTPROC __glewMatrixLoadTransposefEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOADDEXTPROC __glewMatrixLoaddEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOADFEXTPROC __glewMatrixLoadfEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXMULTTRANSPOSEDEXTPROC __glewMatrixMultTransposedEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXMULTTRANSPOSEFEXTPROC __glewMatrixMultTransposefEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXMULTDEXTPROC __glewMatrixMultdEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXMULTFEXTPROC __glewMatrixMultfEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXORTHOEXTPROC __glewMatrixOrthoEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXPOPEXTPROC __glewMatrixPopEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXPUSHEXTPROC __glewMatrixPushEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXROTATEDEXTPROC __glewMatrixRotatedEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXROTATEFEXTPROC __glewMatrixRotatefEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXSCALEDEXTPROC __glewMatrixScaledEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXSCALEFEXTPROC __glewMatrixScalefEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXTRANSLATEDEXTPROC __glewMatrixTranslatedEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXTRANSLATEFEXTPROC __glewMatrixTranslatefEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXBUFFEREXTPROC __glewMultiTexBufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDPOINTEREXTPROC __glewMultiTexCoordPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXENVFEXTPROC __glewMultiTexEnvfEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXENVFVEXTPROC __glewMultiTexEnvfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXENVIEXTPROC __glewMultiTexEnviEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXENVIVEXTPROC __glewMultiTexEnvivEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXGENDEXTPROC __glewMultiTexGendEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXGENDVEXTPROC __glewMultiTexGendvEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXGENFEXTPROC __glewMultiTexGenfEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXGENFVEXTPROC __glewMultiTexGenfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXGENIEXTPROC __glewMultiTexGeniEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXGENIVEXTPROC __glewMultiTexGenivEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXIMAGE1DEXTPROC __glewMultiTexImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXIMAGE2DEXTPROC __glewMultiTexImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXIMAGE3DEXTPROC __glewMultiTexImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXPARAMETERIIVEXTPROC __glewMultiTexParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXPARAMETERIUIVEXTPROC __glewMultiTexParameterIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXPARAMETERFEXTPROC __glewMultiTexParameterfEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXPARAMETERFVEXTPROC __glewMultiTexParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXPARAMETERIEXTPROC __glewMultiTexParameteriEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXPARAMETERIVEXTPROC __glewMultiTexParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXRENDERBUFFEREXTPROC __glewMultiTexRenderbufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXSUBIMAGE1DEXTPROC __glewMultiTexSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXSUBIMAGE2DEXTPROC __glewMultiTexSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXSUBIMAGE3DEXTPROC __glewMultiTexSubImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERDATAEXTPROC __glewNamedBufferDataEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERSUBDATAEXTPROC __glewNamedBufferSubDataEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC __glewNamedCopyBufferSubDataEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC __glewNamedFramebufferRenderbufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC __glewNamedFramebufferTexture1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC __glewNamedFramebufferTexture2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC __glewNamedFramebufferTexture3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC __glewNamedFramebufferTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC __glewNamedFramebufferTextureFaceEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC __glewNamedFramebufferTextureLayerEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC __glewNamedProgramLocalParameter4dEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC __glewNamedProgramLocalParameter4dvEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC __glewNamedProgramLocalParameter4fEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC __glewNamedProgramLocalParameter4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC __glewNamedProgramLocalParameterI4iEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC __glewNamedProgramLocalParameterI4ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC __glewNamedProgramLocalParameterI4uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC __glewNamedProgramLocalParameterI4uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC __glewNamedProgramLocalParameters4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC __glewNamedProgramLocalParametersI4ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC __glewNamedProgramLocalParametersI4uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMSTRINGEXTPROC __glewNamedProgramStringEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC __glewNamedRenderbufferStorageEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC __glewNamedRenderbufferStorageMultisampleCoverageEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewNamedRenderbufferStorageMultisampleEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1FEXTPROC __glewProgramUniform1fEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1FVEXTPROC __glewProgramUniform1fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1IEXTPROC __glewProgramUniform1iEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1IVEXTPROC __glewProgramUniform1ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UIEXTPROC __glewProgramUniform1uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UIVEXTPROC __glewProgramUniform1uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2FEXTPROC __glewProgramUniform2fEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2FVEXTPROC __glewProgramUniform2fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2IEXTPROC __glewProgramUniform2iEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2IVEXTPROC __glewProgramUniform2ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UIEXTPROC __glewProgramUniform2uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UIVEXTPROC __glewProgramUniform2uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3FEXTPROC __glewProgramUniform3fEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3FVEXTPROC __glewProgramUniform3fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3IEXTPROC __glewProgramUniform3iEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3IVEXTPROC __glewProgramUniform3ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UIEXTPROC __glewProgramUniform3uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UIVEXTPROC __glewProgramUniform3uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4FEXTPROC __glewProgramUniform4fEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4FVEXTPROC __glewProgramUniform4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4IEXTPROC __glewProgramUniform4iEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4IVEXTPROC __glewProgramUniform4ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UIEXTPROC __glewProgramUniform4uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UIVEXTPROC __glewProgramUniform4uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC __glewProgramUniformMatrix2fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC __glewProgramUniformMatrix2x3fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC __glewProgramUniformMatrix2x4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC __glewProgramUniformMatrix3fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC __glewProgramUniformMatrix3x2fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC __glewProgramUniformMatrix3x4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC __glewProgramUniformMatrix4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC __glewProgramUniformMatrix4x2fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC __glewProgramUniformMatrix4x3fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC __glewPushClientAttribDefaultEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREBUFFEREXTPROC __glewTextureBufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE1DEXTPROC __glewTextureImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE2DEXTPROC __glewTextureImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE3DEXTPROC __glewTextureImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERIIVEXTPROC __glewTextureParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERIUIVEXTPROC __glewTextureParameterIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERFEXTPROC __glewTextureParameterfEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERFVEXTPROC __glewTextureParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERIEXTPROC __glewTextureParameteriEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERIVEXTPROC __glewTextureParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURERENDERBUFFEREXTPROC __glewTextureRenderbufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESUBIMAGE1DEXTPROC __glewTextureSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESUBIMAGE2DEXTPROC __glewTextureSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESUBIMAGE3DEXTPROC __glewTextureSubImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNMAPNAMEDBUFFEREXTPROC __glewUnmapNamedBufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYCOLOROFFSETEXTPROC __glewVertexArrayColorOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC __glewVertexArrayEdgeFlagOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC __glewVertexArrayFogCoordOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYINDEXOFFSETEXTPROC __glewVertexArrayIndexOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC __glewVertexArrayMultiTexCoordOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYNORMALOFFSETEXTPROC __glewVertexArrayNormalOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC __glewVertexArraySecondaryColorOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC __glewVertexArrayTexCoordOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC __glewVertexArrayVertexAttribDivisorEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC __glewVertexArrayVertexAttribIOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC __glewVertexArrayVertexAttribOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC __glewVertexArrayVertexOffsetEXT;

extern __attribute__ ((visibility("default"))) PFNGLDISCARDFRAMEBUFFEREXTPROC __glewDiscardFramebufferEXT;

extern __attribute__ ((visibility("default"))) PFNGLBEGINQUERYEXTPROC __glewBeginQueryEXT;
extern __attribute__ ((visibility("default"))) PFNGLDELETEQUERIESEXTPROC __glewDeleteQueriesEXT;
extern __attribute__ ((visibility("default"))) PFNGLENDQUERYEXTPROC __glewEndQueryEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENQUERIESEXTPROC __glewGenQueriesEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGER64VEXTPROC __glewGetInteger64vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTIVEXTPROC __glewGetQueryObjectivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTUIVEXTPROC __glewGetQueryObjectuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYIVEXTPROC __glewGetQueryivEXT;
extern __attribute__ ((visibility("default"))) PFNGLISQUERYEXTPROC __glewIsQueryEXT;
extern __attribute__ ((visibility("default"))) PFNGLQUERYCOUNTEREXTPROC __glewQueryCounterEXT;

extern __attribute__ ((visibility("default"))) PFNGLDRAWBUFFERSEXTPROC __glewDrawBuffersEXT;

extern __attribute__ ((visibility("default"))) PFNGLCOLORMASKINDEXEDEXTPROC __glewColorMaskIndexedEXT;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEINDEXEDEXTPROC __glewDisableIndexedEXT;
extern __attribute__ ((visibility("default"))) PFNGLENABLEINDEXEDEXTPROC __glewEnableIndexedEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETBOOLEANINDEXEDVEXTPROC __glewGetBooleanIndexedvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGERINDEXEDVEXTPROC __glewGetIntegerIndexedvEXT;
extern __attribute__ ((visibility("default"))) PFNGLISENABLEDINDEXEDEXTPROC __glewIsEnabledIndexedEXT;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEIEXTPROC __glewBlendEquationSeparateiEXT;
extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONIEXTPROC __glewBlendEquationiEXT;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEIEXTPROC __glewBlendFuncSeparateiEXT;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCIEXTPROC __glewBlendFunciEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOLORMASKIEXTPROC __glewColorMaskiEXT;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEIEXTPROC __glewDisableiEXT;
extern __attribute__ ((visibility("default"))) PFNGLENABLEIEXTPROC __glewEnableiEXT;
extern __attribute__ ((visibility("default"))) PFNGLISENABLEDIEXTPROC __glewIsEnablediEXT;

extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSBASEVERTEXEXTPROC __glewDrawElementsBaseVertexEXT;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXEXTPROC __glewDrawElementsInstancedBaseVertexEXT;
extern __attribute__ ((visibility("default"))) PFNGLDRAWRANGEELEMENTSBASEVERTEXEXTPROC __glewDrawRangeElementsBaseVertexEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSBASEVERTEXEXTPROC __glewMultiDrawElementsBaseVertexEXT;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINSTANCEDEXTPROC __glewDrawArraysInstancedEXT;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDEXTPROC __glewDrawElementsInstancedEXT;

extern __attribute__ ((visibility("default"))) PFNGLDRAWRANGEELEMENTSEXTPROC __glewDrawRangeElementsEXT;

extern __attribute__ ((visibility("default"))) PFNGLDRAWTRANSFORMFEEDBACKEXTPROC __glewDrawTransformFeedbackEXT;
extern __attribute__ ((visibility("default"))) PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDEXTPROC __glewDrawTransformFeedbackInstancedEXT;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERSTORAGEEXTERNALEXTPROC __glewBufferStorageExternalEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERSTORAGEEXTERNALEXTPROC __glewNamedBufferStorageExternalEXT;

extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDPOINTEREXTPROC __glewFogCoordPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDDEXTPROC __glewFogCoorddEXT;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDDVEXTPROC __glewFogCoorddvEXT;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDFEXTPROC __glewFogCoordfEXT;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDFVEXTPROC __glewFogCoordfvEXT;

extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTCOLORMATERIALEXTPROC __glewFragmentColorMaterialEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELFEXTPROC __glewFragmentLightModelfEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELFVEXTPROC __glewFragmentLightModelfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELIEXTPROC __glewFragmentLightModeliEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELIVEXTPROC __glewFragmentLightModelivEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTFEXTPROC __glewFragmentLightfEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTFVEXTPROC __glewFragmentLightfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTIEXTPROC __glewFragmentLightiEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTIVEXTPROC __glewFragmentLightivEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALFEXTPROC __glewFragmentMaterialfEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALFVEXTPROC __glewFragmentMaterialfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALIEXTPROC __glewFragmentMaterialiEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALIVEXTPROC __glewFragmentMaterialivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTLIGHTFVEXTPROC __glewGetFragmentLightfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTLIGHTIVEXTPROC __glewGetFragmentLightivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTMATERIALFVEXTPROC __glewGetFragmentMaterialfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTMATERIALIVEXTPROC __glewGetFragmentMaterialivEXT;
extern __attribute__ ((visibility("default"))) PFNGLLIGHTENVIEXTPROC __glewLightEnviEXT;

extern __attribute__ ((visibility("default"))) PFNGLBLITFRAMEBUFFEREXTPROC __glewBlitFramebufferEXT;

extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewRenderbufferStorageMultisampleEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINDFRAMEBUFFEREXTPROC __glewBindFramebufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDRENDERBUFFEREXTPROC __glewBindRenderbufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC __glewCheckFramebufferStatusEXT;
extern __attribute__ ((visibility("default"))) PFNGLDELETEFRAMEBUFFERSEXTPROC __glewDeleteFramebuffersEXT;
extern __attribute__ ((visibility("default"))) PFNGLDELETERENDERBUFFERSEXTPROC __glewDeleteRenderbuffersEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC __glewFramebufferRenderbufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE1DEXTPROC __glewFramebufferTexture1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE2DEXTPROC __glewFramebufferTexture2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE3DEXTPROC __glewFramebufferTexture3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENFRAMEBUFFERSEXTPROC __glewGenFramebuffersEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENRENDERBUFFERSEXTPROC __glewGenRenderbuffersEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENERATEMIPMAPEXTPROC __glewGenerateMipmapEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetFramebufferAttachmentParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC __glewGetRenderbufferParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLISFRAMEBUFFEREXTPROC __glewIsFramebufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLISRENDERBUFFEREXTPROC __glewIsRenderbufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEEXTPROC __glewRenderbufferStorageEXT;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTUREEXTPROC __glewFramebufferTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC __glewFramebufferTextureFaceEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETERIEXTPROC __glewProgramParameteriEXT;

extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERS4FVEXTPROC __glewProgramEnvParameters4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC __glewProgramLocalParameters4fvEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINDFRAGDATALOCATIONEXTPROC __glewBindFragDataLocationEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGDATALOCATIONEXTPROC __glewGetFragDataLocationEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMUIVEXTPROC __glewGetUniformuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIIVEXTPROC __glewGetVertexAttribIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIUIVEXTPROC __glewGetVertexAttribIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UIEXTPROC __glewUniform1uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UIVEXTPROC __glewUniform1uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UIEXTPROC __glewUniform2uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UIVEXTPROC __glewUniform2uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UIEXTPROC __glewUniform3uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UIVEXTPROC __glewUniform3uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UIEXTPROC __glewUniform4uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UIVEXTPROC __glewUniform4uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1IEXTPROC __glewVertexAttribI1iEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1IVEXTPROC __glewVertexAttribI1ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1UIEXTPROC __glewVertexAttribI1uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1UIVEXTPROC __glewVertexAttribI1uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2IEXTPROC __glewVertexAttribI2iEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2IVEXTPROC __glewVertexAttribI2ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2UIEXTPROC __glewVertexAttribI2uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2UIVEXTPROC __glewVertexAttribI2uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3IEXTPROC __glewVertexAttribI3iEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3IVEXTPROC __glewVertexAttribI3ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3UIEXTPROC __glewVertexAttribI3uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3UIVEXTPROC __glewVertexAttribI3uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4BVEXTPROC __glewVertexAttribI4bvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4IEXTPROC __glewVertexAttribI4iEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4IVEXTPROC __glewVertexAttribI4ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4SVEXTPROC __glewVertexAttribI4svEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4UBVEXTPROC __glewVertexAttribI4ubvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4UIEXTPROC __glewVertexAttribI4uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4UIVEXTPROC __glewVertexAttribI4uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4USVEXTPROC __glewVertexAttribI4usvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBIPOINTEREXTPROC __glewVertexAttribIPointerEXT;

extern __attribute__ ((visibility("default"))) PFNGLGETHISTOGRAMEXTPROC __glewGetHistogramEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETHISTOGRAMPARAMETERFVEXTPROC __glewGetHistogramParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETHISTOGRAMPARAMETERIVEXTPROC __glewGetHistogramParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMINMAXEXTPROC __glewGetMinmaxEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMINMAXPARAMETERFVEXTPROC __glewGetMinmaxParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMINMAXPARAMETERIVEXTPROC __glewGetMinmaxParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLHISTOGRAMEXTPROC __glewHistogramEXT;
extern __attribute__ ((visibility("default"))) PFNGLMINMAXEXTPROC __glewMinmaxEXT;
extern __attribute__ ((visibility("default"))) PFNGLRESETHISTOGRAMEXTPROC __glewResetHistogramEXT;
extern __attribute__ ((visibility("default"))) PFNGLRESETMINMAXEXTPROC __glewResetMinmaxEXT;

extern __attribute__ ((visibility("default"))) PFNGLINDEXFUNCEXTPROC __glewIndexFuncEXT;

extern __attribute__ ((visibility("default"))) PFNGLINDEXMATERIALEXTPROC __glewIndexMaterialEXT;

extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBDIVISOREXTPROC __glewVertexAttribDivisorEXT;

extern __attribute__ ((visibility("default"))) PFNGLAPPLYTEXTUREEXTPROC __glewApplyTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURELIGHTEXTPROC __glewTextureLightEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREMATERIALEXTPROC __glewTextureMaterialEXT;

extern __attribute__ ((visibility("default"))) PFNGLFLUSHMAPPEDBUFFERRANGEEXTPROC __glewFlushMappedBufferRangeEXT;
extern __attribute__ ((visibility("default"))) PFNGLMAPBUFFERRANGEEXTPROC __glewMapBufferRangeEXT;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERSTORAGEMEMEXTPROC __glewBufferStorageMemEXT;
extern __attribute__ ((visibility("default"))) PFNGLCREATEMEMORYOBJECTSEXTPROC __glewCreateMemoryObjectsEXT;
extern __attribute__ ((visibility("default"))) PFNGLDELETEMEMORYOBJECTSEXTPROC __glewDeleteMemoryObjectsEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMEMORYOBJECTPARAMETERIVEXTPROC __glewGetMemoryObjectParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETUNSIGNEDBYTEI_VEXTPROC __glewGetUnsignedBytei_vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETUNSIGNEDBYTEVEXTPROC __glewGetUnsignedBytevEXT;
extern __attribute__ ((visibility("default"))) PFNGLISMEMORYOBJECTEXTPROC __glewIsMemoryObjectEXT;
extern __attribute__ ((visibility("default"))) PFNGLMEMORYOBJECTPARAMETERIVEXTPROC __glewMemoryObjectParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERSTORAGEMEMEXTPROC __glewNamedBufferStorageMemEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGEMEM1DEXTPROC __glewTexStorageMem1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGEMEM2DEXTPROC __glewTexStorageMem2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGEMEM2DMULTISAMPLEEXTPROC __glewTexStorageMem2DMultisampleEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGEMEM3DEXTPROC __glewTexStorageMem3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGEMEM3DMULTISAMPLEEXTPROC __glewTexStorageMem3DMultisampleEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGEMEM1DEXTPROC __glewTextureStorageMem1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGEMEM2DEXTPROC __glewTextureStorageMem2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGEMEM2DMULTISAMPLEEXTPROC __glewTextureStorageMem2DMultisampleEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGEMEM3DEXTPROC __glewTextureStorageMem3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGEMEM3DMULTISAMPLEEXTPROC __glewTextureStorageMem3DMultisampleEXT;

extern __attribute__ ((visibility("default"))) PFNGLIMPORTMEMORYFDEXTPROC __glewImportMemoryFdEXT;

extern __attribute__ ((visibility("default"))) PFNGLIMPORTMEMORYWIN32HANDLEEXTPROC __glewImportMemoryWin32HandleEXT;
extern __attribute__ ((visibility("default"))) PFNGLIMPORTMEMORYWIN32NAMEEXTPROC __glewImportMemoryWin32NameEXT;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSEXTPROC __glewMultiDrawArraysEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSEXTPROC __glewMultiDrawElementsEXT;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSINDIRECTEXTPROC __glewMultiDrawArraysIndirectEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSINDIRECTEXTPROC __glewMultiDrawElementsIndirectEXT;

extern __attribute__ ((visibility("default"))) PFNGLSAMPLEMASKEXTPROC __glewSampleMaskEXT;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLEPATTERNEXTPROC __glewSamplePatternEXT;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE2DMULTISAMPLEEXTPROC __glewFramebufferTexture2DMultisampleEXT;

extern __attribute__ ((visibility("default"))) PFNGLDRAWBUFFERSINDEXEDEXTPROC __glewDrawBuffersIndexedEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGERI_VEXTPROC __glewGetIntegeri_vEXT;
extern __attribute__ ((visibility("default"))) PFNGLREADBUFFERINDEXEDEXTPROC __glewReadBufferIndexedEXT;

extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLEEXTPROC __glewColorTableEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEEXTPROC __glewGetColorTableEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPARAMETERFVEXTPROC __glewGetColorTableParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPARAMETERIVEXTPROC __glewGetColorTableParameterivEXT;

extern __attribute__ ((visibility("default"))) PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC __glewGetPixelTransformParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC __glewGetPixelTransformParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMPARAMETERFEXTPROC __glewPixelTransformParameterfEXT;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC __glewPixelTransformParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMPARAMETERIEXTPROC __glewPixelTransformParameteriEXT;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC __glewPixelTransformParameterivEXT;

extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERFEXTPROC __glewPointParameterfEXT;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERFVEXTPROC __glewPointParameterfvEXT;

extern __attribute__ ((visibility("default"))) PFNGLPOLYGONOFFSETEXTPROC __glewPolygonOffsetEXT;

extern __attribute__ ((visibility("default"))) PFNGLPOLYGONOFFSETCLAMPEXTPROC __glewPolygonOffsetClampEXT;

extern __attribute__ ((visibility("default"))) PFNGLPRIMITIVEBOUNDINGBOXEXTPROC __glewPrimitiveBoundingBoxEXT;

extern __attribute__ ((visibility("default"))) PFNGLPROVOKINGVERTEXEXTPROC __glewProvokingVertexEXT;

extern __attribute__ ((visibility("default"))) PFNGLCOVERAGEMODULATIONNVPROC __glewCoverageModulationNV;
extern __attribute__ ((visibility("default"))) PFNGLCOVERAGEMODULATIONTABLENVPROC __glewCoverageModulationTableNV;
extern __attribute__ ((visibility("default"))) PFNGLGETCOVERAGEMODULATIONTABLENVPROC __glewGetCoverageModulationTableNV;
extern __attribute__ ((visibility("default"))) PFNGLRASTERSAMPLESEXTPROC __glewRasterSamplesEXT;

extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMFVEXTPROC __glewGetnUniformfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMIVEXTPROC __glewGetnUniformivEXT;
extern __attribute__ ((visibility("default"))) PFNGLREADNPIXELSEXTPROC __glewReadnPixelsEXT;

extern __attribute__ ((visibility("default"))) PFNGLBEGINSCENEEXTPROC __glewBeginSceneEXT;
extern __attribute__ ((visibility("default"))) PFNGLENDSCENEEXTPROC __glewEndSceneEXT;

extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3BEXTPROC __glewSecondaryColor3bEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3BVEXTPROC __glewSecondaryColor3bvEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3DEXTPROC __glewSecondaryColor3dEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3DVEXTPROC __glewSecondaryColor3dvEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3FEXTPROC __glewSecondaryColor3fEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3FVEXTPROC __glewSecondaryColor3fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3IEXTPROC __glewSecondaryColor3iEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3IVEXTPROC __glewSecondaryColor3ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3SEXTPROC __glewSecondaryColor3sEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3SVEXTPROC __glewSecondaryColor3svEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UBEXTPROC __glewSecondaryColor3ubEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UBVEXTPROC __glewSecondaryColor3ubvEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UIEXTPROC __glewSecondaryColor3uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UIVEXTPROC __glewSecondaryColor3uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3USEXTPROC __glewSecondaryColor3usEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3USVEXTPROC __glewSecondaryColor3usvEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLORPOINTEREXTPROC __glewSecondaryColorPointerEXT;

extern __attribute__ ((visibility("default"))) PFNGLDELETESEMAPHORESEXTPROC __glewDeleteSemaphoresEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENSEMAPHORESEXTPROC __glewGenSemaphoresEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETSEMAPHOREPARAMETERUI64VEXTPROC __glewGetSemaphoreParameterui64vEXT;
extern __attribute__ ((visibility("default"))) PFNGLISSEMAPHOREEXTPROC __glewIsSemaphoreEXT;
extern __attribute__ ((visibility("default"))) PFNGLSEMAPHOREPARAMETERUI64VEXTPROC __glewSemaphoreParameterui64vEXT;
extern __attribute__ ((visibility("default"))) PFNGLSIGNALSEMAPHOREEXTPROC __glewSignalSemaphoreEXT;
extern __attribute__ ((visibility("default"))) PFNGLWAITSEMAPHOREEXTPROC __glewWaitSemaphoreEXT;

extern __attribute__ ((visibility("default"))) PFNGLIMPORTSEMAPHOREFDEXTPROC __glewImportSemaphoreFdEXT;

extern __attribute__ ((visibility("default"))) PFNGLIMPORTSEMAPHOREWIN32HANDLEEXTPROC __glewImportSemaphoreWin32HandleEXT;
extern __attribute__ ((visibility("default"))) PFNGLIMPORTSEMAPHOREWIN32NAMEEXTPROC __glewImportSemaphoreWin32NameEXT;

extern __attribute__ ((visibility("default"))) PFNGLACTIVEPROGRAMEXTPROC __glewActiveProgramEXT;
extern __attribute__ ((visibility("default"))) PFNGLCREATESHADERPROGRAMEXTPROC __glewCreateShaderProgramEXT;
extern __attribute__ ((visibility("default"))) PFNGLUSESHADERPROGRAMEXTPROC __glewUseShaderProgramEXT;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERFETCHBARRIEREXTPROC __glewFramebufferFetchBarrierEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINDIMAGETEXTUREEXTPROC __glewBindImageTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLMEMORYBARRIEREXTPROC __glewMemoryBarrierEXT;

extern __attribute__ ((visibility("default"))) PFNGLCLEARPIXELLOCALSTORAGEUIEXTPROC __glewClearPixelLocalStorageuiEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERPIXELLOCALSTORAGESIZEEXTPROC __glewFramebufferPixelLocalStorageSizeEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAMEBUFFERPIXELLOCALSTORAGESIZEEXTPROC __glewGetFramebufferPixelLocalStorageSizeEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXPAGECOMMITMENTEXTPROC __glewTexPageCommitmentEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPAGECOMMITMENTEXTPROC __glewTexturePageCommitmentEXT;

extern __attribute__ ((visibility("default"))) PFNGLACTIVESTENCILFACEEXTPROC __glewActiveStencilFaceEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXSUBIMAGE1DEXTPROC __glewTexSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXSUBIMAGE2DEXTPROC __glewTexSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXSUBIMAGE3DEXTPROC __glewTexSubImage3DEXT;

extern __attribute__ ((visibility("default"))) PFNGLPATCHPARAMETERIEXTPROC __glewPatchParameteriEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE3DEXTPROC __glewTexImage3DEXT;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC __glewFramebufferTextureLayerEXT;

extern __attribute__ ((visibility("default"))) PFNGLGETSAMPLERPARAMETERIIVEXTPROC __glewGetSamplerParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETSAMPLERPARAMETERIUIVEXTPROC __glewGetSamplerParameterIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERIIVEXTPROC __glewSamplerParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERIUIVEXTPROC __glewSamplerParameterIuivEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXBUFFEREXTPROC __glewTexBufferEXT;

extern __attribute__ ((visibility("default"))) PFNGLCLEARCOLORIIEXTPROC __glewClearColorIiEXT;
extern __attribute__ ((visibility("default"))) PFNGLCLEARCOLORIUIEXTPROC __glewClearColorIuiEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERIIVEXTPROC __glewGetTexParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERIUIVEXTPROC __glewGetTexParameterIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERIIVEXTPROC __glewTexParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERIUIVEXTPROC __glewTexParameterIuivEXT;

extern __attribute__ ((visibility("default"))) PFNGLARETEXTURESRESIDENTEXTPROC __glewAreTexturesResidentEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDTEXTUREEXTPROC __glewBindTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLDELETETEXTURESEXTPROC __glewDeleteTexturesEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENTEXTURESEXTPROC __glewGenTexturesEXT;
extern __attribute__ ((visibility("default"))) PFNGLISTEXTUREEXTPROC __glewIsTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLPRIORITIZETEXTURESEXTPROC __glewPrioritizeTexturesEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXTURENORMALEXTPROC __glewTextureNormalEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE1DEXTPROC __glewTexStorage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE2DEXTPROC __glewTexStorage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE3DEXTPROC __glewTexStorage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE1DEXTPROC __glewTextureStorage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE2DEXTPROC __glewTextureStorage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE3DEXTPROC __glewTextureStorage3DEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXTUREVIEWEXTPROC __glewTextureViewEXT;

extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTI64VEXTPROC __glewGetQueryObjecti64vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTUI64VEXTPROC __glewGetQueryObjectui64vEXT;

extern __attribute__ ((visibility("default"))) PFNGLBEGINTRANSFORMFEEDBACKEXTPROC __glewBeginTransformFeedbackEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERBASEEXTPROC __glewBindBufferBaseEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFEROFFSETEXTPROC __glewBindBufferOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERRANGEEXTPROC __glewBindBufferRangeEXT;
extern __attribute__ ((visibility("default"))) PFNGLENDTRANSFORMFEEDBACKEXTPROC __glewEndTransformFeedbackEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC __glewGetTransformFeedbackVaryingEXT;
extern __attribute__ ((visibility("default"))) PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC __glewTransformFeedbackVaryingsEXT;

extern __attribute__ ((visibility("default"))) PFNGLARRAYELEMENTEXTPROC __glewArrayElementEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOLORPOINTEREXTPROC __glewColorPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSEXTPROC __glewDrawArraysEXT;
extern __attribute__ ((visibility("default"))) PFNGLEDGEFLAGPOINTEREXTPROC __glewEdgeFlagPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLINDEXPOINTEREXTPROC __glewIndexPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLNORMALPOINTEREXTPROC __glewNormalPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDPOINTEREXTPROC __glewTexCoordPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXPOINTEREXTPROC __glewVertexPointerEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINDARRAYSETEXTPROC __glewBindArraySetEXT;
extern __attribute__ ((visibility("default"))) PFNGLCREATEARRAYSETEXTPROC __glewCreateArraySetExt;
extern __attribute__ ((visibility("default"))) PFNGLDELETEARRAYSETSEXTPROC __glewDeleteArraySetsEXT;

extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBLDVEXTPROC __glewGetVertexAttribLdvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC __glewVertexArrayVertexAttribLOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1DEXTPROC __glewVertexAttribL1dEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1DVEXTPROC __glewVertexAttribL1dvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2DEXTPROC __glewVertexAttribL2dEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2DVEXTPROC __glewVertexAttribL2dvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3DEXTPROC __glewVertexAttribL3dEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3DVEXTPROC __glewVertexAttribL3dvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4DEXTPROC __glewVertexAttribL4dEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4DVEXTPROC __glewVertexAttribL4dvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBLPOINTEREXTPROC __glewVertexAttribLPointerEXT;

extern __attribute__ ((visibility("default"))) PFNGLBEGINVERTEXSHADEREXTPROC __glewBeginVertexShaderEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDLIGHTPARAMETEREXTPROC __glewBindLightParameterEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDMATERIALPARAMETEREXTPROC __glewBindMaterialParameterEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDPARAMETEREXTPROC __glewBindParameterEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDTEXGENPARAMETEREXTPROC __glewBindTexGenParameterEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDTEXTUREUNITPARAMETEREXTPROC __glewBindTextureUnitParameterEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDVERTEXSHADEREXTPROC __glewBindVertexShaderEXT;
extern __attribute__ ((visibility("default"))) PFNGLDELETEVERTEXSHADEREXTPROC __glewDeleteVertexShaderEXT;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC __glewDisableVariantClientStateEXT;
extern __attribute__ ((visibility("default"))) PFNGLENABLEVARIANTCLIENTSTATEEXTPROC __glewEnableVariantClientStateEXT;
extern __attribute__ ((visibility("default"))) PFNGLENDVERTEXSHADEREXTPROC __glewEndVertexShaderEXT;
extern __attribute__ ((visibility("default"))) PFNGLEXTRACTCOMPONENTEXTPROC __glewExtractComponentEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENSYMBOLSEXTPROC __glewGenSymbolsEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENVERTEXSHADERSEXTPROC __glewGenVertexShadersEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETINVARIANTBOOLEANVEXTPROC __glewGetInvariantBooleanvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETINVARIANTFLOATVEXTPROC __glewGetInvariantFloatvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETINVARIANTINTEGERVEXTPROC __glewGetInvariantIntegervEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC __glewGetLocalConstantBooleanvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETLOCALCONSTANTFLOATVEXTPROC __glewGetLocalConstantFloatvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETLOCALCONSTANTINTEGERVEXTPROC __glewGetLocalConstantIntegervEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVARIANTBOOLEANVEXTPROC __glewGetVariantBooleanvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVARIANTFLOATVEXTPROC __glewGetVariantFloatvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVARIANTINTEGERVEXTPROC __glewGetVariantIntegervEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVARIANTPOINTERVEXTPROC __glewGetVariantPointervEXT;
extern __attribute__ ((visibility("default"))) PFNGLINSERTCOMPONENTEXTPROC __glewInsertComponentEXT;
extern __attribute__ ((visibility("default"))) PFNGLISVARIANTENABLEDEXTPROC __glewIsVariantEnabledEXT;
extern __attribute__ ((visibility("default"))) PFNGLSETINVARIANTEXTPROC __glewSetInvariantEXT;
extern __attribute__ ((visibility("default"))) PFNGLSETLOCALCONSTANTEXTPROC __glewSetLocalConstantEXT;
extern __attribute__ ((visibility("default"))) PFNGLSHADEROP1EXTPROC __glewShaderOp1EXT;
extern __attribute__ ((visibility("default"))) PFNGLSHADEROP2EXTPROC __glewShaderOp2EXT;
extern __attribute__ ((visibility("default"))) PFNGLSHADEROP3EXTPROC __glewShaderOp3EXT;
extern __attribute__ ((visibility("default"))) PFNGLSWIZZLEEXTPROC __glewSwizzleEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTPOINTEREXTPROC __glewVariantPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTBVEXTPROC __glewVariantbvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTDVEXTPROC __glewVariantdvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTFVEXTPROC __glewVariantfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTIVEXTPROC __glewVariantivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTSVEXTPROC __glewVariantsvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTUBVEXTPROC __glewVariantubvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTUIVEXTPROC __glewVariantuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTUSVEXTPROC __glewVariantusvEXT;
extern __attribute__ ((visibility("default"))) PFNGLWRITEMASKEXTPROC __glewWriteMaskEXT;

extern __attribute__ ((visibility("default"))) PFNGLVERTEXWEIGHTPOINTEREXTPROC __glewVertexWeightPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXWEIGHTFEXTPROC __glewVertexWeightfEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXWEIGHTFVEXTPROC __glewVertexWeightfvEXT;

extern __attribute__ ((visibility("default"))) PFNGLACQUIREKEYEDMUTEXWIN32EXTPROC __glewAcquireKeyedMutexWin32EXT;
extern __attribute__ ((visibility("default"))) PFNGLRELEASEKEYEDMUTEXWIN32EXTPROC __glewReleaseKeyedMutexWin32EXT;

extern __attribute__ ((visibility("default"))) PFNGLWINDOWRECTANGLESEXTPROC __glewWindowRectanglesEXT;

extern __attribute__ ((visibility("default"))) PFNGLIMPORTSYNCEXTPROC __glewImportSyncEXT;

extern __attribute__ ((visibility("default"))) PFNGLFRAMETERMINATORGREMEDYPROC __glewFrameTerminatorGREMEDY;

extern __attribute__ ((visibility("default"))) PFNGLSTRINGMARKERGREMEDYPROC __glewStringMarkerGREMEDY;

extern __attribute__ ((visibility("default"))) PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC __glewGetImageTransformParameterfvHP;
extern __attribute__ ((visibility("default"))) PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC __glewGetImageTransformParameterivHP;
extern __attribute__ ((visibility("default"))) PFNGLIMAGETRANSFORMPARAMETERFHPPROC __glewImageTransformParameterfHP;
extern __attribute__ ((visibility("default"))) PFNGLIMAGETRANSFORMPARAMETERFVHPPROC __glewImageTransformParameterfvHP;
extern __attribute__ ((visibility("default"))) PFNGLIMAGETRANSFORMPARAMETERIHPPROC __glewImageTransformParameteriHP;
extern __attribute__ ((visibility("default"))) PFNGLIMAGETRANSFORMPARAMETERIVHPPROC __glewImageTransformParameterivHP;

extern __attribute__ ((visibility("default"))) PFNGLMULTIMODEDRAWARRAYSIBMPROC __glewMultiModeDrawArraysIBM;
extern __attribute__ ((visibility("default"))) PFNGLMULTIMODEDRAWELEMENTSIBMPROC __glewMultiModeDrawElementsIBM;

extern __attribute__ ((visibility("default"))) PFNGLCOLORPOINTERLISTIBMPROC __glewColorPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLEDGEFLAGPOINTERLISTIBMPROC __glewEdgeFlagPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDPOINTERLISTIBMPROC __glewFogCoordPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLINDEXPOINTERLISTIBMPROC __glewIndexPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLNORMALPOINTERLISTIBMPROC __glewNormalPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLORPOINTERLISTIBMPROC __glewSecondaryColorPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDPOINTERLISTIBMPROC __glewTexCoordPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXPOINTERLISTIBMPROC __glewVertexPointerListIBM;

extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREHANDLEIMGPROC __glewGetTextureHandleIMG;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTURESAMPLERHANDLEIMGPROC __glewGetTextureSamplerHandleIMG;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMHANDLEUI64IMGPROC __glewProgramUniformHandleui64IMG;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMHANDLEUI64VIMGPROC __glewProgramUniformHandleui64vIMG;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMHANDLEUI64IMGPROC __glewUniformHandleui64IMG;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMHANDLEUI64VIMGPROC __glewUniformHandleui64vIMG;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE2DDOWNSAMPLEIMGPROC __glewFramebufferTexture2DDownsampleIMG;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURELAYERDOWNSAMPLEIMGPROC __glewFramebufferTextureLayerDownsampleIMG;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE2DMULTISAMPLEIMGPROC __glewFramebufferTexture2DMultisampleIMG;
extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEIMGPROC __glewRenderbufferStorageMultisampleIMG;

extern __attribute__ ((visibility("default"))) PFNGLMAPTEXTURE2DINTELPROC __glewMapTexture2DINTEL;
extern __attribute__ ((visibility("default"))) PFNGLSYNCTEXTUREINTELPROC __glewSyncTextureINTEL;
extern __attribute__ ((visibility("default"))) PFNGLUNMAPTEXTURE2DINTELPROC __glewUnmapTexture2DINTEL;

extern __attribute__ ((visibility("default"))) PFNGLCOLORPOINTERVINTELPROC __glewColorPointervINTEL;
extern __attribute__ ((visibility("default"))) PFNGLNORMALPOINTERVINTELPROC __glewNormalPointervINTEL;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDPOINTERVINTELPROC __glewTexCoordPointervINTEL;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXPOINTERVINTELPROC __glewVertexPointervINTEL;

extern __attribute__ ((visibility("default"))) PFNGLBEGINPERFQUERYINTELPROC __glewBeginPerfQueryINTEL;
extern __attribute__ ((visibility("default"))) PFNGLCREATEPERFQUERYINTELPROC __glewCreatePerfQueryINTEL;
extern __attribute__ ((visibility("default"))) PFNGLDELETEPERFQUERYINTELPROC __glewDeletePerfQueryINTEL;
extern __attribute__ ((visibility("default"))) PFNGLENDPERFQUERYINTELPROC __glewEndPerfQueryINTEL;
extern __attribute__ ((visibility("default"))) PFNGLGETFIRSTPERFQUERYIDINTELPROC __glewGetFirstPerfQueryIdINTEL;
extern __attribute__ ((visibility("default"))) PFNGLGETNEXTPERFQUERYIDINTELPROC __glewGetNextPerfQueryIdINTEL;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFCOUNTERINFOINTELPROC __glewGetPerfCounterInfoINTEL;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFQUERYDATAINTELPROC __glewGetPerfQueryDataINTEL;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFQUERYIDBYNAMEINTELPROC __glewGetPerfQueryIdByNameINTEL;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFQUERYINFOINTELPROC __glewGetPerfQueryInfoINTEL;

extern __attribute__ ((visibility("default"))) PFNGLTEXSCISSORFUNCINTELPROC __glewTexScissorFuncINTEL;
extern __attribute__ ((visibility("default"))) PFNGLTEXSCISSORINTELPROC __glewTexScissorINTEL;

extern __attribute__ ((visibility("default"))) PFNGLBLENDBARRIERKHRPROC __glewBlendBarrierKHR;

extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGECALLBACKPROC __glewDebugMessageCallback;
extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGECONTROLPROC __glewDebugMessageControl;
extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGEINSERTPROC __glewDebugMessageInsert;
extern __attribute__ ((visibility("default"))) PFNGLGETDEBUGMESSAGELOGPROC __glewGetDebugMessageLog;
extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTLABELPROC __glewGetObjectLabel;
extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTPTRLABELPROC __glewGetObjectPtrLabel;
extern __attribute__ ((visibility("default"))) PFNGLOBJECTLABELPROC __glewObjectLabel;
extern __attribute__ ((visibility("default"))) PFNGLOBJECTPTRLABELPROC __glewObjectPtrLabel;
extern __attribute__ ((visibility("default"))) PFNGLPOPDEBUGGROUPPROC __glewPopDebugGroup;
extern __attribute__ ((visibility("default"))) PFNGLPUSHDEBUGGROUPPROC __glewPushDebugGroup;

extern __attribute__ ((visibility("default"))) PFNGLMAXSHADERCOMPILERTHREADSKHRPROC __glewMaxShaderCompilerThreadsKHR;

extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMFVPROC __glewGetnUniformfv;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMIVPROC __glewGetnUniformiv;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMUIVPROC __glewGetnUniformuiv;
extern __attribute__ ((visibility("default"))) PFNGLREADNPIXELSPROC __glewReadnPixels;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERREGIONENABLEDPROC __glewBufferRegionEnabled;
extern __attribute__ ((visibility("default"))) PFNGLDELETEBUFFERREGIONPROC __glewDeleteBufferRegion;
extern __attribute__ ((visibility("default"))) PFNGLDRAWBUFFERREGIONPROC __glewDrawBufferRegion;
extern __attribute__ ((visibility("default"))) PFNGLNEWBUFFERREGIONPROC __glewNewBufferRegion;
extern __attribute__ ((visibility("default"))) PFNGLREADBUFFERREGIONPROC __glewReadBufferRegion;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERPARAMETERIMESAPROC __glewFramebufferParameteriMESA;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAMEBUFFERPARAMETERIVMESAPROC __glewGetFramebufferParameterivMESA;

extern __attribute__ ((visibility("default"))) PFNGLRESIZEBUFFERSMESAPROC __glewResizeBuffersMESA;

extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2DMESAPROC __glewWindowPos2dMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2DVMESAPROC __glewWindowPos2dvMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2FMESAPROC __glewWindowPos2fMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2FVMESAPROC __glewWindowPos2fvMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2IMESAPROC __glewWindowPos2iMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2IVMESAPROC __glewWindowPos2ivMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2SMESAPROC __glewWindowPos2sMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2SVMESAPROC __glewWindowPos2svMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3DMESAPROC __glewWindowPos3dMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3DVMESAPROC __glewWindowPos3dvMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3FMESAPROC __glewWindowPos3fMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3FVMESAPROC __glewWindowPos3fvMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3IMESAPROC __glewWindowPos3iMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3IVMESAPROC __glewWindowPos3ivMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3SMESAPROC __glewWindowPos3sMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3SVMESAPROC __glewWindowPos3svMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4DMESAPROC __glewWindowPos4dMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4DVMESAPROC __glewWindowPos4dvMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4FMESAPROC __glewWindowPos4fMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4FVMESAPROC __glewWindowPos4fvMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4IMESAPROC __glewWindowPos4iMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4IVMESAPROC __glewWindowPos4ivMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4SMESAPROC __glewWindowPos4sMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4SVMESAPROC __glewWindowPos4svMESA;

extern __attribute__ ((visibility("default"))) PFNGLBEGINCONDITIONALRENDERNVXPROC __glewBeginConditionalRenderNVX;
extern __attribute__ ((visibility("default"))) PFNGLENDCONDITIONALRENDERNVXPROC __glewEndConditionalRenderNVX;

extern __attribute__ ((visibility("default"))) PFNGLASYNCCOPYBUFFERSUBDATANVXPROC __glewAsyncCopyBufferSubDataNVX;
extern __attribute__ ((visibility("default"))) PFNGLASYNCCOPYIMAGESUBDATANVXPROC __glewAsyncCopyImageSubDataNVX;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTSCISSORARRAYVNVXPROC __glewMulticastScissorArrayvNVX;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTVIEWPORTARRAYVNVXPROC __glewMulticastViewportArrayvNVX;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTVIEWPORTPOSITIONWSCALENVXPROC __glewMulticastViewportPositionWScaleNVX;
extern __attribute__ ((visibility("default"))) PFNGLUPLOADGPUMASKNVXPROC __glewUploadGpuMaskNVX;

extern __attribute__ ((visibility("default"))) PFNGLLGPUCOPYIMAGESUBDATANVXPROC __glewLGPUCopyImageSubDataNVX;
extern __attribute__ ((visibility("default"))) PFNGLLGPUINTERLOCKNVXPROC __glewLGPUInterlockNVX;
extern __attribute__ ((visibility("default"))) PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC __glewLGPUNamedBufferSubDataNVX;

extern __attribute__ ((visibility("default"))) PFNGLCLIENTWAITSEMAPHOREUI64NVXPROC __glewClientWaitSemaphoreui64NVX;
extern __attribute__ ((visibility("default"))) PFNGLSIGNALSEMAPHOREUI64NVXPROC __glewSignalSemaphoreui64NVX;
extern __attribute__ ((visibility("default"))) PFNGLWAITSEMAPHOREUI64NVXPROC __glewWaitSemaphoreui64NVX;

extern __attribute__ ((visibility("default"))) PFNGLSTEREOPARAMETERFNVPROC __glewStereoParameterfNV;
extern __attribute__ ((visibility("default"))) PFNGLSTEREOPARAMETERINVPROC __glewStereoParameteriNV;

extern __attribute__ ((visibility("default"))) PFNGLALPHATOCOVERAGEDITHERCONTROLNVPROC __glewAlphaToCoverageDitherControlNV;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC __glewMultiDrawArraysIndirectBindlessNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC __glewMultiDrawElementsIndirectBindlessNV;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC __glewMultiDrawArraysIndirectBindlessCountNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC __glewMultiDrawElementsIndirectBindlessCountNV;

extern __attribute__ ((visibility("default"))) PFNGLGETIMAGEHANDLENVPROC __glewGetImageHandleNV;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREHANDLENVPROC __glewGetTextureHandleNV;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTURESAMPLERHANDLENVPROC __glewGetTextureSamplerHandleNV;
extern __attribute__ ((visibility("default"))) PFNGLISIMAGEHANDLERESIDENTNVPROC __glewIsImageHandleResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLISTEXTUREHANDLERESIDENTNVPROC __glewIsTextureHandleResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC __glewMakeImageHandleNonResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKEIMAGEHANDLERESIDENTNVPROC __glewMakeImageHandleResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC __glewMakeTextureHandleNonResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKETEXTUREHANDLERESIDENTNVPROC __glewMakeTextureHandleResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC __glewProgramUniformHandleui64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC __glewProgramUniformHandleui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMHANDLEUI64NVPROC __glewUniformHandleui64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMHANDLEUI64VNVPROC __glewUniformHandleui64vNV;

extern __attribute__ ((visibility("default"))) PFNGLBLENDBARRIERNVPROC __glewBlendBarrierNV;
extern __attribute__ ((visibility("default"))) PFNGLBLENDPARAMETERINVPROC __glewBlendParameteriNV;

extern __attribute__ ((visibility("default"))) PFNGLVIEWPORTPOSITIONWSCALENVPROC __glewViewportPositionWScaleNV;

extern __attribute__ ((visibility("default"))) PFNGLCALLCOMMANDLISTNVPROC __glewCallCommandListNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMMANDLISTSEGMENTSNVPROC __glewCommandListSegmentsNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMPILECOMMANDLISTNVPROC __glewCompileCommandListNV;
extern __attribute__ ((visibility("default"))) PFNGLCREATECOMMANDLISTSNVPROC __glewCreateCommandListsNV;
extern __attribute__ ((visibility("default"))) PFNGLCREATESTATESNVPROC __glewCreateStatesNV;
extern __attribute__ ((visibility("default"))) PFNGLDELETECOMMANDLISTSNVPROC __glewDeleteCommandListsNV;
extern __attribute__ ((visibility("default"))) PFNGLDELETESTATESNVPROC __glewDeleteStatesNV;
extern __attribute__ ((visibility("default"))) PFNGLDRAWCOMMANDSADDRESSNVPROC __glewDrawCommandsAddressNV;
extern __attribute__ ((visibility("default"))) PFNGLDRAWCOMMANDSNVPROC __glewDrawCommandsNV;
extern __attribute__ ((visibility("default"))) PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC __glewDrawCommandsStatesAddressNV;
extern __attribute__ ((visibility("default"))) PFNGLDRAWCOMMANDSSTATESNVPROC __glewDrawCommandsStatesNV;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMMANDHEADERNVPROC __glewGetCommandHeaderNV;
extern __attribute__ ((visibility("default"))) PFNGLGETSTAGEINDEXNVPROC __glewGetStageIndexNV;
extern __attribute__ ((visibility("default"))) PFNGLISCOMMANDLISTNVPROC __glewIsCommandListNV;
extern __attribute__ ((visibility("default"))) PFNGLISSTATENVPROC __glewIsStateNV;
extern __attribute__ ((visibility("default"))) PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC __glewListDrawCommandsStatesClientNV;
extern __attribute__ ((visibility("default"))) PFNGLSTATECAPTURENVPROC __glewStateCaptureNV;

extern __attribute__ ((visibility("default"))) PFNGLBEGINCONDITIONALRENDERNVPROC __glewBeginConditionalRenderNV;
extern __attribute__ ((visibility("default"))) PFNGLENDCONDITIONALRENDERNVPROC __glewEndConditionalRenderNV;

extern __attribute__ ((visibility("default"))) PFNGLSUBPIXELPRECISIONBIASNVPROC __glewSubpixelPrecisionBiasNV;

extern __attribute__ ((visibility("default"))) PFNGLCONSERVATIVERASTERPARAMETERFNVPROC __glewConservativeRasterParameterfNV;

extern __attribute__ ((visibility("default"))) PFNGLCONSERVATIVERASTERPARAMETERINVPROC __glewConservativeRasterParameteriNV;

extern __attribute__ ((visibility("default"))) PFNGLCOPYBUFFERSUBDATANVPROC __glewCopyBufferSubDataNV;

extern __attribute__ ((visibility("default"))) PFNGLCOPYIMAGESUBDATANVPROC __glewCopyImageSubDataNV;

extern __attribute__ ((visibility("default"))) PFNGLCLEARDEPTHDNVPROC __glewClearDepthdNV;
extern __attribute__ ((visibility("default"))) PFNGLDEPTHBOUNDSDNVPROC __glewDepthBoundsdNV;
extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEDNVPROC __glewDepthRangedNV;

extern __attribute__ ((visibility("default"))) PFNGLDRAWBUFFERSNVPROC __glewDrawBuffersNV;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINSTANCEDNVPROC __glewDrawArraysInstancedNV;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDNVPROC __glewDrawElementsInstancedNV;

extern __attribute__ ((visibility("default"))) PFNGLDRAWTEXTURENVPROC __glewDrawTextureNV;

extern __attribute__ ((visibility("default"))) PFNGLDRAWVKIMAGENVPROC __glewDrawVkImageNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVKPROCADDRNVPROC __glewGetVkProcAddrNV;
extern __attribute__ ((visibility("default"))) PFNGLSIGNALVKFENCENVPROC __glewSignalVkFenceNV;
extern __attribute__ ((visibility("default"))) PFNGLSIGNALVKSEMAPHORENVPROC __glewSignalVkSemaphoreNV;
extern __attribute__ ((visibility("default"))) PFNGLWAITVKSEMAPHORENVPROC __glewWaitVkSemaphoreNV;

extern __attribute__ ((visibility("default"))) PFNGLEVALMAPSNVPROC __glewEvalMapsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETMAPATTRIBPARAMETERFVNVPROC __glewGetMapAttribParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETMAPATTRIBPARAMETERIVNVPROC __glewGetMapAttribParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETMAPCONTROLPOINTSNVPROC __glewGetMapControlPointsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETMAPPARAMETERFVNVPROC __glewGetMapParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETMAPPARAMETERIVNVPROC __glewGetMapParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLMAPCONTROLPOINTSNVPROC __glewMapControlPointsNV;
extern __attribute__ ((visibility("default"))) PFNGLMAPPARAMETERFVNVPROC __glewMapParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLMAPPARAMETERIVNVPROC __glewMapParameterivNV;

extern __attribute__ ((visibility("default"))) PFNGLGETMULTISAMPLEFVNVPROC __glewGetMultisamplefvNV;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLEMASKINDEXEDNVPROC __glewSampleMaskIndexedNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXRENDERBUFFERNVPROC __glewTexRenderbufferNV;

extern __attribute__ ((visibility("default"))) PFNGLDELETEFENCESNVPROC __glewDeleteFencesNV;
extern __attribute__ ((visibility("default"))) PFNGLFINISHFENCENVPROC __glewFinishFenceNV;
extern __attribute__ ((visibility("default"))) PFNGLGENFENCESNVPROC __glewGenFencesNV;
extern __attribute__ ((visibility("default"))) PFNGLGETFENCEIVNVPROC __glewGetFenceivNV;
extern __attribute__ ((visibility("default"))) PFNGLISFENCENVPROC __glewIsFenceNV;
extern __attribute__ ((visibility("default"))) PFNGLSETFENCENVPROC __glewSetFenceNV;
extern __attribute__ ((visibility("default"))) PFNGLTESTFENCENVPROC __glewTestFenceNV;

extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTCOVERAGECOLORNVPROC __glewFragmentCoverageColorNV;

extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC __glewGetProgramNamedParameterdvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC __glewGetProgramNamedParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMNAMEDPARAMETER4DNVPROC __glewProgramNamedParameter4dNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC __glewProgramNamedParameter4dvNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMNAMEDPARAMETER4FNVPROC __glewProgramNamedParameter4fNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC __glewProgramNamedParameter4fvNV;

extern __attribute__ ((visibility("default"))) PFNGLBLITFRAMEBUFFERNVPROC __glewBlitFramebufferNV;

extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEMULTISAMPLENVPROC __glewRenderbufferStorageMultisampleNV;

extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC __glewRenderbufferStorageMultisampleCoverageNV;

extern __attribute__ ((visibility("default"))) PFNGLPROGRAMVERTEXLIMITNVPROC __glewProgramVertexLimitNV;

extern __attribute__ ((visibility("default"))) PFNGLMULTICASTBARRIERNVPROC __glewMulticastBarrierNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTBLITFRAMEBUFFERNVPROC __glewMulticastBlitFramebufferNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTBUFFERSUBDATANVPROC __glewMulticastBufferSubDataNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC __glewMulticastCopyBufferSubDataNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTCOPYIMAGESUBDATANVPROC __glewMulticastCopyImageSubDataNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC __glewMulticastFramebufferSampleLocationsfvNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC __glewMulticastGetQueryObjecti64vNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTGETQUERYOBJECTIVNVPROC __glewMulticastGetQueryObjectivNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC __glewMulticastGetQueryObjectui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC __glewMulticastGetQueryObjectuivNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTWAITSYNCNVPROC __glewMulticastWaitSyncNV;
extern __attribute__ ((visibility("default"))) PFNGLRENDERGPUMASKNVPROC __glewRenderGpuMaskNV;

extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERI4INVPROC __glewProgramEnvParameterI4iNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERI4IVNVPROC __glewProgramEnvParameterI4ivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERI4UINVPROC __glewProgramEnvParameterI4uiNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERI4UIVNVPROC __glewProgramEnvParameterI4uivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERSI4IVNVPROC __glewProgramEnvParametersI4ivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC __glewProgramEnvParametersI4uivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERI4INVPROC __glewProgramLocalParameterI4iNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC __glewProgramLocalParameterI4ivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERI4UINVPROC __glewProgramLocalParameterI4uiNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC __glewProgramLocalParameterI4uivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC __glewProgramLocalParametersI4ivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC __glewProgramLocalParametersI4uivNV;

extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMI64VNVPROC __glewGetUniformi64vNV;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMUI64VNVPROC __glewGetUniformui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1I64NVPROC __glewProgramUniform1i64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1I64VNVPROC __glewProgramUniform1i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UI64NVPROC __glewProgramUniform1ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UI64VNVPROC __glewProgramUniform1ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2I64NVPROC __glewProgramUniform2i64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2I64VNVPROC __glewProgramUniform2i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UI64NVPROC __glewProgramUniform2ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UI64VNVPROC __glewProgramUniform2ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3I64NVPROC __glewProgramUniform3i64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3I64VNVPROC __glewProgramUniform3i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UI64NVPROC __glewProgramUniform3ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UI64VNVPROC __glewProgramUniform3ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4I64NVPROC __glewProgramUniform4i64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4I64VNVPROC __glewProgramUniform4i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UI64NVPROC __glewProgramUniform4ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UI64VNVPROC __glewProgramUniform4ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1I64NVPROC __glewUniform1i64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1I64VNVPROC __glewUniform1i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UI64NVPROC __glewUniform1ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UI64VNVPROC __glewUniform1ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2I64NVPROC __glewUniform2i64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2I64VNVPROC __glewUniform2i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UI64NVPROC __glewUniform2ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UI64VNVPROC __glewUniform2ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3I64NVPROC __glewUniform3i64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3I64VNVPROC __glewUniform3i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UI64NVPROC __glewUniform3ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UI64VNVPROC __glewUniform3ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4I64NVPROC __glewUniform4i64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4I64VNVPROC __glewUniform4i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UI64NVPROC __glewUniform4ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UI64VNVPROC __glewUniform4ui64vNV;

extern __attribute__ ((visibility("default"))) PFNGLCOLOR3HNVPROC __glewColor3hNV;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR3HVNVPROC __glewColor3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4HNVPROC __glewColor4hNV;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4HVNVPROC __glewColor4hvNV;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDHNVPROC __glewFogCoordhNV;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDHVNVPROC __glewFogCoordhvNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1HNVPROC __glewMultiTexCoord1hNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1HVNVPROC __glewMultiTexCoord1hvNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2HNVPROC __glewMultiTexCoord2hNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2HVNVPROC __glewMultiTexCoord2hvNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3HNVPROC __glewMultiTexCoord3hNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3HVNVPROC __glewMultiTexCoord3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4HNVPROC __glewMultiTexCoord4hNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4HVNVPROC __glewMultiTexCoord4hvNV;
extern __attribute__ ((visibility("default"))) PFNGLNORMAL3HNVPROC __glewNormal3hNV;
extern __attribute__ ((visibility("default"))) PFNGLNORMAL3HVNVPROC __glewNormal3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3HNVPROC __glewSecondaryColor3hNV;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3HVNVPROC __glewSecondaryColor3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD1HNVPROC __glewTexCoord1hNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD1HVNVPROC __glewTexCoord1hvNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2HNVPROC __glewTexCoord2hNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2HVNVPROC __glewTexCoord2hvNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD3HNVPROC __glewTexCoord3hNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD3HVNVPROC __glewTexCoord3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD4HNVPROC __glewTexCoord4hNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD4HVNVPROC __glewTexCoord4hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEX2HNVPROC __glewVertex2hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEX2HVNVPROC __glewVertex2hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEX3HNVPROC __glewVertex3hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEX3HVNVPROC __glewVertex3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEX4HNVPROC __glewVertex4hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEX4HVNVPROC __glewVertex4hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1HNVPROC __glewVertexAttrib1hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1HVNVPROC __glewVertexAttrib1hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2HNVPROC __glewVertexAttrib2hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2HVNVPROC __glewVertexAttrib2hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3HNVPROC __glewVertexAttrib3hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3HVNVPROC __glewVertexAttrib3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4HNVPROC __glewVertexAttrib4hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4HVNVPROC __glewVertexAttrib4hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS1HVNVPROC __glewVertexAttribs1hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS2HVNVPROC __glewVertexAttribs2hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS3HVNVPROC __glewVertexAttribs3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS4HVNVPROC __glewVertexAttribs4hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXWEIGHTHNVPROC __glewVertexWeighthNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXWEIGHTHVNVPROC __glewVertexWeighthvNV;

extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBDIVISORNVPROC __glewVertexAttribDivisorNV;

extern __attribute__ ((visibility("default"))) PFNGLGETINTERNALFORMATSAMPLEIVNVPROC __glewGetInternalformatSampleivNV;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERATTACHMEMORYNVPROC __glewBufferAttachMemoryNV;
extern __attribute__ ((visibility("default"))) PFNGLGETMEMORYOBJECTDETACHEDRESOURCESUIVNVPROC __glewGetMemoryObjectDetachedResourcesuivNV;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERATTACHMEMORYNVPROC __glewNamedBufferAttachMemoryNV;
extern __attribute__ ((visibility("default"))) PFNGLRESETMEMORYOBJECTPARAMETERNVPROC __glewResetMemoryObjectParameterNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXATTACHMEMORYNVPROC __glewTexAttachMemoryNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREATTACHMEMORYNVPROC __glewTextureAttachMemoryNV;

extern __attribute__ ((visibility("default"))) PFNGLDRAWMESHTASKSINDIRECTNVPROC __glewDrawMeshTasksIndirectNV;
extern __attribute__ ((visibility("default"))) PFNGLDRAWMESHTASKSNVPROC __glewDrawMeshTasksNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWMESHTASKSINDIRECTCOUNTNVPROC __glewMultiDrawMeshTasksIndirectCountNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWMESHTASKSINDIRECTNVPROC __glewMultiDrawMeshTasksIndirectNV;

extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2X3FVNVPROC __glewUniformMatrix2x3fvNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2X4FVNVPROC __glewUniformMatrix2x4fvNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3X2FVNVPROC __glewUniformMatrix3x2fvNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3X4FVNVPROC __glewUniformMatrix3x4fvNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4X2FVNVPROC __glewUniformMatrix4x2fvNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4X3FVNVPROC __glewUniformMatrix4x3fvNV;

extern __attribute__ ((visibility("default"))) PFNGLBEGINOCCLUSIONQUERYNVPROC __glewBeginOcclusionQueryNV;
extern __attribute__ ((visibility("default"))) PFNGLDELETEOCCLUSIONQUERIESNVPROC __glewDeleteOcclusionQueriesNV;
extern __attribute__ ((visibility("default"))) PFNGLENDOCCLUSIONQUERYNVPROC __glewEndOcclusionQueryNV;
extern __attribute__ ((visibility("default"))) PFNGLGENOCCLUSIONQUERIESNVPROC __glewGenOcclusionQueriesNV;
extern __attribute__ ((visibility("default"))) PFNGLGETOCCLUSIONQUERYIVNVPROC __glewGetOcclusionQueryivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETOCCLUSIONQUERYUIVNVPROC __glewGetOcclusionQueryuivNV;
extern __attribute__ ((visibility("default"))) PFNGLISOCCLUSIONQUERYNVPROC __glewIsOcclusionQueryNV;

extern __attribute__ ((visibility("default"))) PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC __glewProgramBufferParametersIivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC __glewProgramBufferParametersIuivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC __glewProgramBufferParametersfvNV;

extern __attribute__ ((visibility("default"))) PFNGLCOPYPATHNVPROC __glewCopyPathNV;
extern __attribute__ ((visibility("default"))) PFNGLCOVERFILLPATHINSTANCEDNVPROC __glewCoverFillPathInstancedNV;
extern __attribute__ ((visibility("default"))) PFNGLCOVERFILLPATHNVPROC __glewCoverFillPathNV;
extern __attribute__ ((visibility("default"))) PFNGLCOVERSTROKEPATHINSTANCEDNVPROC __glewCoverStrokePathInstancedNV;
extern __attribute__ ((visibility("default"))) PFNGLCOVERSTROKEPATHNVPROC __glewCoverStrokePathNV;
extern __attribute__ ((visibility("default"))) PFNGLDELETEPATHSNVPROC __glewDeletePathsNV;
extern __attribute__ ((visibility("default"))) PFNGLGENPATHSNVPROC __glewGenPathsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHCOLORGENFVNVPROC __glewGetPathColorGenfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHCOLORGENIVNVPROC __glewGetPathColorGenivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHCOMMANDSNVPROC __glewGetPathCommandsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHCOORDSNVPROC __glewGetPathCoordsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHDASHARRAYNVPROC __glewGetPathDashArrayNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHLENGTHNVPROC __glewGetPathLengthNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHMETRICRANGENVPROC __glewGetPathMetricRangeNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHMETRICSNVPROC __glewGetPathMetricsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHPARAMETERFVNVPROC __glewGetPathParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHPARAMETERIVNVPROC __glewGetPathParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHSPACINGNVPROC __glewGetPathSpacingNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHTEXGENFVNVPROC __glewGetPathTexGenfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHTEXGENIVNVPROC __glewGetPathTexGenivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMRESOURCEFVNVPROC __glewGetProgramResourcefvNV;
extern __attribute__ ((visibility("default"))) PFNGLINTERPOLATEPATHSNVPROC __glewInterpolatePathsNV;
extern __attribute__ ((visibility("default"))) PFNGLISPATHNVPROC __glewIsPathNV;
extern __attribute__ ((visibility("default"))) PFNGLISPOINTINFILLPATHNVPROC __glewIsPointInFillPathNV;
extern __attribute__ ((visibility("default"))) PFNGLISPOINTINSTROKEPATHNVPROC __glewIsPointInStrokePathNV;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOAD3X2FNVPROC __glewMatrixLoad3x2fNV;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOAD3X3FNVPROC __glewMatrixLoad3x3fNV;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC __glewMatrixLoadTranspose3x3fNV;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXMULT3X2FNVPROC __glewMatrixMult3x2fNV;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXMULT3X3FNVPROC __glewMatrixMult3x3fNV;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC __glewMatrixMultTranspose3x3fNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHCOLORGENNVPROC __glewPathColorGenNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHCOMMANDSNVPROC __glewPathCommandsNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHCOORDSNVPROC __glewPathCoordsNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHCOVERDEPTHFUNCNVPROC __glewPathCoverDepthFuncNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHDASHARRAYNVPROC __glewPathDashArrayNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHFOGGENNVPROC __glewPathFogGenNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHGLYPHINDEXARRAYNVPROC __glewPathGlyphIndexArrayNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHGLYPHINDEXRANGENVPROC __glewPathGlyphIndexRangeNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHGLYPHRANGENVPROC __glewPathGlyphRangeNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHGLYPHSNVPROC __glewPathGlyphsNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC __glewPathMemoryGlyphIndexArrayNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHPARAMETERFNVPROC __glewPathParameterfNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHPARAMETERFVNVPROC __glewPathParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHPARAMETERINVPROC __glewPathParameteriNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHPARAMETERIVNVPROC __glewPathParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHSTENCILDEPTHOFFSETNVPROC __glewPathStencilDepthOffsetNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHSTENCILFUNCNVPROC __glewPathStencilFuncNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHSTRINGNVPROC __glewPathStringNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHSUBCOMMANDSNVPROC __glewPathSubCommandsNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHSUBCOORDSNVPROC __glewPathSubCoordsNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHTEXGENNVPROC __glewPathTexGenNV;
extern __attribute__ ((visibility("default"))) PFNGLPOINTALONGPATHNVPROC __glewPointAlongPathNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC __glewProgramPathFragmentInputGenNV;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILFILLPATHINSTANCEDNVPROC __glewStencilFillPathInstancedNV;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILFILLPATHNVPROC __glewStencilFillPathNV;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC __glewStencilStrokePathInstancedNV;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILSTROKEPATHNVPROC __glewStencilStrokePathNV;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC __glewStencilThenCoverFillPathInstancedNV;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILTHENCOVERFILLPATHNVPROC __glewStencilThenCoverFillPathNV;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC __glewStencilThenCoverStrokePathInstancedNV;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC __glewStencilThenCoverStrokePathNV;
extern __attribute__ ((visibility("default"))) PFNGLTRANSFORMPATHNVPROC __glewTransformPathNV;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTPATHSNVPROC __glewWeightPathsNV;

extern __attribute__ ((visibility("default"))) PFNGLFLUSHPIXELDATARANGENVPROC __glewFlushPixelDataRangeNV;
extern __attribute__ ((visibility("default"))) PFNGLPIXELDATARANGENVPROC __glewPixelDataRangeNV;

extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERINVPROC __glewPointParameteriNV;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERIVNVPROC __glewPointParameterivNV;

extern __attribute__ ((visibility("default"))) PFNGLPOLYGONMODENVPROC __glewPolygonModeNV;

extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOI64VNVPROC __glewGetVideoi64vNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOIVNVPROC __glewGetVideoivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOUI64VNVPROC __glewGetVideoui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOUIVNVPROC __glewGetVideouivNV;
extern __attribute__ ((visibility("default"))) PFNGLPRESENTFRAMEDUALFILLNVPROC __glewPresentFrameDualFillNV;
extern __attribute__ ((visibility("default"))) PFNGLPRESENTFRAMEKEYEDNVPROC __glewPresentFrameKeyedNV;

extern __attribute__ ((visibility("default"))) PFNGLPRIMITIVERESTARTINDEXNVPROC __glewPrimitiveRestartIndexNV;
extern __attribute__ ((visibility("default"))) PFNGLPRIMITIVERESTARTNVPROC __glewPrimitiveRestartNV;

extern __attribute__ ((visibility("default"))) PFNGLREADBUFFERNVPROC __glewReadBufferNV;

extern __attribute__ ((visibility("default"))) PFNGLCOMBINERINPUTNVPROC __glewCombinerInputNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMBINEROUTPUTNVPROC __glewCombinerOutputNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMBINERPARAMETERFNVPROC __glewCombinerParameterfNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMBINERPARAMETERFVNVPROC __glewCombinerParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMBINERPARAMETERINVPROC __glewCombinerParameteriNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMBINERPARAMETERIVNVPROC __glewCombinerParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLFINALCOMBINERINPUTNVPROC __glewFinalCombinerInputNV;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC __glewGetCombinerInputParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC __glewGetCombinerInputParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC __glewGetCombinerOutputParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC __glewGetCombinerOutputParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC __glewGetFinalCombinerInputParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC __glewGetFinalCombinerInputParameterivNV;

extern __attribute__ ((visibility("default"))) PFNGLCOMBINERSTAGEPARAMETERFVNVPROC __glewCombinerStageParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC __glewGetCombinerStageParameterfvNV;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC __glewFramebufferSampleLocationsfvNV;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC __glewNamedFramebufferSampleLocationsfvNV;
extern __attribute__ ((visibility("default"))) PFNGLRESOLVEDEPTHVALUESNVPROC __glewResolveDepthValuesNV;

extern __attribute__ ((visibility("default"))) PFNGLSCISSOREXCLUSIVEARRAYVNVPROC __glewScissorExclusiveArrayvNV;
extern __attribute__ ((visibility("default"))) PFNGLSCISSOREXCLUSIVENVPROC __glewScissorExclusiveNV;

extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERPARAMETERUI64VNVPROC __glewGetBufferParameterui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGERUI64VNVPROC __glewGetIntegerui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC __glewGetNamedBufferParameterui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLISBUFFERRESIDENTNVPROC __glewIsBufferResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLISNAMEDBUFFERRESIDENTNVPROC __glewIsNamedBufferResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKEBUFFERNONRESIDENTNVPROC __glewMakeBufferNonResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKEBUFFERRESIDENTNVPROC __glewMakeBufferResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC __glewMakeNamedBufferNonResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKENAMEDBUFFERRESIDENTNVPROC __glewMakeNamedBufferResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMUI64NVPROC __glewProgramUniformui64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMUI64VNVPROC __glewProgramUniformui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMUI64NVPROC __glewUniformui64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMUI64VNVPROC __glewUniformui64vNV;

extern __attribute__ ((visibility("default"))) PFNGLBINDSHADINGRATEIMAGENVPROC __glewBindShadingRateImageNV;
extern __attribute__ ((visibility("default"))) PFNGLGETSHADINGRATEIMAGEPALETTENVPROC __glewGetShadingRateImagePaletteNV;
extern __attribute__ ((visibility("default"))) PFNGLGETSHADINGRATESAMPLELOCATIONIVNVPROC __glewGetShadingRateSampleLocationivNV;
extern __attribute__ ((visibility("default"))) PFNGLSHADINGRATEIMAGEBARRIERNVPROC __glewShadingRateImageBarrierNV;
extern __attribute__ ((visibility("default"))) PFNGLSHADINGRATEIMAGEPALETTENVPROC __glewShadingRateImagePaletteNV;
extern __attribute__ ((visibility("default"))) PFNGLSHADINGRATESAMPLEORDERCUSTOMNVPROC __glewShadingRateSampleOrderCustomNV;

extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE3DNVPROC __glewCompressedTexImage3DNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE3DNVPROC __glewCompressedTexSubImage3DNV;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXSUBIMAGE3DNVPROC __glewCopyTexSubImage3DNV;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURELAYERNVPROC __glewFramebufferTextureLayerNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE3DNVPROC __glewTexImage3DNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXSUBIMAGE3DNVPROC __glewTexSubImage3DNV;

extern __attribute__ ((visibility("default"))) PFNGLTEXTUREBARRIERNVPROC __glewTextureBarrierNV;

extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC __glewTexImage2DMultisampleCoverageNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC __glewTexImage3DMultisampleCoverageNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC __glewTextureImage2DMultisampleCoverageNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC __glewTextureImage2DMultisampleNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC __glewTextureImage3DMultisampleCoverageNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC __glewTextureImage3DMultisampleNV;

extern __attribute__ ((visibility("default"))) PFNGLACTIVEVARYINGNVPROC __glewActiveVaryingNV;
extern __attribute__ ((visibility("default"))) PFNGLBEGINTRANSFORMFEEDBACKNVPROC __glewBeginTransformFeedbackNV;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERBASENVPROC __glewBindBufferBaseNV;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFEROFFSETNVPROC __glewBindBufferOffsetNV;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERRANGENVPROC __glewBindBufferRangeNV;
extern __attribute__ ((visibility("default"))) PFNGLENDTRANSFORMFEEDBACKNVPROC __glewEndTransformFeedbackNV;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEVARYINGNVPROC __glewGetActiveVaryingNV;
extern __attribute__ ((visibility("default"))) PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC __glewGetTransformFeedbackVaryingNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVARYINGLOCATIONNVPROC __glewGetVaryingLocationNV;
extern __attribute__ ((visibility("default"))) PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC __glewTransformFeedbackAttribsNV;
extern __attribute__ ((visibility("default"))) PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC __glewTransformFeedbackVaryingsNV;

extern __attribute__ ((visibility("default"))) PFNGLBINDTRANSFORMFEEDBACKNVPROC __glewBindTransformFeedbackNV;
extern __attribute__ ((visibility("default"))) PFNGLDELETETRANSFORMFEEDBACKSNVPROC __glewDeleteTransformFeedbacksNV;
extern __attribute__ ((visibility("default"))) PFNGLDRAWTRANSFORMFEEDBACKNVPROC __glewDrawTransformFeedbackNV;
extern __attribute__ ((visibility("default"))) PFNGLGENTRANSFORMFEEDBACKSNVPROC __glewGenTransformFeedbacksNV;
extern __attribute__ ((visibility("default"))) PFNGLISTRANSFORMFEEDBACKNVPROC __glewIsTransformFeedbackNV;
extern __attribute__ ((visibility("default"))) PFNGLPAUSETRANSFORMFEEDBACKNVPROC __glewPauseTransformFeedbackNV;
extern __attribute__ ((visibility("default"))) PFNGLRESUMETRANSFORMFEEDBACKNVPROC __glewResumeTransformFeedbackNV;

extern __attribute__ ((visibility("default"))) PFNGLVDPAUFININVPROC __glewVDPAUFiniNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUGETSURFACEIVNVPROC __glewVDPAUGetSurfaceivNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUINITNVPROC __glewVDPAUInitNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUISSURFACENVPROC __glewVDPAUIsSurfaceNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUMAPSURFACESNVPROC __glewVDPAUMapSurfacesNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC __glewVDPAURegisterOutputSurfaceNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUREGISTERVIDEOSURFACENVPROC __glewVDPAURegisterVideoSurfaceNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUSURFACEACCESSNVPROC __glewVDPAUSurfaceAccessNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUUNMAPSURFACESNVPROC __glewVDPAUUnmapSurfacesNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUUNREGISTERSURFACENVPROC __glewVDPAUUnregisterSurfaceNV;

extern __attribute__ ((visibility("default"))) PFNGLVDPAUREGISTERVIDEOSURFACEWITHPICTURESTRUCTURENVPROC __glewVDPAURegisterVideoSurfaceWithPictureStructureNV;

extern __attribute__ ((visibility("default"))) PFNGLFLUSHVERTEXARRAYRANGENVPROC __glewFlushVertexArrayRangeNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYRANGENVPROC __glewVertexArrayRangeNV;

extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBLI64VNVPROC __glewGetVertexAttribLi64vNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBLUI64VNVPROC __glewGetVertexAttribLui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1I64NVPROC __glewVertexAttribL1i64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1I64VNVPROC __glewVertexAttribL1i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1UI64NVPROC __glewVertexAttribL1ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1UI64VNVPROC __glewVertexAttribL1ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2I64NVPROC __glewVertexAttribL2i64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2I64VNVPROC __glewVertexAttribL2i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2UI64NVPROC __glewVertexAttribL2ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2UI64VNVPROC __glewVertexAttribL2ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3I64NVPROC __glewVertexAttribL3i64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3I64VNVPROC __glewVertexAttribL3i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3UI64NVPROC __glewVertexAttribL3ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3UI64VNVPROC __glewVertexAttribL3ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4I64NVPROC __glewVertexAttribL4i64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4I64VNVPROC __glewVertexAttribL4i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4UI64NVPROC __glewVertexAttribL4ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4UI64VNVPROC __glewVertexAttribL4ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBLFORMATNVPROC __glewVertexAttribLFormatNV;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERADDRESSRANGENVPROC __glewBufferAddressRangeNV;
extern __attribute__ ((visibility("default"))) PFNGLCOLORFORMATNVPROC __glewColorFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLEDGEFLAGFORMATNVPROC __glewEdgeFlagFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDFORMATNVPROC __glewFogCoordFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGERUI64I_VNVPROC __glewGetIntegerui64i_vNV;
extern __attribute__ ((visibility("default"))) PFNGLINDEXFORMATNVPROC __glewIndexFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLNORMALFORMATNVPROC __glewNormalFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLORFORMATNVPROC __glewSecondaryColorFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDFORMATNVPROC __glewTexCoordFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBFORMATNVPROC __glewVertexAttribFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBIFORMATNVPROC __glewVertexAttribIFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXFORMATNVPROC __glewVertexFormatNV;

extern __attribute__ ((visibility("default"))) PFNGLAREPROGRAMSRESIDENTNVPROC __glewAreProgramsResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLBINDPROGRAMNVPROC __glewBindProgramNV;
extern __attribute__ ((visibility("default"))) PFNGLDELETEPROGRAMSNVPROC __glewDeleteProgramsNV;
extern __attribute__ ((visibility("default"))) PFNGLEXECUTEPROGRAMNVPROC __glewExecuteProgramNV;
extern __attribute__ ((visibility("default"))) PFNGLGENPROGRAMSNVPROC __glewGenProgramsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMPARAMETERDVNVPROC __glewGetProgramParameterdvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMPARAMETERFVNVPROC __glewGetProgramParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMSTRINGNVPROC __glewGetProgramStringNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMIVNVPROC __glewGetProgramivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETTRACKMATRIXIVNVPROC __glewGetTrackMatrixivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBPOINTERVNVPROC __glewGetVertexAttribPointervNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBDVNVPROC __glewGetVertexAttribdvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBFVNVPROC __glewGetVertexAttribfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIVNVPROC __glewGetVertexAttribivNV;
extern __attribute__ ((visibility("default"))) PFNGLISPROGRAMNVPROC __glewIsProgramNV;
extern __attribute__ ((visibility("default"))) PFNGLLOADPROGRAMNVPROC __glewLoadProgramNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETER4DNVPROC __glewProgramParameter4dNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETER4DVNVPROC __glewProgramParameter4dvNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETER4FNVPROC __glewProgramParameter4fNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETER4FVNVPROC __glewProgramParameter4fvNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETERS4DVNVPROC __glewProgramParameters4dvNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETERS4FVNVPROC __glewProgramParameters4fvNV;
extern __attribute__ ((visibility("default"))) PFNGLREQUESTRESIDENTPROGRAMSNVPROC __glewRequestResidentProgramsNV;
extern __attribute__ ((visibility("default"))) PFNGLTRACKMATRIXNVPROC __glewTrackMatrixNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1DNVPROC __glewVertexAttrib1dNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1DVNVPROC __glewVertexAttrib1dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1FNVPROC __glewVertexAttrib1fNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1FVNVPROC __glewVertexAttrib1fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1SNVPROC __glewVertexAttrib1sNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1SVNVPROC __glewVertexAttrib1svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2DNVPROC __glewVertexAttrib2dNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2DVNVPROC __glewVertexAttrib2dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2FNVPROC __glewVertexAttrib2fNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2FVNVPROC __glewVertexAttrib2fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2SNVPROC __glewVertexAttrib2sNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2SVNVPROC __glewVertexAttrib2svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3DNVPROC __glewVertexAttrib3dNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3DVNVPROC __glewVertexAttrib3dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3FNVPROC __glewVertexAttrib3fNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3FVNVPROC __glewVertexAttrib3fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3SNVPROC __glewVertexAttrib3sNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3SVNVPROC __glewVertexAttrib3svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4DNVPROC __glewVertexAttrib4dNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4DVNVPROC __glewVertexAttrib4dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4FNVPROC __glewVertexAttrib4fNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4FVNVPROC __glewVertexAttrib4fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4SNVPROC __glewVertexAttrib4sNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4SVNVPROC __glewVertexAttrib4svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4UBNVPROC __glewVertexAttrib4ubNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4UBVNVPROC __glewVertexAttrib4ubvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBPOINTERNVPROC __glewVertexAttribPointerNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS1DVNVPROC __glewVertexAttribs1dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS1FVNVPROC __glewVertexAttribs1fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS1SVNVPROC __glewVertexAttribs1svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS2DVNVPROC __glewVertexAttribs2dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS2FVNVPROC __glewVertexAttribs2fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS2SVNVPROC __glewVertexAttribs2svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS3DVNVPROC __glewVertexAttribs3dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS3FVNVPROC __glewVertexAttribs3fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS3SVNVPROC __glewVertexAttribs3svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS4DVNVPROC __glewVertexAttribs4dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS4FVNVPROC __glewVertexAttribs4fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS4SVNVPROC __glewVertexAttribs4svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS4UBVNVPROC __glewVertexAttribs4ubvNV;

extern __attribute__ ((visibility("default"))) PFNGLBEGINVIDEOCAPTURENVPROC __glewBeginVideoCaptureNV;
extern __attribute__ ((visibility("default"))) PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC __glewBindVideoCaptureStreamBufferNV;
extern __attribute__ ((visibility("default"))) PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC __glewBindVideoCaptureStreamTextureNV;
extern __attribute__ ((visibility("default"))) PFNGLENDVIDEOCAPTURENVPROC __glewEndVideoCaptureNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOCAPTURESTREAMDVNVPROC __glewGetVideoCaptureStreamdvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOCAPTURESTREAMFVNVPROC __glewGetVideoCaptureStreamfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOCAPTURESTREAMIVNVPROC __glewGetVideoCaptureStreamivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOCAPTUREIVNVPROC __glewGetVideoCaptureivNV;
extern __attribute__ ((visibility("default"))) PFNGLVIDEOCAPTURENVPROC __glewVideoCaptureNV;
extern __attribute__ ((visibility("default"))) PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC __glewVideoCaptureStreamParameterdvNV;
extern __attribute__ ((visibility("default"))) PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC __glewVideoCaptureStreamParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC __glewVideoCaptureStreamParameterivNV;

extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEARRAYFVNVPROC __glewDepthRangeArrayfvNV;
extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEINDEXEDFNVPROC __glewDepthRangeIndexedfNV;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEINVPROC __glewDisableiNV;
extern __attribute__ ((visibility("default"))) PFNGLENABLEINVPROC __glewEnableiNV;
extern __attribute__ ((visibility("default"))) PFNGLGETFLOATI_VNVPROC __glewGetFloati_vNV;
extern __attribute__ ((visibility("default"))) PFNGLISENABLEDINVPROC __glewIsEnablediNV;
extern __attribute__ ((visibility("default"))) PFNGLSCISSORARRAYVNVPROC __glewScissorArrayvNV;
extern __attribute__ ((visibility("default"))) PFNGLSCISSORINDEXEDNVPROC __glewScissorIndexedNV;
extern __attribute__ ((visibility("default"))) PFNGLSCISSORINDEXEDVNVPROC __glewScissorIndexedvNV;
extern __attribute__ ((visibility("default"))) PFNGLVIEWPORTARRAYVNVPROC __glewViewportArrayvNV;
extern __attribute__ ((visibility("default"))) PFNGLVIEWPORTINDEXEDFNVPROC __glewViewportIndexedfNV;
extern __attribute__ ((visibility("default"))) PFNGLVIEWPORTINDEXEDFVNVPROC __glewViewportIndexedfvNV;

extern __attribute__ ((visibility("default"))) PFNGLVIEWPORTSWIZZLENVPROC __glewViewportSwizzleNV;

extern __attribute__ ((visibility("default"))) PFNGLEGLIMAGETARGETRENDERBUFFERSTORAGEOESPROC __glewEGLImageTargetRenderbufferStorageOES;
extern __attribute__ ((visibility("default"))) PFNGLEGLIMAGETARGETTEXTURE2DOESPROC __glewEGLImageTargetTexture2DOES;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEOESPROC __glewBlendEquationSeparateOES;

extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEOESPROC __glewBlendFuncSeparateOES;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONOESPROC __glewBlendEquationOES;

extern __attribute__ ((visibility("default"))) PFNGLCOPYIMAGESUBDATAOESPROC __glewCopyImageSubDataOES;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEIOESPROC __glewBlendEquationSeparateiOES;
extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONIOESPROC __glewBlendEquationiOES;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEIOESPROC __glewBlendFuncSeparateiOES;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCIOESPROC __glewBlendFunciOES;
extern __attribute__ ((visibility("default"))) PFNGLCOLORMASKIOESPROC __glewColorMaskiOES;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEIOESPROC __glewDisableiOES;
extern __attribute__ ((visibility("default"))) PFNGLENABLEIOESPROC __glewEnableiOES;
extern __attribute__ ((visibility("default"))) PFNGLISENABLEDIOESPROC __glewIsEnablediOES;

extern __attribute__ ((visibility("default"))) PFNGLBINDFRAMEBUFFEROESPROC __glewBindFramebufferOES;
extern __attribute__ ((visibility("default"))) PFNGLBINDRENDERBUFFEROESPROC __glewBindRenderbufferOES;
extern __attribute__ ((visibility("default"))) PFNGLCHECKFRAMEBUFFERSTATUSOESPROC __glewCheckFramebufferStatusOES;
extern __attribute__ ((visibility("default"))) PFNGLDELETEFRAMEBUFFERSOESPROC __glewDeleteFramebuffersOES;
extern __attribute__ ((visibility("default"))) PFNGLDELETERENDERBUFFERSOESPROC __glewDeleteRenderbuffersOES;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERRENDERBUFFEROESPROC __glewFramebufferRenderbufferOES;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE2DOESPROC __glewFramebufferTexture2DOES;
extern __attribute__ ((visibility("default"))) PFNGLGENFRAMEBUFFERSOESPROC __glewGenFramebuffersOES;
extern __attribute__ ((visibility("default"))) PFNGLGENRENDERBUFFERSOESPROC __glewGenRenderbuffersOES;
extern __attribute__ ((visibility("default"))) PFNGLGENERATEMIPMAPOESPROC __glewGenerateMipmapOES;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVOESPROC __glewGetFramebufferAttachmentParameterivOES;
extern __attribute__ ((visibility("default"))) PFNGLGETRENDERBUFFERPARAMETERIVOESPROC __glewGetRenderbufferParameterivOES;
extern __attribute__ ((visibility("default"))) PFNGLISFRAMEBUFFEROESPROC __glewIsFramebufferOES;
extern __attribute__ ((visibility("default"))) PFNGLISRENDERBUFFEROESPROC __glewIsRenderbufferOES;
extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEOESPROC __glewRenderbufferStorageOES;

extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMBINARYOESPROC __glewGetProgramBinaryOES;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMBINARYOESPROC __glewProgramBinaryOES;

extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERPOINTERVOESPROC __glewGetBufferPointervOES;
extern __attribute__ ((visibility("default"))) PFNGLMAPBUFFEROESPROC __glewMapBufferOES;
extern __attribute__ ((visibility("default"))) PFNGLUNMAPBUFFEROESPROC __glewUnmapBufferOES;

extern __attribute__ ((visibility("default"))) PFNGLCURRENTPALETTEMATRIXOESPROC __glewCurrentPaletteMatrixOES;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXINDEXPOINTEROESPROC __glewMatrixIndexPointerOES;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTPOINTEROESPROC __glewWeightPointerOES;

extern __attribute__ ((visibility("default"))) PFNGLMINSAMPLESHADINGOESPROC __glewMinSampleShadingOES;

extern __attribute__ ((visibility("default"))) PFNGLCLEARDEPTHFOESPROC __glewClearDepthfOES;
extern __attribute__ ((visibility("default"))) PFNGLCLIPPLANEFOESPROC __glewClipPlanefOES;
extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEFOESPROC __glewDepthRangefOES;
extern __attribute__ ((visibility("default"))) PFNGLFRUSTUMFOESPROC __glewFrustumfOES;
extern __attribute__ ((visibility("default"))) PFNGLGETCLIPPLANEFOESPROC __glewGetClipPlanefOES;
extern __attribute__ ((visibility("default"))) PFNGLORTHOFOESPROC __glewOrthofOES;

extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE3DOESPROC __glewCompressedTexImage3DOES;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE3DOESPROC __glewCompressedTexSubImage3DOES;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXSUBIMAGE3DOESPROC __glewCopyTexSubImage3DOES;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE3DOESPROC __glewFramebufferTexture3DOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE3DOESPROC __glewTexImage3DOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXSUBIMAGE3DOESPROC __glewTexSubImage3DOES;

extern __attribute__ ((visibility("default"))) PFNGLGETSAMPLERPARAMETERIIVOESPROC __glewGetSamplerParameterIivOES;
extern __attribute__ ((visibility("default"))) PFNGLGETSAMPLERPARAMETERIUIVOESPROC __glewGetSamplerParameterIuivOES;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERIIVOESPROC __glewGetTexParameterIivOES;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERIUIVOESPROC __glewGetTexParameterIuivOES;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERIIVOESPROC __glewSamplerParameterIivOES;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERIUIVOESPROC __glewSamplerParameterIuivOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERIIVOESPROC __glewTexParameterIivOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERIUIVOESPROC __glewTexParameterIuivOES;

extern __attribute__ ((visibility("default"))) PFNGLTEXBUFFEROESPROC __glewTexBufferOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXBUFFERRANGEOESPROC __glewTexBufferRangeOES;

extern __attribute__ ((visibility("default"))) PFNGLGETTEXGENFVOESPROC __glewGetTexGenfvOES;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXGENIVOESPROC __glewGetTexGenivOES;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXGENXVOESPROC __glewGetTexGenxvOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXGENFOESPROC __glewTexGenfOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXGENFVOESPROC __glewTexGenfvOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXGENIOESPROC __glewTexGeniOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXGENIVOESPROC __glewTexGenivOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXGENXOESPROC __glewTexGenxOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXGENXVOESPROC __glewTexGenxvOES;

extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE3DMULTISAMPLEOESPROC __glewTexStorage3DMultisampleOES;

extern __attribute__ ((visibility("default"))) PFNGLTEXTUREVIEWOESPROC __glewTextureViewOES;

extern __attribute__ ((visibility("default"))) PFNGLBINDVERTEXARRAYOESPROC __glewBindVertexArrayOES;
extern __attribute__ ((visibility("default"))) PFNGLDELETEVERTEXARRAYSOESPROC __glewDeleteVertexArraysOES;
extern __attribute__ ((visibility("default"))) PFNGLGENVERTEXARRAYSOESPROC __glewGenVertexArraysOES;
extern __attribute__ ((visibility("default"))) PFNGLISVERTEXARRAYOESPROC __glewIsVertexArrayOES;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC __glewFramebufferTextureMultiviewOVR;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC __glewNamedFramebufferTextureMultiviewOVR;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTUREMULTISAMPLEMULTIVIEWOVRPROC __glewFramebufferTextureMultisampleMultiviewOVR;

extern __attribute__ ((visibility("default"))) PFNGLALPHAFUNCQCOMPROC __glewAlphaFuncQCOM;

extern __attribute__ ((visibility("default"))) PFNGLDISABLEDRIVERCONTROLQCOMPROC __glewDisableDriverControlQCOM;
extern __attribute__ ((visibility("default"))) PFNGLENABLEDRIVERCONTROLQCOMPROC __glewEnableDriverControlQCOM;
extern __attribute__ ((visibility("default"))) PFNGLGETDRIVERCONTROLSTRINGQCOMPROC __glewGetDriverControlStringQCOM;
extern __attribute__ ((visibility("default"))) PFNGLGETDRIVERCONTROLSQCOMPROC __glewGetDriverControlsQCOM;

extern __attribute__ ((visibility("default"))) PFNGLEXTGETBUFFERPOINTERVQCOMPROC __glewExtGetBufferPointervQCOM;
extern __attribute__ ((visibility("default"))) PFNGLEXTGETBUFFERSQCOMPROC __glewExtGetBuffersQCOM;
extern __attribute__ ((visibility("default"))) PFNGLEXTGETFRAMEBUFFERSQCOMPROC __glewExtGetFramebuffersQCOM;
extern __attribute__ ((visibility("default"))) PFNGLEXTGETRENDERBUFFERSQCOMPROC __glewExtGetRenderbuffersQCOM;
extern __attribute__ ((visibility("default"))) PFNGLEXTGETTEXLEVELPARAMETERIVQCOMPROC __glewExtGetTexLevelParameterivQCOM;
extern __attribute__ ((visibility("default"))) PFNGLEXTGETTEXSUBIMAGEQCOMPROC __glewExtGetTexSubImageQCOM;
extern __attribute__ ((visibility("default"))) PFNGLEXTGETTEXTURESQCOMPROC __glewExtGetTexturesQCOM;
extern __attribute__ ((visibility("default"))) PFNGLEXTTEXOBJECTSTATEOVERRIDEIQCOMPROC __glewExtTexObjectStateOverrideiQCOM;

extern __attribute__ ((visibility("default"))) PFNGLEXTGETPROGRAMBINARYSOURCEQCOMPROC __glewExtGetProgramBinarySourceQCOM;
extern __attribute__ ((visibility("default"))) PFNGLEXTGETPROGRAMSQCOMPROC __glewExtGetProgramsQCOM;
extern __attribute__ ((visibility("default"))) PFNGLEXTGETSHADERSQCOMPROC __glewExtGetShadersQCOM;
extern __attribute__ ((visibility("default"))) PFNGLEXTISPROGRAMBINARYQCOMPROC __glewExtIsProgramBinaryQCOM;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERFOVEATIONCONFIGQCOMPROC __glewFramebufferFoveationConfigQCOM;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERFOVEATIONPARAMETERSQCOMPROC __glewFramebufferFoveationParametersQCOM;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERFETCHBARRIERQCOMPROC __glewFramebufferFetchBarrierQCOM;

extern __attribute__ ((visibility("default"))) PFNGLTEXTUREFOVEATIONPARAMETERSQCOMPROC __glewTextureFoveationParametersQCOM;

extern __attribute__ ((visibility("default"))) PFNGLENDTILINGQCOMPROC __glewEndTilingQCOM;
extern __attribute__ ((visibility("default"))) PFNGLSTARTTILINGQCOMPROC __glewStartTilingQCOM;

extern __attribute__ ((visibility("default"))) PFNGLALPHAFUNCXPROC __glewAlphaFuncx;
extern __attribute__ ((visibility("default"))) PFNGLCLEARCOLORXPROC __glewClearColorx;
extern __attribute__ ((visibility("default"))) PFNGLCLEARDEPTHXPROC __glewClearDepthx;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4XPROC __glewColor4x;
extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEXPROC __glewDepthRangex;
extern __attribute__ ((visibility("default"))) PFNGLFOGXPROC __glewFogx;
extern __attribute__ ((visibility("default"))) PFNGLFOGXVPROC __glewFogxv;
extern __attribute__ ((visibility("default"))) PFNGLFRUSTUMFPROC __glewFrustumf;
extern __attribute__ ((visibility("default"))) PFNGLFRUSTUMXPROC __glewFrustumx;
extern __attribute__ ((visibility("default"))) PFNGLLIGHTMODELXPROC __glewLightModelx;
extern __attribute__ ((visibility("default"))) PFNGLLIGHTMODELXVPROC __glewLightModelxv;
extern __attribute__ ((visibility("default"))) PFNGLLIGHTXPROC __glewLightx;
extern __attribute__ ((visibility("default"))) PFNGLLIGHTXVPROC __glewLightxv;
extern __attribute__ ((visibility("default"))) PFNGLLINEWIDTHXPROC __glewLineWidthx;
extern __attribute__ ((visibility("default"))) PFNGLLOADMATRIXXPROC __glewLoadMatrixx;
extern __attribute__ ((visibility("default"))) PFNGLMATERIALXPROC __glewMaterialx;
extern __attribute__ ((visibility("default"))) PFNGLMATERIALXVPROC __glewMaterialxv;
extern __attribute__ ((visibility("default"))) PFNGLMULTMATRIXXPROC __glewMultMatrixx;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4XPROC __glewMultiTexCoord4x;
extern __attribute__ ((visibility("default"))) PFNGLNORMAL3XPROC __glewNormal3x;
extern __attribute__ ((visibility("default"))) PFNGLORTHOFPROC __glewOrthof;
extern __attribute__ ((visibility("default"))) PFNGLORTHOXPROC __glewOrthox;
extern __attribute__ ((visibility("default"))) PFNGLPOINTSIZEXPROC __glewPointSizex;
extern __attribute__ ((visibility("default"))) PFNGLPOLYGONOFFSETXPROC __glewPolygonOffsetx;
extern __attribute__ ((visibility("default"))) PFNGLROTATEXPROC __glewRotatex;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLECOVERAGEXPROC __glewSampleCoveragex;
extern __attribute__ ((visibility("default"))) PFNGLSCALEXPROC __glewScalex;
extern __attribute__ ((visibility("default"))) PFNGLTEXENVXPROC __glewTexEnvx;
extern __attribute__ ((visibility("default"))) PFNGLTEXENVXVPROC __glewTexEnvxv;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERXPROC __glewTexParameterx;
extern __attribute__ ((visibility("default"))) PFNGLTRANSLATEXPROC __glewTranslatex;

extern __attribute__ ((visibility("default"))) PFNGLCLIPPLANEFPROC __glewClipPlanef;
extern __attribute__ ((visibility("default"))) PFNGLCLIPPLANEXPROC __glewClipPlanex;
extern __attribute__ ((visibility("default"))) PFNGLGETCLIPPLANEFPROC __glewGetClipPlanef;
extern __attribute__ ((visibility("default"))) PFNGLGETCLIPPLANEXPROC __glewGetClipPlanex;
extern __attribute__ ((visibility("default"))) PFNGLGETFIXEDVPROC __glewGetFixedv;
extern __attribute__ ((visibility("default"))) PFNGLGETLIGHTXVPROC __glewGetLightxv;
extern __attribute__ ((visibility("default"))) PFNGLGETMATERIALXVPROC __glewGetMaterialxv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXENVXVPROC __glewGetTexEnvxv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERXVPROC __glewGetTexParameterxv;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERXPROC __glewPointParameterx;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERXVPROC __glewPointParameterxv;
extern __attribute__ ((visibility("default"))) PFNGLPOINTSIZEPOINTEROESPROC __glewPointSizePointerOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERXVPROC __glewTexParameterxv;

extern __attribute__ ((visibility("default"))) PFNGLERRORSTRINGREGALPROC __glewErrorStringREGAL;

extern __attribute__ ((visibility("default"))) PFNGLGETEXTENSIONREGALPROC __glewGetExtensionREGAL;
extern __attribute__ ((visibility("default"))) PFNGLISSUPPORTEDREGALPROC __glewIsSupportedREGAL;

extern __attribute__ ((visibility("default"))) PFNGLLOGMESSAGECALLBACKREGALPROC __glewLogMessageCallbackREGAL;

extern __attribute__ ((visibility("default"))) PFNGLGETPROCADDRESSREGALPROC __glewGetProcAddressREGAL;

extern __attribute__ ((visibility("default"))) PFNGLDETAILTEXFUNCSGISPROC __glewDetailTexFuncSGIS;
extern __attribute__ ((visibility("default"))) PFNGLGETDETAILTEXFUNCSGISPROC __glewGetDetailTexFuncSGIS;

extern __attribute__ ((visibility("default"))) PFNGLFOGFUNCSGISPROC __glewFogFuncSGIS;
extern __attribute__ ((visibility("default"))) PFNGLGETFOGFUNCSGISPROC __glewGetFogFuncSGIS;

extern __attribute__ ((visibility("default"))) PFNGLSAMPLEMASKSGISPROC __glewSampleMaskSGIS;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLEPATTERNSGISPROC __glewSamplePatternSGIS;

extern __attribute__ ((visibility("default"))) PFNGLINTERLEAVEDTEXTURECOORDSETSSGISPROC __glewInterleavedTextureCoordSetsSGIS;
extern __attribute__ ((visibility("default"))) PFNGLSELECTTEXTURECOORDSETSGISPROC __glewSelectTextureCoordSetSGIS;
extern __attribute__ ((visibility("default"))) PFNGLSELECTTEXTURESGISPROC __glewSelectTextureSGIS;
extern __attribute__ ((visibility("default"))) PFNGLSELECTTEXTURETRANSFORMSGISPROC __glewSelectTextureTransformSGIS;

extern __attribute__ ((visibility("default"))) PFNGLMULTISAMPLESUBRECTPOSSGISPROC __glewMultisampleSubRectPosSGIS;

extern __attribute__ ((visibility("default"))) PFNGLGETSHARPENTEXFUNCSGISPROC __glewGetSharpenTexFuncSGIS;
extern __attribute__ ((visibility("default"))) PFNGLSHARPENTEXFUNCSGISPROC __glewSharpenTexFuncSGIS;

extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE4DSGISPROC __glewTexImage4DSGIS;
extern __attribute__ ((visibility("default"))) PFNGLTEXSUBIMAGE4DSGISPROC __glewTexSubImage4DSGIS;

extern __attribute__ ((visibility("default"))) PFNGLGETTEXFILTERFUNCSGISPROC __glewGetTexFilterFuncSGIS;
extern __attribute__ ((visibility("default"))) PFNGLTEXFILTERFUNCSGISPROC __glewTexFilterFuncSGIS;

extern __attribute__ ((visibility("default"))) PFNGLASYNCMARKERSGIXPROC __glewAsyncMarkerSGIX;
extern __attribute__ ((visibility("default"))) PFNGLDELETEASYNCMARKERSSGIXPROC __glewDeleteAsyncMarkersSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFINISHASYNCSGIXPROC __glewFinishAsyncSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGENASYNCMARKERSSGIXPROC __glewGenAsyncMarkersSGIX;
extern __attribute__ ((visibility("default"))) PFNGLISASYNCMARKERSGIXPROC __glewIsAsyncMarkerSGIX;
extern __attribute__ ((visibility("default"))) PFNGLPOLLASYNCSGIXPROC __glewPollAsyncSGIX;

extern __attribute__ ((visibility("default"))) PFNGLADDRESSSPACEPROC __glewAddressSpace;
extern __attribute__ ((visibility("default"))) PFNGLDATAPIPEPROC __glewDataPipe;

extern __attribute__ ((visibility("default"))) PFNGLFLUSHRASTERSGIXPROC __glewFlushRasterSGIX;

extern __attribute__ ((visibility("default"))) PFNGLFOGLAYERSSGIXPROC __glewFogLayersSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETFOGLAYERSSGIXPROC __glewGetFogLayersSGIX;

extern __attribute__ ((visibility("default"))) PFNGLTEXTUREFOGSGIXPROC __glewTextureFogSGIX;

extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTCOLORMATERIALSGIXPROC __glewFragmentColorMaterialSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELFSGIXPROC __glewFragmentLightModelfSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELFVSGIXPROC __glewFragmentLightModelfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELISGIXPROC __glewFragmentLightModeliSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELIVSGIXPROC __glewFragmentLightModelivSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTFSGIXPROC __glewFragmentLightfSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTFVSGIXPROC __glewFragmentLightfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTISGIXPROC __glewFragmentLightiSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTIVSGIXPROC __glewFragmentLightivSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALFSGIXPROC __glewFragmentMaterialfSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALFVSGIXPROC __glewFragmentMaterialfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALISGIXPROC __glewFragmentMaterialiSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALIVSGIXPROC __glewFragmentMaterialivSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTLIGHTFVSGIXPROC __glewGetFragmentLightfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTLIGHTIVSGIXPROC __glewGetFragmentLightivSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTMATERIALFVSGIXPROC __glewGetFragmentMaterialfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTMATERIALIVSGIXPROC __glewGetFragmentMaterialivSGIX;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEZOOMSGIXPROC __glewFrameZoomSGIX;

extern __attribute__ ((visibility("default"))) PFNGLIGLOOINTERFACESGIXPROC __glewIglooInterfaceSGIX;

extern __attribute__ ((visibility("default"))) PFNGLALLOCMPEGPREDICTORSSGIXPROC __glewAllocMPEGPredictorsSGIX;
extern __attribute__ ((visibility("default"))) PFNGLDELETEMPEGPREDICTORSSGIXPROC __glewDeleteMPEGPredictorsSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGENMPEGPREDICTORSSGIXPROC __glewGenMPEGPredictorsSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETMPEGPARAMETERFVSGIXPROC __glewGetMPEGParameterfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETMPEGPARAMETERIVSGIXPROC __glewGetMPEGParameterivSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETMPEGPREDICTORSGIXPROC __glewGetMPEGPredictorSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETMPEGQUANTTABLEUBVPROC __glewGetMPEGQuantTableubv;
extern __attribute__ ((visibility("default"))) PFNGLISMPEGPREDICTORSGIXPROC __glewIsMPEGPredictorSGIX;
extern __attribute__ ((visibility("default"))) PFNGLMPEGPREDICTORSGIXPROC __glewMPEGPredictorSGIX;
extern __attribute__ ((visibility("default"))) PFNGLMPEGQUANTTABLEUBVPROC __glewMPEGQuantTableubv;
extern __attribute__ ((visibility("default"))) PFNGLSWAPMPEGPREDICTORSSGIXPROC __glewSwapMPEGPredictorsSGIX;

extern __attribute__ ((visibility("default"))) PFNGLGETNONLINLIGHTFVSGIXPROC __glewGetNonlinLightfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETNONLINMATERIALFVSGIXPROC __glewGetNonlinMaterialfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLNONLINLIGHTFVSGIXPROC __glewNonlinLightfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLNONLINMATERIALFVSGIXPROC __glewNonlinMaterialfvSGIX;

extern __attribute__ ((visibility("default"))) PFNGLPIXELTEXGENSGIXPROC __glewPixelTexGenSGIX;

extern __attribute__ ((visibility("default"))) PFNGLDEFORMSGIXPROC __glewDeformSGIX;
extern __attribute__ ((visibility("default"))) PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC __glewLoadIdentityDeformationMapSGIX;

extern __attribute__ ((visibility("default"))) PFNGLMESHBREADTHSGIXPROC __glewMeshBreadthSGIX;
extern __attribute__ ((visibility("default"))) PFNGLMESHSTRIDESGIXPROC __glewMeshStrideSGIX;

extern __attribute__ ((visibility("default"))) PFNGLREFERENCEPLANESGIXPROC __glewReferencePlaneSGIX;

extern __attribute__ ((visibility("default"))) PFNGLSPRITEPARAMETERFSGIXPROC __glewSpriteParameterfSGIX;
extern __attribute__ ((visibility("default"))) PFNGLSPRITEPARAMETERFVSGIXPROC __glewSpriteParameterfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLSPRITEPARAMETERISGIXPROC __glewSpriteParameteriSGIX;
extern __attribute__ ((visibility("default"))) PFNGLSPRITEPARAMETERIVSGIXPROC __glewSpriteParameterivSGIX;

extern __attribute__ ((visibility("default"))) PFNGLTAGSAMPLEBUFFERSGIXPROC __glewTagSampleBufferSGIX;

extern __attribute__ ((visibility("default"))) PFNGLGETVECTOROPERATIONSGIXPROC __glewGetVectorOperationSGIX;
extern __attribute__ ((visibility("default"))) PFNGLVECTOROPERATIONSGIXPROC __glewVectorOperationSGIX;

extern __attribute__ ((visibility("default"))) PFNGLAREVERTEXARRAYSRESIDENTSGIXPROC __glewAreVertexArraysResidentSGIX;
extern __attribute__ ((visibility("default"))) PFNGLBINDVERTEXARRAYSGIXPROC __glewBindVertexArraySGIX;
extern __attribute__ ((visibility("default"))) PFNGLDELETEVERTEXARRAYSSGIXPROC __glewDeleteVertexArraysSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGENVERTEXARRAYSSGIXPROC __glewGenVertexArraysSGIX;
extern __attribute__ ((visibility("default"))) PFNGLISVERTEXARRAYSGIXPROC __glewIsVertexArraySGIX;
extern __attribute__ ((visibility("default"))) PFNGLPRIORITIZEVERTEXARRAYSSGIXPROC __glewPrioritizeVertexArraysSGIX;

extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLEPARAMETERFVSGIPROC __glewColorTableParameterfvSGI;
extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLEPARAMETERIVSGIPROC __glewColorTableParameterivSGI;
extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLESGIPROC __glewColorTableSGI;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCOLORTABLESGIPROC __glewCopyColorTableSGI;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPARAMETERFVSGIPROC __glewGetColorTableParameterfvSGI;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPARAMETERIVSGIPROC __glewGetColorTableParameterivSGI;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLESGIPROC __glewGetColorTableSGI;

extern __attribute__ ((visibility("default"))) PFNGLGETPIXELTRANSFORMPARAMETERFVSGIPROC __glewGetPixelTransformParameterfvSGI;
extern __attribute__ ((visibility("default"))) PFNGLGETPIXELTRANSFORMPARAMETERIVSGIPROC __glewGetPixelTransformParameterivSGI;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMPARAMETERFSGIPROC __glewPixelTransformParameterfSGI;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMPARAMETERFVSGIPROC __glewPixelTransformParameterfvSGI;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMPARAMETERISGIPROC __glewPixelTransformParameteriSGI;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMPARAMETERIVSGIPROC __glewPixelTransformParameterivSGI;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMSGIPROC __glewPixelTransformSGI;

extern __attribute__ ((visibility("default"))) PFNGLFINISHTEXTURESUNXPROC __glewFinishTextureSUNX;

extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORBSUNPROC __glewGlobalAlphaFactorbSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORDSUNPROC __glewGlobalAlphaFactordSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORFSUNPROC __glewGlobalAlphaFactorfSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORISUNPROC __glewGlobalAlphaFactoriSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORSSUNPROC __glewGlobalAlphaFactorsSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORUBSUNPROC __glewGlobalAlphaFactorubSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORUISUNPROC __glewGlobalAlphaFactoruiSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORUSSUNPROC __glewGlobalAlphaFactorusSUN;

extern __attribute__ ((visibility("default"))) PFNGLREADVIDEOPIXELSSUNPROC __glewReadVideoPixelsSUN;

extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEPOINTERSUNPROC __glewReplacementCodePointerSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUBSUNPROC __glewReplacementCodeubSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUBVSUNPROC __glewReplacementCodeubvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUISUNPROC __glewReplacementCodeuiSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUIVSUNPROC __glewReplacementCodeuivSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUSSUNPROC __glewReplacementCodeusSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUSVSUNPROC __glewReplacementCodeusvSUN;

extern __attribute__ ((visibility("default"))) PFNGLCOLOR3FVERTEX3FSUNPROC __glewColor3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR3FVERTEX3FVSUNPROC __glewColor3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewColor4fNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewColor4fNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4UBVERTEX2FSUNPROC __glewColor4ubVertex2fSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4UBVERTEX2FVSUNPROC __glewColor4ubVertex2fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4UBVERTEX3FSUNPROC __glewColor4ubVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4UBVERTEX3FVSUNPROC __glewColor4ubVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLNORMAL3FVERTEX3FSUNPROC __glewNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLNORMAL3FVERTEX3FVSUNPROC __glewNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC __glewReplacementCodeuiColor3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC __glewReplacementCodeuiColor4ubVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC __glewReplacementCodeuiColor4ubVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC __glewReplacementCodeuiVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC __glewReplacementCodeuiVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC __glewTexCoord2fColor3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC __glewTexCoord2fColor3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC __glewTexCoord2fColor4ubVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC __glewTexCoord2fColor4ubVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FVERTEX3FSUNPROC __glewTexCoord2fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FVERTEX3FVSUNPROC __glewTexCoord2fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD4FVERTEX4FSUNPROC __glewTexCoord4fVertex4fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD4FVERTEX4FVSUNPROC __glewTexCoord4fVertex4fvSUN;

extern __attribute__ ((visibility("default"))) PFNGLADDSWAPHINTRECTWINPROC __glewAddSwapHintRectWIN;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_1_1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_1_2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_1_2_1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_1_3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_1_4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_1_5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_2_0;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_2_1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_3_0;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_3_1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_3_2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_3_3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_4_0;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_4_1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_4_2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_4_3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_4_4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_4_5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_4_6;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_3DFX_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_3DFX_tbuffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_3DFX_texture_compression_FXT1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_blend_minmax_factor;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_compressed_3DC_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_compressed_ATC_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_conservative_depth;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_debug_output;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_depth_clamp_separate;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_draw_buffers_blend;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_framebuffer_multisample_advanced;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_framebuffer_sample_positions;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_gcn_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_gpu_shader_half_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_gpu_shader_half_float_fetch;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_gpu_shader_int16;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_gpu_shader_int64;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_interleaved_elements;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_multi_draw_indirect;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_name_gen_delete;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_occlusion_query_event;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_performance_monitor;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_pinned_memory;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_program_binary_Z400;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_query_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_sample_positions;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_seamless_cubemap_per_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_shader_atomic_counter_ops;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_shader_ballot;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_shader_explicit_vertex_parameter;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_shader_image_load_store_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_shader_stencil_export;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_shader_stencil_value_export;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_shader_trinary_minmax;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_sparse_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_stencil_operation_extended;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_texture_gather_bias_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_texture_texture4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_transform_feedback3_lines_triangles;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_transform_feedback4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_vertex_shader_layer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_vertex_shader_tessellator;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_vertex_shader_viewport_index;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANDROID_extension_pack_es31a;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_depth_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_framebuffer_blit;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_framebuffer_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_instanced_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_pack_reverse_row_order;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_program_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_texture_compression_dxt1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_texture_compression_dxt3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_texture_compression_dxt5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_texture_usage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_timer_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_translated_shader_source;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_aux_depth_stencil;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_client_storage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_clip_distance;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_color_buffer_packed_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_copy_texture_levels;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_element_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_fence;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_float_pixels;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_flush_buffer_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_framebuffer_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_object_purgeable;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_pixel_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_rgb_422;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_row_bytes;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_specular_vector;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_sync;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_texture_2D_limited_npot;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_texture_format_BGRA8888;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_texture_max_level;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_texture_packed_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_texture_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_transform_hint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_vertex_array_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_vertex_array_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_vertex_program_evaluators;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_ycbcr_422;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_ES2_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_ES3_1_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_ES3_2_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_ES3_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_arrays_of_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_base_instance;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_bindless_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_blend_func_extended;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_buffer_storage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_cl_event;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_clear_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_clear_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_clip_control;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_color_buffer_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_compressed_texture_pixel_storage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_compute_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_compute_variable_group_size;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_conditional_render_inverted;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_conservative_depth;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_copy_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_copy_image;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_cull_distance;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_debug_output;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_depth_buffer_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_depth_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_depth_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_derivative_control;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_direct_state_access;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_draw_buffers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_draw_buffers_blend;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_draw_elements_base_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_draw_indirect;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_draw_instanced;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_enhanced_layouts;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_explicit_attrib_location;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_explicit_uniform_location;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_fragment_coord_conventions;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_fragment_layer_viewport;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_fragment_program;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_fragment_program_shadow;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_fragment_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_fragment_shader_interlock;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_framebuffer_no_attachments;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_framebuffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_framebuffer_sRGB;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_geometry_shader4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_get_program_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_get_texture_sub_image;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_gl_spirv;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_gpu_shader5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_gpu_shader_fp64;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_gpu_shader_int64;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_half_float_pixel;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_half_float_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_imaging;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_indirect_parameters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_instanced_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_internalformat_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_internalformat_query2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_invalidate_subdata;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_map_buffer_alignment;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_map_buffer_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_matrix_palette;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_multi_bind;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_multi_draw_indirect;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_multitexture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_occlusion_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_occlusion_query2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_parallel_shader_compile;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_pipeline_statistics_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_pixel_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_point_parameters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_point_sprite;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_polygon_offset_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_post_depth_coverage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_program_interface_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_provoking_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_query_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_robust_buffer_access_behavior;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_robustness;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_robustness_application_isolation;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_robustness_share_group_isolation;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_sample_locations;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_sample_shading;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_sampler_objects;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_seamless_cube_map;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_seamless_cubemap_per_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_separate_shader_objects;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_atomic_counter_ops;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_atomic_counters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_ballot;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_bit_encoding;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_clock;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_draw_parameters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_group_vote;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_image_load_store;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_image_size;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_objects;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_precision;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_stencil_export;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_storage_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_subroutine;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_texture_image_samples;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_texture_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_viewport_layer_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shading_language_100;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shading_language_420pack;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shading_language_include;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shading_language_packing;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shadow;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shadow_ambient;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_sparse_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_sparse_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_sparse_texture2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_sparse_texture_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_spirv_extensions;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_stencil_texturing;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_sync;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_tessellation_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_barrier;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_border_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_buffer_object_rgb32;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_buffer_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_compression;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_compression_bptc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_compression_rgtc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_cube_map;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_cube_map_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_env_add;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_env_combine;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_env_crossbar;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_env_dot3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_filter_anisotropic;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_filter_minmax;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_gather;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_mirror_clamp_to_edge;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_mirrored_repeat;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_non_power_of_two;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_query_levels;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_query_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_rectangle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_rg;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_rgb10_a2ui;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_stencil8;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_storage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_storage_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_swizzle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_view;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_timer_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_transform_feedback2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_transform_feedback3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_transform_feedback_instanced;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_transform_feedback_overflow_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_transpose_matrix;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_uniform_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_array_bgra;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_array_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_attrib_64bit;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_attrib_binding;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_blend;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_program;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_type_10f_11f_11f_rev;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_type_2_10_10_10_rev;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_viewport_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_window_pos;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARM_mali_program_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARM_mali_shader_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARM_rgba8;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARM_shader_framebuffer_fetch;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARM_shader_framebuffer_fetch_depth_stencil;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARM_texture_unnormalized_coordinates;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATIX_point_sprites;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATIX_texture_env_combine3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATIX_texture_env_route;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATIX_vertex_shader_output_point_size;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_draw_buffers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_element_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_envmap_bumpmap;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_fragment_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_map_object_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_meminfo;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_pn_triangles;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_separate_stencil;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_shader_texture_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_text_fragment_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_texture_compression_3dc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_texture_env_combine3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_texture_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_texture_mirror_once;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_vertex_array_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_vertex_attrib_array_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_vertex_streams;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_DMP_program_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_DMP_shader_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_422_pixels;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_Cg_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_EGL_image_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_EGL_image_external_wrap_modes;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_EGL_image_storage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_EGL_sync;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_YUV_target;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_abgr;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_base_instance;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_bgra;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_bindable_uniform;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_blend_color;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_blend_equation_separate;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_blend_func_extended;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_blend_func_separate;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_blend_logic_op;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_blend_minmax;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_blend_subtract;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_buffer_storage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_clear_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_clip_control;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_clip_cull_distance;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_clip_volume_hint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_cmyka;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_color_buffer_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_color_buffer_half_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_color_subtable;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_compiled_vertex_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_compressed_ETC1_RGB8_sub_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_conservative_depth;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_convolution;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_coordinate_frame;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_copy_image;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_copy_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_cull_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_debug_label;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_debug_marker;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_depth_bounds_test;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_depth_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_direct_state_access;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_discard_framebuffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_disjoint_timer_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_draw_buffers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_draw_buffers2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_draw_buffers_indexed;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_draw_elements_base_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_draw_instanced;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_draw_range_elements;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_draw_transform_feedback;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_external_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_float_blend;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_fog_coord;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_frag_depth;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_fragment_lighting;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_framebuffer_blit;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_framebuffer_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_framebuffer_multisample_blit_scaled;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_framebuffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_framebuffer_sRGB;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_geometry_point_size;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_geometry_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_geometry_shader4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_gpu_program_parameters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_gpu_shader4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_gpu_shader5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_histogram;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_index_array_formats;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_index_func;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_index_material;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_index_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_instanced_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_light_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_map_buffer_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_memory_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_memory_object_fd;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_memory_object_win32;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_misc_attribute;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multi_draw_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multi_draw_indirect;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multiple_textures;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multisample_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multisampled_render_to_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multisampled_render_to_texture2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multiview_draw_buffers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multiview_tessellation_geometry_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multiview_texture_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multiview_timer_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_occlusion_query_boolean;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_packed_depth_stencil;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_packed_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_packed_pixels;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_paletted_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_pixel_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_pixel_transform;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_pixel_transform_color_table;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_point_parameters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_polygon_offset;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_polygon_offset_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_post_depth_coverage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_primitive_bounding_box;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_protected_textures;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_provoking_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_pvrtc_sRGB;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_raster_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_read_format_bgra;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_render_snorm;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_rescale_normal;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_robustness;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_sRGB;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_sRGB_write_control;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_scene_marker;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_secondary_color;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_semaphore;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_semaphore_fd;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_semaphore_win32;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_separate_shader_objects;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_separate_specular_color;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_framebuffer_fetch;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_framebuffer_fetch_non_coherent;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_group_vote;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_image_load_formatted;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_image_load_store;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_implicit_conversions;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_integer_mix;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_io_blocks;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_non_constant_global_initializers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_pixel_local_storage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_pixel_local_storage2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_texture_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shadow_funcs;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shadow_samplers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shared_texture_palette;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_sparse_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_sparse_texture2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_static_vertex_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_stencil_clear_tag;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_stencil_two_side;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_stencil_wrap;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_subtexture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_tessellation_point_size;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_tessellation_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture3D;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_border_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_compression_astc_decode_mode;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_compression_astc_decode_mode_rgb9e5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_compression_bptc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_compression_dxt1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_compression_latc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_compression_rgtc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_compression_s3tc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_compression_s3tc_srgb;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_cube_map;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_cube_map_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_edge_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_env;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_env_add;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_env_combine;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_env_dot3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_filter_anisotropic;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_filter_minmax;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_format_BGRA8888;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_format_sRGB_override;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_integer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_lod_bias;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_mirror_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_mirror_clamp_to_edge;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_norm16;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_perturb_normal;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_query_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_rectangle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_rg;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_sRGB;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_sRGB_R8;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_sRGB_RG8;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_sRGB_decode;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_shadow_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_shared_exponent;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_snorm;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_storage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_swizzle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_type_2_10_10_10_REV;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_view;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_timer_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_transform_feedback;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_unpack_subimage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_vertex_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_vertex_array_bgra;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_vertex_array_setXXX;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_vertex_attrib_64bit;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_vertex_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_vertex_weighting;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_win32_keyed_mutex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_window_rectangles;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_x11_sync_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_FJ_shader_binary_GCCSO;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_GREMEDY_frame_terminator;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_GREMEDY_string_marker;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_HP_convolution_border_modes;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_HP_image_transform;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_HP_occlusion_test;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_HP_texture_lighting;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IBM_cull_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IBM_multimode_draw_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IBM_rasterpos_clip;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IBM_static_data;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IBM_texture_mirrored_repeat;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IBM_vertex_array_lists;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IMG_bindless_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IMG_framebuffer_downsample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IMG_multisampled_render_to_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IMG_program_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IMG_read_format;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IMG_shader_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IMG_texture_compression_pvrtc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IMG_texture_compression_pvrtc2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IMG_texture_env_enhanced_fixed_function;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IMG_texture_filter_cubic;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INGR_color_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INGR_interlace_read;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_blackhole_render;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_conservative_rasterization;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_fragment_shader_ordering;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_framebuffer_CMAA;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_map_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_parallel_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_performance_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_shader_integer_functions2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_texture_scissor;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_blend_equation_advanced;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_blend_equation_advanced_coherent;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_context_flush_control;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_debug;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_no_error;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_parallel_shader_compile;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_robust_buffer_access_behavior;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_robustness;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_shader_subgroup;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_texture_compression_astc_hdr;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_texture_compression_astc_ldr;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_texture_compression_astc_sliced_3d;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KTX_buffer_region;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESAX_texture_stack;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESA_framebuffer_flip_y;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESA_pack_invert;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESA_program_binary_formats;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESA_resize_buffers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESA_shader_integer_functions;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESA_tile_raster_order;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESA_window_pos;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESA_ycbcr_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NVX_blend_equation_advanced_multi_draw_buffers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NVX_conditional_render;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NVX_gpu_memory_info;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NVX_gpu_multicast2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NVX_linked_gpu_multicast;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NVX_progress_fence;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_3dvision_settings;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_EGL_stream_consumer_external;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_alpha_to_coverage_dither_control;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_bgr;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_bindless_multi_draw_indirect;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_bindless_multi_draw_indirect_count;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_bindless_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_blend_equation_advanced;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_blend_equation_advanced_coherent;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_blend_minmax_factor;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_blend_square;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_clip_space_w_scaling;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_command_list;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_compute_program5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_compute_shader_derivatives;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_conditional_render;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_conservative_raster;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_conservative_raster_dilate;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_conservative_raster_pre_snap;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_conservative_raster_pre_snap_triangles;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_conservative_raster_underestimation;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_copy_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_copy_depth_to_color;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_copy_image;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_deep_texture3D;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_depth_buffer_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_depth_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_depth_nonlinear;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_depth_range_unclamped;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_draw_buffers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_draw_instanced;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_draw_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_draw_vulkan_image;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_evaluators;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_explicit_attrib_location;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_explicit_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fbo_color_attachments;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fence;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fill_rectangle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_float_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fog_distance;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fragment_coverage_to_color;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fragment_program;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fragment_program2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fragment_program4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fragment_program_option;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fragment_shader_barycentric;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fragment_shader_interlock;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_framebuffer_blit;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_framebuffer_mixed_samples;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_framebuffer_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_framebuffer_multisample_coverage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_generate_mipmap_sRGB;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_geometry_program4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_geometry_shader4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_geometry_shader_passthrough;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_gpu_multicast;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_gpu_program4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_gpu_program5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_gpu_program5_mem_extended;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_gpu_program_fp64;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_gpu_shader5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_half_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_image_formats;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_instanced_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_internalformat_sample_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_light_max_exponent;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_memory_attachment;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_mesh_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_multisample_coverage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_multisample_filter_hint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_non_square_matrices;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_occlusion_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_pack_subimage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_packed_depth_stencil;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_packed_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_packed_float_linear;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_parameter_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_parameter_buffer_object2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_path_rendering;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_path_rendering_shared_edge;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_pixel_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_pixel_data_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_platform_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_point_sprite;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_polygon_mode;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_present_video;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_primitive_restart;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_query_resource_tag;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_read_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_read_buffer_front;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_read_depth;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_read_depth_stencil;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_read_stencil;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_register_combiners;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_register_combiners2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_representative_fragment_test;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_robustness_video_memory_purge;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_sRGB_formats;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_sample_locations;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_sample_mask_override_coverage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_scissor_exclusive;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_atomic_counters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_atomic_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_atomic_float64;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_atomic_fp16_vector;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_atomic_int64;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_buffer_load;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_noperspective_interpolation;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_storage_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_subgroup_partitioned;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_texture_footprint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_thread_group;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_thread_shuffle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shading_rate_image;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shadow_samplers_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shadow_samplers_cube;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_stereo_view_rendering;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_tessellation_program5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texgen_emboss;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texgen_reflection;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_barrier;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_border_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_compression_latc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_compression_s3tc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_compression_s3tc_update;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_compression_vtc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_env_combine4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_expand_normal;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_npot_2D_mipmap;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_rectangle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_rectangle_compressed;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_shader2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_shader3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_transform_feedback;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_transform_feedback2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_uniform_buffer_unified_memory;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vdpau_interop;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vdpau_interop2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_array_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_array_range2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_attrib_integer_64bit;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_buffer_unified_memory;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_program;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_program1_1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_program2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_program2_option;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_program3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_program4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_video_capture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_viewport_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_viewport_array2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_viewport_swizzle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_EGL_image;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_EGL_image_external;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_EGL_image_external_essl3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_blend_equation_separate;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_blend_func_separate;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_blend_subtract;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_byte_coordinates;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_compressed_ETC1_RGB8_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_compressed_paletted_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_copy_image;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_depth24;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_depth32;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_depth_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_depth_texture_cube_map;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_draw_buffers_indexed;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_draw_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_element_index_uint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_extended_matrix_palette;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_fbo_render_mipmap;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_fragment_precision_high;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_framebuffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_geometry_point_size;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_geometry_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_get_program_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_gpu_shader5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_mapbuffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_matrix_get;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_matrix_palette;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_packed_depth_stencil;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_point_size_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_point_sprite;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_read_format;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_required_internalformat;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_rgb8_rgba8;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_sample_shading;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_sample_variables;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_shader_image_atomic;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_shader_io_blocks;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_shader_multisample_interpolation;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_single_precision;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_standard_derivatives;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_stencil1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_stencil4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_stencil8;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_surfaceless_context;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_tessellation_point_size;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_tessellation_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_3D;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_border_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_compression_astc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_cube_map;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_cube_map_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_env_crossbar;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_mirrored_repeat;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_npot;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_stencil8;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_storage_multisample_2d_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_view;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_vertex_array_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_vertex_half_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_vertex_type_10_10_10_2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OML_interlace;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OML_resample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OML_subsample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OVR_multiview;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OVR_multiview2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OVR_multiview_multisampled_render_to_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_PGI_misc_hints;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_PGI_vertex_hints;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_YUV_texture_gather;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_alpha_test;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_binning_control;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_driver_control;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_extended_get;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_extended_get2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_framebuffer_foveated;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_perfmon_global_mode;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_shader_framebuffer_fetch_noncoherent;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_shader_framebuffer_fetch_rate;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_texture_foveated;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_texture_foveated_subsampled_layout;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_tiled_rendering;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_writeonly_rendering;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REGAL_ES1_0_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REGAL_ES1_1_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REGAL_enable;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REGAL_error_string;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REGAL_extension_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REGAL_log;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REGAL_proc_address;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REND_screen_coordinates;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_S3_s3tc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_clip_band_hint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_color_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_detail_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_fog_function;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_generate_mipmap;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_line_texgen;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_multitexture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_pixel_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_point_line_texgen;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_shared_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_sharpen_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_texture4D;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_texture_border_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_texture_edge_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_texture_filter4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_texture_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_texture_select;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_async;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_async_histogram;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_async_pixel;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_bali_g_instruments;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_bali_r_instruments;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_bali_timer_instruments;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_blend_alpha_minmax;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_blend_cadd;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_blend_cmultiply;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_calligraphic_fragment;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_clipmap;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_color_matrix_accuracy;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_color_table_index_mode;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_complex_polar;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_convolution_accuracy;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_cube_map;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_cylinder_texgen;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_datapipe;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_decimation;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_depth_pass_instrument;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_depth_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_dvc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_flush_raster;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fog_blend;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fog_factor_to_alpha;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fog_layers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fog_offset;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fog_patchy;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fog_scale;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fog_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fragment_lighting_space;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fragment_specular_lighting;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fragments_instrument;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_framezoom;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_icc_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_igloo_interface;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_image_compression;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_impact_pixel_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_instrument_error;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_interlace;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_ir_instrument1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_line_quality_hint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_list_priority;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_mpeg1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_mpeg2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_nonlinear_lighting_pervertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_nurbs_eval;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_occlusion_instrument;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_packed_6bytes;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_pixel_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_pixel_texture_bits;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_pixel_texture_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_pixel_tiles;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_polynomial_ffd;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_quad_mesh;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_reference_plane;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_resample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_scalebias_hint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_shadow;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_shadow_ambient;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_slim;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_spotlight_cutoff;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_sprite;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_subdiv_patch;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_subsample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_tag_sample_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_add_env;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_coordinate_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_lod_bias;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_mipmap_anisotropic;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_multi_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_phase;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_scale_bias;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_supersample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_vector_ops;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_vertex_array_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_vertex_preclip;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_vertex_preclip_hint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_ycrcb;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_ycrcb_subsample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_ycrcba;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGI_color_matrix;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGI_color_table;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGI_complex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGI_complex_type;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGI_fft;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGI_texture_color_table;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUNX_constant_data;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_convolution_border_modes;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_global_alpha;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_mesh_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_read_video_pixels;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_slice_accum;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_triangle_list;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VIV_shader_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_WIN_phong_shading;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_WIN_scene_markerXXX;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_WIN_specular_fog;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_WIN_swap_hint;
# 26388 "/opt/homebrew/include/GL/glew.h"
extern __attribute__ ((visibility("default"))) GLenum glewInit (void);
extern __attribute__ ((visibility("default"))) GLboolean glewIsSupported (const char *name);
# 26400 "/opt/homebrew/include/GL/glew.h"
extern __attribute__ ((visibility("default"))) GLboolean glewExperimental;
extern __attribute__ ((visibility("default"))) GLboolean glewGetExtension (const char *name);
extern __attribute__ ((visibility("default"))) const GLubyte * glewGetErrorString (GLenum error);
extern __attribute__ ((visibility("default"))) const GLubyte * glewGetString (GLenum name);


}
# 5 "src/core/Renderer.h" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 1 3
# 308 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_move_common.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_move_common.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/iterator_operations.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/iterator_operations.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/iter_swap.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/iter_swap.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/swap.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/swap.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/move.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/move.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/move.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __libcpp_remove_reference_t<_Tp>&&
move( _Tp&& __t) throw() {
  typedef __attribute__((__nodebug__)) __libcpp_remove_reference_t<_Tp> _Up;
  return static_cast<_Up&&>(__t);
}

template <class _Tp>
using __move_if_noexcept_result_t =
    __conditional_t<!is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value, const _Tp&, _Tp&&>;

template <class _Tp>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __move_if_noexcept_result_t<_Tp>
move_if_noexcept( _Tp& __x) throw() {
  return std::move(__x);
}

}}
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/swap.h" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/swap.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/swap.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class>
using __swap_result_t = void;


template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __swap_result_t<_Tp> swap(_Tp& __x, _Tp& __y)
                                                                                                   {
  _Tp __t(std::move(__x));
  __x = std::move(__y);
  __y = std::move(__t);
}

template <class _Tp, size_t _Np, __enable_if_t<__is_swappable<_Tp>::value, int> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np])
                                                   {
  for (size_t __i = 0; __i != _Np; ++__i) {
    swap(__a[__i], __b[__i]);
  }
}

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/iter_swap.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/iter_swap.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)

                                                                                                         {
  swap(*__a, *__b);
}

}}
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_iterator_concept.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_iterator_concept.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/arithmetic.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/arithmetic.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_signed_integer.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_signed_integer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp> struct __libcpp_is_signed_integer : public false_type {};
template <> struct __libcpp_is_signed_integer<signed char> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed short> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed int> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed long> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed long long> : public true_type {};

template <> struct __libcpp_is_signed_integer<__int128_t> : public true_type {};



}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/arithmetic.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_unsigned_integer.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_unsigned_integer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Tp> struct __libcpp_is_unsigned_integer : public false_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned char> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned short> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned int> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned long> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned long long> : public true_type {};

template <> struct __libcpp_is_unsigned_integer<__uint128_t> : public true_type {};



}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/arithmetic.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/arithmetic.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 54 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/arithmetic.h" 3
}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/assignable.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/assignable.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/common_reference_with.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/common_reference_with.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/convertible_to.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/convertible_to.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/convertible_to.h" 3
}}
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/common_reference_with.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/same_as.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/same_as.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/same_as.h" 3
}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/common_reference_with.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/common_reference_with.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/common_reference_with.h" 3
}}
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/assignable.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/assignable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/assignable.h" 3
}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/constructible.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/constructible.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/destructible.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/destructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/destructible.h" 3
}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/constructible.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/constructible.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 53 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/constructible.h" 3
}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/copyable.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/copyable.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/movable.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/movable.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/swappable.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/swappable.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/class_or_enum.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/class_or_enum.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/class_or_enum.h" 3
}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/swappable.h" 2 3







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/exchange.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/exchange.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/exchange.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/exchange.h" 3
}}
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/swappable.h" 2 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/swappable.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/swappable.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 119 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/swappable.h" 3
}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/movable.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/movable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/movable.h" 3
}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/copyable.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/copyable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/copyable.h" 3
}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/derived_from.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/derived_from.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/derived_from.h" 3
}}
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/equality_comparable.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/equality_comparable.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/boolean_testable.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/boolean_testable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/boolean_testable.h" 3
}}
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/equality_comparable.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/equality_comparable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 54 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/equality_comparable.h" 3
}}
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/invocable.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/invocable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/invocable.h" 3
}}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/predicate.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/predicate.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/predicate.h" 3
}}
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/regular.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/regular.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/semiregular.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/semiregular.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/semiregular.h" 3
}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/regular.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/regular.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/regular.h" 3
}}
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/relation.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/relation.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/relation.h" 3
}}
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/totally_ordered.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/totally_ordered.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/totally_ordered.h" 3
}}
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/incrementable_traits.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/incrementable_traits.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_primary_template.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_primary_template.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_valid_expansion.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_valid_expansion.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <template <class...> class _Templ, class... _Args, class = _Templ<_Args...> >
true_type __sfinae_test_impl(int);
template <template <class...> class, class...>
false_type __sfinae_test_impl(...);

template <template <class...> class _Templ, class... _Args>
using _IsValidExpansion __attribute__((__nodebug__)) = __decltype(std::__sfinae_test_impl<_Templ, _Args...>(0));

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_primary_template.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_primary_template.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
using __test_for_primary_template = __enable_if_t<_IsSame<_Tp, typename _Tp::__primary_template>::value>;

template <class _Tp>
using __is_primary_template = _IsValidExpansion<__test_for_primary_template, _Tp>;

}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/incrementable_traits.h" 2 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/incrementable_traits.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/incrementable_traits.h" 3
}}
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_move.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_move.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator_traits.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator_traits.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/readable_traits.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/readable_traits.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/readable_traits.h" 3
}}
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator_traits.h" 2 3
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator_traits.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator_traits.h" 3
template <class _Iter>
struct iterator_traits;

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};




template <class _Iter>
struct __iter_traits_cache {
  using type = _If< __is_primary_template<iterator_traits<_Iter> >::value, _Iter, iterator_traits<_Iter> >;
};
template <class _Iter>
using _ITER_TRAITS = typename __iter_traits_cache<_Iter>::type;

struct __iter_concept_concept_test {
  template <class _Iter>
  using _Apply = typename _ITER_TRAITS<_Iter>::iterator_concept;
};
struct __iter_concept_category_test {
  template <class _Iter>
  using _Apply = typename _ITER_TRAITS<_Iter>::iterator_category;
};
struct __iter_concept_random_fallback {
  template <class _Iter>
  using _Apply = __enable_if_t< __is_primary_template<iterator_traits<_Iter> >::value, random_access_iterator_tag >;
};

template <class _Iter, class _Tester>
struct __test_iter_concept : _IsValidExpansion<_Tester::template _Apply, _Iter>, _Tester {};

template <class _Iter>
struct __iter_concept_cache {
  using type = _Or< __test_iter_concept<_Iter, __iter_concept_concept_test>,
                    __test_iter_concept<_Iter, __iter_concept_category_test>,
                    __test_iter_concept<_Iter, __iter_concept_random_fallback> >;
};

template <class _Iter>
using _ITER_CONCEPT = typename __iter_concept_cache<_Iter>::type::template _Apply<_Iter>;

template <class _Tp>
struct __has_iterator_typedefs {
private:
  template <class _Up>
  static false_type __test(...);
  template <class _Up>
  static true_type
  __test(__void_t<typename _Up::iterator_category>* = __nullptr,
         __void_t<typename _Up::difference_type>* = __nullptr,
         __void_t<typename _Up::value_type>* = __nullptr,
         __void_t<typename _Up::reference>* = __nullptr,
         __void_t<typename _Up::pointer>* = __nullptr);

public:
  static const bool value = __decltype(__test<_Tp>(__nullptr, __nullptr, __nullptr, __nullptr, __nullptr))::value;
};

template <class _Tp>
struct __has_iterator_category {
private:
  template <class _Up>
  static false_type __test(...);
  template <class _Up>
  static true_type __test(typename _Up::iterator_category* = __nullptr);

public:
  static const bool value = __decltype(__test<_Tp>(__nullptr))::value;
};

template <class _Tp>
struct __has_iterator_concept {
private:
  template <class _Up>
  static false_type __test(...);
  template <class _Up>
  static true_type __test(typename _Up::iterator_concept* = __nullptr);

public:
  static const bool value = __decltype(__test<_Tp>(__nullptr))::value;
};
# 371 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator_traits.h" 3
template <class _Iter, bool>
struct __iterator_traits {};

template <class _Iter, bool>
struct __iterator_traits_impl {};

template <class _Iter>
struct __iterator_traits_impl<_Iter, true> {
  typedef typename _Iter::difference_type difference_type;
  typedef typename _Iter::value_type value_type;
  typedef typename _Iter::pointer pointer;
  typedef typename _Iter::reference reference;
  typedef typename _Iter::iterator_category iterator_category;
};

template <class _Iter>
struct __iterator_traits<_Iter, true>
    : __iterator_traits_impl< _Iter,
                              is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||
                                  is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value > {};






template <class _Iter>
struct iterator_traits : __iterator_traits<_Iter, __has_iterator_typedefs<_Iter>::value> {
  using __primary_template = iterator_traits;
};


template <class _Tp>



struct iterator_traits<_Tp*> {
  typedef ptrdiff_t difference_type;
  typedef __remove_cv_t<_Tp> value_type;
  typedef _Tp* pointer;
  typedef _Tp& reference;
  typedef random_access_iterator_tag iterator_category;



};

template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>
struct __has_iterator_category_convertible_to : is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up> {
};

template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false> : false_type {};

template <class _Tp, class _Up, bool = __has_iterator_concept<_Tp>::value>
struct __has_iterator_concept_convertible_to : is_convertible<typename _Tp::iterator_concept, _Up> {};

template <class _Tp, class _Up>
struct __has_iterator_concept_convertible_to<_Tp, _Up, false> : false_type {};

template <class _Tp>
using __has_input_iterator_category = __has_iterator_category_convertible_to<_Tp, input_iterator_tag>;

template <class _Tp>
using __has_forward_iterator_category = __has_iterator_category_convertible_to<_Tp, forward_iterator_tag>;

template <class _Tp>
using __has_bidirectional_iterator_category = __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag>;

template <class _Tp>
using __has_random_access_iterator_category = __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag>;
# 456 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator_traits.h" 3
template <class _Tp>
struct __libcpp_is_contiguous_iterator : false_type {};



template <class _Up>
struct __libcpp_is_contiguous_iterator<_Up*> : true_type {};

template <class _Iter>
class __wrap_iter;

template <class _Tp>
using __has_exactly_input_iterator_category =
    integral_constant<bool,
                      __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value &&
                          !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value>;

template <class _Tp>
using __has_exactly_forward_iterator_category =
    integral_constant<bool,
                      __has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value &&
                          !__has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag>::value>;

template <class _Tp>
using __has_exactly_bidirectional_iterator_category =
    integral_constant<bool,
                      __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag>::value &&
                          !__has_iterator_category_convertible_to<_Tp, random_access_iterator_tag>::value>;

template <class _InputIterator>
using __iter_value_type = typename iterator_traits<_InputIterator>::value_type;

template <class _InputIterator>
using __iter_key_type = __remove_const_t<typename iterator_traits<_InputIterator>::value_type::first_type>;

template <class _InputIterator>
using __iter_mapped_type = typename iterator_traits<_InputIterator>::value_type::second_type;

template <class _InputIterator>
using __iter_to_alloc_type =
    pair< typename add_const<typename iterator_traits<_InputIterator>::value_type::first_type>::type,
          typename iterator_traits<_InputIterator>::value_type::second_type>;

template <class _Iter>
using __iterator_category_type = typename iterator_traits<_Iter>::iterator_category;

template <class _Iter>
using __iterator_pointer_type = typename iterator_traits<_Iter>::pointer;

template <class _Iter>
using __iter_diff_t = typename iterator_traits<_Iter>::difference_type;

template <class _Iter>
using __iter_reference = typename iterator_traits<_Iter>::reference;
# 527 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator_traits.h" 3
}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_move.h" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_move.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_move.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 99 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_move.h" 3
}}
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/pointer_traits.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/pointer_traits.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/addressof.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/addressof.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
inline __attribute__((__no_sanitize__("cfi"))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* addressof(_Tp& __x) throw() {
  return __builtin_addressof(__x);
}
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/addressof.h" 3
}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/pointer_traits.h" 2 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/pointer_traits.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class = void>
struct __has_element_type : false_type {};

template <class _Tp>
struct __has_element_type<_Tp, __void_t<typename _Tp::element_type> > : true_type {};

template <class _Ptr, bool = __has_element_type<_Ptr>::value>
struct __pointer_traits_element_type {};

template <class _Ptr>
struct __pointer_traits_element_type<_Ptr, true> {
  typedef __attribute__((__nodebug__)) typename _Ptr::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class... _Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true> {
  typedef __attribute__((__nodebug__)) typename _Sp<_Tp, _Args...>::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class... _Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false> {
  typedef __attribute__((__nodebug__)) _Tp type;
};

template <class _Tp, class = void>
struct __has_difference_type : false_type {};

template <class _Tp>
struct __has_difference_type<_Tp, __void_t<typename _Tp::difference_type> > : true_type {};

template <class _Ptr, bool = __has_difference_type<_Ptr>::value>
struct __pointer_traits_difference_type {
  typedef __attribute__((__nodebug__)) ptrdiff_t type;
};

template <class _Ptr>
struct __pointer_traits_difference_type<_Ptr, true> {
  typedef __attribute__((__nodebug__)) typename _Ptr::difference_type type;
};

template <class _Tp, class _Up>
struct __has_rebind {
private:
  template <class _Xp>
  static false_type __test(...);
#pragma GCC diagnostic push
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/pointer_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/pointer_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  template <class _Xp>
  static true_type __test(typename _Xp::template rebind<_Up>* = 0);
#pragma GCC diagnostic pop

public:
  static const bool value = __decltype(__test<_Tp>(0))::value;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __pointer_traits_rebind {



  typedef __attribute__((__nodebug__)) typename _Tp::template rebind<_Up>::other type;

};

template <template <class, class...> class _Sp, class _Tp, class... _Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true> {



  typedef __attribute__((__nodebug__)) typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;

};

template <template <class, class...> class _Sp, class _Tp, class... _Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false> {
  typedef _Sp<_Up, _Args...> type;
};

template <class _Ptr, class = void>
struct __pointer_traits_impl {};

template <class _Ptr>
struct __pointer_traits_impl<_Ptr, __void_t<typename __pointer_traits_element_type<_Ptr>::type> > {
  typedef _Ptr pointer;
  typedef typename __pointer_traits_element_type<pointer>::type element_type;
  typedef typename __pointer_traits_difference_type<pointer>::type difference_type;





  template <class _Up>
  struct rebind {
    typedef typename __pointer_traits_rebind<pointer, _Up>::type other;
  };


private:
  struct __nat {};

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static pointer
  pointer_to(__conditional_t<is_void<element_type>::value, __nat, element_type>& __r) {
    return pointer::pointer_to(__r);
  }
};

template <class _Ptr>
struct pointer_traits : __pointer_traits_impl<_Ptr> {};

template <class _Tp>
struct pointer_traits<_Tp*> {
  typedef _Tp* pointer;
  typedef _Tp element_type;
  typedef ptrdiff_t difference_type;





  template <class _Up>
  struct rebind {
    typedef _Up* other;
  };


private:
  struct __nat {};

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static pointer
  pointer_to(__conditional_t<is_void<element_type>::value, __nat, element_type>& __r) throw() {
    return std::addressof(__r);
  }
};





template <class _From, class _To>
using __rebind_pointer_t = typename pointer_traits<_From>::template rebind<_To>::other;




template <class _Pointer, class = void>
struct __to_address_helper;

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* __to_address(_Tp* __p) throw() {
  _Static_assert(!is_function<_Tp>::value, "_Tp is a function type");
  return __p;
}

template <class _Pointer, class = void>
struct _HasToAddress : false_type {};

template <class _Pointer>
struct _HasToAddress<_Pointer, __decltype((void)pointer_traits<_Pointer>::to_address(std::declval<const _Pointer&>())) >
    : true_type {};

template <class _Pointer, class = void>
struct _HasArrow : false_type {};

template <class _Pointer>
struct _HasArrow<_Pointer, __decltype((void)std::declval<const _Pointer&>().operator->()) > : true_type {};

template <class _Pointer>
struct _IsFancyPointer {
  static const bool value = _HasArrow<_Pointer>::value || _HasToAddress<_Pointer>::value;
};


template <class _Pointer, class = __enable_if_t< _And<is_class<_Pointer>, _IsFancyPointer<_Pointer> >::value > >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
    __decay_t<__decltype(__to_address_helper<_Pointer>::__call(std::declval<const _Pointer&>()))>
    __to_address(const _Pointer& __p) throw() {
  return __to_address_helper<_Pointer>::__call(__p);
}

template <class _Pointer, class>
struct __to_address_helper {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static __decltype(std::__to_address( std::declval<const _Pointer&>().operator->()))

  __call(const _Pointer& __p) throw() {
    return std::__to_address(__p.operator->());
  }
};

template <class _Pointer>
struct __to_address_helper<_Pointer,
                           __decltype((void)pointer_traits<_Pointer>::to_address(std::declval<const _Pointer&>()))> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static __decltype(pointer_traits<_Pointer>::to_address( std::declval<const _Pointer&>()))

  __call(const _Pointer& __p) throw() {
    return pointer_traits<_Pointer>::to_address(__p);
  }
};
# 243 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/pointer_traits.h" 3
}}
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 2 3
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 250 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/concepts.h" 3
template <class _Tp>
using __has_random_access_iterator_category_or_concept



    = __has_random_access_iterator_category<_Tp>;


}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_iterator_concept.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_iterator_concept.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_iterator_concept.h" 2 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/advance.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/advance.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/convert_to_integral.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/convert_to_integral.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int __convert_to_integral(int __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned __convert_to_integral(unsigned __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long __convert_to_integral(long __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long __convert_to_integral(unsigned long __val) {
  return __val;
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long long __convert_to_integral(long long __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long long __convert_to_integral(unsigned long long __val) {
  return __val;
}

template <typename _Fp, __enable_if_t<is_floating_point<_Fp>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long long __convert_to_integral(_Fp __val) {
  return __val;
}


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __int128_t __convert_to_integral(__int128_t __val) { return __val; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __uint128_t __convert_to_integral(__uint128_t __val) { return __val; }


template <class _Tp, bool = is_enum<_Tp>::value>
struct __sfinae_underlying_type {
  typedef typename underlying_type<_Tp>::type type;
  typedef __decltype(((type)1) + 0) __promoted_type;
};

template <class _Tp>
struct __sfinae_underlying_type<_Tp, false> {};

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename __sfinae_underlying_type<_Tp>::__promoted_type
__convert_to_integral(_Tp __val) {
  return __val;
}

}}
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/advance.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/unreachable.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/unreachable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

__attribute__((__noreturn__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline void __libcpp_unreachable() {
  ((void)0);
  __builtin_unreachable();
}







}}
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/advance.h" 2 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/advance.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/advance.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__advance(_InputIter& __i, typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag) {
  for (; __n > 0; --__n)
    ++__i;
}

template <class _BiDirIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__advance(_BiDirIter& __i, typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag) {
  if (__n >= 0)
    for (; __n > 0; --__n)
      ++__i;
  else
    for (; __n < 0; ++__n)
      --__i;
}

template <class _RandIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__advance(_RandIter& __i, typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag) {
  __i += __n;
}

template < class _InputIter,
           class _Distance,
           class _IntegralDistance = __decltype(std::__convert_to_integral(std::declval<_Distance>())),
           class = __enable_if_t<is_integral<_IntegralDistance>::value> >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void advance(_InputIter& __i, _Distance __orig_n) {
  typedef typename iterator_traits<_InputIter>::difference_type _Difference;
  _Difference __n = static_cast<_Difference>(std::__convert_to_integral(__orig_n));

  ((void)0);

  std::__advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
}
# 201 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/advance.h" 3
}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/distance.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/distance.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/access.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/access.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/enable_borrowed_range.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/enable_borrowed_range.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/enable_borrowed_range.h" 3
}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/access.h" 2 3




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/auto_cast.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/auto_cast.h" 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/access.h" 2 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/access.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 211 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/access.h" 3
}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/distance.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/concepts.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/concepts.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/data.h" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/data.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 101 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/data.h" 3
}}
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/concepts.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/enable_view.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/enable_view.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/enable_view.h" 3
}}
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/concepts.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/size.h" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/size.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 136 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/size.h" 3
}}
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/concepts.h" 2 3





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/initializer_list" 1 3
# 51 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/initializer_list" 3


namespace std
{
# 97 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/initializer_list" 3
}
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/concepts.h" 2 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/concepts.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 140 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/concepts.h" 3
}}
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/distance.h" 2 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/distance.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename iterator_traits<_InputIter>::difference_type
__distance(_InputIter __first, _InputIter __last, input_iterator_tag) {
  typename iterator_traits<_InputIter>::difference_type __r(0);
  for (; __first != __last; ++__first)
    ++__r;
  return __r;
}

template <class _RandIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename iterator_traits<_RandIter>::difference_type
__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag) {
  return __last - __first;
}

template <class _InputIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename iterator_traits<_InputIter>::difference_type
distance(_InputIter __first, _InputIter __last) {
  return std::__distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
}
# 97 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/distance.h" 3
}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_swap.h" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_swap.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_swap.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 104 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iter_swap.h" 3
}}
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/next.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/next.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIter, __enable_if_t<__has_input_iterator_category<_InputIter>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _InputIter
next(_InputIter __x, typename iterator_traits<_InputIter>::difference_type __n = 1) {


  ((void)0);


  std::advance(__x, __n);
  return __x;
}
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/next.h" 3
}}
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/prev.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/prev.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIter, __enable_if_t<__has_input_iterator_category<_InputIter>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _InputIter
prev(_InputIter __x, typename iterator_traits<_InputIter>::difference_type __n = 1) {


  ((void)0);

  std::advance(__x, -__n);
  return __x;
}
# 74 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/prev.h" 3
}}
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/iterator_operations.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/iterator_operations.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy>
struct _IterOps;
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/iterator_operations.h" 3
struct _ClassicAlgPolicy {};

template <>
struct _IterOps<_ClassicAlgPolicy> {
  template <class _Iter>
  using __value_type = typename iterator_traits<_Iter>::value_type;

  template <class _Iter>
  using __iterator_category = typename iterator_traits<_Iter>::iterator_category;

  template <class _Iter>
  using __difference_type = typename iterator_traits<_Iter>::difference_type;


  template <class _Iter, class _Distance>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static void advance(_Iter& __iter, _Distance __count) {
    std::advance(__iter, __count);
  }


  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static typename iterator_traits<_Iter>::difference_type
  distance(_Iter __first, _Iter __last) {
    return std::distance(__first, __last);
  }

  template <class _Iter>
  using __deref_t = __decltype(*std::declval<_Iter&>());

  template <class _Iter>
  using __move_t = __decltype(std::move(*std::declval<_Iter&>()));

  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static void __validate_iter_reference() {
    _Static_assert(is_same<__deref_t<_Iter>, typename iterator_traits<__remove_cvref_t<_Iter> >::reference>::value, "It looks like your iterator's `iterator_traits<It>::reference` does not match the return type of " "dereferencing the iterator, i.e., calling `*it`. This is undefined behavior according to [input.iterators] " "and can lead to dangling reference issues at runtime, so we are flagging this.");




  }


  template <class _Iter, __enable_if_t<is_reference<__deref_t<_Iter> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static


      __move_t<_Iter>
      __iter_move(_Iter&& __i) {
    __validate_iter_reference<_Iter>();

    return std::move(*std::forward<_Iter>(__i));
  }

  template <class _Iter, __enable_if_t<!is_reference<__deref_t<_Iter> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static



      __deref_t<_Iter>
      __iter_move(_Iter&& __i) {
    __validate_iter_reference<_Iter>();

    return *std::forward<_Iter>(__i);
  }


  template <class _Iter1, class _Iter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static void iter_swap(_Iter1&& __a, _Iter2&& __b) {
    std::iter_swap(std::forward<_Iter1>(__a), std::forward<_Iter2>(__b));
  }


  template <class _Iterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static _Iterator next(_Iterator, _Iterator __last) {
    return __last;
  }

  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static __remove_cvref_t<_Iter>
  next(_Iter&& __it, typename iterator_traits<__remove_cvref_t<_Iter> >::difference_type __n = 1) {
    return std::next(std::forward<_Iter>(__it), __n);
  }


  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static __remove_cvref_t<_Iter>
  prev(_Iter&& __iter, typename iterator_traits<__remove_cvref_t<_Iter> >::difference_type __n = 1) {
    return std::prev(std::forward<_Iter>(__iter), __n);
  }

  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static void __advance_to(_Iter& __first, _Iter __last) {
    __first = __last;
  }
};

}}
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_move_common.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unwrap_iter.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unwrap_iter.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unwrap_iter.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unwrap_iter.h" 3
template <class _Iter, bool = __libcpp_is_contiguous_iterator<_Iter>::value>
struct __unwrap_iter_impl {
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Iter __rewrap(_Iter, _Iter __iter) { return __iter; }
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Iter __unwrap(_Iter __i) throw() { return __i; }
};





template <class _Iter>
struct __unwrap_iter_impl<_Iter, true> {
  using _ToAddressT = __decltype(std::__to_address(std::declval<_Iter>()));

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Iter __rewrap(_Iter __orig_iter, _ToAddressT __unwrapped_iter) {
    return __orig_iter + (__unwrapped_iter - std::__to_address(__orig_iter));
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ToAddressT __unwrap(_Iter __i) throw() {
    return std::__to_address(__i);
  }
};

template <class _Iter,
          class _Impl = __unwrap_iter_impl<_Iter>,
          __enable_if_t<is_copy_constructible<_Iter>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __decltype(_Impl::__unwrap(std::declval<_Iter>()))
__unwrap_iter(_Iter __i) throw() {
  return _Impl::__unwrap(__i);
}
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unwrap_iter.h" 3
template <class _OrigIter, class _Iter, class _Impl = __unwrap_iter_impl<_OrigIter> >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OrigIter __rewrap_iter(_OrigIter __orig_iter, _Iter __iter) throw() {
  return _Impl::__rewrap(std::move(__orig_iter), std::move(__iter));
}

}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_move_common.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unwrap_range.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unwrap_range.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/common_comparison_category.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/common_comparison_category.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/ordering.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/ordering.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 276 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/ordering.h" 3
}}
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/common_comparison_category.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/common_comparison_category.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/common_comparison_category.h" 3
}}
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/synth_three_way.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/synth_three_way.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/three_way_comparable.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/three_way_comparable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 53 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/three_way_comparable.h" 3
}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/synth_three_way.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/synth_three_way.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/synth_three_way.h" 3
}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/different_from.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/different_from.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/different_from.h" 3
}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/array.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/array.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, size_t _Size>
struct array;

}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/get.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/get.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/subrange.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/subrange.h" 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/get.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/tuple.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/tuple.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/tuple.h" 3
}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/get.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_element.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_element.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_indices.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_indices.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/integer_sequence.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/integer_sequence.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <size_t...>
struct __tuple_indices;

template <class _IdxType, _IdxType... _Values>
struct __integer_sequence {
  template <template <class _OIdxType, _OIdxType...> class _ToIndexSeq, class _ToIndexType>
  using __convert = _ToIndexSeq<_ToIndexType, _Values...>;

  template <size_t _Sp>
  using __to_tuple_indices = __tuple_indices<(_Values + _Sp)...>;
};
# 86 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/integer_sequence.h" 3
template <size_t _Ep, size_t _Sp>
using __make_indices_imp =
    typename __make_integer_seq<__integer_sequence, size_t, _Ep - _Sp>::template __to_tuple_indices<_Sp>;
# 151 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/integer_sequence.h" 3
}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_indices.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_indices.h" 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_element.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_types.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_types.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class... _Tp>
struct __tuple_types {};

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_element.h" 2 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_element.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <size_t _Ip, class _Tp>
struct tuple_element;

template <size_t _Ip, class _Tp>
struct tuple_element<_Ip, const _Tp> {
  typedef __attribute__((__nodebug__)) typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
struct tuple_element<_Ip, volatile _Tp> {
  typedef __attribute__((__nodebug__)) typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
struct tuple_element<_Ip, const volatile _Tp> {
  typedef __attribute__((__nodebug__)) typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;
};
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_element.h" 3
}}
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/get.h" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/get.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 47 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/get.h" 3
template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>&) throw();

template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>&) throw();
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/get.h" 3
template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp& get(array<_Tp, _Size>&) throw();

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _Tp& get(const array<_Tp, _Size>&) throw();
# 97 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/get.h" 3
}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/pair_like.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/pair_like.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_like.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_like.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_like.h" 3
}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/pair_like.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_size.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_size.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct tuple_size;
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_size.h" 3
template <class _Tp>
struct tuple_size<const _Tp> : public tuple_size<_Tp> {};
template <class _Tp>
struct tuple_size<volatile _Tp> : public tuple_size<_Tp> {};
template <class _Tp>
struct tuple_size<const volatile _Tp> : public tuple_size<_Tp> {};
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_size.h" 3
}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/pair_like.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/pair_like.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/pair_like.h" 3
}}
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/sfinae_helpers.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/sfinae_helpers.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/make_tuple_types.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/make_tuple_types.h" 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/sfinae_helpers.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_like_ext.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/tuple_like_ext.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __tuple_like_ext : false_type {};

template <class _Tp>
struct __tuple_like_ext<const _Tp> : public __tuple_like_ext<_Tp> {};
template <class _Tp>
struct __tuple_like_ext<volatile _Tp> : public __tuple_like_ext<_Tp> {};
template <class _Tp>
struct __tuple_like_ext<const volatile _Tp> : public __tuple_like_ext<_Tp> {};






template <class _T1, class _T2>
struct __tuple_like_ext<pair<_T1, _T2> > : true_type {};

template <class _Tp, size_t _Size>
struct __tuple_like_ext<array<_Tp, _Size> > : true_type {};

template <class... _Tp>
struct __tuple_like_ext<__tuple_types<_Tp...> > : true_type {};

}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/sfinae_helpers.h" 2 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/sfinae_helpers.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 177 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tuple/sfinae_helpers.h" 3
}}
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 2 3
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/piecewise_construct.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/piecewise_construct.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct piecewise_construct_t {
  explicit piecewise_construct_t() = default;
};







}}
# 53 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 2 3
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class, class>
struct __non_trivially_copyable_base {
                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __non_trivially_copyable_base() throw() {}
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  __non_trivially_copyable_base(__non_trivially_copyable_base const&) throw() {}
};
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 3
template <class _T1, class _T2>
struct pair



{
  using first_type = _T1;
  using second_type = _T2;

  _T1 first;
  _T2 second;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair(pair const&) = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair(pair&&) = default;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair() : first(), second() {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair(_T1 const& __t1, _T2 const& __t2) : first(__t1), second(__t2) {}

  template <class _U1, class _U2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair& operator=(pair const& __p) {
    first = __p.first;
    second = __p.second;
    return *this;
  }




  template <class _U1,
            class _U2,
            class = __enable_if_t< is_assignable<first_type&, _U1 const&>::value &&
                                   is_assignable<second_type&, _U2 const&>::value > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair& operator=(pair<_U1, _U2> const& __p) {
    first = __p.first;
    second = __p.second;
    return *this;
  }
# 478 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(pair& __p)
                                                                                                         {
    using std::swap;
    swap(first, __p.first);
    swap(second, __p.second);
  }
# 494 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 3
private:
# 504 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 3
};
# 513 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 3
template <class _T1, class _T2, class _U1, class _U2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator==(const pair<_T1, _T2>& __x, const pair<_U1, _U2>& __y) {
  return __x.first == __y.first && __x.second == __y.second;
}
# 533 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 3
template <class _T1, class _T2, class _U1, class _U2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator!=(const pair<_T1, _T2>& __x, const pair<_U1, _U2>& __y) {
  return !(__x == __y);
}

template <class _T1, class _T2, class _U1, class _U2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<(const pair<_T1, _T2>& __x, const pair<_U1, _U2>& __y) {
  return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
}

template <class _T1, class _T2, class _U1, class _U2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>(const pair<_T1, _T2>& __x, const pair<_U1, _U2>& __y) {
  return __y < __x;
}

template <class _T1, class _T2, class _U1, class _U2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>=(const pair<_T1, _T2>& __x, const pair<_U1, _U2>& __y) {
  return !(__x < __y);
}

template <class _T1, class _T2, class _U1, class _U2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<=(const pair<_T1, _T2>& __x, const pair<_U1, _U2>& __y) {
  return !(__y < __x);
}
# 581 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 3
template <class _T1, class _T2, __enable_if_t<__is_swappable<_T1>::value && __is_swappable<_T2>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
                                                                                           {
  __x.swap(__y);
}
# 596 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 3
template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
    pair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>
    make_pair(_T1&& __t1, _T2&& __t2) {
  return pair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>(
      std::forward<_T1>(__t1), std::forward<_T2>(__t2));
}

template <class _T1, class _T2>
struct tuple_size<pair<_T1, _T2> > : public integral_constant<size_t, 2> {};

template <size_t _Ip, class _T1, class _T2>
struct tuple_element<_Ip, pair<_T1, _T2> > {
  _Static_assert(_Ip < 2, "Index out of bounds in std::tuple_element<std::pair<T1, T2>>");
};

template <class _T1, class _T2>
struct tuple_element<0, pair<_T1, _T2> > {
  using type __attribute__((__nodebug__)) = _T1;
};

template <class _T1, class _T2>
struct tuple_element<1, pair<_T1, _T2> > {
  using type __attribute__((__nodebug__)) = _T2;
};

template <size_t _Ip>
struct __get_pair;

template <>
struct __get_pair<0> {
  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _T1& get(pair<_T1, _T2>& __p) throw() {
    return __p.first;
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _T1& get(const pair<_T1, _T2>& __p) throw() {
    return __p.first;
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _T1&& get(pair<_T1, _T2>&& __p) throw() {
    return std::forward<_T1>(__p.first);
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _T1&& get(const pair<_T1, _T2>&& __p) throw() {
    return std::forward<const _T1>(__p.first);
  }
};

template <>
struct __get_pair<1> {
  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _T2& get(pair<_T1, _T2>& __p) throw() {
    return __p.second;
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _T2& get(const pair<_T1, _T2>& __p) throw() {
    return __p.second;
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _T2&& get(pair<_T1, _T2>&& __p) throw() {
    return std::forward<_T2>(__p.second);
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _T2&& get(const pair<_T1, _T2>&& __p) throw() {
    return std::forward<const _T2>(__p.second);
  }
};

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>& __p) throw() {
  return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>& __p) throw() {
  return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&& __p) throw() {
  return __get_pair<_Ip>::get(std::move(__p));
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&& __p) throw() {
  return __get_pair<_Ip>::get(std::move(__p));
}
# 738 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/pair.h" 3
}}
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unwrap_range.h" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unwrap_range.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unwrap_range.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unwrap_range.h" 3
template <class _Iter, class _Unwrapped = __decltype(std::__unwrap_iter(std::declval<_Iter>()))>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_Unwrapped, _Unwrapped> __unwrap_range(_Iter __first, _Iter __last) {
  return std::make_pair(std::__unwrap_iter(std::move(__first)), std::__unwrap_iter(std::move(__last)));
}

template <class _Iter, class _Unwrapped>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Iter __rewrap_range(_Iter __orig_iter, _Unwrapped __iter) {
  return std::__rewrap_iter(std::move(__orig_iter), std::move(__iter));
}


}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_move_common.h" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/constexpr_c_functions.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/constexpr_c_functions.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/construct_at.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/construct_at.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/access.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/access.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, size_t _Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* begin(_Tp (&__array)[_Np]) throw() {
  return __array;
}

template <class _Tp, size_t _Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* end(_Tp (&__array)[_Np]) throw() {
  return __array + _Np;
}
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/access.h" 3
template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename _Cp::iterator begin(_Cp& __c) {
  return __c.begin();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename _Cp::const_iterator begin(const _Cp& __c) {
  return __c.begin();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename _Cp::iterator end(_Cp& __c) {
  return __c.end();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename _Cp::const_iterator end(const _Cp& __c) {
  return __c.end();
}



}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/construct_at.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/voidify.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/voidify.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <typename _Tp>
__attribute__((__always_inline__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void* __voidify(_Tp& __from) {

  return const_cast<void*>(static_cast<const volatile void*>(std::addressof(__from)));
}

}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/construct_at.h" 2 3





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 1 3
# 92 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__exception/exception.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__exception/exception.h" 3


namespace std {
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__exception/exception.h" 3
class __attribute__((__visibility__("default"))) exception {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) exception() throw() {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) exception(const exception&) throw() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) exception& operator=(const exception&) throw() = default;

  virtual ~exception() throw();
  virtual const char* what() const throw();
};

class __attribute__((__visibility__("default"))) bad_exception : public exception {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bad_exception() throw() {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bad_exception(const bad_exception&) throw() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bad_exception& operator=(const bad_exception&) throw() = default;
  ~bad_exception() throw() override;
  const char* what() const throw() override;
};


}
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 2 3




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3
# 98 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 2 3
# 106 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 3
# 120 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 3
namespace std
{


struct __attribute__((__visibility__("default"))) nothrow_t {
  explicit nothrow_t() = default;
};
extern __attribute__((__visibility__("default"))) const nothrow_t nothrow;

class __attribute__((__visibility__("default"))) bad_alloc : public exception {
public:
  bad_alloc() throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bad_alloc(const bad_alloc&) throw() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bad_alloc& operator=(const bad_alloc&) throw() = default;
  ~bad_alloc() throw() override;
  const char* what() const throw() override;
};

class __attribute__((__visibility__("default"))) bad_array_new_length : public bad_alloc {
public:
  bad_array_new_length() throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bad_array_new_length(const bad_array_new_length&) throw() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bad_array_new_length& operator=(const bad_array_new_length&) throw() = default;
  ~bad_array_new_length() throw() override;
  const char* what() const throw() override;
};

typedef void (*new_handler)();
__attribute__((__visibility__("default"))) new_handler set_new_handler(new_handler) throw();
__attribute__((__visibility__("default"))) new_handler get_new_handler() throw();
# 171 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 3
__attribute__((__noreturn__)) __attribute__((__visibility__("default"))) void __throw_bad_alloc();

__attribute__((__noreturn__)) inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __throw_bad_array_new_length() {

  throw bad_array_new_length();





}





enum align_val_t { __zero = 0, __max = (size_t)-1 };
# 200 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 3
}
# 239 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 3
                              __attribute__((__visibility__("default"))) void* operator new(std::size_t __sz) throw(std::bad_alloc);
                              __attribute__((__visibility__("default"))) void*
operator new(std::size_t __sz, const std::nothrow_t&) throw() __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete(void* __p) throw();
__attribute__((__visibility__("default"))) void operator delete(void* __p, const std::nothrow_t&) throw();




                              __attribute__((__visibility__("default"))) void* operator new[](std::size_t __sz) throw(std::bad_alloc);
                              __attribute__((__visibility__("default"))) void*
operator new[](std::size_t __sz, const std::nothrow_t&) throw() __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete[](void* __p) throw();
__attribute__((__visibility__("default"))) void operator delete[](void* __p, const std::nothrow_t&) throw();





                              __attribute__((__visibility__("default"))) void*
operator new(std::size_t __sz, std::align_val_t) throw(std::bad_alloc);
                              __attribute__((__visibility__("default"))) void*
operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) throw() __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete(void* __p, std::align_val_t) throw();
__attribute__((__visibility__("default"))) void operator delete(void* __p, std::align_val_t, const std::nothrow_t&) throw();




                              __attribute__((__visibility__("default"))) void*
operator new[](std::size_t __sz, std::align_val_t) throw(std::bad_alloc);
                              __attribute__((__visibility__("default"))) void*
operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) throw() __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t) throw();
__attribute__((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) throw();





                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void* operator new(std::size_t, void* __p) throw() {
  return __p;
}
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void* operator new[](std::size_t, void* __p) throw() {
  return __p;
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator delete(void*, void*) throw() {}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator delete[](void*, void*) throw() {}



namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

                  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __is_overaligned_for_new(size_t __align) throw() {

  return __align > 16UL;



}

template <class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void* __libcpp_operator_new(_Args... __args) {

  return __builtin_operator_new(__args...);



}

template <class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __libcpp_operator_delete(_Args... __args) {

  __builtin_operator_delete(__args...);



}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void* __libcpp_allocate(size_t __size, size_t __align) {







  (void)__align;
  return __libcpp_operator_new(__size);
}

template <class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __do_deallocate_handle_size(void* __ptr, size_t __size, _Args... __args) {

  (void)__size;
  return std::__libcpp_operator_delete(__ptr, __args...);



}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __libcpp_deallocate(void* __ptr, size_t __size, size_t __align) {

  (void)__align;
  return __do_deallocate_handle_size(__ptr, __size);
# 352 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 3
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __libcpp_deallocate_unsized(void* __ptr, size_t __align) {

  (void)__align;
  return __libcpp_operator_delete(__ptr);
# 366 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 3
}

template <class _Tp>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* __launder(_Tp* __p) throw() {
  _Static_assert(!(is_function<_Tp>::value), "can't launder functions");
  _Static_assert(!(is_same<void, __remove_cv_t<_Tp> >::value), "can't launder cv-void");
  return __builtin_launder(__p);
}
# 393 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 3
}}


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdlib" 1 3
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdlib" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3
# 88 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdlib" 2 3
# 99 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdlib" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::size_t __attribute__((__using_if_exists__));
using ::div_t __attribute__((__using_if_exists__));
using ::ldiv_t __attribute__((__using_if_exists__));
using ::lldiv_t __attribute__((__using_if_exists__));
using ::atof __attribute__((__using_if_exists__));
using ::atoi __attribute__((__using_if_exists__));
using ::atol __attribute__((__using_if_exists__));
using ::atoll __attribute__((__using_if_exists__));
using ::strtod __attribute__((__using_if_exists__));
using ::strtof __attribute__((__using_if_exists__));
using ::strtold __attribute__((__using_if_exists__));
using ::strtol __attribute__((__using_if_exists__));
using ::strtoll __attribute__((__using_if_exists__));
using ::strtoul __attribute__((__using_if_exists__));
using ::strtoull __attribute__((__using_if_exists__));
using ::rand __attribute__((__using_if_exists__));
using ::srand __attribute__((__using_if_exists__));
using ::calloc __attribute__((__using_if_exists__));
using ::free __attribute__((__using_if_exists__));
using ::malloc __attribute__((__using_if_exists__));
using ::realloc __attribute__((__using_if_exists__));
using ::abort __attribute__((__using_if_exists__));
using ::atexit __attribute__((__using_if_exists__));
using ::exit __attribute__((__using_if_exists__));
using ::_Exit __attribute__((__using_if_exists__));
using ::getenv __attribute__((__using_if_exists__));
using ::system __attribute__((__using_if_exists__));
using ::bsearch __attribute__((__using_if_exists__));
using ::qsort __attribute__((__using_if_exists__));
using ::abs __attribute__((__using_if_exists__));
using ::labs __attribute__((__using_if_exists__));
using ::llabs __attribute__((__using_if_exists__));
using ::div __attribute__((__using_if_exists__));
using ::ldiv __attribute__((__using_if_exists__));
using ::lldiv __attribute__((__using_if_exists__));
using ::mblen __attribute__((__using_if_exists__));

using ::mbtowc __attribute__((__using_if_exists__));
using ::wctomb __attribute__((__using_if_exists__));
using ::mbstowcs __attribute__((__using_if_exists__));
using ::wcstombs __attribute__((__using_if_exists__));
# 153 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdlib" 3
}}
# 397 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/new" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/construct_at.h" 2 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/construct_at.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/construct_at.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/construct_at.h" 3
template <class _Tp, class... _Args, class = __decltype(::new(std::declval<void*>()) _Tp(std::declval<_Args>()...))>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* __construct_at(_Tp* __location, _Args&&... __args) {



  return ((void)0),
         ::new (const_cast<void*>(static_cast<const volatile void*>(__location))) _Tp(std::forward<_Args>(__args)...);

}






template <class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator __destroy(_ForwardIterator, _ForwardIterator);

template <class _Tp, __enable_if_t<!is_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __destroy_at(_Tp* __loc) {
  ((void)0);
  __loc->~_Tp();
}
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/construct_at.h" 3
template <class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
__destroy(_ForwardIterator __first, _ForwardIterator __last) {
  for (; __first != __last; ++__first)
    std::__destroy_at(std::addressof(*__first));
  return __first;
}

template <class _BidirectionalIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _BidirectionalIterator
__reverse_destroy(_BidirectionalIterator __first, _BidirectionalIterator __last) {
  while (__last != __first) {
    --__last;
    std::__destroy_at(std::addressof(*__last));
  }
  return __last;
}
# 124 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/construct_at.h" 3
}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/datasizeof.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/datasizeof.h" 3








namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __libcpp_datasizeof {
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/datasizeof.h" 3
  template <bool = __libcpp_is_final<_Tp>::value || !is_class<_Tp>::value>
  struct _FirstPaddingByte : _Tp {
    char __first_padding_byte_;
  };

  template <>
  struct _FirstPaddingByte<true> {
    _Tp __v_;
    char __first_padding_byte_;
  };




#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Winvalid-offsetof"
  static const size_t value = __builtin_offsetof(_FirstPaddingByte<>, __first_padding_byte_);
#pragma clang diagnostic pop

};

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_always_bitcastable.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_always_bitcastable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {







template <class _From, class _To>
struct __is_always_bitcastable {
  using _UnqualFrom = __remove_cv_t<_From>;
  using _UnqualTo = __remove_cv_t<_To>;


  static const bool value =

      (is_same<_UnqualFrom, _UnqualTo>::value && is_trivially_copyable<_UnqualFrom>::value) ||
# 74 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_always_bitcastable.h" 3
      (
        sizeof(_From) == sizeof(_To) &&
        is_integral<_From>::value &&
        is_integral<_To>::value &&
        !is_same<_UnqualTo, bool>::value
      );

};

}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_equality_comparable.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_equality_comparable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Up, class = void>
struct __is_equality_comparable : false_type {};

template <class _Tp, class _Up>
struct __is_equality_comparable<_Tp, _Up, __void_t<__decltype(std::declval<_Tp>() == std::declval<_Up>())> > : true_type {
};
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_equality_comparable.h" 3
template <class _Tp, class _Up, class = void>
struct __libcpp_is_trivially_equality_comparable_impl : false_type {};

template <class _Tp>
struct __libcpp_is_trivially_equality_comparable_impl<_Tp, _Tp>

    : integral_constant<bool, __is_trivially_equality_comparable(_Tp) && __is_equality_comparable<_Tp, _Tp>::value> {
};





template <class _Tp, class _Up>
struct __libcpp_is_trivially_equality_comparable_impl<
    _Tp,
    _Up,
    __enable_if_t<is_integral<_Tp>::value && is_integral<_Up>::value && !is_same<_Tp, _Up>::value &&
                  is_signed<_Tp>::value == is_signed<_Up>::value && sizeof(_Tp) == sizeof(_Up)> > : true_type {};

template <class _Tp>
struct __libcpp_is_trivially_equality_comparable_impl<_Tp*, _Tp*> : true_type {};


template <class _Tp, class _Up>
struct __libcpp_is_trivially_equality_comparable_impl<_Tp*, _Up*>
    : integral_constant<
          bool,
          __is_equality_comparable<_Tp*, _Up*>::value &&
              (is_same<__remove_cv_t<_Tp>, __remove_cv_t<_Up> >::value || is_void<_Tp>::value || is_void<_Up>::value)> {
};

template <class _Tp, class _Up>
using __libcpp_is_trivially_equality_comparable =
    __libcpp_is_trivially_equality_comparable_impl<__remove_cv_t<_Tp>, __remove_cv_t<_Up> >;

}}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_lexicographically_comparable.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_lexicographically_comparable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_trivially_lexicographically_comparable.h" 3
template <class _Tp, class _Up>
struct __libcpp_is_trivially_lexicographically_comparable
    : integral_constant<bool,
                        is_same<__remove_cv_t<_Tp>, __remove_cv_t<_Up> >::value && sizeof(_Tp) == 1 &&
                            is_unsigned<_Tp>::value> {};

}}
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/is_pointer_in_range.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/is_pointer_in_range.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/comp.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/comp.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/operation_traits.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/operation_traits.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


struct __equal_tag {};
struct __plus_tag {};
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/operation_traits.h" 3
template <class _CanonicalTag, class _Operation, class... _Args>
struct __desugars_to : false_type {};

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/comp.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/comp.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct __equal_to {
  template <class _T1, class _T2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _T1& __x, const _T2& __y) const {
    return __x == __y;
  }
};

template <class _Tp, class _Up>
struct __desugars_to<__equal_tag, __equal_to, _Tp, _Up> : true_type {};



template <class _T1 = void, class _T2 = _T1>
struct __less {};

template <>
struct __less<void, void> {
  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _Tp& __lhs, const _Up& __rhs) const {
    return __lhs < __rhs;
  }
};

}}
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/is_pointer_in_range.h" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/is_pointer_in_range.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Up, class = void>
struct __is_less_than_comparable : false_type {};

template <class _Tp, class _Up>
struct __is_less_than_comparable<_Tp, _Up, __void_t<__decltype(std::declval<_Tp>() < std::declval<_Up>())> > : true_type {
};

template <class _Tp, class _Up, __enable_if_t<__is_less_than_comparable<const _Tp*, const _Up*>::value, int> = 0>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__no_sanitize__("address"))) bool __is_pointer_in_range(
    const _Tp* __begin, const _Tp* __end, const _Up* __ptr) {
  if (__libcpp_is_constant_evaluated()) {
    ((void)0);



    if (!__builtin_constant_p(__begin <= __ptr && __ptr < __end))
      return false;
  }


  return !__less<>()(__ptr, __begin) && __less<>()(__ptr, __end);
}

template <class _Tp, class _Up, __enable_if_t<!__is_less_than_comparable<const _Tp*, const _Up*>::value, int> = 0>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__no_sanitize__("address"))) bool __is_pointer_in_range(
    const _Tp* __begin, const _Tp* __end, const _Up* __ptr) {
  if (__libcpp_is_constant_evaluated())
    return false;

  return reinterpret_cast<const char*>(__begin) <= reinterpret_cast<const char*>(__ptr) &&
         reinterpret_cast<const char*>(__ptr) < reinterpret_cast<const char*>(__end);
}

}}
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/constexpr_c_functions.h" 2 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/constexpr_c_functions.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



enum class __element_count : size_t {};

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t __constexpr_strlen(const char* __str) {
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/constexpr_c_functions.h" 3
  return __builtin_strlen(__str);
}




template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int
__constexpr_memcmp(const _Tp* __lhs, const _Up* __rhs, __element_count __n) {
  _Static_assert(__libcpp_is_trivially_lexicographically_comparable<_Tp, _Up>::value, "_Tp and _Up have to be trivially lexicographically comparable");


  auto __count = static_cast<size_t>(__n);

  if (__libcpp_is_constant_evaluated()) {

    if (sizeof(_Tp) == 1 && !is_same<_Tp, bool>::value)
      return __builtin_memcmp(__lhs, __rhs, __count * sizeof(_Tp));


    while (__count != 0) {
      if (*__lhs < *__rhs)
        return -1;
      if (*__rhs < *__lhs)
        return 1;

      --__count;
      ++__lhs;
      ++__rhs;
    }
    return 0;
  } else {
    return __builtin_memcmp(__lhs, __rhs, __count * sizeof(_Tp));
  }
}




template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
__constexpr_memcmp_equal(const _Tp* __lhs, const _Up* __rhs, __element_count __n) {
  _Static_assert(__libcpp_is_trivially_equality_comparable<_Tp, _Up>::value, "_Tp and _Up have to be trivially equality comparable");


  auto __count = static_cast<size_t>(__n);

  if (__libcpp_is_constant_evaluated()) {

    if (sizeof(_Tp) == 1 && is_integral<_Tp>::value && !is_same<_Tp, bool>::value)
      return __builtin_memcmp(__lhs, __rhs, __count * sizeof(_Tp)) == 0;

    while (__count != 0) {
      if (*__lhs != *__rhs)
        return false;

      --__count;
      ++__lhs;
      ++__rhs;
    }
    return true;
  } else {
    return __builtin_memcmp(__lhs, __rhs, __count * sizeof(_Tp)) == 0;
  }
}

template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* __constexpr_memchr(_Tp* __str, _Up __value, size_t __count) {
  _Static_assert(sizeof(_Tp) == 1 && __libcpp_is_trivially_equality_comparable<_Tp, _Up>::value, "Calling memchr on non-trivially equality comparable types is unsafe.");


  if (__libcpp_is_constant_evaluated()) {






    for (; __count; --__count) {
      if (*__str == __value)
        return __str;
      ++__str;
    }
    return __nullptr;
  } else {
    char __value_buffer = 0;
    __builtin_memcpy(&__value_buffer, &__value, sizeof(char));
    return static_cast<_Tp*>(__builtin_memchr(__str, __value_buffer, __count));
  }
}
# 150 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/constexpr_c_functions.h" 3
template <class _Tp, class _Up, __enable_if_t<is_assignable<_Tp&, _Up const&>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp& __assign_trivially_copyable(_Tp& __dest, _Up const& __src) {
  __dest = __src;
  return __dest;
}


template <class _Tp, class _Up, __enable_if_t<!is_assignable<_Tp&, _Up const&>::value &&
                                               is_assignable<_Tp&, _Up&&>::value, int> = 0>

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp& __assign_trivially_copyable(_Tp& __dest, _Up& __src) {
  __dest =
      static_cast<_Up&&>(__src);
  return __dest;
}


template <class _Tp, class _Up, __enable_if_t<!is_assignable<_Tp&, _Up const&>::value &&
                                              !is_assignable<_Tp&, _Up&&>::value &&
                                               is_constructible<_Tp, _Up const&>::value, int> = 0>

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp& __assign_trivially_copyable(_Tp& __dest, _Up const& __src) {


  std::__construct_at(std::addressof(__dest), __src);
  return __dest;
}


template <class _Tp, class _Up, __enable_if_t<!is_assignable<_Tp&, _Up const&>::value &&
                                              !is_assignable<_Tp&, _Up&&>::value &&
                                              !is_constructible<_Tp, _Up const&>::value &&
                                               is_constructible<_Tp, _Up&&>::value, int> = 0>

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp& __assign_trivially_copyable(_Tp& __dest, _Up& __src) {


  std::__construct_at(
      std::addressof(__dest),
      static_cast<_Up&&>(__src));
  return __dest;
}

template <class _Tp, class _Up, __enable_if_t<__is_always_bitcastable<_Up, _Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp*
__constexpr_memmove(_Tp* __dest, _Up* __src, __element_count __n) {
  size_t __count = static_cast<size_t>(__n);
  if (__libcpp_is_constant_evaluated()) {

    if (is_same<__remove_cv_t<_Tp>, __remove_cv_t<_Up> >::value) {
      ::__builtin_memmove(__dest, __src, __count * sizeof(_Tp));
      return __dest;
    }

    if (std::__is_pointer_in_range(__src, __src + __count, __dest)) {
      for (; __count > 0; --__count)
        std::__assign_trivially_copyable(__dest[__count - 1], __src[__count - 1]);
    } else {
      for (size_t __i = 0; __i != __count; ++__i)
        std::__assign_trivially_copyable(__dest[__i], __src[__i]);
    }
  } else if (__count > 0) {
    ::__builtin_memmove(__dest, __src, (__count - 1) * sizeof(_Tp) + __libcpp_datasizeof<_Tp>::value);
  }
  return __dest;
}

}}
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_move_common.h" 2 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_move_common.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_move_common.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _From, class _To>
struct __can_lower_copy_assignment_to_memmove {
  static const bool value =

      __is_always_bitcastable<_From, _To>::value &&

      is_trivially_assignable<_To&, const _From&>::value &&

      !is_volatile<_From>::value && !is_volatile<_To>::value;
};

template <class _From, class _To>
struct __can_lower_move_assignment_to_memmove {
  static const bool value =
      __is_always_bitcastable<_From, _To>::value && is_trivially_assignable<_To&, _From&&>::value &&
      !is_volatile<_From>::value && !is_volatile<_To>::value;
};



template <class _In, class _Out>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_In*, _Out*>
__copy_trivial_impl(_In* __first, _In* __last, _Out* __result) {
  const size_t __n = static_cast<size_t>(__last - __first);

  std::__constexpr_memmove(__result, __first, __element_count(__n));

  return std::make_pair(__last, __result + __n);
}

template <class _In, class _Out>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_In*, _Out*>
__copy_backward_trivial_impl(_In* __first, _In* __last, _Out* __result) {
  const size_t __n = static_cast<size_t>(__last - __first);
  __result -= __n;

  std::__constexpr_memmove(__result, __first, __element_count(__n));

  return std::make_pair(__last, __result);
}



template <class _F1, class _F2>
struct __overload : _F1, _F2 {
  using _F1::operator();
  using _F2::operator();
};

template <class _InIter, class _Sent, class _OutIter, class = void>
struct __can_rewrap : false_type {};

template <class _InIter, class _Sent, class _OutIter>
struct __can_rewrap<_InIter,
                    _Sent,
                    _OutIter,

                    __enable_if_t< is_copy_constructible<_InIter>::value && is_copy_constructible<_OutIter>::value > >
    : true_type {};

template <class _Algorithm,
          class _InIter,
          class _Sent,
          class _OutIter,
          __enable_if_t<__can_rewrap<_InIter, _Sent, _OutIter>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InIter, _OutIter>
__unwrap_and_dispatch(_InIter __first, _Sent __last, _OutIter __out_first) {
  auto __range = std::__unwrap_range(__first, std::move(__last));
  auto __result = _Algorithm()(std::move(__range.first), std::move(__range.second), std::__unwrap_iter(__out_first));
  return std::make_pair(std::__rewrap_range<_Sent>(std::move(__first), std::move(__result.first)),
                        std::__rewrap_iter(std::move(__out_first), std::move(__result.second)));
}

template <class _Algorithm,
          class _InIter,
          class _Sent,
          class _OutIter,
          __enable_if_t<!__can_rewrap<_InIter, _Sent, _OutIter>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InIter, _OutIter>
__unwrap_and_dispatch(_InIter __first, _Sent __last, _OutIter __out_first) {
  return _Algorithm()(std::move(__first), std::move(__last), std::move(__out_first));
}

template <class _AlgPolicy,
          class _NaiveAlgorithm,
          class _OptimizedAlgorithm,
          class _InIter,
          class _Sent,
          class _OutIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InIter, _OutIter>
__dispatch_copy_or_move(_InIter __first, _Sent __last, _OutIter __out_first) {
  using _Algorithm = __overload<_NaiveAlgorithm, _OptimizedAlgorithm>;
  return std::__unwrap_and_dispatch<_Algorithm>(std::move(__first), std::move(__last), std::move(__out_first));
}

}}
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each_segment.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each_segment.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/segmented_iterator.h" 1 3
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/segmented_iterator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Iterator>
struct __segmented_iterator_traits;
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/segmented_iterator.h" 3
template <class _Tp, size_t = 0>
struct __has_specialization : false_type {};

template <class _Tp>
struct __has_specialization<_Tp, sizeof(_Tp) * 0> : true_type {};

template <class _Iterator>
using __is_segmented_iterator = __has_specialization<__segmented_iterator_traits<_Iterator> >;

}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each_segment.h" 2 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each_segment.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _SegmentedIterator, class _Functor>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__for_each_segment(_SegmentedIterator __first, _SegmentedIterator __last, _Functor __func) {
  using _Traits = __segmented_iterator_traits<_SegmentedIterator>;

  auto __sfirst = _Traits::__segment(__first);
  auto __slast = _Traits::__segment(__last);


  if (__sfirst == __slast) {
    __func(_Traits::__local(__first), _Traits::__local(__last));
    return;
  }


  __func(_Traits::__local(__first), _Traits::__end(__sfirst));
  ++__sfirst;

  while (__sfirst != __slast) {
    __func(_Traits::__begin(__sfirst), _Traits::__end(__sfirst));
    ++__sfirst;
  }

  __func(_Traits::__begin(__sfirst), _Traits::__local(__last));
}

}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/comp_ref_type.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/comp_ref_type.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Compare>
struct __debug_less {
  _Compare& __comp_;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __debug_less(_Compare& __c) : __comp_(__c) {}

  template <class _Tp, class _Up>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _Tp& __x, const _Up& __y) {
    bool __r = __comp_(__x, __y);
    if (__r)
      __do_compare_assert(0, __y, __x);
    return __r;
  }

  template <class _Tp, class _Up>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(_Tp& __x, _Up& __y) {
    bool __r = __comp_(__x, __y);
    if (__r)
      __do_compare_assert(0, __y, __x);
    return __r;
  }

  template <class _LHS, class _RHS>
                                inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __decltype((void)std::declval<_Compare&>()( std::declval<_LHS&>(), std::declval<_RHS&>()))

  __do_compare_assert(int, _LHS& __l, _RHS& __r) {
    ((void)0);
    (void)__l;
    (void)__r;
  }

  template <class _LHS, class _RHS>
                                inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __do_compare_assert(long, _LHS&, _RHS&) {}
};






template <class _Comp>
using __comp_ref_type = _Comp&;


}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min_element.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min_element.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/identity.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/identity.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/reference_wrapper.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/reference_wrapper.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/weak_result_type.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/weak_result_type.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/binary_function.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/binary_function.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Arg1, class _Arg2, class _Result>
struct binary_function {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;
};



template <class _Arg1, class _Arg2, class _Result>
struct __binary_function_keep_layout_base {

  using first_argument_type = _Arg1;
  using second_argument_type = _Arg2;
  using result_type = _Result;

};


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
template <class _Arg1, class _Arg2, class _Result>
using __binary_function = binary_function<_Arg1, _Arg2, _Result>;
#pragma clang diagnostic pop





}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/weak_result_type.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/unary_function.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/unary_function.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Arg, class _Result>
struct unary_function {
  typedef _Arg argument_type;
  typedef _Result result_type;
};



template <class _Arg, class _Result>
struct __unary_function_keep_layout_base {

  using argument_type = _Arg;
  using result_type = _Result;

};


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
template <class _Arg, class _Result>
using __unary_function = unary_function<_Arg, _Result>;
#pragma clang diagnostic pop





}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/weak_result_type.h" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/weak_result_type.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __has_result_type {
private:
  template <class _Up>
  static false_type __test(...);
  template <class _Up>
  static true_type __test(typename _Up::result_type* = 0);

public:
  static const bool value = __decltype(__test<_Tp>(0))::value;
};



template <class _Tp>
struct __derives_from_unary_function {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  static __two __test(...);
  template <class _Ap, class _Rp>
  static __unary_function<_Ap, _Rp> __test(const volatile __unary_function<_Ap, _Rp>*);

public:
  static const bool value = !is_same<__decltype(__test((_Tp*)0)), __two>::value;
  typedef __decltype(__test((_Tp*)0)) type;
};

template <class _Tp>
struct __derives_from_binary_function {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  static __two __test(...);
  template <class _A1, class _A2, class _Rp>
  static __binary_function<_A1, _A2, _Rp> __test(const volatile __binary_function<_A1, _A2, _Rp>*);

public:
  static const bool value = !is_same<__decltype(__test((_Tp*)0)), __two>::value;
  typedef __decltype(__test((_Tp*)0)) type;
};

template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
struct __maybe_derive_from_unary_function
    : public __derives_from_unary_function<_Tp>::type {};

template <class _Tp>
struct __maybe_derive_from_unary_function<_Tp, false> {};

template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
struct __maybe_derive_from_binary_function
    : public __derives_from_binary_function<_Tp>::type {};

template <class _Tp>
struct __maybe_derive_from_binary_function<_Tp, false> {};

template <class _Tp, bool = __has_result_type<_Tp>::value>
struct __weak_result_type_imp
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp> {

  using result_type __attribute__((__nodebug__)) = typename _Tp::result_type;

};

template <class _Tp>
struct __weak_result_type_imp<_Tp, false>
    : public __maybe_derive_from_unary_function<_Tp>, public __maybe_derive_from_binary_function<_Tp> {};

template <class _Tp>
struct __weak_result_type : public __weak_result_type_imp<_Tp> {};



template <class _Rp>
struct __weak_result_type<_Rp()> {

  using result_type __attribute__((__nodebug__)) = _Rp;

};

template <class _Rp>
struct __weak_result_type<_Rp (&)()> {

  using result_type __attribute__((__nodebug__)) = _Rp;

};

template <class _Rp>
struct __weak_result_type<_Rp (*)()> {

  using result_type __attribute__((__nodebug__)) = _Rp;

};



template <class _Rp, class _A1>
struct __weak_result_type<_Rp(_A1)> : public __unary_function<_A1, _Rp> {};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (&)(_A1)> : public __unary_function<_A1, _Rp> {};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (*)(_A1)> : public __unary_function<_A1, _Rp> {};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)()> : public __unary_function<_Cp*, _Rp> {};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const> : public __unary_function<const _Cp*, _Rp> {};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() volatile> : public __unary_function<volatile _Cp*, _Rp> {};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const volatile> : public __unary_function<const volatile _Cp*, _Rp> {};



template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp(_A1, _A2)> : public __binary_function<_A1, _A2, _Rp> {};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (*)(_A1, _A2)> : public __binary_function<_A1, _A2, _Rp> {};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (&)(_A1, _A2)> : public __binary_function<_A1, _A2, _Rp> {};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1)> : public __binary_function<_Cp*, _A1, _Rp> {};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const> : public __binary_function<const _Cp*, _A1, _Rp> {};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile> : public __binary_function<volatile _Cp*, _A1, _Rp> {};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile> : public __binary_function<const volatile _Cp*, _A1, _Rp> {
};



template <class _Rp, class _A1, class _A2, class _A3, class... _A4>
struct __weak_result_type<_Rp(_A1, _A2, _A3, _A4...)> {

  using result_type __attribute__((__nodebug__)) = _Rp;

};

template <class _Rp, class _A1, class _A2, class _A3, class... _A4>
struct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)> {

  using result_type __attribute__((__nodebug__)) = _Rp;

};

template <class _Rp, class _A1, class _A2, class _A3, class... _A4>
struct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)> {

  using result_type __attribute__((__nodebug__)) = _Rp;

};

template <class _Rp, class _Cp, class _A1, class _A2, class... _A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)> {

  using result_type __attribute__((__nodebug__)) = _Rp;

};

template <class _Rp, class _Cp, class _A1, class _A2, class... _A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const> {

  using result_type __attribute__((__nodebug__)) = _Rp;

};

template <class _Rp, class _Cp, class _A1, class _A2, class... _A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile> {

  using result_type __attribute__((__nodebug__)) = _Rp;

};

template <class _Rp, class _Cp, class _A1, class _A2, class... _A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile> {

  using result_type __attribute__((__nodebug__)) = _Rp;

};

template <class _Tp, class... _Args>
struct __invoke_return {
  typedef __decltype(std::__invoke(std::declval<_Tp>(), std::declval<_Args>()...)) type;
};

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/reference_wrapper.h" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/reference_wrapper.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
class reference_wrapper : public __weak_result_type<_Tp> {
public:

  typedef _Tp type;

private:
  type* __f_;

  static void __fun(_Tp&) throw();
  static void __fun(_Tp&&) = delete;

public:
  template <
      class _Up,
      class = __enable_if_t<!__is_same_uncvref<_Up, reference_wrapper>::value, __decltype(__fun(std::declval<_Up>())) > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference_wrapper(_Up&& __u)
                                                       {
    type& __f = static_cast<_Up&&>(__u);
    __f_ = std::addressof(__f);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) operator type&() const throw() { return *__f_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) type& get() const throw() { return *__f_; }


  template <class... _ArgTypes>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename __invoke_of<type&, _ArgTypes...>::type
  operator()(_ArgTypes&&... __args) const





  {
    return std::__invoke(get(), std::forward<_ArgTypes>(__args)...);
  }
};






template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference_wrapper<_Tp> ref(_Tp& __t) throw() {
  return reference_wrapper<_Tp>(__t);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference_wrapper<_Tp>
ref(reference_wrapper<_Tp> __t) throw() {
  return __t;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference_wrapper<const _Tp> cref(const _Tp& __t) throw() {
  return reference_wrapper<const _Tp>(__t);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference_wrapper<const _Tp>
cref(reference_wrapper<_Tp> __t) throw() {
  return __t;
}

template <class _Tp>
void ref(const _Tp&&) = delete;
template <class _Tp>
void cref(const _Tp&&) = delete;

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/identity.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/identity.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __is_identity : false_type {};

struct __identity {
  template <class _Tp>
                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp&& operator()(_Tp&& __t) const throw() {
    return std::forward<_Tp>(__t);
  }

  using is_transparent = void;
};

template <>
struct __is_identity<__identity> : true_type {};
template <>
struct __is_identity<reference_wrapper<__identity> > : true_type {};
template <>
struct __is_identity<reference_wrapper<const __identity> > : true_type {};
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/identity.h" 3
}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min_element.h" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min_element.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min_element.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Comp, class _Iter, class _Sent, class _Proj>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Iter
__min_element(_Iter __first, _Sent __last, _Comp __comp, _Proj& __proj) {
  if (__first == __last)
    return __first;

  _Iter __i = __first;
  while (++__i != __last)
    if (std::__invoke(__comp, std::__invoke(__proj, *__i), std::__invoke(__proj, *__first)))
      __first = __i;

  return __first;
}

template <class _Comp, class _Iter, class _Sent>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Iter __min_element(_Iter __first, _Sent __last, _Comp __comp) {
  auto __proj = __identity();
  return std::__min_element<_Comp>(std::move(__first), std::move(__last), __comp, __proj);
}

template <class _ForwardIterator, class _Compare>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
  _Static_assert(__has_forward_iterator_category<_ForwardIterator>::value, "std::min_element requires a ForwardIterator");

  _Static_assert(__is_callable<_Compare, __decltype(*__first), __decltype(*__first)>::value, "The comparator has to be callable");


  return std::__min_element<__comp_ref_type<_Compare> >(std::move(__first), std::move(__last), __comp);
}

template <class _ForwardIterator>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last) {
  return std::min_element(__first, __last, __less<>());
}

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Compare>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _Tp&
min( const _Tp& __a, const _Tp& __b, _Compare __comp) {
  return __comp(__b, __a) ? __b : __a;
}

template <class _Tp>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _Tp&
min( const _Tp& __a, const _Tp& __b) {
  return std::min(__a, __b, __less<>());
}
# 54 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min.h" 3
}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy.h" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class, class _InIter, class _Sent, class _OutIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InIter, _OutIter> __copy(_InIter, _Sent, _OutIter);

template <class _AlgPolicy>
struct __copy_loop {
  template <class _InIter, class _Sent, class _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    while (__first != __last) {
      *__result = *__first;
      ++__first;
      ++__result;
    }

    return std::make_pair(std::move(__first), std::move(__result));
  }

  template <class _InIter, class _OutIter>
  struct _CopySegment {
    using _Traits = __segmented_iterator_traits<_InIter>;

    _OutIter& __result_;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit _CopySegment(_OutIter& __result)
        : __result_(__result) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
    operator()(typename _Traits::__local_iterator __lfirst, typename _Traits::__local_iterator __llast) {
      __result_ = std::__copy<_AlgPolicy>(__lfirst, __llast, std::move(__result_)).second;
    }
  };

  template <class _InIter, class _OutIter, __enable_if_t<__is_segmented_iterator<_InIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    std::__for_each_segment(__first, __last, _CopySegment<_InIter, _OutIter>(__result));
    return std::make_pair(__last, std::move(__result));
  }

  template <class _InIter,
            class _OutIter,
            __enable_if_t<__has_random_access_iterator_category<_InIter>::value &&
                              !__is_segmented_iterator<_InIter>::value && __is_segmented_iterator<_OutIter>::value,
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    using _Traits = __segmented_iterator_traits<_OutIter>;
    using _DiffT = typename common_type<__iter_diff_t<_InIter>, __iter_diff_t<_OutIter> >::type;

    if (__first == __last)
      return std::make_pair(std::move(__first), std::move(__result));

    auto __local_first = _Traits::__local(__result);
    auto __segment_iterator = _Traits::__segment(__result);
    while (true) {
      auto __local_last = _Traits::__end(__segment_iterator);
      auto __size = std::min<_DiffT>(__local_last - __local_first, __last - __first);
      auto __iters = std::__copy<_AlgPolicy>(__first, __first + __size, __local_first);
      __first = std::move(__iters.first);

      if (__first == __last)
        return std::make_pair(std::move(__first), _Traits::__compose(__segment_iterator, std::move(__iters.second)));

      __local_first = _Traits::__begin(++__segment_iterator);
    }
  }
};

struct __copy_trivial {

  template <class _In, class _Out, __enable_if_t<__can_lower_copy_assignment_to_memmove<_In, _Out>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_In*, _Out*>
  operator()(_In* __first, _In* __last, _Out* __result) const {
    return std::__copy_trivial_impl(__first, __last, __result);
  }
};

template <class _AlgPolicy, class _InIter, class _Sent, class _OutIter>
pair<_InIter, _OutIter> inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
__copy(_InIter __first, _Sent __last, _OutIter __result) {
  return std::__dispatch_copy_or_move<_AlgPolicy, __copy_loop<_AlgPolicy>, __copy_trivial>(
      std::move(__first), std::move(__last), std::move(__result));
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator
copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result) {
  return std::__copy<_ClassicAlgPolicy>(__first, __last, __result).second;
}

}}
# 309 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/equal.h" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/equal.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/equal.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
                  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __equal_iter_impl(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate& __pred) {
  for (; __first1 != __last1; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      return false;
  return true;
}

template <class _Tp,
          class _Up,
          class _BinaryPredicate,
          __enable_if_t<__desugars_to<__equal_tag, _BinaryPredicate, _Tp, _Up>::value && !is_volatile<_Tp>::value &&
                            !is_volatile<_Up>::value && __libcpp_is_trivially_equality_comparable<_Tp, _Up>::value,
                        int> = 0>
                  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
__equal_iter_impl(_Tp* __first1, _Tp* __last1, _Up* __first2, _BinaryPredicate&) {
  return std::__constexpr_memcmp_equal(__first1, __first2, __element_count(__last1 - __first1));
}

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred) {
  return std::__equal_iter_impl(
      std::__unwrap_iter(__first1), std::__unwrap_iter(__last1), std::__unwrap_iter(__first2), __pred);
}

template <class _InputIterator1, class _InputIterator2>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2) {
  return std::equal(__first1, __last1, __first2, __equal_to());
}
# 166 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/equal.h" 3
}}
# 310 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/fill_n.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/fill_n.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator
__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value) {
  for (; __n > 0; ++__first, (void)--__n)
    *__first = __value;
  return __first;
}

template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator
fill_n(_OutputIterator __first, _Size __n, const _Tp& __value) {
  return std::__fill_n(__first, std::__convert_to_integral(__n), __value);
}

}}
# 311 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lexicographical_compare.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lexicographical_compare.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Compare, class _InputIterator1, class _InputIterator2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __lexicographical_compare(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _Compare __comp) {
  for (; __first2 != __last2; ++__first1, (void)++__first2) {
    if (__first1 == __last1 || __comp(*__first1, *__first2))
      return true;
    if (__comp(*__first2, *__first1))
      return false;
  }
  return false;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool lexicographical_compare(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _Compare __comp) {
  return std::__lexicographical_compare<__comp_ref_type<_Compare> >(__first1, __last1, __first2, __last2, __comp);
}

template <class _InputIterator1, class _InputIterator2>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool lexicographical_compare(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) {
  return std::lexicographical_compare(__first1, __last1, __first2, __last2, __less<>());
}

}}
# 313 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/three_way_comp_ref_type.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/three_way_comp_ref_type.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/three_way_comp_ref_type.h" 3
}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/compare_three_way.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/compare_three_way.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/compare_three_way.h" 3
}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 2 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 121 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lexicographical_compare_three_way.h" 3
}}
# 314 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_segment_if.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_segment_if.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {







template <class _SegmentedIterator, class _Pred, class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _SegmentedIterator
__find_segment_if(_SegmentedIterator __first, _SegmentedIterator __last, _Pred __pred, _Proj& __proj) {
  using _Traits = __segmented_iterator_traits<_SegmentedIterator>;

  auto __sfirst = _Traits::__segment(__first);
  auto __slast = _Traits::__segment(__last);


  if (__sfirst == __slast)
    return _Traits::__compose(__sfirst, __pred(_Traits::__local(__first), _Traits::__local(__last), __proj));

  {
    auto __llast = _Traits::__end(__sfirst);
    auto __liter = __pred(_Traits::__local(__first), __llast, __proj);
    if (__liter != __llast)
      return _Traits::__compose(__sfirst, __liter);
  }
  ++__sfirst;


  while (__sfirst != __slast) {
    auto __llast = _Traits::__end(__sfirst);
    auto __liter = __pred(_Traits::__begin(__sfirst), _Traits::__end(__sfirst), __proj);
    if (__liter != __llast)
      return _Traits::__compose(__sfirst, __liter);
    ++__sfirst;
  }


  return _Traits::__compose(__sfirst, __pred(_Traits::__begin(__sfirst), _Traits::__local(__last), __proj));
}

}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/countr.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/countr.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/rotate.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/rotate.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp __rotr(_Tp __t, int __cnt) throw() {
  _Static_assert(__libcpp_is_unsigned_integer<_Tp>::value, "__rotr requires an unsigned integer type");
  const unsigned int __dig = numeric_limits<_Tp>::digits;
  if ((__cnt % __dig) == 0)
    return __t;

  if (__cnt < 0) {
    __cnt *= -1;
    return (__t << (__cnt % __dig)) | (__t >> (__dig - (__cnt % __dig)));
  }

  return (__t >> (__cnt % __dig)) | (__t << (__dig - (__cnt % __dig)));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp __rotl(_Tp __t, int __cnt) throw() {
  return std::__rotr(__t, -__cnt);
}
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/rotate.h" 3
}}
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/countr.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/countr.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/countr.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

                  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int __libcpp_ctz(unsigned __x) throw() {
  return __builtin_ctz(__x);
}

                  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int __libcpp_ctz(unsigned long __x) throw() {
  return __builtin_ctzl(__x);
}

                  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int __libcpp_ctz(unsigned long long __x) throw() {
  return __builtin_ctzll(__x);
}
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/countr.h" 3
}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/invert_if.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/invert_if.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <bool _Invert, class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp __invert_if(_Tp __v) {
  if (_Invert)
    return ~__v;
  return __v;
}

}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find.h" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/bit_reference.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/bit_reference.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0>
class __bit_iterator;

}}
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find.h" 2 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwchar" 1 3
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwchar" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwctype" 1 3
# 54 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwctype" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cctype" 1 3
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cctype" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ctype.h" 1 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ctype.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/ctype.h" 1 3 4
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/ctype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_ctype.h" 1 3 4
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_ctype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/runetype.h" 1 3 4
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/runetype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 47 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/runetype.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/runetype.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_wint_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_wint_t.h" 3 4
typedef __darwin_wint_t wint_t;
# 51 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/runetype.h" 2 3 4
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/runetype.h" 3 4
typedef struct {
 __darwin_rune_t __min;
 __darwin_rune_t __max;
 __darwin_rune_t __map;
 __uint32_t *__types;
} _RuneEntry;

typedef struct {
 int __nranges;
 _RuneEntry *__ranges;
} _RuneRange;

typedef struct {
 char __name[14];
 __uint32_t __mask;
} _RuneCharClass;

typedef struct {
 char __magic[8];
 char __encoding[32];

 __darwin_rune_t (*__sgetrune)(const char *, __darwin_size_t, char const **);
 int (*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
 __darwin_rune_t __invalid_rune;

 __uint32_t __runetype[(1 <<8 )];
 __darwin_rune_t __maplower[(1 <<8 )];
 __darwin_rune_t __mapupper[(1 <<8 )];






 _RuneRange __runetype_ext;
 _RuneRange __maplower_ext;
 _RuneRange __mapupper_ext;

 void *__variable;
 int __variable_len;




 int __ncharclasses;
 _RuneCharClass *__charclasses;
} _RuneLocale;



extern "C" {
extern _RuneLocale _DefaultRuneLocale;
extern _RuneLocale *_CurrentRuneLocale;
}
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_ctype.h" 2 3 4
# 130 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_ctype.h" 3 4
extern "C" {
unsigned long ___runetype(__darwin_ct_rune_t);
__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t);
__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t);
}

inline int
isascii(int _c)
{
 return ((_c & ~0x7F) == 0);
}
# 149 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_ctype.h" 3 4
extern "C" {
int __maskrune(__darwin_ct_rune_t, unsigned long);
}


inline int
__istype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] & _f)
  : !!__maskrune(_c, _f));

}

inline __darwin_ct_rune_t
__isctype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (_c < 0 || _c >= (1 <<8 )) ? 0 :
  !!(_DefaultRuneLocale.__runetype[_c] & _f);

}
# 189 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_ctype.h" 3 4
extern "C" {
__darwin_ct_rune_t __toupper(__darwin_ct_rune_t);
__darwin_ct_rune_t __tolower(__darwin_ct_rune_t);
}


inline int
__wcwidth(__darwin_ct_rune_t _c)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune(_c, 0xe0000000L|0x00040000L);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}






inline int
isalnum(int _c)
{
 return (__istype(_c, 0x00000100L|0x00000400L));
}

inline int
isalpha(int _c)
{
 return (__istype(_c, 0x00000100L));
}

inline int
isblank(int _c)
{
 return (__istype(_c, 0x00020000L));
}

inline int
iscntrl(int _c)
{
 return (__istype(_c, 0x00000200L));
}


inline int
isdigit(int _c)
{
 return (__isctype(_c, 0x00000400L));
}

inline int
isgraph(int _c)
{
 return (__istype(_c, 0x00000800L));
}

inline int
islower(int _c)
{
 return (__istype(_c, 0x00001000L));
}

inline int
isprint(int _c)
{
 return (__istype(_c, 0x00040000L));
}

inline int
ispunct(int _c)
{
 return (__istype(_c, 0x00002000L));
}

inline int
isspace(int _c)
{
 return (__istype(_c, 0x00004000L));
}

inline int
isupper(int _c)
{
 return (__istype(_c, 0x00008000L));
}


inline int
isxdigit(int _c)
{
 return (__isctype(_c, 0x00010000L));
}

inline int
toascii(int _c)
{
 return (_c & 0x7F);
}

inline int
tolower(int _c)
{
        return (__tolower(_c));
}

inline int
toupper(int _c)
{
        return (__toupper(_c));
}


inline int
digittoint(int _c)
{
 return (__maskrune(_c, 0x0F));
}

inline int
ishexnumber(int _c)
{
 return (__istype(_c, 0x00010000L));
}

inline int
isideogram(int _c)
{
 return (__istype(_c, 0x00080000L));
}

inline int
isnumber(int _c)
{
 return (__istype(_c, 0x00000400L));
}

inline int
isphonogram(int _c)
{
 return (__istype(_c, 0x00200000L));
}

inline int
isrune(int _c)
{
 return (__istype(_c, 0xFFFFFFF0L));
}

inline int
isspecial(int _c)
{
 return (__istype(_c, 0x00100000L));
}
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/ctype.h" 2 3 4
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ctype.h" 2 3
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cctype" 2 3
# 51 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cctype" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cctype" 3
using ::isalnum __attribute__((__using_if_exists__));
using ::isalpha __attribute__((__using_if_exists__));
using ::isblank __attribute__((__using_if_exists__));
using ::iscntrl __attribute__((__using_if_exists__));
using ::isdigit __attribute__((__using_if_exists__));
using ::isgraph __attribute__((__using_if_exists__));
using ::islower __attribute__((__using_if_exists__));
using ::isprint __attribute__((__using_if_exists__));
using ::ispunct __attribute__((__using_if_exists__));
using ::isspace __attribute__((__using_if_exists__));
using ::isupper __attribute__((__using_if_exists__));
using ::isxdigit __attribute__((__using_if_exists__));
using ::tolower __attribute__((__using_if_exists__));
using ::toupper __attribute__((__using_if_exists__));

}}
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwctype" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wctype.h" 1 3
# 56 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wctype.h" 3
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wctype.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wctype.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wctype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wctype.h" 1 3 4
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wctype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_wctrans_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_wctrans_t.h" 3 4
typedef __darwin_wctrans_t wctrans_t;
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wctype.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/__wctype.h" 1 3 4
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/__wctype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/___wctype.h" 1 3 4
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/___wctype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_wctype_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_wctype_t.h" 3 4
typedef __darwin_wctype_t wctype_t;
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/___wctype.h" 2 3 4
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/___wctype.h" 3 4
inline int
iswalnum(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L|0x00000400L));
}

inline int
iswalpha(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L));
}

inline int
iswcntrl(wint_t _wc)
{
 return (__istype(_wc, 0x00000200L));
}

inline int
iswctype(wint_t _wc, wctype_t _charclass)
{
 return (__istype(_wc, _charclass));
}

inline int
iswdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00000400L));
}

inline int
iswgraph(wint_t _wc)
{
 return (__istype(_wc, 0x00000800L));
}

inline int
iswlower(wint_t _wc)
{
 return (__istype(_wc, 0x00001000L));
}

inline int
iswprint(wint_t _wc)
{
 return (__istype(_wc, 0x00040000L));
}

inline int
iswpunct(wint_t _wc)
{
 return (__istype(_wc, 0x00002000L));
}

inline int
iswspace(wint_t _wc)
{
 return (__istype(_wc, 0x00004000L));
}

inline int
iswupper(wint_t _wc)
{
 return (__istype(_wc, 0x00008000L));
}

inline int
iswxdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00010000L));
}

inline wint_t
towlower(wint_t _wc)
{
  return (__tolower(_wc));
}

inline wint_t
towupper(wint_t _wc)
{
  return (__toupper(_wc));
}
# 185 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/___wctype.h" 3 4
extern "C" {
wctype_t
 wctype(const char *);
}
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/__wctype.h" 2 3 4
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wctype.h" 2 3 4








inline int
iswblank(wint_t _wc)
{
 return (__istype(_wc, 0x00020000L));
}


inline int
iswascii(wint_t _wc)
{
 return ((_wc & ~0x7F) == 0);
}

inline int
iswhexnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00010000L));
}

inline int
iswideogram(wint_t _wc)
{
 return (__istype(_wc, 0x00080000L));
}

inline int
iswnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00000400L));
}

inline int
iswphonogram(wint_t _wc)
{
 return (__istype(_wc, 0x00200000L));
}

inline int
iswrune(wint_t _wc)
{
 return (__istype(_wc, 0xFFFFFFF0L));
}

inline int
iswspecial(wint_t _wc)
{
 return (__istype(_wc, 0x00100000L));
}
# 117 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wctype.h" 3 4
extern "C" {

wint_t nextwctype(wint_t, wctype_t);

wint_t towctrans(wint_t, wctrans_t);
wctrans_t
 wctrans(const char *);
}
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wctype.h" 2 3 4
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wctype.h" 2 3
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwctype" 2 3
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwctype" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


using ::wint_t __attribute__((__using_if_exists__));
using ::wctrans_t __attribute__((__using_if_exists__));
using ::wctype_t __attribute__((__using_if_exists__));
using ::iswalnum __attribute__((__using_if_exists__));
using ::iswalpha __attribute__((__using_if_exists__));
using ::iswblank __attribute__((__using_if_exists__));
using ::iswcntrl __attribute__((__using_if_exists__));
using ::iswdigit __attribute__((__using_if_exists__));
using ::iswgraph __attribute__((__using_if_exists__));
using ::iswlower __attribute__((__using_if_exists__));
using ::iswprint __attribute__((__using_if_exists__));
using ::iswpunct __attribute__((__using_if_exists__));
using ::iswspace __attribute__((__using_if_exists__));
using ::iswupper __attribute__((__using_if_exists__));
using ::iswxdigit __attribute__((__using_if_exists__));
using ::iswctype __attribute__((__using_if_exists__));
using ::wctype __attribute__((__using_if_exists__));
using ::towlower __attribute__((__using_if_exists__));
using ::towupper __attribute__((__using_if_exists__));
using ::towctrans __attribute__((__using_if_exists__));
using ::wctrans __attribute__((__using_if_exists__));


}}
# 113 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwchar" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wchar.h" 1 3
# 109 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wchar.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 1 3
# 82 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_ptrdiff_t.h" 1 3
# 83 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3




# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_size_t.h" 1 3
# 88 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3




# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_rsize_t.h" 1 3
# 93 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3




# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_wchar_t.h" 1 3
# 98 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3
# 107 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_nullptr_t.h" 1 3
# 108 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3
# 122 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_offsetof.h" 1 3
# 123 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 2 3
# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wchar.h" 2 3
# 118 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wchar.h" 3
# 127 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wchar.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wchar.h" 1 3 4
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wchar.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wchar.h" 1 3 4
# 74 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wchar.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_null.h" 1 3 4
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wchar.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wchar.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_mbstate_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_mbstate_t.h" 3 4
typedef __darwin_mbstate_t mbstate_t;
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wchar.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wchar.h" 2 3 4
# 89 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wchar.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stdarg.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stdarg.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stdarg_header_macro.h" 1 3 4
# 38 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stdarg.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stdarg___gnuc_va_list.h" 1 3 4
# 12 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stdarg___gnuc_va_list.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 42 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stdarg.h" 2 3 4




# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stdarg_va_list.h" 1 3 4
# 12 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stdarg_va_list.h" 3 4
typedef __builtin_va_list va_list;
# 47 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stdarg.h" 2 3 4




# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stdarg_va_arg.h" 1 3 4
# 52 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stdarg.h" 2 3 4




# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stdarg___va_copy.h" 1 3 4
# 57 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stdarg.h" 2 3 4




# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stdarg_va_copy.h" 1 3 4
# 62 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stdarg.h" 2 3 4
# 90 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wchar.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdio.h" 1 3 4
# 105 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdio.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 1 3 4
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 1 3 4
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_va_list.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_va_list.h" 3 4
typedef __darwin_va_list va_list;
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_null.h" 1 3 4
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/stdio.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/stdio.h" 3 4
extern "C" {

int renameat(int, const char *, int, const char *) __attribute__((availability(macosx,introduced=10.10)));



int renamex_np(const char *, const char *, unsigned int) __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)));
int renameatx_np(int, const char *, int, const char *, unsigned int) __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)));



}
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_printf.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_printf.h" 3 4
extern "C" {
int printf(const char * , ...) __attribute__((__format__ (__printf__, 1, 2)));
}
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 2 3 4

typedef __darwin_off_t fpos_t;
# 94 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 3 4
struct __sbuf {
 unsigned char *_base;
 int _size;
};


struct __sFILEX;
# 128 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 3 4
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (* _Nullable _close)(void *);
 int (* _Nullable _read) (void *, char *, int);
 fpos_t (* _Nullable _seek) (void *, fpos_t, int);
 int (* _Nullable _write)(void *, const char *, int);


 struct __sbuf _ub;
 struct __sFILEX *_extra;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;
} FILE;

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_seek_set.h" 1 3 4
# 162 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 2 3 4

extern "C" {
extern FILE *__stdinp __attribute__((__swift_attr__("nonisolated(unsafe)")));
extern FILE *__stdoutp __attribute__((__swift_attr__("nonisolated(unsafe)")));
extern FILE *__stderrp __attribute__((__swift_attr__("nonisolated(unsafe)")));
}
# 228 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 3 4
extern "C" {
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE * , fpos_t *);
char *fgets(char * , int, FILE *);



FILE *fopen(const char * __filename, const char * __mode) __asm("_" "fopen" );

int fprintf(FILE * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int fputc(int, FILE *);
int fputs(const char * , FILE * ) __asm("_" "fputs" );
size_t fread(void * __ptr, size_t __size, size_t __nitems, FILE * __stream);
FILE *freopen(const char * , const char * ,
     FILE * ) __asm("_" "freopen" );
int fscanf(FILE * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void * __ptr, size_t __size, size_t __nitems, FILE * __stream) __asm("_" "fwrite" );
int getc(FILE *);
int getchar(void);


__attribute__((__deprecated__("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of gets(3), it is highly recommended that you use fgets(3) instead.")))

char *gets(char *);

void perror(const char *) __attribute__((__cold__));
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename (const char *__old, const char *__new);
void rewind(FILE *);
int scanf(const char * , ...) __attribute__((__format__ (__scanf__, 1, 2)));
void setbuf(FILE * , char * );
int setvbuf(FILE * , char * , int, size_t);

__attribute__((__availability__(swift, unavailable, message="Use snprintf instead.")))

__attribute__((__deprecated__("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of sprintf(3), it is highly recommended that you use snprintf(3) instead.")))

int sprintf(char * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));

int sscanf(const char * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
FILE *tmpfile(void);

__attribute__((__availability__(swift, unavailable, message="Use mkstemp(3) instead.")))

__attribute__((__deprecated__("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tmpnam(3), it is highly recommended that you use mkstemp(3) instead.")))

char *tmpnam(char *);

int ungetc(int, FILE *);
int vfprintf(FILE * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
int vprintf(const char * , va_list) __attribute__((__format__ (__printf__, 1, 0)));

__attribute__((__availability__(swift, unavailable, message="Use vsnprintf instead.")))

__attribute__((__deprecated__("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of sprintf(3), it is highly recommended that you use vsnprintf(3) instead.")))

int vsprintf(char * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
}
# 307 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_ctermid.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_ctermid.h" 3 4
extern "C" {

char *ctermid(char *);

}
# 308 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 2 3 4

extern "C" {




FILE *fdopen(int, const char *) __asm("_" "fdopen" );

int fileno(FILE *);
}
# 326 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 3 4
extern "C" {
int pclose(FILE *) __attribute__((__availability__(swift, unavailable, message="Use posix_spawn APIs or NSTask instead. (On iOS, process spawning is unavailable.)")));



FILE *popen(const char *, const char *) __asm("_" "popen" ) __attribute__((__availability__(swift, unavailable, message="Use posix_spawn APIs or NSTask instead. (On iOS, process spawning is unavailable.)")));

}
# 345 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 3 4
extern "C" {
int __srget(FILE *);
int __svfscanf(FILE *, const char *, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int __swbuf(int, FILE *);
}







inline __attribute__ ((__always_inline__)) int __sputc(int _c, FILE *_p) {
 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf(_c, _p));
}
# 382 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 3 4
extern "C" {
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);



int getw(FILE *);
int putw(int, FILE *);


__attribute__((__availability__(swift, unavailable, message="Use mkstemp(3) instead.")))

__attribute__((__deprecated__("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tempnam(3), it is highly recommended that you use mkstemp(3) instead.")))

char *tempnam(const char *__dir, const char *__prefix) __asm("_" "tempnam" );
}
# 421 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_off_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_off_t.h" 3 4
typedef __darwin_off_t off_t;
# 422 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 2 3 4

extern "C" {
int fseeko(FILE * __stream, off_t __offset, int __whence);
off_t ftello(FILE * __stream);
}



extern "C" {
int snprintf(char * __str, size_t __size, const char * __format, ...) __attribute__((__format__ (__printf__, 3, 4)));
int vfscanf(FILE * __stream, const char * __format, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int vscanf(const char * __format, va_list) __attribute__((__format__ (__scanf__, 1, 0)));
int vsnprintf(char * __str, size_t __size, const char * __format, va_list) __attribute__((__format__ (__printf__, 3, 0)));
int vsscanf(const char * __str, const char * __format, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
}
# 446 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ssize_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ssize_t.h" 3 4
typedef __darwin_ssize_t ssize_t;
# 447 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 2 3 4

extern "C" {
int dprintf(int, const char * , ...) __attribute__((__format__ (__printf__, 2, 3))) __attribute__((availability(macosx,introduced=10.7)));
int vdprintf(int, const char * , va_list) __attribute__((__format__ (__printf__, 2, 0))) __attribute__((availability(macosx,introduced=10.7)));
ssize_t getdelim(char ** __linep, size_t * __linecapp, int __delimiter, FILE * __stream) __attribute__((availability(macosx,introduced=10.7)));
ssize_t getline(char ** __linep, size_t * __linecapp, FILE * __stream) __attribute__((availability(macosx,introduced=10.7)));
FILE *fmemopen(void * __buf, size_t __size, const char * __mode) __attribute__((availability(macos,introduced=10.13))) __attribute__((availability(ios,introduced=11.0))) __attribute__((availability(tvos,introduced=11.0))) __attribute__((availability(watchos,introduced=4.0)));
FILE *open_memstream(char **__bufp, size_t *__sizep) __attribute__((availability(macos,introduced=10.13))) __attribute__((availability(ios,introduced=11.0))) __attribute__((availability(tvos,introduced=11.0))) __attribute__((availability(watchos,introduced=4.0)));
}







extern "C" {
extern const int sys_nerr;
extern const char *const sys_errlist[];

int asprintf(char ** , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
char *ctermid_r(char *);
char *fgetln(FILE *, size_t *);
const char *fmtcheck(const char *, const char *) __attribute__((format_arg(2)));
int fpurge(FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);
int vasprintf(char ** , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));





FILE *funopen(const void *,
     int (* _Nullable)(void *, char *, int),
     int (* _Nullable)(void *, const char *, int),
     fpos_t (* _Nullable)(void *, fpos_t, int),
     int (* _Nullable)(void *));
}
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/stdio.h" 2 3 4
# 109 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdio.h" 2 3
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wchar.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 1 3 4
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_time.h" 1 3 4
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_time.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_clock_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_clock_t.h" 3 4
typedef __darwin_clock_t clock_t;
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_null.h" 1 3 4
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_time_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_time_t.h" 3 4
typedef __darwin_time_t time_t;
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_timespec.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_timespec.h" 3 4
struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};
# 74 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_time.h" 2 3 4

struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 char *tm_zone;
};
# 98 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_time.h" 3 4
extern char *tzname[];


extern int getdate_err;

extern long timezone __asm("_" "timezone" );

extern int daylight;

extern "C" {
char *asctime(const struct tm *);
clock_t clock(void) __asm("_" "clock" );
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_" "mktime" );
size_t strftime(char * , size_t, const char * , const struct tm * ) __asm("_" "strftime" );
char *strptime(const char * , const char * , struct tm * ) __asm("_" "strptime" );
time_t time(time_t *);


void tzset(void);



char *asctime_r(const struct tm * , char * );
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t * , struct tm * );
struct tm *localtime_r(const time_t * , struct tm * );


time_t posix2time(time_t);



void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm * const);
time_t timegm(struct tm * const);



int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp) __asm("_" "nanosleep" );
# 153 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_time.h" 3 4
typedef enum {
_CLOCK_REALTIME __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 0,

_CLOCK_MONOTONIC __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 6,


_CLOCK_MONOTONIC_RAW __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 4,

_CLOCK_MONOTONIC_RAW_APPROX __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 5,

_CLOCK_UPTIME_RAW __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 8,

_CLOCK_UPTIME_RAW_APPROX __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 9,


_CLOCK_PROCESS_CPUTIME_ID __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 12,

_CLOCK_THREAD_CPUTIME_ID __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 16

} clockid_t;

__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)))
int clock_getres(clockid_t __clock_id, struct timespec *__res);

__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)))
int clock_gettime(clockid_t __clock_id, struct timespec *__tp);


__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)))
__uint64_t clock_gettime_nsec_np(clockid_t __clock_id);


__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,unavailable)))
__attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable)))
int clock_settime(clockid_t __clock_id, const struct timespec *__tp);
# 198 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_time.h" 3 4
__attribute__((availability(macos,introduced=10.15))) __attribute__((availability(ios,introduced=13.0))) __attribute__((availability(tvos,introduced=13.0))) __attribute__((availability(watchos,introduced=6.0)))
int timespec_get(struct timespec *ts, int base);


}
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 2 3 4
# 92 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wchar.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/__wctype.h" 1 3 4
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wchar.h" 2 3 4



extern "C" {
wint_t btowc(int);
wint_t fgetwc(FILE *);
wchar_t *fgetws(wchar_t * , int, FILE * );
wint_t fputwc(wchar_t, FILE *);
int fputws(const wchar_t * , FILE * );
int fwide(FILE *, int);
int fwprintf(FILE * , const wchar_t * , ...);
int fwscanf(FILE * , const wchar_t * , ...);
wint_t getwc(FILE *);
wint_t getwchar(void);
size_t mbrlen(const char * , size_t, mbstate_t * );
size_t mbrtowc(wchar_t * , const char * , size_t,
     mbstate_t * );
int mbsinit(const mbstate_t *);
size_t mbsrtowcs(wchar_t * , const char ** , size_t,
     mbstate_t * );
wint_t putwc(wchar_t, FILE *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t * , size_t, const wchar_t * , ...);
int swscanf(const wchar_t * , const wchar_t * , ...);
wint_t ungetwc(wint_t, FILE *);
int vfwprintf(FILE * , const wchar_t * ,
     __darwin_va_list);
int vswprintf(wchar_t * , size_t, const wchar_t * ,
     __darwin_va_list);
int vwprintf(const wchar_t * , __darwin_va_list);
size_t wcrtomb(char * , wchar_t, mbstate_t * );
wchar_t *wcscat(wchar_t * , const wchar_t * );
wchar_t *wcschr(const wchar_t *, wchar_t);
int wcscmp(const wchar_t *, const wchar_t *);
int wcscoll(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t * , const wchar_t * );
size_t wcscspn(const wchar_t *, const wchar_t *);
size_t wcsftime(wchar_t * , size_t, const wchar_t * ,
     const struct tm * ) __asm("_" "wcsftime" );
size_t wcslen(const wchar_t *);
wchar_t *wcsncat(wchar_t * , const wchar_t * , size_t);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
wchar_t *wcsrchr(const wchar_t *, wchar_t);
size_t wcsrtombs(char * , const wchar_t ** , size_t,
     mbstate_t * );
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcsstr(const wchar_t * , const wchar_t * );
size_t wcsxfrm(wchar_t * , const wchar_t * , size_t);
int wctob(wint_t);
double wcstod(const wchar_t * , wchar_t ** );
wchar_t *wcstok(wchar_t * , const wchar_t * ,
     wchar_t ** );
long wcstol(const wchar_t * , wchar_t ** , int);
unsigned long
  wcstoul(const wchar_t * , wchar_t ** , int);
wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);
int wprintf(const wchar_t * , ...);
int wscanf(const wchar_t * , ...);
int wcswidth(const wchar_t *, size_t);
int wcwidth(wchar_t);
}
# 169 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wchar.h" 3 4
extern "C" {
int vfwscanf(FILE * , const wchar_t * ,
     __darwin_va_list);
int vswscanf(const wchar_t * , const wchar_t * ,
     __darwin_va_list);
int vwscanf(const wchar_t * , __darwin_va_list);
float wcstof(const wchar_t * , wchar_t ** );
long double
 wcstold(const wchar_t * , wchar_t ** );

long long
 wcstoll(const wchar_t * , wchar_t ** , int);
unsigned long long
 wcstoull(const wchar_t * , wchar_t ** , int);

}
# 194 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_wchar.h" 3 4
extern "C" {
size_t mbsnrtowcs(wchar_t * , const char ** , size_t,
            size_t, mbstate_t * );
wchar_t *wcpcpy(wchar_t * , const wchar_t * ) __attribute__((availability(macosx,introduced=10.7)));
wchar_t *wcpncpy(wchar_t * , const wchar_t * , size_t) __attribute__((availability(macosx,introduced=10.7)));
wchar_t *wcsdup(const wchar_t *) __attribute__((availability(macosx,introduced=10.7)));
int wcscasecmp(const wchar_t *, const wchar_t *) __attribute__((availability(macosx,introduced=10.7)));
int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n) __attribute__((availability(macosx,introduced=10.7)));
size_t wcsnlen(const wchar_t *, size_t) __attribute__((availability(macosx,introduced=10.7)));
size_t wcsnrtombs(char * , const wchar_t ** , size_t,
            size_t, mbstate_t * );
FILE *open_wmemstream(wchar_t ** __bufp, size_t * __sizep) __attribute__((availability(macos,introduced=10.13))) __attribute__((availability(ios,introduced=11.0))) __attribute__((availability(tvos,introduced=11.0))) __attribute__((availability(watchos,introduced=4.0)));
}







extern "C" {
wchar_t *fgetwln(FILE * , size_t *) __attribute__((availability(macosx,introduced=10.7)));
size_t wcslcat(wchar_t *, const wchar_t *, size_t);
size_t wcslcpy(wchar_t *, const wchar_t *, size_t);
}
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/wchar.h" 2 3 4
# 128 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wchar.h" 2 3
# 146 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/wchar.h" 3
extern "C++" {
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) wchar_t* __libcpp_wcschr(const wchar_t* __s, wchar_t __c) {
  return (wchar_t*)wcschr(__s, __c);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) const wchar_t* wcschr(const wchar_t* __s, wchar_t __c) {
  return __libcpp_wcschr(__s, __c);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) wchar_t* wcschr(wchar_t* __s, wchar_t __c) {
  return __libcpp_wcschr(__s, __c);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) wchar_t* __libcpp_wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {
  return (wchar_t*)wcspbrk(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) const wchar_t*
wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {
  return __libcpp_wcspbrk(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) wchar_t* wcspbrk(wchar_t* __s1, const wchar_t* __s2) {
  return __libcpp_wcspbrk(__s1, __s2);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) wchar_t* __libcpp_wcsrchr(const wchar_t* __s, wchar_t __c) {
  return (wchar_t*)wcsrchr(__s, __c);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) const wchar_t* wcsrchr(const wchar_t* __s, wchar_t __c) {
  return __libcpp_wcsrchr(__s, __c);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) wchar_t* wcsrchr(wchar_t* __s, wchar_t __c) {
  return __libcpp_wcsrchr(__s, __c);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) wchar_t* __libcpp_wcsstr(const wchar_t* __s1, const wchar_t* __s2) {
  return (wchar_t*)wcsstr(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) const wchar_t*
wcsstr(const wchar_t* __s1, const wchar_t* __s2) {
  return __libcpp_wcsstr(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) wchar_t* wcsstr(wchar_t* __s1, const wchar_t* __s2) {
  return __libcpp_wcsstr(__s1, __s2);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) wchar_t* __libcpp_wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {
  return (wchar_t*)wmemchr(__s, __c, __n);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) const wchar_t*
wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {
  return __libcpp_wmemchr(__s, __c, __n);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) wchar_t* wmemchr(wchar_t* __s, wchar_t __c, size_t __n) {
  return __libcpp_wmemchr(__s, __c, __n);
}
}
# 115 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwchar" 2 3
# 126 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwchar" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::mbstate_t __attribute__((__using_if_exists__));
using ::size_t __attribute__((__using_if_exists__));
using ::tm __attribute__((__using_if_exists__));
using ::wint_t __attribute__((__using_if_exists__));
using ::FILE __attribute__((__using_if_exists__));
using ::fwprintf __attribute__((__using_if_exists__));
using ::fwscanf __attribute__((__using_if_exists__));
using ::swprintf __attribute__((__using_if_exists__));
using ::vfwprintf __attribute__((__using_if_exists__));
using ::vswprintf __attribute__((__using_if_exists__));
using ::swscanf __attribute__((__using_if_exists__));
using ::vfwscanf __attribute__((__using_if_exists__));
using ::vswscanf __attribute__((__using_if_exists__));
using ::fgetwc __attribute__((__using_if_exists__));
using ::fgetws __attribute__((__using_if_exists__));
using ::fputwc __attribute__((__using_if_exists__));
using ::fputws __attribute__((__using_if_exists__));
using ::fwide __attribute__((__using_if_exists__));
using ::getwc __attribute__((__using_if_exists__));
using ::putwc __attribute__((__using_if_exists__));
using ::ungetwc __attribute__((__using_if_exists__));
using ::wcstod __attribute__((__using_if_exists__));
using ::wcstof __attribute__((__using_if_exists__));
using ::wcstold __attribute__((__using_if_exists__));
using ::wcstol __attribute__((__using_if_exists__));
using ::wcstoll __attribute__((__using_if_exists__));
using ::wcstoul __attribute__((__using_if_exists__));
using ::wcstoull __attribute__((__using_if_exists__));
using ::wcscpy __attribute__((__using_if_exists__));
using ::wcsncpy __attribute__((__using_if_exists__));
using ::wcscat __attribute__((__using_if_exists__));
using ::wcsncat __attribute__((__using_if_exists__));
using ::wcscmp __attribute__((__using_if_exists__));
using ::wcscoll __attribute__((__using_if_exists__));
using ::wcsncmp __attribute__((__using_if_exists__));
using ::wcsxfrm __attribute__((__using_if_exists__));
using ::wcschr __attribute__((__using_if_exists__));
using ::wcspbrk __attribute__((__using_if_exists__));
using ::wcsrchr __attribute__((__using_if_exists__));
using ::wcsstr __attribute__((__using_if_exists__));
using ::wmemchr __attribute__((__using_if_exists__));
using ::wcscspn __attribute__((__using_if_exists__));
using ::wcslen __attribute__((__using_if_exists__));
using ::wcsspn __attribute__((__using_if_exists__));
using ::wcstok __attribute__((__using_if_exists__));
using ::wmemcmp __attribute__((__using_if_exists__));
using ::wmemcpy __attribute__((__using_if_exists__));
using ::wmemmove __attribute__((__using_if_exists__));
using ::wmemset __attribute__((__using_if_exists__));
using ::wcsftime __attribute__((__using_if_exists__));
using ::btowc __attribute__((__using_if_exists__));
using ::wctob __attribute__((__using_if_exists__));
using ::mbsinit __attribute__((__using_if_exists__));
using ::mbrlen __attribute__((__using_if_exists__));
using ::mbrtowc __attribute__((__using_if_exists__));
using ::wcrtomb __attribute__((__using_if_exists__));
using ::mbsrtowcs __attribute__((__using_if_exists__));
using ::wcsrtombs __attribute__((__using_if_exists__));

using ::getwchar __attribute__((__using_if_exists__));
using ::vwscanf __attribute__((__using_if_exists__));
using ::wscanf __attribute__((__using_if_exists__));

using ::putwchar __attribute__((__using_if_exists__));
using ::vwprintf __attribute__((__using_if_exists__));
using ::wprintf __attribute__((__using_if_exists__));

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t __constexpr_wcslen(const wchar_t* __str) {

  return __builtin_wcslen(__str);
# 209 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwchar" 3
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int
__constexpr_wmemcmp(const wchar_t* __lhs, const wchar_t* __rhs, size_t __count) {

  return __builtin_wmemcmp(__lhs, __rhs, __count);
# 227 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cwchar" 3
}

template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* __constexpr_wmemchr(_Tp* __str, _Up __value, size_t __count) {
  _Static_assert(sizeof(_Tp) == sizeof(wchar_t)&& _Alignof(_Tp) >= _Alignof(wchar_t) && __libcpp_is_trivially_equality_comparable<_Tp, _Tp>::value, "Calling wmemchr on non-trivially equality comparable types is unsafe.");




  if (!__libcpp_is_constant_evaluated()) {
    wchar_t __value_buffer = 0;
    __builtin_memcpy(&__value_buffer, &__value, sizeof(wchar_t));
    return reinterpret_cast<_Tp*>(
        __builtin_wmemchr(reinterpret_cast<__apply_cv_t<_Tp, wchar_t>*>(__str), __value_buffer, __count));
  }






  for (; __count; --__count) {
    if (*__str == __value)
      return __str;
    ++__str;
  }
  return __nullptr;
}

}}
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find.h" 2 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _Iter, class _Sent, class _Tp, class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Iter
__find_impl(_Iter __first, _Sent __last, const _Tp& __value, _Proj& __proj) {
  for (; __first != __last; ++__first)
    if (std::__invoke(__proj, *__first) == __value)
      break;
  return __first;
}


template <class _Tp,
          class _Up,
          class _Proj,
          __enable_if_t<__is_identity<_Proj>::value && __libcpp_is_trivially_equality_comparable<_Tp, _Up>::value &&
                            sizeof(_Tp) == 1,
                        int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp*
__find_impl(_Tp* __first, _Tp* __last, const _Up& __value, _Proj&) {
  if (auto __ret = std::__constexpr_memchr(__first, __value, __last - __first))
    return __ret;
  return __last;
}





template <class _Tp,
          class _Up,
          class _Proj,
          __enable_if_t<__is_identity<_Proj>::value && __libcpp_is_trivially_equality_comparable<_Tp, _Up>::value &&
                            sizeof(_Tp) == sizeof(wchar_t) && _Alignof(_Tp) >= _Alignof(wchar_t),
                        int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp*
__find_impl(_Tp* __first, _Tp* __last, const _Up& __value, _Proj&) {
  if (auto __ret = std::__constexpr_wmemchr(__first, __value, __last - __first))
    return __ret;
  return __last;
}





template <class _Tp,
          class _Up,
          class _Proj,
          __enable_if_t<__is_identity<_Proj>::value && !__libcpp_is_trivially_equality_comparable<_Tp, _Up>::value &&
                            is_integral<_Tp>::value && is_integral<_Up>::value &&
                            is_signed<_Tp>::value == is_signed<_Up>::value,
                        int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp*
__find_impl(_Tp* __first, _Tp* __last, const _Up& __value, _Proj& __proj) {
  if (__value < numeric_limits<_Tp>::min() || __value > numeric_limits<_Tp>::max())
    return __last;
  return std::__find_impl(__first, __last, _Tp(__value), __proj);
}


template <bool _ToFind, class _Cp, bool _IsConst>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator<_Cp, _IsConst>
__find_bool(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n) {
  using _It = __bit_iterator<_Cp, _IsConst>;
  using __storage_type = typename _It::__storage_type;

  const int __bits_per_word = _It::__bits_per_word;

  if (__first.__ctz_ != 0) {
    __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
    __storage_type __dn = std::min(__clz_f, __n);
    __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
    __storage_type __b = std::__invert_if<!_ToFind>(*__first.__seg_) & __m;
    if (__b)
      return _It(__first.__seg_, static_cast<unsigned>(std::__libcpp_ctz(__b)));
    if (__n == __dn)
      return __first + __n;
    __n -= __dn;
    ++__first.__seg_;
  }

  for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word) {
    __storage_type __b = std::__invert_if<!_ToFind>(*__first.__seg_);
    if (__b)
      return _It(__first.__seg_, static_cast<unsigned>(std::__libcpp_ctz(__b)));
  }

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __storage_type __b = std::__invert_if<!_ToFind>(*__first.__seg_) & __m;
    if (__b)
      return _It(__first.__seg_, static_cast<unsigned>(std::__libcpp_ctz(__b)));
  }
  return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst, class _Tp, class _Proj, __enable_if_t<__is_identity<_Proj>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator<_Cp, _IsConst>
__find_impl(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value, _Proj&) {
  if (static_cast<bool>(__value))
    return std::__find_bool<true>(__first, static_cast<typename _Cp::size_type>(__last - __first));
  return std::__find_bool<false>(__first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <class>
struct __find_segment;

template <class _SegmentedIterator,
          class _Tp,
          class _Proj,
          __enable_if_t<__is_segmented_iterator<_SegmentedIterator>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _SegmentedIterator
__find_impl(_SegmentedIterator __first, _SegmentedIterator __last, const _Tp& __value, _Proj& __proj) {
  return std::__find_segment_if(std::move(__first), std::move(__last), __find_segment<_Tp>(__value), __proj);
}

template <class _Tp>
struct __find_segment {
  const _Tp& __value_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __find_segment(const _Tp& __value) : __value_(__value) {}

  template <class _InputIterator, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _InputIterator
  operator()(_InputIterator __first, _InputIterator __last, _Proj& __proj) const {
    return std::__find_impl(__first, __last, __value_, __proj);
  }
};


template <class _InputIterator, class _Tp>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _InputIterator
find(_InputIterator __first, _InputIterator __last, const _Tp& __value) {
  __identity __proj;
  return std::__rewrap_iter(
      __first, std::__find_impl(std::__unwrap_iter(__first), std::__unwrap_iter(__last), __value, __proj));
}

}}
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_if.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_if.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _InputIterator
find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      break;
  return __first;
}

}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator, class _Tp>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value) {
  __first = std::find(__first, __last, __value);
  if (__first != __last) {
    _ForwardIterator __i = __first;
    while (++__i != __last) {
      if (!(*__i == __value)) {
        *__first = std::move(*__i);
        ++__first;
      }
    }
  }
  return __first;
}

}}
# 315 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove_if.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove_if.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove_if.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator, class _Predicate>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {
  __first = std::find_if<_ForwardIterator, _Predicate&>(__first, __last, __pred);
  if (__first != __last) {
    _ForwardIterator __i = __first;
    while (++__i != __last) {
      if (!__pred(*__i)) {
        *__first = std::move(*__i);
        ++__first;
      }
    }
  }
  return __first;
}

}}
# 316 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/rotate.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/rotate.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/move.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/move.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/move.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _InIter, class _Sent, class _OutIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InIter, _OutIter>
__move(_InIter __first, _Sent __last, _OutIter __result);

template <class _AlgPolicy>
struct __move_loop {
  template <class _InIter, class _Sent, class _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    while (__first != __last) {
      *__result = _IterOps<_AlgPolicy>::__iter_move(__first);
      ++__first;
      ++__result;
    }
    return std::make_pair(std::move(__first), std::move(__result));
  }

  template <class _InIter, class _OutIter>
  struct _MoveSegment {
    using _Traits = __segmented_iterator_traits<_InIter>;

    _OutIter& __result_;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit _MoveSegment(_OutIter& __result)
        : __result_(__result) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
    operator()(typename _Traits::__local_iterator __lfirst, typename _Traits::__local_iterator __llast) {
      __result_ = std::__move<_AlgPolicy>(__lfirst, __llast, std::move(__result_)).second;
    }
  };

  template <class _InIter, class _OutIter, __enable_if_t<__is_segmented_iterator<_InIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    std::__for_each_segment(__first, __last, _MoveSegment<_InIter, _OutIter>(__result));
    return std::make_pair(__last, std::move(__result));
  }

  template <class _InIter,
            class _OutIter,
            __enable_if_t<__has_random_access_iterator_category<_InIter>::value &&
                              !__is_segmented_iterator<_InIter>::value && __is_segmented_iterator<_OutIter>::value,
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    using _Traits = __segmented_iterator_traits<_OutIter>;
    using _DiffT = typename common_type<__iter_diff_t<_InIter>, __iter_diff_t<_OutIter> >::type;

    if (__first == __last)
      return std::make_pair(std::move(__first), std::move(__result));

    auto __local_first = _Traits::__local(__result);
    auto __segment_iterator = _Traits::__segment(__result);
    while (true) {
      auto __local_last = _Traits::__end(__segment_iterator);
      auto __size = std::min<_DiffT>(__local_last - __local_first, __last - __first);
      auto __iters = std::__move<_AlgPolicy>(__first, __first + __size, __local_first);
      __first = std::move(__iters.first);

      if (__first == __last)
        return std::make_pair(std::move(__first), _Traits::__compose(__segment_iterator, std::move(__iters.second)));

      __local_first = _Traits::__begin(++__segment_iterator);
    }
  }
};

struct __move_trivial {

  template <class _In, class _Out, __enable_if_t<__can_lower_move_assignment_to_memmove<_In, _Out>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_In*, _Out*>
  operator()(_In* __first, _In* __last, _Out* __result) const {
    return std::__copy_trivial_impl(__first, __last, __result);
  }
};

template <class _AlgPolicy, class _InIter, class _Sent, class _OutIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InIter, _OutIter>
__move(_InIter __first, _Sent __last, _OutIter __result) {
  return std::__dispatch_copy_or_move<_AlgPolicy, __move_loop<_AlgPolicy>, __move_trivial>(
      std::move(__first), std::move(__last), std::move(__result));
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator
move(_InputIterator __first, _InputIterator __last, _OutputIterator __result) {
  _Static_assert(is_copy_constructible<_InputIterator>::value, "Iterators has to be copy constructible.");
  _Static_assert(is_copy_constructible<_OutputIterator>::value, "The output iterator has to be copy constructible.");

  return std::__move<_ClassicAlgPolicy>(std::move(__first), std::move(__last), std::move(__result)).second;
}

}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/rotate.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/move_backward.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/move_backward.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/move_backward.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _BidirectionalIterator1, class _Sentinel, class _BidirectionalIterator2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_BidirectionalIterator1, _BidirectionalIterator2>
__move_backward(_BidirectionalIterator1 __first, _Sentinel __last, _BidirectionalIterator2 __result);

template <class _AlgPolicy>
struct __move_backward_loop {
  template <class _InIter, class _Sent, class _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    auto __last_iter = _IterOps<_AlgPolicy>::next(__first, __last);
    auto __original_last_iter = __last_iter;

    while (__first != __last_iter) {
      *--__result = _IterOps<_AlgPolicy>::__iter_move(--__last_iter);
    }

    return std::make_pair(std::move(__original_last_iter), std::move(__result));
  }

  template <class _InIter, class _OutIter, __enable_if_t<__is_segmented_iterator<_InIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    using _Traits = __segmented_iterator_traits<_InIter>;
    auto __sfirst = _Traits::__segment(__first);
    auto __slast = _Traits::__segment(__last);
    if (__sfirst == __slast) {
      auto __iters =
          std::__move_backward<_AlgPolicy>(_Traits::__local(__first), _Traits::__local(__last), std::move(__result));
      return std::make_pair(__last, __iters.second);
    }

    __result =
        std::__move_backward<_AlgPolicy>(_Traits::__begin(__slast), _Traits::__local(__last), std::move(__result))
            .second;
    --__slast;
    while (__sfirst != __slast) {
      __result =
          std::__move_backward<_AlgPolicy>(_Traits::__begin(__slast), _Traits::__end(__slast), std::move(__result))
              .second;
      --__slast;
    }
    __result = std::__move_backward<_AlgPolicy>(_Traits::__local(__first), _Traits::__end(__slast), std::move(__result))
                   .second;
    return std::make_pair(__last, std::move(__result));
  }

  template <class _InIter,
            class _OutIter,
            __enable_if_t<__has_random_access_iterator_category<_InIter>::value &&
                              !__is_segmented_iterator<_InIter>::value && __is_segmented_iterator<_OutIter>::value,
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    using _Traits = __segmented_iterator_traits<_OutIter>;
    using _DiffT = typename common_type<__iter_diff_t<_InIter>, __iter_diff_t<_OutIter> >::type;


    if (__first == __last)
      return std::make_pair(__first, __result);

    auto __orig_last = __last;

    auto __local_last = _Traits::__local(__result);
    auto __segment_iterator = _Traits::__segment(__result);
    while (true) {
      auto __local_first = _Traits::__begin(__segment_iterator);
      auto __size = std::min<_DiffT>(__local_last - __local_first, __last - __first);
      auto __iter = std::__move_backward<_AlgPolicy>(__last - __size, __last, __local_last).second;
      __last -= __size;

      if (__first == __last)
        return std::make_pair(std::move(__orig_last), _Traits::__compose(__segment_iterator, std::move(__iter)));

      __local_last = _Traits::__end(--__segment_iterator);
    }
  }
};

struct __move_backward_trivial {

  template <class _In, class _Out, __enable_if_t<__can_lower_move_assignment_to_memmove<_In, _Out>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_In*, _Out*>
  operator()(_In* __first, _In* __last, _Out* __result) const {
    return std::__copy_backward_trivial_impl(__first, __last, __result);
  }
};

template <class _AlgPolicy, class _BidirectionalIterator1, class _Sentinel, class _BidirectionalIterator2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_BidirectionalIterator1, _BidirectionalIterator2>
__move_backward(_BidirectionalIterator1 __first, _Sentinel __last, _BidirectionalIterator2 __result) {
  _Static_assert(std::is_copy_constructible<_BidirectionalIterator1>::value && std::is_copy_constructible<_BidirectionalIterator1>::value, "Iterators must be copy constructible.");



  return std::__dispatch_copy_or_move<_AlgPolicy, __move_backward_loop<_AlgPolicy>, __move_backward_trivial>(
      std::move(__first), std::move(__last), std::move(__result));
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _BidirectionalIterator2
move_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last, _BidirectionalIterator2 __result) {
  return std::__move_backward<_ClassicAlgPolicy>(std::move(__first), std::move(__last), std::move(__result)).second;
}

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/rotate.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/swap_ranges.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/swap_ranges.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/swap_ranges.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _AlgPolicy, class _ForwardIterator1, class _Sentinel1, class _ForwardIterator2, class _Sentinel2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_ForwardIterator1, _ForwardIterator2>
__swap_ranges(_ForwardIterator1 __first1, _Sentinel1 __last1, _ForwardIterator2 __first2, _Sentinel2 __last2) {
  while (__first1 != __last1 && __first2 != __last2) {
    _IterOps<_AlgPolicy>::iter_swap(__first1, __first2);
    ++__first1;
    ++__first2;
  }

  return pair<_ForwardIterator1, _ForwardIterator2>(std::move(__first1), std::move(__first2));
}


template <class _AlgPolicy, class _ForwardIterator1, class _Sentinel1, class _ForwardIterator2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_ForwardIterator1, _ForwardIterator2>
__swap_ranges(_ForwardIterator1 __first1, _Sentinel1 __last1, _ForwardIterator2 __first2) {
  while (__first1 != __last1) {
    _IterOps<_AlgPolicy>::iter_swap(__first1, __first2);
    ++__first1;
    ++__first2;
  }

  return pair<_ForwardIterator1, _ForwardIterator2>(std::move(__first1), std::move(__first2));
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2) {
  return std::__swap_ranges<_ClassicAlgPolicy>(std::move(__first1), std::move(__last1), std::move(__first2)).second;
}

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/rotate.h" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/rotate.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/rotate.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
__rotate_left(_ForwardIterator __first, _ForwardIterator __last) {
  typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
  using _Ops = _IterOps<_AlgPolicy>;

  value_type __tmp = _Ops::__iter_move(__first);
  _ForwardIterator __lm1 = std::__move<_AlgPolicy>(_Ops::next(__first), __last, __first).second;
  *__lm1 = std::move(__tmp);
  return __lm1;
}

template <class _AlgPolicy, class _BidirectionalIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _BidirectionalIterator
__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last) {
  typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
  using _Ops = _IterOps<_AlgPolicy>;

  _BidirectionalIterator __lm1 = _Ops::prev(__last);
  value_type __tmp = _Ops::__iter_move(__lm1);
  _BidirectionalIterator __fp1 = std::__move_backward<_AlgPolicy>(__first, __lm1, std::move(__last)).second;
  *__first = std::move(__tmp);
  return __fp1;
}

template <class _AlgPolicy, class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last) {
  _ForwardIterator __i = __middle;
  while (true) {
    _IterOps<_AlgPolicy>::iter_swap(__first, __i);
    ++__first;
    if (++__i == __last)
      break;
    if (__first == __middle)
      __middle = __i;
  }
  _ForwardIterator __r = __first;
  if (__first != __middle) {
    __i = __middle;
    while (true) {
      _IterOps<_AlgPolicy>::iter_swap(__first, __i);
      ++__first;
      if (++__i == __last) {
        if (__first == __middle)
          break;
        __i = __middle;
      } else if (__first == __middle)
        __middle = __i;
    }
  }
  return __r;
}

template <typename _Integral>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Integral __algo_gcd(_Integral __x, _Integral __y) {
  do {
    _Integral __t = __x % __y;
    __x = __y;
    __y = __t;
  } while (__y);
  return __x;
}

template <class _AlgPolicy, typename _RandomAccessIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _RandomAccessIterator
__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last) {
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  using _Ops = _IterOps<_AlgPolicy>;

  const difference_type __m1 = __middle - __first;
  const difference_type __m2 = _Ops::distance(__middle, __last);
  if (__m1 == __m2) {
    std::__swap_ranges<_AlgPolicy>(__first, __middle, __middle, __last);
    return __middle;
  }
  const difference_type __g = std::__algo_gcd(__m1, __m2);
  for (_RandomAccessIterator __p = __first + __g; __p != __first;) {
    value_type __t(_Ops::__iter_move(--__p));
    _RandomAccessIterator __p1 = __p;
    _RandomAccessIterator __p2 = __p1 + __m1;
    do {
      *__p1 = _Ops::__iter_move(__p2);
      __p1 = __p2;
      const difference_type __d = _Ops::distance(__p2, __last);
      if (__m1 < __d)
        __p2 += __m1;
      else
        __p2 = __first + (__m1 - __d);
    } while (__p2 != __p);
    *__p1 = std::move(__t);
  }
  return __first + __m2;
}

template <class _AlgPolicy, class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
__rotate_impl(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, std::forward_iterator_tag) {
  typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
  if (is_trivially_move_assignable<value_type>::value) {
    if (_IterOps<_AlgPolicy>::next(__first) == __middle)
      return std::__rotate_left<_AlgPolicy>(__first, __last);
  }
  return std::__rotate_forward<_AlgPolicy>(__first, __middle, __last);
}

template <class _AlgPolicy, class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _BidirectionalIterator __rotate_impl(
    _BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    bidirectional_iterator_tag) {
  typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
  if (is_trivially_move_assignable<value_type>::value) {
    if (_IterOps<_AlgPolicy>::next(__first) == __middle)
      return std::__rotate_left<_AlgPolicy>(__first, __last);
    if (_IterOps<_AlgPolicy>::next(__middle) == __last)
      return std::__rotate_right<_AlgPolicy>(__first, __last);
  }
  return std::__rotate_forward<_AlgPolicy>(__first, __middle, __last);
}

template <class _AlgPolicy, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _RandomAccessIterator __rotate_impl(
    _RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last,
    random_access_iterator_tag) {
  typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  if (is_trivially_move_assignable<value_type>::value) {
    if (_IterOps<_AlgPolicy>::next(__first) == __middle)
      return std::__rotate_left<_AlgPolicy>(__first, __last);
    if (_IterOps<_AlgPolicy>::next(__middle) == __last)
      return std::__rotate_right<_AlgPolicy>(__first, __last);
    return std::__rotate_gcd<_AlgPolicy>(__first, __middle, __last);
  }
  return std::__rotate_forward<_AlgPolicy>(__first, __middle, __last);
}

template <class _AlgPolicy, class _Iterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_Iterator, _Iterator>
__rotate(_Iterator __first, _Iterator __middle, _Sentinel __last) {
  using _Ret = pair<_Iterator, _Iterator>;
  _Iterator __last_iter = _IterOps<_AlgPolicy>::next(__middle, __last);

  if (__first == __middle)
    return _Ret(__last_iter, __last_iter);
  if (__middle == __last)
    return _Ret(std::move(__first), std::move(__last_iter));

  using _IterCategory = typename _IterOps<_AlgPolicy>::template __iterator_category<_Iterator>;
  auto __result = std::__rotate_impl<_AlgPolicy>(std::move(__first), std::move(__middle), __last_iter, _IterCategory());

  return _Ret(std::move(__result), std::move(__last_iter));
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last) {
  return std::__rotate<_ClassicAlgPolicy>(std::move(__first), std::move(__middle), std::move(__last)).first;
}

}}
# 317 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit_reference" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit_reference" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_n.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_n.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator,
          class _Size,
          class _OutputIterator,
          __enable_if_t<__has_input_iterator_category<_InputIterator>::value &&
                            !__has_random_access_iterator_category<_InputIterator>::value,
                        int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator
copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result) {
  typedef __decltype(std::__convert_to_integral(__orig_n)) _IntegralSize;
  _IntegralSize __n = __orig_n;
  if (__n > 0) {
    *__result = *__first;
    ++__result;
    for (--__n; __n > 0; --__n) {
      ++__first;
      *__result = *__first;
      ++__result;
    }
  }
  return __result;
}

template <class _InputIterator,
          class _Size,
          class _OutputIterator,
          __enable_if_t<__has_random_access_iterator_category<_InputIterator>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator
copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result) {
  typedef typename iterator_traits<_InputIterator>::difference_type difference_type;
  typedef __decltype(std::__convert_to_integral(__orig_n)) _IntegralSize;
  _IntegralSize __n = __orig_n;
  return std::copy(__first, __first + difference_type(__n), __result);
}

}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit_reference" 2 3




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/popcount.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/popcount.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/popcount.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int __libcpp_popcount(unsigned __x) throw() {
  return __builtin_popcount(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int __libcpp_popcount(unsigned long __x) throw() {
  return __builtin_popcountl(__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int __libcpp_popcount(unsigned long long __x) throw() {
  return __builtin_popcountll(__x);
}
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/popcount.h" 3
}}
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit_reference" 2 3







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstring" 1 3
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstring" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string.h" 1 3
# 58 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/string.h" 1 3 4
# 58 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/string.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_string.h" 1 3 4
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_string.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_string.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_null.h" 1 3 4
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_string.h" 2 3 4



extern "C" {
void *memchr(const void *__s, int __c, size_t __n);
int memcmp(const void *__s1, const void *__s2, size_t __n);
void *memcpy(void *__dst, const void *__src, size_t __n);
void *memmove(void *__dst, const void *__src, size_t __len);
void *memset(void *__b, int __c, size_t __len);
char *strcat(char *__s1, const char *__s2);
char *strchr(const char *__s, int __c);
int strcmp(const char *__s1, const char *__s2);
int strcoll(const char *__s1, const char *__s2);
char *strcpy(char *__dst, const char *__src);
size_t strcspn(const char *__s, const char *__charset);
char *strerror(int __errnum) __asm("_" "strerror" );
size_t strlen(const char *__s);
char *strncat(char *__s1, const char *__s2, size_t __n);
int strncmp(const char *__s1, const char *__s2, size_t __n);
char *strncpy(char *__dst, const char *__src, size_t __n);
char *strpbrk(const char *__s, const char *__charset);
char *strrchr(const char *__s, int __c);
size_t strspn(const char *__s, const char *__charset);
char *strstr(const char *__big, const char *__little);
char *strtok(char *__str, const char *__sep);
size_t strxfrm(char *__s1, const char *__s2, size_t __n);
}
# 103 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_string.h" 3 4
extern "C" {
char *strtok_r(char *__str, const char *__sep, char **__lasts);
}
# 115 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_string.h" 3 4
extern "C" {
int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen);
char *strdup(const char *__s1);
void *memccpy(void *__dst, const void *__src, int __c, size_t __n);
}
# 129 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_string.h" 3 4
extern "C" {
char *stpcpy(char *__dst, const char *__src);
char *stpncpy(char *__dst, const char *__src, size_t __n) __attribute__((availability(macosx,introduced=10.7)));
char *strndup(const char *__s1, size_t __n) __attribute__((availability(macosx,introduced=10.7)));
size_t strnlen(const char *__s1, size_t __n) __attribute__((availability(macosx,introduced=10.7)));
char *strsignal(int __sig);
}





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_rsize_t.h" 1 3 4
# 142 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_string.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_errno_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_errno_t.h" 3 4
typedef int errno_t;
# 143 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_string.h" 2 3 4

extern "C" {
errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n) __attribute__((availability(macosx,introduced=10.9)));
}







extern "C" {
void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len) __attribute__((availability(macosx,introduced=10.7)));
void memset_pattern4(void *__b, const void *__pattern4, size_t __len) __attribute__((availability(macosx,introduced=10.5)));
void memset_pattern8(void *__b, const void *__pattern8, size_t __len) __attribute__((availability(macosx,introduced=10.5)));
void memset_pattern16(void *__b, const void *__pattern16, size_t __len) __attribute__((availability(macosx,introduced=10.5)));

char *strcasestr(const char *__big, const char *__little);
char *strnstr(const char *__big, const char *__little, size_t __len);
size_t strlcat(char *__dst, const char *__source, size_t __size);
size_t strlcpy(char *__dst, const char *__source, size_t __size);
void strmode(int __mode, char *__bp);
char *strsep(char **__stringp, const char *__delim);


void swab(const void * , void * , ssize_t);

__attribute__((availability(macosx,introduced=10.12.1))) __attribute__((availability(ios,introduced=10.1)))
__attribute__((availability(tvos,introduced=10.0.1))) __attribute__((availability(watchos,introduced=3.1)))
int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len);

__attribute__((availability(macosx,introduced=11.0))) __attribute__((availability(ios,introduced=14.0)))
__attribute__((availability(tvos,introduced=14.0))) __attribute__((availability(watchos,introduced=7.0)))
int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen);
}




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_strings.h" 1 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_strings.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_strings.h" 2 3 4

extern "C" {


int bcmp(const void *, const void *, size_t) ;
void bcopy(const void *, void *, size_t) ;
void bzero(void *, size_t) ;
char *index(const char *, int) ;
char *rindex(const char *, int) ;


int ffs(int);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);
}



extern "C" {
int ffsl(long) __attribute__((availability(macosx,introduced=10.5)));
int ffsll(long long) __attribute__((availability(macosx,introduced=10.9)));
int fls(int) __attribute__((availability(macosx,introduced=10.5)));
int flsl(long) __attribute__((availability(macosx,introduced=10.5)));
int flsll(long long) __attribute__((availability(macosx,introduced=10.9)));
}
# 183 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_string.h" 2 3 4
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/string.h" 2 3 4
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string.h" 2 3
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string.h" 3
extern "C++" {
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) const char* strchr(const char* __s, int __c) {
  return __builtin_strchr(__s, __c);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) char* strchr(char* __s, int __c) {
  return __builtin_strchr(__s, __c);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) const char* strpbrk(const char* __s1, const char* __s2) {
  return __builtin_strpbrk(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) char* strpbrk(char* __s1, const char* __s2) {
  return __builtin_strpbrk(__s1, __s2);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) const char* strrchr(const char* __s, int __c) {
  return __builtin_strrchr(__s, __c);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) char* strrchr(char* __s, int __c) {
  return __builtin_strrchr(__s, __c);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) const void* memchr(const void* __s, int __c, size_t __n) {
  return __builtin_memchr(__s, __c, __n);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) void* memchr(void* __s, int __c, size_t __n) {
  return __builtin_memchr(__s, __c, __n);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) const char* strstr(const char* __s1, const char* __s2) {
  return __builtin_strstr(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__enable_if__(true, ""))) char* strstr(char* __s1, const char* __s2) {
  return __builtin_strstr(__s1, __s2);
}
}
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstring" 2 3
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstring" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::size_t __attribute__((__using_if_exists__));
using ::memcpy __attribute__((__using_if_exists__));
using ::memmove __attribute__((__using_if_exists__));
using ::strcpy __attribute__((__using_if_exists__));
using ::strncpy __attribute__((__using_if_exists__));
using ::strcat __attribute__((__using_if_exists__));
using ::strncat __attribute__((__using_if_exists__));
using ::memcmp __attribute__((__using_if_exists__));
using ::strcmp __attribute__((__using_if_exists__));
using ::strncmp __attribute__((__using_if_exists__));
using ::strcoll __attribute__((__using_if_exists__));
using ::strxfrm __attribute__((__using_if_exists__));
using ::memchr __attribute__((__using_if_exists__));
using ::strchr __attribute__((__using_if_exists__));
using ::strcspn __attribute__((__using_if_exists__));
using ::strpbrk __attribute__((__using_if_exists__));
using ::strrchr __attribute__((__using_if_exists__));
using ::strspn __attribute__((__using_if_exists__));
using ::strstr __attribute__((__using_if_exists__));
using ::strtok __attribute__((__using_if_exists__));
using ::memset __attribute__((__using_if_exists__));
using ::strerror __attribute__((__using_if_exists__));
using ::strlen __attribute__((__using_if_exists__));

}}
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit_reference" 2 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit_reference" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit_reference" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Cp>
class __bit_const_reference;

template <class _Tp>
struct __has_storage_type {
  static const bool value = false;
};

template <class _Cp, bool = __has_storage_type<_Cp>::value>
class __bit_reference {
  using __storage_type = typename _Cp::__storage_type;
  using __storage_pointer = typename _Cp::__storage_pointer;

  __storage_pointer __seg_;
  __storage_type __mask_;

  friend typename _Cp::__self;

  friend class __bit_const_reference<_Cp>;
  friend class __bit_iterator<_Cp, false>;

public:
  using __container = typename _Cp::__self;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_reference(const __bit_reference&) = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) operator bool() const throw() {
    return static_cast<bool>(*__seg_ & __mask_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator~() const throw() {
    return !static_cast<bool>(*this);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_reference& operator=(bool __x) throw() {
    if (__x)
      *__seg_ |= __mask_;
    else
      *__seg_ &= ~__mask_;
    return *this;
  }
# 88 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit_reference" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_reference& operator=(const __bit_reference& __x) throw() {
    return operator=(static_cast<bool>(__x));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void flip() throw() { *__seg_ ^= __mask_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator<_Cp, false> operator&() const throw() {
    return __bit_iterator<_Cp, false>(__seg_, static_cast<unsigned>(std::__libcpp_ctz(__mask_)));
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __bit_reference(
      __storage_pointer __s, __storage_type __m) throw()
      : __seg_(__s),
        __mask_(__m) {}
};

template <class _Cp>
class __bit_reference<_Cp, false> {};

template <class _Cp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
swap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) throw() {
  bool __t = __x;
  __x = __y;
  __y = __t;
}

template <class _Cp, class _Dp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
swap(__bit_reference<_Cp> __x, __bit_reference<_Dp> __y) throw() {
  bool __t = __x;
  __x = __y;
  __y = __t;
}

template <class _Cp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(__bit_reference<_Cp> __x, bool& __y) throw() {
  bool __t = __x;
  __x = __y;
  __y = __t;
}

template <class _Cp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(bool& __x, __bit_reference<_Cp> __y) throw() {
  bool __t = __x;
  __x = __y;
  __y = __t;
}

template <class _Cp>
class __bit_const_reference {
  using __storage_type = typename _Cp::__storage_type;
  using __storage_pointer = typename _Cp::__const_storage_pointer;

  __storage_pointer __seg_;
  __storage_type __mask_;

  friend typename _Cp::__self;
  friend class __bit_iterator<_Cp, true>;

public:
  using __container = typename _Cp::__self;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_const_reference(const __bit_const_reference&) = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_const_reference(const __bit_reference<_Cp>& __x) throw()
      : __seg_(__x.__seg_),
        __mask_(__x.__mask_) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) operator bool() const throw() {
    return static_cast<bool>(*__seg_ & __mask_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator<_Cp, true> operator&() const throw() {
    return __bit_iterator<_Cp, true>(__seg_, static_cast<unsigned>(std::__libcpp_ctz(__mask_)));
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __bit_const_reference(
      __storage_pointer __s, __storage_type __m) throw()
      : __seg_(__s),
        __mask_(__m) {}

  __bit_const_reference& operator=(const __bit_const_reference&) = delete;
};



template <bool _FillVal, class _Cp>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__fill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n) {
  using _It = __bit_iterator<_Cp, false>;
  using __storage_type = typename _It::__storage_type;

  const int __bits_per_word = _It::__bits_per_word;

  if (__first.__ctz_ != 0) {
    __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
    __storage_type __dn = std::min(__clz_f, __n);
    __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
    if (_FillVal)
      *__first.__seg_ |= __m;
    else
      *__first.__seg_ &= ~__m;
    __n -= __dn;
    ++__first.__seg_;
  }

  __storage_type __nw = __n / __bits_per_word;
  std::fill_n(std::__to_address(__first.__seg_), __nw, _FillVal ? static_cast<__storage_type>(-1) : 0);
  __n -= __nw * __bits_per_word;

  if (__n > 0) {
    __first.__seg_ += __nw;
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    if (_FillVal)
      *__first.__seg_ |= __m;
    else
      *__first.__seg_ &= ~__m;
  }
}

template <class _Cp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
fill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n, bool __value) {
  if (__n > 0) {
    if (__value)
      std::__fill_n<true>(__first, __n);
    else
      std::__fill_n<false>(__first, __n);
  }
}



template <class _Cp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
fill(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __last, bool __value) {
  std::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first), __value);
}



template <class _Cp, bool _IsConst>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator<_Cp, false> __copy_aligned(
    __bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) {
  using _In = __bit_iterator<_Cp, _IsConst>;
  using difference_type = typename _In::difference_type;
  using __storage_type = typename _In::__storage_type;

  const int __bits_per_word = _In::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__first.__ctz_ != 0) {
      unsigned __clz = __bits_per_word - __first.__ctz_;
      difference_type __dn = std::min(static_cast<difference_type>(__clz), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
      __storage_type __b = *__first.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b;
      __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
      ++__first.__seg_;

    }


    __storage_type __nw = __n / __bits_per_word;
    std::copy_n(std::__to_address(__first.__seg_), __nw, std::__to_address(__result.__seg_));
    __n -= __nw * __bits_per_word;
    __result.__seg_ += __nw;

    if (__n > 0) {
      __first.__seg_ += __nw;
      __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
      __storage_type __b = *__first.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b;
      __result.__ctz_ = static_cast<unsigned>(__n);
    }
  }
  return __result;
}

template <class _Cp, bool _IsConst>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator<_Cp, false> __copy_unaligned(
    __bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) {
  using _In = __bit_iterator<_Cp, _IsConst>;
  using difference_type = typename _In::difference_type;
  using __storage_type = typename _In::__storage_type;

  const int __bits_per_word = _In::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__first.__ctz_ != 0) {
      unsigned __clz_f = __bits_per_word - __first.__ctz_;
      difference_type __dn = std::min(static_cast<difference_type>(__clz_f), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
      __storage_type __b = *__first.__seg_ & __m;
      unsigned __clz_r = __bits_per_word - __result.__ctz_;
      __storage_type __ddn = std::min<__storage_type>(__dn, __clz_r);
      __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
      *__result.__seg_ &= ~__m;
      if (__result.__ctz_ > __first.__ctz_)
        *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);
      else
        *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);
      __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
      __dn -= __ddn;
      if (__dn > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __dn);
        *__result.__seg_ &= ~__m;
        *__result.__seg_ |= __b >> (__first.__ctz_ + __ddn);
        __result.__ctz_ = static_cast<unsigned>(__dn);
      }
      ++__first.__seg_;

    }


    unsigned __clz_r = __bits_per_word - __result.__ctz_;
    __storage_type __m = ~__storage_type(0) << __result.__ctz_;
    for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_) {
      __storage_type __b = *__first.__seg_;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b << __result.__ctz_;
      ++__result.__seg_;
      *__result.__seg_ &= __m;
      *__result.__seg_ |= __b >> __clz_r;
    }

    if (__n > 0) {
      __m = ~__storage_type(0) >> (__bits_per_word - __n);
      __storage_type __b = *__first.__seg_ & __m;
      __storage_type __dn = std::min(__n, static_cast<difference_type>(__clz_r));
      __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b << __result.__ctz_;
      __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
      __n -= __dn;
      if (__n > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__result.__seg_ &= ~__m;
        *__result.__seg_ |= __b >> __dn;
        __result.__ctz_ = static_cast<unsigned>(__n);
      }
    }
  }
  return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator<_Cp, false>
copy(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) {
  if (__first.__ctz_ == __result.__ctz_)
    return std::__copy_aligned(__first, __last, __result);
  return std::__copy_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator<_Cp, false> __copy_backward_aligned(
    __bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) {
  using _In = __bit_iterator<_Cp, _IsConst>;
  using difference_type = typename _In::difference_type;
  using __storage_type = typename _In::__storage_type;

  const int __bits_per_word = _In::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__last.__ctz_ != 0) {
      difference_type __dn = std::min(static_cast<difference_type>(__last.__ctz_), __n);
      __n -= __dn;
      unsigned __clz = __bits_per_word - __last.__ctz_;
      __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz);
      __storage_type __b = *__last.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b;
      __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) + __result.__ctz_) % __bits_per_word);

    }



    __storage_type __nw = __n / __bits_per_word;
    __result.__seg_ -= __nw;
    __last.__seg_ -= __nw;
    std::copy_n(std::__to_address(__last.__seg_), __nw, std::__to_address(__result.__seg_));
    __n -= __nw * __bits_per_word;

    if (__n > 0) {
      __storage_type __m = ~__storage_type(0) << (__bits_per_word - __n);
      __storage_type __b = *--__last.__seg_ & __m;
      *--__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b;
      __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
    }
  }
  return __result;
}

template <class _Cp, bool _IsConst>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator<_Cp, false> __copy_backward_unaligned(
    __bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) {
  using _In = __bit_iterator<_Cp, _IsConst>;
  using difference_type = typename _In::difference_type;
  using __storage_type = typename _In::__storage_type;

  const int __bits_per_word = _In::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__last.__ctz_ != 0) {
      difference_type __dn = std::min(static_cast<difference_type>(__last.__ctz_), __n);
      __n -= __dn;
      unsigned __clz_l = __bits_per_word - __last.__ctz_;
      __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_l);
      __storage_type __b = *__last.__seg_ & __m;
      unsigned __clz_r = __bits_per_word - __result.__ctz_;
      __storage_type __ddn = std::min(__dn, static_cast<difference_type>(__result.__ctz_));
      if (__ddn > 0) {
        __m = (~__storage_type(0) << (__result.__ctz_ - __ddn)) & (~__storage_type(0) >> __clz_r);
        *__result.__seg_ &= ~__m;
        if (__result.__ctz_ > __last.__ctz_)
          *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
        else
          *__result.__seg_ |= __b >> (__last.__ctz_ - __result.__ctz_);
        __result.__ctz_ = static_cast<unsigned>(((-__ddn & (__bits_per_word - 1)) + __result.__ctz_) % __bits_per_word);
        __dn -= __ddn;
      }
      if (__dn > 0) {

        --__result.__seg_;
        __result.__ctz_ = static_cast<unsigned>(-__dn & (__bits_per_word - 1));
        __m = ~__storage_type(0) << __result.__ctz_;
        *__result.__seg_ &= ~__m;
        __last.__ctz_ -= __dn + __ddn;
        *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
      }

    }



    unsigned __clz_r = __bits_per_word - __result.__ctz_;
    __storage_type __m = ~__storage_type(0) >> __clz_r;
    for (; __n >= __bits_per_word; __n -= __bits_per_word) {
      __storage_type __b = *--__last.__seg_;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b >> __clz_r;
      *--__result.__seg_ &= __m;
      *__result.__seg_ |= __b << __result.__ctz_;
    }

    if (__n > 0) {
      __m = ~__storage_type(0) << (__bits_per_word - __n);
      __storage_type __b = *--__last.__seg_ & __m;
      __clz_r = __bits_per_word - __result.__ctz_;
      __storage_type __dn = std::min(__n, static_cast<difference_type>(__result.__ctz_));
      __m = (~__storage_type(0) << (__result.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_r);
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b >> (__bits_per_word - __result.__ctz_);
      __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) + __result.__ctz_) % __bits_per_word);
      __n -= __dn;
      if (__n > 0) {

        --__result.__seg_;
        __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
        __m = ~__storage_type(0) << __result.__ctz_;
        *__result.__seg_ &= ~__m;
        *__result.__seg_ |= __b << (__result.__ctz_ - (__bits_per_word - __n - __dn));
      }
    }
  }
  return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator<_Cp, false> copy_backward(
    __bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) {
  if (__last.__ctz_ == __result.__ctz_)
    return std::__copy_backward_aligned(__first, __last, __result);
  return std::__copy_backward_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator<_Cp, false>
move(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) {
  return std::copy(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator<_Cp, false> move_backward(
    __bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result) {
  return std::copy_backward(__first, __last, __result);
}



template <class _Cl, class _Cr>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator<_Cr, false> __swap_ranges_aligned(
    __bit_iterator<_Cl, false> __first, __bit_iterator<_Cl, false> __last, __bit_iterator<_Cr, false> __result) {
  using _I1 = __bit_iterator<_Cl, false>;
  using difference_type = typename _I1::difference_type;
  using __storage_type = typename _I1::__storage_type;

  const int __bits_per_word = _I1::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__first.__ctz_ != 0) {
      unsigned __clz = __bits_per_word - __first.__ctz_;
      difference_type __dn = std::min(static_cast<difference_type>(__clz), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
      __storage_type __b1 = *__first.__seg_ & __m;
      *__first.__seg_ &= ~__m;
      __storage_type __b2 = *__result.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b1;
      *__first.__seg_ |= __b2;
      __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
      ++__first.__seg_;

    }


    for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_, ++__result.__seg_)
      swap(*__first.__seg_, *__result.__seg_);

    if (__n > 0) {
      __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
      __storage_type __b1 = *__first.__seg_ & __m;
      *__first.__seg_ &= ~__m;
      __storage_type __b2 = *__result.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b1;
      *__first.__seg_ |= __b2;
      __result.__ctz_ = static_cast<unsigned>(__n);
    }
  }
  return __result;
}

template <class _Cl, class _Cr>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator<_Cr, false> __swap_ranges_unaligned(
    __bit_iterator<_Cl, false> __first, __bit_iterator<_Cl, false> __last, __bit_iterator<_Cr, false> __result) {
  using _I1 = __bit_iterator<_Cl, false>;
  using difference_type = typename _I1::difference_type;
  using __storage_type = typename _I1::__storage_type;

  const int __bits_per_word = _I1::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__first.__ctz_ != 0) {
      unsigned __clz_f = __bits_per_word - __first.__ctz_;
      difference_type __dn = std::min(static_cast<difference_type>(__clz_f), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
      __storage_type __b1 = *__first.__seg_ & __m;
      *__first.__seg_ &= ~__m;
      unsigned __clz_r = __bits_per_word - __result.__ctz_;
      __storage_type __ddn = std::min<__storage_type>(__dn, __clz_r);
      __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
      __storage_type __b2 = *__result.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      if (__result.__ctz_ > __first.__ctz_) {
        unsigned __s = __result.__ctz_ - __first.__ctz_;
        *__result.__seg_ |= __b1 << __s;
        *__first.__seg_ |= __b2 >> __s;
      } else {
        unsigned __s = __first.__ctz_ - __result.__ctz_;
        *__result.__seg_ |= __b1 >> __s;
        *__first.__seg_ |= __b2 << __s;
      }
      __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
      __dn -= __ddn;
      if (__dn > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __dn);
        __b2 = *__result.__seg_ & __m;
        *__result.__seg_ &= ~__m;
        unsigned __s = __first.__ctz_ + __ddn;
        *__result.__seg_ |= __b1 >> __s;
        *__first.__seg_ |= __b2 << __s;
        __result.__ctz_ = static_cast<unsigned>(__dn);
      }
      ++__first.__seg_;

    }


    __storage_type __m = ~__storage_type(0) << __result.__ctz_;
    unsigned __clz_r = __bits_per_word - __result.__ctz_;
    for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_) {
      __storage_type __b1 = *__first.__seg_;
      __storage_type __b2 = *__result.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b1 << __result.__ctz_;
      *__first.__seg_ = __b2 >> __result.__ctz_;
      ++__result.__seg_;
      __b2 = *__result.__seg_ & ~__m;
      *__result.__seg_ &= __m;
      *__result.__seg_ |= __b1 >> __clz_r;
      *__first.__seg_ |= __b2 << __clz_r;
    }

    if (__n > 0) {
      __m = ~__storage_type(0) >> (__bits_per_word - __n);
      __storage_type __b1 = *__first.__seg_ & __m;
      *__first.__seg_ &= ~__m;
      __storage_type __dn = std::min<__storage_type>(__n, __clz_r);
      __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
      __storage_type __b2 = *__result.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b1 << __result.__ctz_;
      *__first.__seg_ |= __b2 >> __result.__ctz_;
      __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
      __n -= __dn;
      if (__n > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __b2 = *__result.__seg_ & __m;
        *__result.__seg_ &= ~__m;
        *__result.__seg_ |= __b1 >> __dn;
        *__first.__seg_ |= __b2 << __dn;
        __result.__ctz_ = static_cast<unsigned>(__n);
      }
    }
  }
  return __result;
}

template <class _Cl, class _Cr>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator<_Cr, false> swap_ranges(
    __bit_iterator<_Cl, false> __first1, __bit_iterator<_Cl, false> __last1, __bit_iterator<_Cr, false> __first2) {
  if (__first1.__ctz_ == __first2.__ctz_)
    return std::__swap_ranges_aligned(__first1, __last1, __first2);
  return std::__swap_ranges_unaligned(__first1, __last1, __first2);
}



template <class _Cp>
struct __bit_array {
  using difference_type = typename _Cp::difference_type;
  using __storage_type = typename _Cp::__storage_type;
  using __storage_pointer = typename _Cp::__storage_pointer;
  using iterator = typename _Cp::iterator;

  static const unsigned __bits_per_word = _Cp::__bits_per_word;
  static const unsigned _Np = 4;

  difference_type __size_;
  __storage_type __word_[_Np];

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static difference_type capacity() {
    return static_cast<difference_type>(_Np * __bits_per_word);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __bit_array(difference_type __s) : __size_(__s) {
    if (__libcpp_is_constant_evaluated()) {
      for (size_t __i = 0; __i != __bit_array<_Cp>::_Np; ++__i)
        std::__construct_at(__word_ + __i, 0);
    }
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator begin() {
    return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]), 0);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator end() {
    return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]) + __size_ / __bits_per_word,
                    static_cast<unsigned>(__size_ % __bits_per_word));
  }
};

template <class _Cp>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator<_Cp, false>
rotate(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __middle, __bit_iterator<_Cp, false> __last) {
  using _I1 = __bit_iterator<_Cp, false>;
  using difference_type = typename _I1::difference_type;

  difference_type __d1 = __middle - __first;
  difference_type __d2 = __last - __middle;
  _I1 __r = __first + __d2;
  while (__d1 != 0 && __d2 != 0) {
    if (__d1 <= __d2) {
      if (__d1 <= __bit_array<_Cp>::capacity()) {
        __bit_array<_Cp> __b(__d1);
        std::copy(__first, __middle, __b.begin());
        std::copy(__b.begin(), __b.end(), std::copy(__middle, __last, __first));
        break;
      } else {
        __bit_iterator<_Cp, false> __mp = std::swap_ranges(__first, __middle, __middle);
        __first = __middle;
        __middle = __mp;
        __d2 -= __d1;
      }
    } else {
      if (__d2 <= __bit_array<_Cp>::capacity()) {
        __bit_array<_Cp> __b(__d2);
        std::copy(__middle, __last, __b.begin());
        std::copy_backward(__b.begin(), __b.end(), std::copy_backward(__first, __middle, __last));
        break;
      } else {
        __bit_iterator<_Cp, false> __mp = __first + __d2;
        std::swap_ranges(__first, __mp, __middle);
        __first = __mp;
        __d1 -= __d2;
      }
    }
  }
  return __r;
}



template <class _Cp, bool _IC1, bool _IC2>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __equal_unaligned(
    __bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2) {
  using _It = __bit_iterator<_Cp, _IC1>;
  using difference_type = typename _It::difference_type;
  using __storage_type = typename _It::__storage_type;

  const int __bits_per_word = _It::__bits_per_word;
  difference_type __n = __last1 - __first1;
  if (__n > 0) {

    if (__first1.__ctz_ != 0) {
      unsigned __clz_f = __bits_per_word - __first1.__ctz_;
      difference_type __dn = std::min(static_cast<difference_type>(__clz_f), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
      __storage_type __b = *__first1.__seg_ & __m;
      unsigned __clz_r = __bits_per_word - __first2.__ctz_;
      __storage_type __ddn = std::min<__storage_type>(__dn, __clz_r);
      __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
      if (__first2.__ctz_ > __first1.__ctz_) {
        if ((*__first2.__seg_ & __m) != (__b << (__first2.__ctz_ - __first1.__ctz_)))
          return false;
      } else {
        if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ - __first2.__ctz_)))
          return false;
      }
      __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;
      __first2.__ctz_ = static_cast<unsigned>((__ddn + __first2.__ctz_) % __bits_per_word);
      __dn -= __ddn;
      if (__dn > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __dn);
        if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))
          return false;
        __first2.__ctz_ = static_cast<unsigned>(__dn);
      }
      ++__first1.__seg_;

    }


    unsigned __clz_r = __bits_per_word - __first2.__ctz_;
    __storage_type __m = ~__storage_type(0) << __first2.__ctz_;
    for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_) {
      __storage_type __b = *__first1.__seg_;
      if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
        return false;
      ++__first2.__seg_;
      if ((*__first2.__seg_ & ~__m) != (__b >> __clz_r))
        return false;
    }

    if (__n > 0) {
      __m = ~__storage_type(0) >> (__bits_per_word - __n);
      __storage_type __b = *__first1.__seg_ & __m;
      __storage_type __dn = std::min(__n, static_cast<difference_type>(__clz_r));
      __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
      if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
        return false;
      __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;
      __first2.__ctz_ = static_cast<unsigned>((__dn + __first2.__ctz_) % __bits_per_word);
      __n -= __dn;
      if (__n > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if ((*__first2.__seg_ & __m) != (__b >> __dn))
          return false;
      }
    }
  }
  return true;
}

template <class _Cp, bool _IC1, bool _IC2>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __equal_aligned(
    __bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2) {
  using _It = __bit_iterator<_Cp, _IC1>;
  using difference_type = typename _It::difference_type;
  using __storage_type = typename _It::__storage_type;

  const int __bits_per_word = _It::__bits_per_word;
  difference_type __n = __last1 - __first1;
  if (__n > 0) {

    if (__first1.__ctz_ != 0) {
      unsigned __clz = __bits_per_word - __first1.__ctz_;
      difference_type __dn = std::min(static_cast<difference_type>(__clz), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
      if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
        return false;
      ++__first2.__seg_;
      ++__first1.__seg_;


    }



    for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_, ++__first2.__seg_)
      if (*__first2.__seg_ != *__first1.__seg_)
        return false;

    if (__n > 0) {
      __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
      if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
        return false;
    }
  }
  return true;
}

template <class _Cp, bool _IC1, bool _IC2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
equal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2) {
  if (__first1.__ctz_ == __first2.__ctz_)
    return std::__equal_aligned(__first1, __last1, __first2);
  return std::__equal_unaligned(__first1, __last1, __first2);
}

template <class _Cp, bool _IsConst, typename _Cp::__storage_type>
class __bit_iterator {
public:
  using difference_type = typename _Cp::difference_type;
  using value_type = bool;
  using pointer = __bit_iterator;

  using reference = __conditional_t<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >;



  using iterator_category = random_access_iterator_tag;

private:
  using __storage_type = typename _Cp::__storage_type;
  using __storage_pointer =
      __conditional_t<_IsConst, typename _Cp::__const_storage_pointer, typename _Cp::__storage_pointer>;

  static const unsigned __bits_per_word = _Cp::__bits_per_word;

  __storage_pointer __seg_;
  unsigned __ctz_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator() throw()




  {
  }






  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator(const __bit_iterator<_Cp, false>& __it) throw()
      : __seg_(__it.__seg_),
        __ctz_(__it.__ctz_) {}






  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator&
  operator=(const _If<_IsConst, struct __private_nat, __bit_iterator>& __it) {
    __seg_ = __it.__seg_;
    __ctz_ = __it.__ctz_;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator*() const throw() {
    return __conditional_t<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >(
        __seg_, __storage_type(1) << __ctz_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator& operator++() {
    if (__ctz_ != __bits_per_word - 1)
      ++__ctz_;
    else {
      __ctz_ = 0;
      ++__seg_;
    }
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator operator++(int) {
    __bit_iterator __tmp = *this;
    ++(*this);
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator& operator--() {
    if (__ctz_ != 0)
      --__ctz_;
    else {
      __ctz_ = __bits_per_word - 1;
      --__seg_;
    }
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator operator--(int) {
    __bit_iterator __tmp = *this;
    --(*this);
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator& operator+=(difference_type __n) {
    if (__n >= 0)
      __seg_ += (__n + __ctz_) / __bits_per_word;
    else
      __seg_ += static_cast<difference_type>(__n - __bits_per_word + __ctz_ + 1) /
                static_cast<difference_type>(__bits_per_word);
    __n &= (__bits_per_word - 1);
    __ctz_ = static_cast<unsigned>((__n + __ctz_) % __bits_per_word);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator& operator-=(difference_type __n) {
    return *this += -__n;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator operator+(difference_type __n) const {
    __bit_iterator __t(*this);
    __t += __n;
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bit_iterator operator-(difference_type __n) const {
    __bit_iterator __t(*this);
    __t -= __n;
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend __bit_iterator
  operator+(difference_type __n, const __bit_iterator& __it) {
    return __it + __n;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend difference_type
  operator-(const __bit_iterator& __x, const __bit_iterator& __y) {
    return (__x.__seg_ - __y.__seg_) * __bits_per_word + __x.__ctz_ - __y.__ctz_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator[](difference_type __n) const {
    return *(*this + __n);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool
  operator==(const __bit_iterator& __x, const __bit_iterator& __y) {
    return __x.__seg_ == __y.__seg_ && __x.__ctz_ == __y.__ctz_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool
  operator!=(const __bit_iterator& __x, const __bit_iterator& __y) {
    return !(__x == __y);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool
  operator<(const __bit_iterator& __x, const __bit_iterator& __y) {
    return __x.__seg_ < __y.__seg_ || (__x.__seg_ == __y.__seg_ && __x.__ctz_ < __y.__ctz_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool
  operator>(const __bit_iterator& __x, const __bit_iterator& __y) {
    return __y < __x;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool
  operator<=(const __bit_iterator& __x, const __bit_iterator& __y) {
    return !(__y < __x);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool
  operator>=(const __bit_iterator& __x, const __bit_iterator& __y) {
    return !(__x < __y);
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __bit_iterator(
      __storage_pointer __s, unsigned __ctz) throw()
      : __seg_(__s),
        __ctz_(__ctz) {}

  friend typename _Cp::__self;

  friend class __bit_reference<_Cp>;
  friend class __bit_const_reference<_Cp>;
  friend class __bit_iterator<_Cp, true>;
  template <class _Dp>
  friend struct __bit_array;
  template <bool _FillVal, class _Dp>
                                friend void __fill_n(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);

  template <class _Dp, bool _IC>
                                friend __bit_iterator<_Dp, false> __copy_aligned(
      __bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
  template <class _Dp, bool _IC>
                                friend __bit_iterator<_Dp, false> __copy_unaligned(
      __bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
  template <class _Dp, bool _IC>
                                friend __bit_iterator<_Dp, false>
  copy(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
  template <class _Dp, bool _IC>
                                friend __bit_iterator<_Dp, false> __copy_backward_aligned(
      __bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
  template <class _Dp, bool _IC>
                                friend __bit_iterator<_Dp, false> __copy_backward_unaligned(
      __bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
  template <class _Dp, bool _IC>
                                friend __bit_iterator<_Dp, false>
  copy_backward(__bit_iterator<_Dp, _IC> __first, __bit_iterator<_Dp, _IC> __last, __bit_iterator<_Dp, false> __result);
  template <class _Cl, class _Cr>
  friend __bit_iterator<_Cr, false>
      __swap_ranges_aligned(__bit_iterator<_Cl, false>, __bit_iterator<_Cl, false>, __bit_iterator<_Cr, false>);
  template <class _Cl, class _Cr>
  friend __bit_iterator<_Cr, false>
      __swap_ranges_unaligned(__bit_iterator<_Cl, false>, __bit_iterator<_Cl, false>, __bit_iterator<_Cr, false>);
  template <class _Cl, class _Cr>
  friend __bit_iterator<_Cr, false>
      swap_ranges(__bit_iterator<_Cl, false>, __bit_iterator<_Cl, false>, __bit_iterator<_Cr, false>);
  template <class _Dp>
                                friend __bit_iterator<_Dp, false>
      rotate(__bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>, __bit_iterator<_Dp, false>);
  template <class _Dp, bool _IC1, bool _IC2>
                                friend bool
      __equal_aligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
  template <class _Dp, bool _IC1, bool _IC2>
                                friend bool
      __equal_unaligned(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
  template <class _Dp, bool _IC1, bool _IC2>
                                friend bool
      equal(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC2>);
  template <bool _ToFind, class _Dp, bool _IC>
                                friend __bit_iterator<_Dp, _IC>
      __find_bool(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
  template <bool _ToCount, class _Dp, bool _IC>
  friend typename __bit_iterator<_Dp, _IC>::difference_type __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
      __count_bool(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
};

}}
# 321 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/enable_insertable.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/enable_insertable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/enable_insertable.h" 3
}}
# 324 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_fwd.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_fwd.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_fwd.h" 3
}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter.h" 3
}}
# 325 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_bool.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_bool.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/concepts.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/concepts.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_parse_context.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_parse_context.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_error.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_error.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdexcept" 1 3
# 47 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdexcept" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/string.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/string.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/memory_resource.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/memory_resource.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace pmr {
template <class _ValueType>
class polymorphic_allocator;
}

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/string.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/string.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT>
struct char_traits;
template <>
struct char_traits<char>;






template <>
struct char_traits<char16_t>;
template <>
struct char_traits<char32_t>;


template <>
struct char_traits<wchar_t>;


template <class _Tp>
class allocator;

template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT> >
class basic_string;

using string = basic_string<char>;


using wstring = basic_string<wchar_t>;






using u16string = basic_string<char16_t>;
using u32string = basic_string<char32_t>;
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/string.h" 3
template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__preferred_name__(string)))

      __attribute__((__preferred_name__(wstring)))




      __attribute__((__preferred_name__(u16string)))
      __attribute__((__preferred_name__(u32string)))
# 105 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/string.h" 3
      basic_string;


}}
# 48 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdexcept" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdexcept" 2 3
# 53 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdexcept" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


class __attribute__((__visibility__("hidden"))) __libcpp_refstring {
  const char* __imp_;

  bool __uses_refcount() const;

public:
  explicit __libcpp_refstring(const char* __msg);
  __libcpp_refstring(const __libcpp_refstring& __s) throw();
  __libcpp_refstring& operator=(const __libcpp_refstring& __s) throw();
  ~__libcpp_refstring();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const char* c_str() const throw() { return __imp_; }
};


}}

namespace std
{

class __attribute__((__visibility__("default"))) logic_error : public exception {


private:
  std::__libcpp_refstring __imp_;

public:
  explicit logic_error(const string&);
  explicit logic_error(const char*);

  logic_error(const logic_error&) throw();
  logic_error& operator=(const logic_error&) throw();

  ~logic_error() throw() override;

  const char* what() const throw() override;






};

class __attribute__((__visibility__("default"))) runtime_error : public exception {


private:
  std::__libcpp_refstring __imp_;

public:
  explicit runtime_error(const string&);
  explicit runtime_error(const char*);

  runtime_error(const runtime_error&) throw();
  runtime_error& operator=(const runtime_error&) throw();

  ~runtime_error() throw() override;

  const char* what() const throw() override;






};

class __attribute__((__visibility__("default"))) domain_error : public logic_error {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit domain_error(const string& __s) : logic_error(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit domain_error(const char* __s) : logic_error(__s) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) domain_error(const domain_error&) throw() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) domain_error& operator=(const domain_error&) throw() = default;
  ~domain_error() throw() override;

};

class __attribute__((__visibility__("default"))) invalid_argument : public logic_error {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit invalid_argument(const string& __s) : logic_error(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit invalid_argument(const char* __s) : logic_error(__s) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) invalid_argument(const invalid_argument&) throw() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) invalid_argument& operator=(const invalid_argument&) throw() = default;
  ~invalid_argument() throw() override;

};

class __attribute__((__visibility__("default"))) length_error : public logic_error {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit length_error(const string& __s) : logic_error(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit length_error(const char* __s) : logic_error(__s) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) length_error(const length_error&) throw() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) length_error& operator=(const length_error&) throw() = default;
  ~length_error() throw() override;

};

class __attribute__((__visibility__("default"))) out_of_range : public logic_error {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit out_of_range(const string& __s) : logic_error(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit out_of_range(const char* __s) : logic_error(__s) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) out_of_range(const out_of_range&) throw() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) out_of_range& operator=(const out_of_range&) throw() = default;
  ~out_of_range() throw() override;

};

class __attribute__((__visibility__("default"))) range_error : public runtime_error {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit range_error(const string& __s) : runtime_error(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit range_error(const char* __s) : runtime_error(__s) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) range_error(const range_error&) throw() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) range_error& operator=(const range_error&) throw() = default;
  ~range_error() throw() override;

};

class __attribute__((__visibility__("default"))) overflow_error : public runtime_error {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit overflow_error(const string& __s) : runtime_error(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit overflow_error(const char* __s) : runtime_error(__s) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) overflow_error(const overflow_error&) throw() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) overflow_error& operator=(const overflow_error&) throw() = default;
  ~overflow_error() throw() override;

};

class __attribute__((__visibility__("default"))) underflow_error : public runtime_error {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit underflow_error(const string& __s) : runtime_error(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit underflow_error(const char* __s) : runtime_error(__s) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) underflow_error(const underflow_error&) throw() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) underflow_error& operator=(const underflow_error&) throw() = default;
  ~underflow_error() throw() override;

};

}

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


__attribute__((__noreturn__)) __attribute__((__visibility__("default"))) void __throw_runtime_error(const char*);

__attribute__((__noreturn__)) inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __throw_logic_error(const char* __msg) {

  throw logic_error(__msg);



}

__attribute__((__noreturn__)) inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __throw_domain_error(const char* __msg) {

  throw domain_error(__msg);



}

__attribute__((__noreturn__)) inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __throw_invalid_argument(const char* __msg) {

  throw invalid_argument(__msg);



}

__attribute__((__noreturn__)) inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __throw_length_error(const char* __msg) {

  throw length_error(__msg);






}

__attribute__((__noreturn__)) inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __throw_out_of_range(const char* __msg) {

  throw out_of_range(__msg);






}

__attribute__((__noreturn__)) inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __throw_range_error(const char* __msg) {

  throw range_error(__msg);



}

__attribute__((__noreturn__)) inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __throw_overflow_error(const char* __msg) {

  throw overflow_error(__msg);



}

__attribute__((__noreturn__)) inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __throw_underflow_error(const char* __msg) {

  throw underflow_error(__msg);



}

}}



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/exception" 1 3
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/exception" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__exception/exception_ptr.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__exception/exception_ptr.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__exception/operations.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__exception/operations.h" 3


namespace std {


using unexpected_handler = void (*)();
__attribute__((__visibility__("default"))) unexpected_handler set_unexpected(unexpected_handler) throw();
__attribute__((__visibility__("default"))) unexpected_handler get_unexpected() throw();
__attribute__((__noreturn__)) __attribute__((__visibility__("default"))) void unexpected();


using terminate_handler = void (*)();
__attribute__((__visibility__("default"))) terminate_handler set_terminate(terminate_handler) throw();
__attribute__((__visibility__("default"))) terminate_handler get_terminate() throw();

__attribute__((__visibility__("default"))) bool uncaught_exception() throw();
__attribute__((__visibility__("default"))) int uncaught_exceptions() throw();

class __attribute__((__visibility__("default"))) exception_ptr;

__attribute__((__visibility__("default"))) exception_ptr current_exception() throw();
__attribute__((__noreturn__)) __attribute__((__visibility__("default"))) void rethrow_exception(exception_ptr);
}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__exception/exception_ptr.h" 2 3






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/typeinfo" 1 3
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/typeinfo" 3






namespace std
{
# 186 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/typeinfo" 3
struct __type_info_implementations {
  struct __string_impl_base {
    typedef const char* __type_name_t;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__always_inline__)) static const char*
    __type_name_to_string(__type_name_t __v) throw() {
      return __v;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__always_inline__)) static __type_name_t
    __string_to_type_name(const char* __v) throw() {
      return __v;
    }
  };

  struct __unique_impl : __string_impl_base {
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__always_inline__)) static size_t __hash(__type_name_t __v) throw() {
      return reinterpret_cast<size_t>(__v);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__always_inline__)) static bool __eq(__type_name_t __lhs, __type_name_t __rhs) throw() {
      return __lhs == __rhs;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__always_inline__)) static bool __lt(__type_name_t __lhs, __type_name_t __rhs) throw() {
      return __lhs < __rhs;
    }
  };

  struct __non_unique_impl : __string_impl_base {
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__always_inline__)) static size_t __hash(__type_name_t __ptr) throw() {
      size_t __hash = 5381;
      while (unsigned char __c = static_cast<unsigned char>(*__ptr++))
        __hash = (__hash * 33) ^ __c;
      return __hash;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__always_inline__)) static bool __eq(__type_name_t __lhs, __type_name_t __rhs) throw() {
      return __lhs == __rhs || __builtin_strcmp(__lhs, __rhs) == 0;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__always_inline__)) static bool __lt(__type_name_t __lhs, __type_name_t __rhs) throw() {
      return __builtin_strcmp(__lhs, __rhs) < 0;
    }
  };

  struct __non_unique_arm_rtti_bit_impl {
    typedef uintptr_t __type_name_t;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__always_inline__)) static const char* __type_name_to_string(__type_name_t __v) throw() {
      return reinterpret_cast<const char*>(__v & ~__non_unique_rtti_bit::value);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__always_inline__)) static __type_name_t __string_to_type_name(const char* __v) throw() {
      return reinterpret_cast<__type_name_t>(__v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__always_inline__)) static size_t __hash(__type_name_t __v) throw() {
      if (__is_type_name_unique(__v))
        return __v;
      return __non_unique_impl::__hash(__type_name_to_string(__v));
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__always_inline__)) static bool __eq(__type_name_t __lhs, __type_name_t __rhs) throw() {
      if (__lhs == __rhs)
        return true;
      if (__is_type_name_unique(__lhs) || __is_type_name_unique(__rhs))


        return false;
      return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) == 0;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__always_inline__)) static bool __lt(__type_name_t __lhs, __type_name_t __rhs) throw() {
      if (__is_type_name_unique(__lhs) || __is_type_name_unique(__rhs))
        return __lhs < __rhs;
      return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) < 0;
    }

  private:


    typedef integral_constant<__type_name_t, (1ULL << ((8 * sizeof(__type_name_t)) - 1))>
        __non_unique_rtti_bit;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static bool __is_type_name_unique(__type_name_t __lhs) throw() {
      return !(__lhs & __non_unique_rtti_bit::value);
    }
  };

  typedef





      __non_unique_arm_rtti_bit_impl



          __impl;
};
# 292 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/typeinfo" 3
class __attribute__((__visibility__("default"))) type_info {
  type_info& operator=(const type_info&);
  type_info(const type_info&);

protected:
  typedef __type_info_implementations::__impl __impl;

  __impl::__type_name_t __type_name;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit type_info(const char* __n) : __type_name(__impl::__string_to_type_name(__n)) {}

public:
  virtual ~type_info();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const char* name() const throw() { return __impl::__type_name_to_string(__type_name); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool before(const type_info& __arg) const throw() {
    return __impl::__lt(__type_name, __arg.__type_name);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t hash_code() const throw() { return __impl::__hash(__type_name); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const type_info& __arg) const throw() {


    if (__libcpp_is_constant_evaluated()) {
      return this == &__arg;
    }
    return __impl::__eq(__type_name, __arg.__type_name);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const type_info& __arg) const throw() { return !operator==(__arg); }

};


class __attribute__((__visibility__("default"))) bad_cast : public exception {
public:
  bad_cast() throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bad_cast(const bad_cast&) throw() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bad_cast& operator=(const bad_cast&) throw() = default;
  ~bad_cast() throw() override;
  const char* what() const throw() override;
};

class __attribute__((__visibility__("default"))) bad_typeid : public exception {
public:
  bad_typeid() throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bad_typeid(const bad_typeid&) throw() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bad_typeid& operator=(const bad_typeid&) throw() = default;
  ~bad_typeid() throw() override;
  const char* what() const throw() override;
};

}
# 375 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/typeinfo" 3
namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
__attribute__((__noreturn__)) inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __throw_bad_cast() {

  throw bad_cast();



}
}}
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__exception/exception_ptr.h" 2 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__exception/exception_ptr.h" 3




namespace __cxxabiv1 {

extern "C" {
__attribute__((__visibility__("default"))) void* __cxa_allocate_exception(size_t) throw();
__attribute__((__visibility__("default"))) void __cxa_free_exception(void*) throw();

struct __cxa_exception;
__attribute__((__visibility__("default"))) __cxa_exception* __cxa_init_primary_exception(
    void*,
    std::type_info*,
    void(



            *)(void*)) throw();
}

}



namespace std {



class __attribute__((__visibility__("default"))) exception_ptr {
  void* __ptr_;

  static exception_ptr __from_native_exception_pointer(void*) throw();

  template <class _Ep>
  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) exception_ptr make_exception_ptr(_Ep) throw();

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) exception_ptr() throw() : __ptr_() {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) exception_ptr(nullptr_t) throw() : __ptr_() {}

  exception_ptr(const exception_ptr&) throw();
  exception_ptr& operator=(const exception_ptr&) throw();
  ~exception_ptr() throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit operator bool() const throw() { return __ptr_ != __nullptr; }

  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const exception_ptr& __x, const exception_ptr& __y) throw() {
    return __x.__ptr_ == __y.__ptr_;
  }

  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const exception_ptr& __x, const exception_ptr& __y) throw() {
    return !(__x == __y);
  }

  friend __attribute__((__visibility__("default"))) exception_ptr current_exception() throw();
  friend __attribute__((__visibility__("default"))) void rethrow_exception(exception_ptr);
};

template <class _Ep>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) exception_ptr make_exception_ptr(_Ep __e) throw() {
# 103 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__exception/exception_ptr.h" 3
  try {
    throw __e;
  } catch (...) {
    return current_exception();
  }





}
# 157 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__exception/exception_ptr.h" 3
}
# 83 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/exception" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__exception/nested_exception.h" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__exception/nested_exception.h" 3


namespace std {

class __attribute__((__visibility__("default"))) nested_exception {
  exception_ptr __ptr_;

public:
  nested_exception() throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) nested_exception(const nested_exception&) throw() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) nested_exception& operator=(const nested_exception&) throw() = default;
  virtual ~nested_exception() throw();


  __attribute__((__noreturn__)) void rethrow_nested() const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) exception_ptr nested_ptr() const throw() { return __ptr_; }
};

template <class _Tp>
struct __nested : public _Tp, public nested_exception {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __nested(const _Tp& __t) : _Tp(__t) {}
};


template <class _Tp, class _Up, bool>
struct __throw_with_nested;

template <class _Tp, class _Up>
struct __throw_with_nested<_Tp, _Up, true> {
  __attribute__((__noreturn__)) static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __do_throw(_Tp&& __t) {
    throw __nested<_Up>(std::forward<_Tp>(__t));
  }
};

template <class _Tp, class _Up>
struct __throw_with_nested<_Tp, _Up, false> {
  __attribute__((__noreturn__)) static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __do_throw(_Tp&& __t) { throw std::forward<_Tp>(__t); }
};


template <class _Tp>
__attribute__((__noreturn__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void throw_with_nested(_Tp&& __t) {

  using _Up = __decay_t<_Tp>;
  _Static_assert(is_copy_constructible<_Up>::value, "type thrown must be CopyConstructible");
  __throw_with_nested<_Tp,
                      _Up,
                      is_class<_Up>::value && !is_base_of<nested_exception, _Up>::value &&
                          !__libcpp_is_final<_Up>::value>::__do_throw(std::forward<_Tp>(__t));




}

template <class _From, class _To>
struct __can_dynamic_cast
    : _BoolConstant< is_polymorphic<_From>::value &&
                     (!is_base_of<_To, _From>::value || is_convertible<const _From*, const _To*>::value)> {};

template <class _Ep>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
rethrow_if_nested(const _Ep& __e, __enable_if_t< __can_dynamic_cast<_Ep, nested_exception>::value>* = 0) {
  const nested_exception* __nep = dynamic_cast<const nested_exception*>(std::addressof(__e));
  if (__nep)
    __nep->rethrow_nested();
}

template <class _Ep>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
rethrow_if_nested(const _Ep&, __enable_if_t<!__can_dynamic_cast<_Ep, nested_exception>::value>* = 0) {}

}
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/exception" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__exception/terminate.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__exception/terminate.h" 3


namespace std {
__attribute__((__noreturn__)) __attribute__((__visibility__("default"))) void terminate() throw();
}
# 86 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/exception" 2 3
# 90 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/exception" 3
# 291 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdexcept" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iosfwd" 1 3
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iosfwd" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/fstream.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/fstream.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_filebuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ifstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ofstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_fstream;

using filebuf = basic_filebuf<char>;
using ifstream = basic_ifstream<char>;
using ofstream = basic_ofstream<char>;
using fstream = basic_fstream<char>;


using wfilebuf = basic_filebuf<wchar_t>;
using wifstream = basic_ifstream<wchar_t>;
using wofstream = basic_ofstream<wchar_t>;
using wfstream = basic_fstream<wchar_t>;


template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(filebuf))) __attribute__((__preferred_name__(wfilebuf))) basic_filebuf;
template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(ifstream))) __attribute__((__preferred_name__(wifstream))) basic_ifstream;
template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(ofstream))) __attribute__((__preferred_name__(wofstream))) basic_ofstream;
template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(fstream))) __attribute__((__preferred_name__(wfstream))) basic_fstream;

}}
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iosfwd" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/ios.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/ios.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ios;

using ios = basic_ios<char>;

using wios = basic_ios<wchar_t>;


template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(ios))) __attribute__((__preferred_name__(wios))) basic_ios;





using streamoff = long long;


}}
# 113 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iosfwd" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/istream.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/istream.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_istream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_iostream;

using istream = basic_istream<char>;
using iostream = basic_iostream<char>;


using wistream = basic_istream<wchar_t>;
using wiostream = basic_iostream<wchar_t>;


template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(istream))) __attribute__((__preferred_name__(wistream))) basic_istream;

template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(iostream))) __attribute__((__preferred_name__(wiostream))) basic_iostream;

}}
# 114 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iosfwd" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/ostream.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/ostream.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ostream;

using ostream = basic_ostream<char>;


using wostream = basic_ostream<wchar_t>;


template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(ostream))) __attribute__((__preferred_name__(wostream))) basic_ostream;

}}
# 115 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iosfwd" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/sstream.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/sstream.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT> >
class basic_stringbuf;

template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT> >
class basic_istringstream;
template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT> >
class basic_ostringstream;
template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT> >
class basic_stringstream;

using stringbuf = basic_stringbuf<char>;
using istringstream = basic_istringstream<char>;
using ostringstream = basic_ostringstream<char>;
using stringstream = basic_stringstream<char>;


using wstringbuf = basic_stringbuf<wchar_t>;
using wistringstream = basic_istringstream<wchar_t>;
using wostringstream = basic_ostringstream<wchar_t>;
using wstringstream = basic_stringstream<wchar_t>;


template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__preferred_name__(stringbuf))) __attribute__((__preferred_name__(wstringbuf))) basic_stringbuf;
template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__preferred_name__(istringstream)))
    __attribute__((__preferred_name__(wistringstream))) basic_istringstream;
template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__preferred_name__(ostringstream)))
    __attribute__((__preferred_name__(wostringstream))) basic_ostringstream;
template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__preferred_name__(stringstream)))
    __attribute__((__preferred_name__(wstringstream))) basic_stringstream;

}}
# 116 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iosfwd" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/streambuf.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/streambuf.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_streambuf;

using streambuf = basic_streambuf<char>;


using wstreambuf = basic_streambuf<wchar_t>;


template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(streambuf))) __attribute__((__preferred_name__(wstreambuf))) basic_streambuf;

}}
# 117 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iosfwd" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__std_mbstate_t.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__std_mbstate_t.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mbstate_t.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mbstate_t.h" 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__std_mbstate_t.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__std_mbstate_t.h" 3





namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::mbstate_t __attribute__((__using_if_exists__));

}}
# 119 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iosfwd" 2 3
# 123 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iosfwd" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

class __attribute__((__visibility__("default"))) ios_base;

template <class _CharT, class _Traits = char_traits<_CharT> >
class istreambuf_iterator;
template <class _CharT, class _Traits = char_traits<_CharT> >
class ostreambuf_iterator;

template <class _State>
class fpos;
typedef fpos<mbstate_t> streampos;

typedef fpos<mbstate_t> wstreampos;




typedef fpos<mbstate_t> u16streampos;
typedef fpos<mbstate_t> u32streampos;
# 167 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iosfwd" 3
template <class _Tp, class _Alloc = allocator<_Tp> >
class vector;

template <class _CharT, class _Traits>
class __save_flags {
  typedef basic_ios<_CharT, _Traits> __stream_type;
  typedef typename __stream_type::fmtflags fmtflags;

  __stream_type& __stream_;
  fmtflags __fmtflags_;
  _CharT __fill_;

  __save_flags(const __save_flags&);
  __save_flags& operator=(const __save_flags&);

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __save_flags(__stream_type& __stream)
      : __stream_(__stream), __fmtflags_(__stream.flags()), __fill_(__stream.fill()) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~__save_flags() {
    __stream_.flags(__fmtflags_);
    __stream_.fill(__fill_);
  }
};

}}
# 292 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdexcept" 2 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_error.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_error.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 48 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_error.h" 3
}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_parse_context.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 1 3
# 211 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Size __loadword(const void* __p) {
  _Size __r;
  std::memcpy(&__r, __p, sizeof(__r));
  return __r;
}




template <class _Size, size_t = sizeof(_Size) * 8>
struct __murmur2_or_cityhash;

template <class _Size>
struct __murmur2_or_cityhash<_Size, 32> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__no_sanitize__("unsigned-integer-overflow"))) _Size
  operator()(const void* __key, _Size __len) const {

    const _Size __m = 0x5bd1e995;
    const _Size __r = 24;
    _Size __h = __len;
    const unsigned char* __data = static_cast<const unsigned char*>(__key);
    for (; __len >= 4; __data += 4, __len -= 4) {
      _Size __k = std::__loadword<_Size>(__data);
      __k *= __m;
      __k ^= __k >> __r;
      __k *= __m;
      __h *= __m;
      __h ^= __k;
    }
    switch (__len) {
    case 3:
      __h ^= static_cast<_Size>(__data[2] << 16);
      __attribute__((__fallthrough__));
    case 2:
      __h ^= static_cast<_Size>(__data[1] << 8);
      __attribute__((__fallthrough__));
    case 1:
      __h ^= __data[0];
      __h *= __m;
    }
    __h ^= __h >> 13;
    __h *= __m;
    __h ^= __h >> 15;
    return __h;
  }
};

template <class _Size>
struct __murmur2_or_cityhash<_Size, 64> {

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__no_sanitize__("unsigned-integer-overflow"))) _Size
  operator()(const void* __key, _Size __len) const {
    const char* __s = static_cast<const char*>(__key);
    if (__len <= 32) {
      if (__len <= 16) {
        return __hash_len_0_to_16(__s, __len);
      } else {
        return __hash_len_17_to_32(__s, __len);
      }
    } else if (__len <= 64) {
      return __hash_len_33_to_64(__s, __len);
    }



    _Size __x = std::__loadword<_Size>(__s + __len - 40);
    _Size __y = std::__loadword<_Size>(__s + __len - 16) + std::__loadword<_Size>(__s + __len - 56);
    _Size __z =
        __hash_len_16(std::__loadword<_Size>(__s + __len - 48) + __len, std::__loadword<_Size>(__s + __len - 24));
    pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
    pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
    __x = __x * __k1 + std::__loadword<_Size>(__s);


    __len = (__len - 1) & ~static_cast<_Size>(63);
    do {
      __x = __rotate(__x + __y + __v.first + std::__loadword<_Size>(__s + 8), 37) * __k1;
      __y = __rotate(__y + __v.second + std::__loadword<_Size>(__s + 48), 42) * __k1;
      __x ^= __w.second;
      __y += __v.first + std::__loadword<_Size>(__s + 40);
      __z = __rotate(__z + __w.first, 33) * __k1;
      __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
      __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second, __y + std::__loadword<_Size>(__s + 16));
      std::swap(__z, __x);
      __s += 64;
      __len -= 64;
    } while (__len != 0);
    return __hash_len_16(__hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,
                         __hash_len_16(__v.second, __w.second) + __x);
  }

private:

  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
  static const _Size __k1 = 0xb492b66fbe98f273ULL;
  static const _Size __k2 = 0x9ae16a3b2f90404fULL;
  static const _Size __k3 = 0xc949d7c7509e6557ULL;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static _Size __rotate(_Size __val, int __shift) {
    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static _Size __rotate_by_at_least_1(_Size __val, int __shift) {
    return (__val >> __shift) | (__val << (64 - __shift));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static _Size __shift_mix(_Size __val) { return __val ^ (__val >> 47); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__no_sanitize__("unsigned-integer-overflow"))) static _Size __hash_len_16(_Size __u, _Size __v) {
    const _Size __mul = 0x9ddfea08eb382d69ULL;
    _Size __a = (__u ^ __v) * __mul;
    __a ^= (__a >> 47);
    _Size __b = (__v ^ __a) * __mul;
    __b ^= (__b >> 47);
    __b *= __mul;
    return __b;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__no_sanitize__("unsigned-integer-overflow"))) static _Size
  __hash_len_0_to_16(const char* __s, _Size __len) {
    if (__len > 8) {
      const _Size __a = std::__loadword<_Size>(__s);
      const _Size __b = std::__loadword<_Size>(__s + __len - 8);
      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
    }
    if (__len >= 4) {
      const uint32_t __a = std::__loadword<uint32_t>(__s);
      const uint32_t __b = std::__loadword<uint32_t>(__s + __len - 4);



      return __hash_len_16(__len + (__a << 3), __b);

    }
    if (__len > 0) {
      const unsigned char __a = static_cast<unsigned char>(__s[0]);
      const unsigned char __b = static_cast<unsigned char>(__s[__len >> 1]);
      const unsigned char __c = static_cast<unsigned char>(__s[__len - 1]);
      const uint32_t __y = static_cast<uint32_t>(__a) + (static_cast<uint32_t>(__b) << 8);
      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
    }
    return __k2;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__no_sanitize__("unsigned-integer-overflow"))) static _Size
  __hash_len_17_to_32(const char* __s, _Size __len) {
    const _Size __a = std::__loadword<_Size>(__s) * __k1;
    const _Size __b = std::__loadword<_Size>(__s + 8);
    const _Size __c = std::__loadword<_Size>(__s + __len - 8) * __k2;
    const _Size __d = std::__loadword<_Size>(__s + __len - 16) * __k0;
    return __hash_len_16(
        __rotate(__a - __b, 43) + __rotate(__c, 30) + __d, __a + __rotate(__b ^ __k3, 20) - __c + __len);
  }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__no_sanitize__("unsigned-integer-overflow"))) static pair<_Size, _Size>
  __weak_hash_len_32_with_seeds(_Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {
    __a += __w;
    __b = __rotate(__b + __a + __z, 21);
    const _Size __c = __a;
    __a += __x;
    __a += __y;
    __b += __rotate(__a, 44);
    return pair<_Size, _Size>(__a + __z, __b + __c);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__no_sanitize__("unsigned-integer-overflow"))) static pair<_Size, _Size>
  __weak_hash_len_32_with_seeds(const char* __s, _Size __a, _Size __b) {
    return __weak_hash_len_32_with_seeds(
        std::__loadword<_Size>(__s),
        std::__loadword<_Size>(__s + 8),
        std::__loadword<_Size>(__s + 16),
        std::__loadword<_Size>(__s + 24),
        __a,
        __b);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__no_sanitize__("unsigned-integer-overflow"))) static _Size
  __hash_len_33_to_64(const char* __s, size_t __len) {
    _Size __z = std::__loadword<_Size>(__s + 24);
    _Size __a = std::__loadword<_Size>(__s) + (__len + std::__loadword<_Size>(__s + __len - 16)) * __k0;
    _Size __b = __rotate(__a + __z, 52);
    _Size __c = __rotate(__a, 37);
    __a += std::__loadword<_Size>(__s + 8);
    __c += __rotate(__a, 7);
    __a += std::__loadword<_Size>(__s + 16);
    _Size __vf = __a + __z;
    _Size __vs = __b + __rotate(__a, 31) + __c;
    __a = std::__loadword<_Size>(__s + 16) + std::__loadword<_Size>(__s + __len - 32);
    __z += std::__loadword<_Size>(__s + __len - 8);
    __b = __rotate(__a + __z, 52);
    __c = __rotate(__a, 37);
    __a += std::__loadword<_Size>(__s + __len - 24);
    __c += __rotate(__a, 7);
    __a += std::__loadword<_Size>(__s + __len - 16);
    _Size __wf = __a + __z;
    _Size __ws = __b + __rotate(__a, 31) + __c;
    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
    return __shift_mix(__r * __k0 + __vs) * __k2;
  }
};

template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>
struct __scalar_hash;

template <class _Tp>
struct __scalar_hash<_Tp, 0> : public __unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(_Tp __v) const throw() {
    union {
      _Tp __t;
      size_t __a;
    } __u;
    __u.__a = 0;
    __u.__t = __v;
    return __u.__a;
  }
};

template <class _Tp>
struct __scalar_hash<_Tp, 1> : public __unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(_Tp __v) const throw() {
    union {
      _Tp __t;
      size_t __a;
    } __u;
    __u.__t = __v;
    return __u.__a;
  }
};

template <class _Tp>
struct __scalar_hash<_Tp, 2> : public __unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(_Tp __v) const throw() {
    union {
      _Tp __t;
      struct {
        size_t __a;
        size_t __b;
      } __s;
    } __u;
    __u.__t = __v;
    return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
  }
};

template <class _Tp>
struct __scalar_hash<_Tp, 3> : public __unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(_Tp __v) const throw() {
    union {
      _Tp __t;
      struct {
        size_t __a;
        size_t __b;
        size_t __c;
      } __s;
    } __u;
    __u.__t = __v;
    return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
  }
};

template <class _Tp>
struct __scalar_hash<_Tp, 4> : public __unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(_Tp __v) const throw() {
    union {
      _Tp __t;
      struct {
        size_t __a;
        size_t __b;
        size_t __c;
        size_t __d;
      } __s;
    } __u;
    __u.__t = __v;
    return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
  }
};

struct _PairT {
  size_t first;
  size_t second;
};

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline size_t __hash_combine(size_t __lhs, size_t __rhs) throw() {
  typedef __scalar_hash<_PairT> _HashT;
  const _PairT __p = {__lhs, __rhs};
  return _HashT()(__p);
}

template <class _Tp>
struct hash<_Tp*> : public __unary_function<_Tp*, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(_Tp* __v) const throw() {
    union {
      _Tp* __t;
      size_t __a;
    } __u;
    __u.__t = __v;
    return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
  }
};

template <>
struct hash<bool> : public __unary_function<bool, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(bool __v) const throw() { return static_cast<size_t>(__v); }
};

template <>
struct hash<char> : public __unary_function<char, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(char __v) const throw() { return static_cast<size_t>(__v); }
};

template <>
struct hash<signed char> : public __unary_function<signed char, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(signed char __v) const throw() { return static_cast<size_t>(__v); }
};

template <>
struct hash<unsigned char> : public __unary_function<unsigned char, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(unsigned char __v) const throw() { return static_cast<size_t>(__v); }
};
# 370 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
template <>
struct hash<char16_t> : public __unary_function<char16_t, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(char16_t __v) const throw() { return static_cast<size_t>(__v); }
};

template <>
struct hash<char32_t> : public __unary_function<char32_t, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(char32_t __v) const throw() { return static_cast<size_t>(__v); }
};


template <>
struct hash<wchar_t> : public __unary_function<wchar_t, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(wchar_t __v) const throw() { return static_cast<size_t>(__v); }
};


template <>
struct hash<short> : public __unary_function<short, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(short __v) const throw() { return static_cast<size_t>(__v); }
};

template <>
struct hash<unsigned short> : public __unary_function<unsigned short, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(unsigned short __v) const throw() { return static_cast<size_t>(__v); }
};

template <>
struct hash<int> : public __unary_function<int, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(int __v) const throw() { return static_cast<size_t>(__v); }
};

template <>
struct hash<unsigned int> : public __unary_function<unsigned int, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(unsigned int __v) const throw() { return static_cast<size_t>(__v); }
};

template <>
struct hash<long> : public __unary_function<long, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(long __v) const throw() { return static_cast<size_t>(__v); }
};

template <>
struct hash<unsigned long> : public __unary_function<unsigned long, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(unsigned long __v) const throw() { return static_cast<size_t>(__v); }
};

template <>
struct hash<long long> : public __scalar_hash<long long> {};

template <>
struct hash<unsigned long long> : public __scalar_hash<unsigned long long> {};



template <>
struct hash<__int128_t> : public __scalar_hash<__int128_t> {};

template <>
struct hash<__uint128_t> : public __scalar_hash<__uint128_t> {};



template <>
struct hash<float> : public __scalar_hash<float> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(float __v) const throw() {

    if (__v == 0.0f)
      return 0;
    return __scalar_hash<float>::operator()(__v);
  }
};

template <>
struct hash<double> : public __scalar_hash<double> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(double __v) const throw() {

    if (__v == 0.0)
      return 0;
    return __scalar_hash<double>::operator()(__v);
  }
};

template <>
struct hash<long double> : public __scalar_hash<long double> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(long double __v) const throw() {

    if (__v == 0.0L)
      return 0;
# 490 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
    return __scalar_hash<long double>::operator()(__v);

  }
};

template <class _Tp, bool = is_enum<_Tp>::value>
struct __enum_hash : public __unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(_Tp __v) const throw() {
    typedef typename underlying_type<_Tp>::type type;
    return hash<type>()(static_cast<type>(__v));
  }
};
template <class _Tp>
struct __enum_hash<_Tp, false> {
  __enum_hash() = delete;
  __enum_hash(__enum_hash const&) = delete;
  __enum_hash& operator=(__enum_hash const&) = delete;
};

template <class _Tp>
struct hash : public __enum_hash<_Tp> {};
# 545 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/hash.h" 3
}}
# 212 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/string_view.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__fwd/string_view.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_string_view;

typedef basic_string_view<char> string_view;



typedef basic_string_view<char16_t> u16string_view;
typedef basic_string_view<char32_t> u32string_view;

typedef basic_string_view<wchar_t> wstring_view;



template <class _CharT, class _Traits>
class __attribute__((__preferred_name__(string_view)))

      __attribute__((__preferred_name__(wstring_view)))




      __attribute__((__preferred_name__(u16string_view)))
      __attribute__((__preferred_name__(u32string_view)))
      basic_string_view;

}}
# 214 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/bounded_iter.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/bounded_iter.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/bounded_iter.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/bounded_iter.h" 3
template <class _Iterator, class = __enable_if_t< __libcpp_is_contiguous_iterator<_Iterator>::value > >
struct __bounded_iter {
  using value_type = typename iterator_traits<_Iterator>::value_type;
  using difference_type = typename iterator_traits<_Iterator>::difference_type;
  using pointer = typename iterator_traits<_Iterator>::pointer;
  using reference = typename iterator_traits<_Iterator>::reference;
  using iterator_category = typename iterator_traits<_Iterator>::iterator_category;
# 56 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/bounded_iter.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bounded_iter() = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bounded_iter(__bounded_iter const&) = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bounded_iter(__bounded_iter&&) = default;

  template <class _OtherIterator, class = __enable_if_t< is_convertible<_OtherIterator, _Iterator>::value > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bounded_iter(__bounded_iter<_OtherIterator> const& __other) throw()
      : __current_(__other.__current_),
        __begin_(__other.__begin_),
        __end_(__other.__end_) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bounded_iter& operator=(__bounded_iter const&) = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bounded_iter& operator=(__bounded_iter&&) = default;

private:
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/bounded_iter.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __bounded_iter(
      _Iterator __current, _Iterator __begin, _Iterator __end)
      : __current_(__current), __begin_(__begin), __end_(__end) {
    ((void)0);
  }

  template <class _It>
  friend __bounded_iter<_It> __make_bounded_iter(_It, _It, _It);

public:



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator*() const throw() {
    ((void)0);

    return *__current_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer operator->() const throw() {
    ((void)0);

    return std::__to_address(__current_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator[](difference_type __n) const throw() {
    ((void)0);

    return __current_[__n];
  }





  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bounded_iter& operator++() throw() {
    ++__current_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bounded_iter operator++(int) throw() {
    __bounded_iter __tmp(*this);
    ++*this;
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bounded_iter& operator--() throw() {
    --__current_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bounded_iter operator--(int) throw() {
    __bounded_iter __tmp(*this);
    --*this;
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bounded_iter& operator+=(difference_type __n) throw() {
    __current_ += __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend __bounded_iter
  operator+(__bounded_iter const& __self, difference_type __n) throw() {
    __bounded_iter __tmp(__self);
    __tmp += __n;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend __bounded_iter
  operator+(difference_type __n, __bounded_iter const& __self) throw() {
    __bounded_iter __tmp(__self);
    __tmp += __n;
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bounded_iter& operator-=(difference_type __n) throw() {
    __current_ -= __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend __bounded_iter
  operator-(__bounded_iter const& __self, difference_type __n) throw() {
    __bounded_iter __tmp(__self);
    __tmp -= __n;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend difference_type
  operator-(__bounded_iter const& __x, __bounded_iter const& __y) throw() {
    return __x.__current_ - __y.__current_;
  }







  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool
  operator==(__bounded_iter const& __x, __bounded_iter const& __y) throw() {
    return __x.__current_ == __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool
  operator!=(__bounded_iter const& __x, __bounded_iter const& __y) throw() {
    return __x.__current_ != __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool
  operator<(__bounded_iter const& __x, __bounded_iter const& __y) throw() {
    return __x.__current_ < __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool
  operator>(__bounded_iter const& __x, __bounded_iter const& __y) throw() {
    return __x.__current_ > __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool
  operator<=(__bounded_iter const& __x, __bounded_iter const& __y) throw() {
    return __x.__current_ <= __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool
  operator>=(__bounded_iter const& __x, __bounded_iter const& __y) throw() {
    return __x.__current_ >= __y.__current_;
  }

private:

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __in_bounds(_Iterator const& __iter) const {
    return __iter >= __begin_ && __iter < __end_;
  }

  template <class>
  friend struct pointer_traits;
  _Iterator __current_;
  _Iterator __begin_, __end_;
};

template <class _It>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bounded_iter<_It> __make_bounded_iter(_It __it, _It __begin, _It __end) {
  return __bounded_iter<_It>(std::move(__it), std::move(__begin), std::move(__end));
}


template <class _Iterator>
struct __libcpp_is_contiguous_iterator<__bounded_iter<_Iterator> > : true_type {};


template <class _Iterator>
struct pointer_traits<__bounded_iter<_Iterator> > {
  using pointer = __bounded_iter<_Iterator>;
  using element_type = typename pointer_traits<_Iterator>::element_type;
  using difference_type = typename pointer_traits<_Iterator>::difference_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static element_type* to_address(pointer __it) throw() {
    return std::__to_address(__it.__current_);
  }
};

}}
# 215 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/compare_three_way_result.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/compare_three_way_result.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/compare_three_way_result.h" 3
}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 2 3








# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/iterator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Category, class _Tp, class _Distance = ptrdiff_t, class _Pointer = _Tp*, class _Reference = _Tp&>
struct iterator {
  typedef _Tp value_type;
  typedef _Distance difference_type;
  typedef _Pointer pointer;
  typedef _Reference reference;
  typedef _Category iterator_category;
};

}}
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 2 3








# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/subrange.h" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/subrange.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/dangling.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/dangling.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/dangling.h" 3
}}
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/subrange.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/view_interface.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/view_interface.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/empty.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/empty.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/empty.h" 3
}}
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/view_interface.h" 2 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/view_interface.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 159 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/view_interface.h" 3
}}
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/subrange.h" 2 3
# 47 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/subrange.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 51 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/subrange.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 272 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/subrange.h" 3
}}
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 2 3
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

#pragma GCC diagnostic push
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Iter>
class reverse_iterator

    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference>

{
#pragma GCC diagnostic pop

private:

  _Iter __t_;







protected:
  _Iter current;

public:
  using iterator_type = _Iter;

  using iterator_category =
      _If<__has_random_access_iterator_category<_Iter>::value,
          random_access_iterator_tag,
          typename iterator_traits<_Iter>::iterator_category>;
  using pointer = typename iterator_traits<_Iter>::pointer;






  using value_type = typename iterator_traits<_Iter>::value_type;
  using difference_type = typename iterator_traits<_Iter>::difference_type;
  using reference = typename iterator_traits<_Iter>::reference;



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator() : __t_(), current() {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit reverse_iterator(_Iter __x) : __t_(__x), current(__x) {}

  template <class _Up,
            class = __enable_if_t< !is_same<_Up, _Iter>::value && is_convertible<_Up const&, _Iter>::value > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator(const reverse_iterator<_Up>& __u)
      : __t_(__u.base()), current(__u.base()) {}

  template <class _Up,
            class = __enable_if_t< !is_same<_Up, _Iter>::value && is_convertible<_Up const&, _Iter>::value &&
                                   is_assignable<_Iter&, _Up const&>::value > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator& operator=(const reverse_iterator<_Up>& __u) {
    __t_ = current = __u.base();
    return *this;
  }
# 129 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Iter base() const { return current; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator*() const {
    _Iter __tmp = current;
    return *--__tmp;
  }
# 146 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer operator->() const { return std::addressof(operator*()); }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator& operator++() {
    --current;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator operator++(int) {
    reverse_iterator __tmp(*this);
    --current;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator& operator--() {
    ++current;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator operator--(int) {
    reverse_iterator __tmp(*this);
    ++current;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator operator+(difference_type __n) const {
    return reverse_iterator(current - __n);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator& operator+=(difference_type __n) {
    current -= __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator operator-(difference_type __n) const {
    return reverse_iterator(current + __n);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator& operator-=(difference_type __n) {
    current += __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator[](difference_type __n) const {
    return *(*this + __n);
  }
# 203 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 3
};

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)





{
  return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)





{
  return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)





{
  return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)





{
  return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)





{
  return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)





{
  return __x.base() >= __y.base();
}
# 293 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 3
template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename reverse_iterator<_Iter1>::difference_type
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y) {
  return __y.base() - __x.base();
}


template <class _Iter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator<_Iter>
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x) {
  return reverse_iterator<_Iter>(__x.base() - __n);
}
# 320 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 3
template <class _Iter>
using __unconstrained_reverse_iterator = reverse_iterator<_Iter>;
# 469 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 3
template <template <class> class _RevIter1, template <class> class _RevIter2, class _Iter>
struct __unwrap_reverse_iter_impl {
  using _UnwrappedIter = __decltype(__unwrap_iter_impl<_Iter>::__unwrap(std::declval<_Iter>()));
  using _ReverseWrapper = _RevIter1<_RevIter2<_Iter> >;

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ReverseWrapper
  __rewrap(_ReverseWrapper __orig_iter, _UnwrappedIter __unwrapped_iter) {
    return _ReverseWrapper(
        _RevIter2<_Iter>(__unwrap_iter_impl<_Iter>::__rewrap(__orig_iter.base().base(), __unwrapped_iter)));
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _UnwrappedIter __unwrap(_ReverseWrapper __i) throw() {
    return __unwrap_iter_impl<_Iter>::__unwrap(__i.base().base());
  }
};
# 495 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 3
template <class _Iter, bool __b>
struct __unwrap_iter_impl<reverse_iterator<reverse_iterator<_Iter> >, __b>
    : __unwrap_reverse_iter_impl<reverse_iterator, reverse_iterator, _Iter> {};
# 515 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_iterator.h" 3
}}
# 218 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 2 3






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/char_traits.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/char_traits.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_end.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_end.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/search.h" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/search.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy,
          class _Iter1,
          class _Sent1,
          class _Iter2,
          class _Sent2,
          class _Pred,
          class _Proj1,
          class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_Iter1, _Iter1> __search_forward_impl(
    _Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2, _Pred& __pred, _Proj1& __proj1, _Proj2& __proj2) {
  if (__first2 == __last2)
    return std::make_pair(__first1, __first1);
  while (true) {

    while (true) {
      if (__first1 == __last1) {
        _IterOps<_AlgPolicy>::__advance_to(__first1, __last1);
        return std::make_pair(__first1, __first1);
      }
      if (std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
        break;
      ++__first1;
    }

    _Iter1 __m1 = __first1;
    _Iter2 __m2 = __first2;
    while (true) {
      if (++__m2 == __last2)
        return std::make_pair(__first1, ++__m1);
      if (++__m1 == __last1) {
        return std::make_pair(__m1, __m1);
      }


      if (!std::__invoke(__pred, std::__invoke(__proj1, *__m1), std::__invoke(__proj2, *__m2))) {
        ++__first1;
        break;
      }
    }
  }
}

template <class _AlgPolicy,
          class _Iter1,
          class _Sent1,
          class _Iter2,
          class _Sent2,
          class _Pred,
          class _Proj1,
          class _Proj2,
          class _DiffT1,
          class _DiffT2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_Iter1, _Iter1> __search_random_access_impl(
    _Iter1 __first1,
    _Sent1 __last1,
    _Iter2 __first2,
    _Sent2 __last2,
    _Pred& __pred,
    _Proj1& __proj1,
    _Proj2& __proj2,
    _DiffT1 __size1,
    _DiffT2 __size2) {
  const _Iter1 __s = __first1 + __size1 - _DiffT1(__size2 - 1);

  while (true) {
    while (true) {
      if (__first1 == __s) {
        _IterOps<_AlgPolicy>::__advance_to(__first1, __last1);
        return std::make_pair(__first1, __first1);
      }
      if (std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
        break;
      ++__first1;
    }

    _Iter1 __m1 = __first1;
    _Iter2 __m2 = __first2;
    while (true) {
      if (++__m2 == __last2)
        return std::make_pair(__first1, __first1 + _DiffT1(__size2));
      ++__m1;
      if (!std::__invoke(__pred, std::__invoke(__proj1, *__m1), std::__invoke(__proj2, *__m2))) {
        ++__first1;
        break;
      }
    }
  }
}

template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class _Pred, class _Proj1, class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_Iter1, _Iter1> __search_impl(
    _Iter1 __first1,
    _Sent1 __last1,
    _Iter2 __first2,
    _Sent2 __last2,
    _Pred& __pred,
    _Proj1& __proj1,
    _Proj2& __proj2,
    __enable_if_t<__has_random_access_iterator_category<_Iter1>::value &&
                  __has_random_access_iterator_category<_Iter2>::value>* = __nullptr) {
  auto __size2 = __last2 - __first2;
  if (__size2 == 0)
    return std::make_pair(__first1, __first1);

  auto __size1 = __last1 - __first1;
  if (__size1 < __size2) {
    return std::make_pair(__last1, __last1);
  }

  return std::__search_random_access_impl<_ClassicAlgPolicy>(
      __first1, __last1, __first2, __last2, __pred, __proj1, __proj2, __size1, __size2);
}

template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class _Pred, class _Proj1, class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_Iter1, _Iter1> __search_impl(
    _Iter1 __first1,
    _Sent1 __last1,
    _Iter2 __first2,
    _Sent2 __last2,
    _Pred& __pred,
    _Proj1& __proj1,
    _Proj2& __proj2,
    __enable_if_t<__has_forward_iterator_category<_Iter1>::value && __has_forward_iterator_category<_Iter2>::value &&
                  !(__has_random_access_iterator_category<_Iter1>::value &&
                    __has_random_access_iterator_category<_Iter2>::value)>* = __nullptr) {
  return std::__search_forward_impl<_ClassicAlgPolicy>(__first1, __last1, __first2, __last2, __pred, __proj1, __proj2);
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator1
search(_ForwardIterator1 __first1,
       _ForwardIterator1 __last1,
       _ForwardIterator2 __first2,
       _ForwardIterator2 __last2,
       _BinaryPredicate __pred) {
  _Static_assert(__is_callable<_BinaryPredicate, __decltype(*__first1), __decltype(*__first2)>::value, "BinaryPredicate has to be callable");

  auto __proj = __identity();
  return std::__search_impl(__first1, __last1, __first2, __last2, __pred, __proj, __proj).first;
}

template <class _ForwardIterator1, class _ForwardIterator2>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  return std::search(__first1, __last1, __first2, __last2, __equal_to());
}
# 187 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/search.h" 3
}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_end.h" 2 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_end.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template < class _AlgPolicy,
           class _Iter1,
           class _Sent1,
           class _Iter2,
           class _Sent2,
           class _Pred,
           class _Proj1,
           class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline pair<_Iter1, _Iter1> __find_end_impl(
    _Iter1 __first1,
    _Sent1 __last1,
    _Iter2 __first2,
    _Sent2 __last2,
    _Pred& __pred,
    _Proj1& __proj1,
    _Proj2& __proj2,
    forward_iterator_tag,
    forward_iterator_tag) {

  _Iter1 __match_first = _IterOps<_AlgPolicy>::next(__first1, __last1);
  _Iter1 __match_last = __match_first;
  if (__first2 == __last2)
    return pair<_Iter1, _Iter1>(__match_last, __match_last);
  while (true) {
    while (true) {
      if (__first1 == __last1)
        return pair<_Iter1, _Iter1>(__match_first, __match_last);
      if (std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
        break;
      ++__first1;
    }

    _Iter1 __m1 = __first1;
    _Iter2 __m2 = __first2;
    while (true) {
      if (++__m2 == __last2) {
        __match_first = __first1;
        __match_last = ++__m1;
        ++__first1;
        break;
      }
      if (++__m1 == __last1)
        return pair<_Iter1, _Iter1>(__match_first, __match_last);

      if (!std::__invoke(__pred, std::__invoke(__proj1, *__m1), std::__invoke(__proj2, *__m2))) {
        ++__first1;
        break;
      }
    }
  }
}

template < class _IterOps,
           class _Pred,
           class _Iter1,
           class _Sent1,
           class _Iter2,
           class _Sent2,
           class _Proj1,
           class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Iter1 __find_end(
    _Iter1 __first1,
    _Sent1 __sent1,
    _Iter2 __first2,
    _Sent2 __sent2,
    _Pred& __pred,
    _Proj1& __proj1,
    _Proj2& __proj2,
    bidirectional_iterator_tag,
    bidirectional_iterator_tag) {
  auto __last1 = _IterOps::next(__first1, __sent1);
  auto __last2 = _IterOps::next(__first2, __sent2);

  if (__first2 == __last2)
    return __last1;
  _Iter1 __l1 = __last1;
  _Iter2 __l2 = __last2;
  --__l2;
  while (true) {

    while (true) {
      if (__first1 == __l1)
        return __last1;
      if (std::__invoke(__pred, std::__invoke(__proj1, *--__l1), std::__invoke(__proj2, *__l2)))
        break;
    }

    _Iter1 __m1 = __l1;
    _Iter2 __m2 = __l2;
    while (true) {
      if (__m2 == __first2)
        return __m1;
      if (__m1 == __first1)
        return __last1;


      if (!std::__invoke(__pred, std::__invoke(__proj1, *--__m1), std::__invoke(__proj2, *--__m2))) {
        break;
      }
    }
  }
}

template < class _AlgPolicy,
           class _Pred,
           class _Iter1,
           class _Sent1,
           class _Iter2,
           class _Sent2,
           class _Proj1,
           class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Iter1 __find_end(
    _Iter1 __first1,
    _Sent1 __sent1,
    _Iter2 __first2,
    _Sent2 __sent2,
    _Pred& __pred,
    _Proj1& __proj1,
    _Proj2& __proj2,
    random_access_iterator_tag,
    random_access_iterator_tag) {
  typedef typename iterator_traits<_Iter1>::difference_type _D1;
  auto __last1 = _IterOps<_AlgPolicy>::next(__first1, __sent1);
  auto __last2 = _IterOps<_AlgPolicy>::next(__first2, __sent2);

  auto __len2 = __last2 - __first2;
  if (__len2 == 0)
    return __last1;
  auto __len1 = __last1 - __first1;
  if (__len1 < __len2)
    return __last1;
  const _Iter1 __s = __first1 + _D1(__len2 - 1);
  _Iter1 __l1 = __last1;
  _Iter2 __l2 = __last2;
  --__l2;
  while (true) {
    while (true) {
      if (__s == __l1)
        return __last1;
      if (std::__invoke(__pred, std::__invoke(__proj1, *--__l1), std::__invoke(__proj2, *__l2)))
        break;
    }
    _Iter1 __m1 = __l1;
    _Iter2 __m2 = __l2;
    while (true) {
      if (__m2 == __first2)
        return __m1;

      if (!std::__invoke(__pred, std::__invoke(__proj1, *--__m1), std::__invoke(*--__m2))) {
        break;
      }
    }
  }
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator1 __find_end_classic(
    _ForwardIterator1 __first1,
    _ForwardIterator1 __last1,
    _ForwardIterator2 __first2,
    _ForwardIterator2 __last2,
    _BinaryPredicate& __pred) {
  auto __proj = __identity();
  return std::__find_end_impl<_ClassicAlgPolicy>(
             __first1,
             __last1,
             __first2,
             __last2,
             __pred,
             __proj,
             __proj,
             typename iterator_traits<_ForwardIterator1>::iterator_category(),
             typename iterator_traits<_ForwardIterator2>::iterator_category())
      .first;
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator1 find_end(
    _ForwardIterator1 __first1,
    _ForwardIterator1 __last1,
    _ForwardIterator2 __first2,
    _ForwardIterator2 __last2,
    _BinaryPredicate __pred) {
  return std::__find_end_classic(__first1, __last1, __first2, __last2, __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  return std::find_end(__first1, __last1, __first2, __last2, __equal_to());
}

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/char_traits.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_first_of.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_first_of.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator1 __find_first_of_ce(
    _ForwardIterator1 __first1,
    _ForwardIterator1 __last1,
    _ForwardIterator2 __first2,
    _ForwardIterator2 __last2,
    _BinaryPredicate&& __pred) {
  for (; __first1 != __last1; ++__first1)
    for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
      if (__pred(*__first1, *__j))
        return __first1;
  return __last1;
}

template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator1 find_first_of(
    _ForwardIterator1 __first1,
    _ForwardIterator1 __last1,
    _ForwardIterator2 __first2,
    _ForwardIterator2 __last2,
    _BinaryPredicate __pred) {
  return std::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator1 find_first_of(
    _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  return std::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to());
}

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/char_traits.h" 2 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/char_traits.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdio" 1 3
# 101 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdio" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdio.h" 1 3
# 102 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdio" 2 3
# 113 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdio" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::FILE __attribute__((__using_if_exists__));
using ::fpos_t __attribute__((__using_if_exists__));
using ::size_t __attribute__((__using_if_exists__));

using ::fclose __attribute__((__using_if_exists__));
using ::fflush __attribute__((__using_if_exists__));
using ::setbuf __attribute__((__using_if_exists__));
using ::setvbuf __attribute__((__using_if_exists__));
using ::fprintf __attribute__((__using_if_exists__));
using ::fscanf __attribute__((__using_if_exists__));
using ::snprintf __attribute__((__using_if_exists__));
using ::sprintf __attribute__((__using_if_exists__));
using ::sscanf __attribute__((__using_if_exists__));
using ::vfprintf __attribute__((__using_if_exists__));
using ::vfscanf __attribute__((__using_if_exists__));
using ::vsscanf __attribute__((__using_if_exists__));
using ::vsnprintf __attribute__((__using_if_exists__));
using ::vsprintf __attribute__((__using_if_exists__));
using ::fgetc __attribute__((__using_if_exists__));
using ::fgets __attribute__((__using_if_exists__));
using ::fputc __attribute__((__using_if_exists__));
using ::fputs __attribute__((__using_if_exists__));
using ::getc __attribute__((__using_if_exists__));
using ::putc __attribute__((__using_if_exists__));
using ::ungetc __attribute__((__using_if_exists__));
using ::fread __attribute__((__using_if_exists__));
using ::fwrite __attribute__((__using_if_exists__));
using ::fgetpos __attribute__((__using_if_exists__));
using ::fseek __attribute__((__using_if_exists__));
using ::fsetpos __attribute__((__using_if_exists__));
using ::ftell __attribute__((__using_if_exists__));
using ::rewind __attribute__((__using_if_exists__));
using ::clearerr __attribute__((__using_if_exists__));
using ::feof __attribute__((__using_if_exists__));
using ::ferror __attribute__((__using_if_exists__));
using ::perror __attribute__((__using_if_exists__));

using ::fopen __attribute__((__using_if_exists__));
using ::freopen __attribute__((__using_if_exists__));

using ::remove __attribute__((__using_if_exists__));

using ::rename __attribute__((__using_if_exists__));
using ::tmpfile __attribute__((__using_if_exists__));
using ::tmpnam __attribute__((__using_if_exists__));

using ::getchar __attribute__((__using_if_exists__));

using ::gets __attribute__((__using_if_exists__));

using ::scanf __attribute__((__using_if_exists__));
using ::vscanf __attribute__((__using_if_exists__));

using ::printf __attribute__((__using_if_exists__));
using ::putchar __attribute__((__using_if_exists__));
using ::puts __attribute__((__using_if_exists__));
using ::vprintf __attribute__((__using_if_exists__));

}}
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/char_traits.h" 2 3
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/char_traits.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/char_traits.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT>
struct char_traits;
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/char_traits.h" 3
template <class _CharT>
struct __attribute__((__deprecated__("char_traits<T> for T not equal to char, wchar_t, char8_t, char16_t or char32_t is non-standard and is provided " "for a temporary period. It will be removed in LLVM 19, so please migrate off of it."))) char_traits {


  using char_type = _CharT;
  using int_type = int;
  using off_type = streamoff;
  using pos_type = streampos;
  using state_type = mbstate_t;

  static inline void __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  assign(char_type& __c1, const char_type& __c2) throw() {
    __c1 = __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool eq(char_type __c1, char_type __c2) throw() {
    return __c1 == __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool lt(char_type __c1, char_type __c2) throw() {
    return __c1 < __c2;
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int
  compare(const char_type* __s1, const char_type* __s2, size_t __n) {
    for (; __n; --__n, ++__s1, ++__s2) {
      if (lt(*__s1, *__s2))
        return -1;
      if (lt(*__s2, *__s1))
        return 1;
    }
    return 0;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static size_t length(const char_type* __s) {
    size_t __len = 0;
    for (; !eq(*__s, char_type(0)); ++__s)
      ++__len;
    return __len;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static const char_type*
  find(const char_type* __s, size_t __n, const char_type& __a) {
    for (; __n; --__n) {
      if (eq(*__s, __a))
        return __s;
      ++__s;
    }
    return __nullptr;
  }
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type*
  move(char_type* __s1, const char_type* __s2, size_t __n) {
    if (__n == 0)
      return __s1;
    char_type* __r = __s1;
    if (__s1 < __s2) {
      for (; __n; --__n, ++__s1, ++__s2)
        assign(*__s1, *__s2);
    } else if (__s2 < __s1) {
      __s1 += __n;
      __s2 += __n;
      for (; __n; --__n)
        assign(*--__s1, *--__s2);
    }
    return __r;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static char_type*
  copy(char_type* __s1, const char_type* __s2, size_t __n) {
    ((void)0);

    char_type* __r = __s1;
    for (; __n; --__n, ++__s1, ++__s2)
      assign(*__s1, *__s2);
    return __r;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static char_type*
  assign(char_type* __s, size_t __n, char_type __a) {
    char_type* __r = __s;
    for (; __n; --__n, ++__s)
      assign(*__s, __a);
    return __r;
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type not_eof(int_type __c) throw() {
    return eq_int_type(__c, eof()) ? ~eof() : __c;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type to_char_type(int_type __c) throw() {
    return char_type(__c);
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type to_int_type(char_type __c) throw() {
    return int_type(__c);
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool eq_int_type(int_type __c1, int_type __c2) throw() {
    return __c1 == __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type eof() throw() { return int_type((-1)); }
};




template <>
struct char_traits<char> {
  using char_type = char;
  using int_type = int;
  using off_type = streamoff;
  using pos_type = streampos;
  using state_type = mbstate_t;




  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  assign(char_type& __c1, const char_type& __c2) throw() {
    __c1 = __c2;
  }


  static inline __attribute__((__visibility__("hidden"))) bool eq(char_type __c1, char_type __c2) throw() {
    return __c1 == __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool lt(char_type __c1, char_type __c2) throw() {
    return (unsigned char)__c1 < (unsigned char)__c2;
  }



  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int
  compare(const char_type* __lhs, const char_type* __rhs, size_t __count) throw() {
    if (__libcpp_is_constant_evaluated()) {

      return __builtin_memcmp(__lhs, __rhs, __count);
# 221 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/char_traits.h" 3
    } else {
      return __builtin_memcmp(__lhs, __rhs, __count);
    }
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t length(const char_type* __s) throw() {
    return std::__constexpr_strlen(__s);
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const char_type*
  find(const char_type* __s, size_t __n, const char_type& __a) throw() {
    if (__n == 0)
      return __nullptr;
    return std::__constexpr_memchr(__s, __a, __n);
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type*
  move(char_type* __s1, const char_type* __s2, size_t __n) throw() {
    return std::__constexpr_memmove(__s1, __s2, __element_count(__n));
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type*
  copy(char_type* __s1, const char_type* __s2, size_t __n) throw() {
    ((void)0);

    std::copy_n(__s2, __n, __s1);
    return __s1;
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type*
  assign(char_type* __s, size_t __n, char_type __a) throw() {
    std::fill_n(__s, __n, __a);
    return __s;
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type not_eof(int_type __c) throw() {
    return eq_int_type(__c, eof()) ? ~eof() : __c;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type to_char_type(int_type __c) throw() {
    return char_type(__c);
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type to_int_type(char_type __c) throw() {
    return int_type((unsigned char)__c);
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool eq_int_type(int_type __c1, int_type __c2) throw() {
    return __c1 == __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type eof() throw() { return int_type((-1)); }
};




template <>
struct char_traits<wchar_t> {
  using char_type = wchar_t;
  using int_type = wint_t;
  using off_type = streamoff;
  using pos_type = streampos;
  using state_type = mbstate_t;




  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  assign(char_type& __c1, const char_type& __c2) throw() {
    __c1 = __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool eq(char_type __c1, char_type __c2) throw() {
    return __c1 == __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool lt(char_type __c1, char_type __c2) throw() {
    return __c1 < __c2;
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int
  compare(const char_type* __s1, const char_type* __s2, size_t __n) throw() {
    if (__n == 0)
      return 0;
    return std::__constexpr_wmemcmp(__s1, __s2, __n);
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t length(const char_type* __s) throw() {
    return std::__constexpr_wcslen(__s);
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const char_type*
  find(const char_type* __s, size_t __n, const char_type& __a) throw() {
    if (__n == 0)
      return __nullptr;
    return std::__constexpr_wmemchr(__s, __a, __n);
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type*
  move(char_type* __s1, const char_type* __s2, size_t __n) throw() {
    return std::__constexpr_memmove(__s1, __s2, __element_count(__n));
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type*
  copy(char_type* __s1, const char_type* __s2, size_t __n) throw() {
    ((void)0);

    std::copy_n(__s2, __n, __s1);
    return __s1;
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type*
  assign(char_type* __s, size_t __n, char_type __a) throw() {
    std::fill_n(__s, __n, __a);
    return __s;
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type not_eof(int_type __c) throw() {
    return eq_int_type(__c, eof()) ? ~eof() : __c;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type to_char_type(int_type __c) throw() {
    return char_type(__c);
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type to_int_type(char_type __c) throw() {
    return int_type(__c);
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool eq_int_type(int_type __c1, int_type __c2) throw() {
    return __c1 == __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type eof() throw() { return int_type(((__darwin_wint_t)-1)); }
};
# 431 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/char_traits.h" 3
template <>
struct char_traits<char16_t> {
  using char_type = char16_t;
  using int_type = uint_least16_t;
  using off_type = streamoff;
  using pos_type = u16streampos;
  using state_type = mbstate_t;




  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  assign(char_type& __c1, const char_type& __c2) throw() {
    __c1 = __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool eq(char_type __c1, char_type __c2) throw() {
    return __c1 == __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool lt(char_type __c1, char_type __c2) throw() {
    return __c1 < __c2;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static int
  compare(const char_type* __s1, const char_type* __s2, size_t __n) throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static size_t length(const char_type* __s) throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static const char_type*
  find(const char_type* __s, size_t __n, const char_type& __a) throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static char_type*
  move(char_type* __s1, const char_type* __s2, size_t __n) throw() {
    return std::__constexpr_memmove(__s1, __s2, __element_count(__n));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static char_type*
  copy(char_type* __s1, const char_type* __s2, size_t __n) throw() {
    ((void)0);

    std::copy_n(__s2, __n, __s1);
    return __s1;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static char_type*
  assign(char_type* __s, size_t __n, char_type __a) throw() {
    std::fill_n(__s, __n, __a);
    return __s;
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type not_eof(int_type __c) throw() {
    return eq_int_type(__c, eof()) ? ~eof() : __c;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type to_char_type(int_type __c) throw() {
    return char_type(__c);
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type to_int_type(char_type __c) throw() {
    return int_type(__c);
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool eq_int_type(int_type __c1, int_type __c2) throw() {
    return __c1 == __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type eof() throw() { return int_type(0xFFFF); }
};

inline int
char_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) throw() {
  for (; __n; --__n, ++__s1, ++__s2) {
    if (lt(*__s1, *__s2))
      return -1;
    if (lt(*__s2, *__s1))
      return 1;
  }
  return 0;
}

inline size_t char_traits<char16_t>::length(const char_type* __s) throw() {
  size_t __len = 0;
  for (; !eq(*__s, char_type(0)); ++__s)
    ++__len;
  return __len;
}

inline const char16_t*
char_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a) throw() {
  for (; __n; --__n) {
    if (eq(*__s, __a))
      return __s;
    ++__s;
  }
  return __nullptr;
}

template <>
struct char_traits<char32_t> {
  using char_type = char32_t;
  using int_type = uint_least32_t;
  using off_type = streamoff;
  using pos_type = u32streampos;
  using state_type = mbstate_t;




  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  assign(char_type& __c1, const char_type& __c2) throw() {
    __c1 = __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool eq(char_type __c1, char_type __c2) throw() {
    return __c1 == __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool lt(char_type __c1, char_type __c2) throw() {
    return __c1 < __c2;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static int
  compare(const char_type* __s1, const char_type* __s2, size_t __n) throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static size_t length(const char_type* __s) throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static const char_type*
  find(const char_type* __s, size_t __n, const char_type& __a) throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static char_type*
  move(char_type* __s1, const char_type* __s2, size_t __n) throw() {
    return std::__constexpr_memmove(__s1, __s2, __element_count(__n));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static char_type*
  copy(char_type* __s1, const char_type* __s2, size_t __n) throw() {
    std::copy_n(__s2, __n, __s1);
    return __s1;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static char_type*
  assign(char_type* __s, size_t __n, char_type __a) throw() {
    std::fill_n(__s, __n, __a);
    return __s;
  }

  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type not_eof(int_type __c) throw() {
    return eq_int_type(__c, eof()) ? ~eof() : __c;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type to_char_type(int_type __c) throw() {
    return char_type(__c);
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type to_int_type(char_type __c) throw() {
    return int_type(__c);
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool eq_int_type(int_type __c1, int_type __c2) throw() {
    return __c1 == __c2;
  }
  static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type eof() throw() { return int_type(0xFFFFFFFF); }
};

inline int
char_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n) throw() {
  for (; __n; --__n, ++__s1, ++__s2) {
    if (lt(*__s1, *__s2))
      return -1;
    if (lt(*__s2, *__s1))
      return 1;
  }
  return 0;
}

inline size_t char_traits<char32_t>::length(const char_type* __s) throw() {
  size_t __len = 0;
  for (; !eq(*__s, char_type(0)); ++__s)
    ++__len;
  return __len;
}

inline const char32_t*
char_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a) throw() {
  for (; __n; --__n) {
    if (eq(*__s, __a))
      return __s;
    ++__s;
  }
  return __nullptr;
}




template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
__str_find(const _CharT* __p, _SizeT __sz, _CharT __c, _SizeT __pos) throw() {
  if (__pos >= __sz)
    return __npos;
  const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);
  if (__r == __nullptr)
    return __npos;
  return static_cast<_SizeT>(__r - __p);
}

template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline const _CharT* __search_substring(
    const _CharT* __first1, const _CharT* __last1, const _CharT* __first2, const _CharT* __last2) throw() {


  const ptrdiff_t __len2 = __last2 - __first2;
  if (__len2 == 0)
    return __first1;

  ptrdiff_t __len1 = __last1 - __first1;
  if (__len1 < __len2)
    return __last1;


  _CharT __f2 = *__first2;
  while (true) {
    __len1 = __last1 - __first1;

    if (__len1 < __len2)
      return __last1;


    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);
    if (__first1 == __nullptr)
      return __last1;






    if (_Traits::compare(__first1, __first2, __len2) == 0)
      return __first1;

    ++__first1;
  }
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
__str_find(const _CharT* __p, _SizeT __sz, const _CharT* __s, _SizeT __pos, _SizeT __n) throw() {
  if (__pos > __sz)
    return __npos;

  if (__n == 0)
    return __pos;

  const _CharT* __r = std::__search_substring<_CharT, _Traits>(__p + __pos, __p + __sz, __s, __s + __n);

  if (__r == __p + __sz)
    return __npos;
  return static_cast<_SizeT>(__r - __p);
}



template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
__str_rfind(const _CharT* __p, _SizeT __sz, _CharT __c, _SizeT __pos) throw() {
  if (__sz < 1)
    return __npos;
  if (__pos < __sz)
    ++__pos;
  else
    __pos = __sz;
  for (const _CharT* __ps = __p + __pos; __ps != __p;) {
    if (_Traits::eq(*--__ps, __c))
      return static_cast<_SizeT>(__ps - __p);
  }
  return __npos;
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
__str_rfind(const _CharT* __p, _SizeT __sz, const _CharT* __s, _SizeT __pos, _SizeT __n) throw() {
  __pos = std::min(__pos, __sz);
  if (__n < __sz - __pos)
    __pos += __n;
  else
    __pos = __sz;
  const _CharT* __r = std::__find_end_classic(__p, __p + __pos, __s, __s + __n, _Traits::eq);
  if (__n > 0 && __r == __p + __pos)
    return __npos;
  return static_cast<_SizeT>(__r - __p);
}


template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
__str_find_first_of(const _CharT* __p, _SizeT __sz, const _CharT* __s, _SizeT __pos, _SizeT __n) throw() {
  if (__pos >= __sz || __n == 0)
    return __npos;
  const _CharT* __r = std::__find_first_of_ce(__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq);
  if (__r == __p + __sz)
    return __npos;
  return static_cast<_SizeT>(__r - __p);
}


template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
__str_find_last_of(const _CharT* __p, _SizeT __sz, const _CharT* __s, _SizeT __pos, _SizeT __n) throw() {
  if (__n != 0) {
    if (__pos < __sz)
      ++__pos;
    else
      __pos = __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __p;) {
      const _CharT* __r = _Traits::find(__s, __n, *--__ps);
      if (__r)
        return static_cast<_SizeT>(__ps - __p);
    }
  }
  return __npos;
}


template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
__str_find_first_not_of(const _CharT* __p, _SizeT __sz, const _CharT* __s, _SizeT __pos, _SizeT __n) throw() {
  if (__pos < __sz) {
    const _CharT* __pe = __p + __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
      if (_Traits::find(__s, __n, *__ps) == __nullptr)
        return static_cast<_SizeT>(__ps - __p);
  }
  return __npos;
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
__str_find_first_not_of(const _CharT* __p, _SizeT __sz, _CharT __c, _SizeT __pos) throw() {
  if (__pos < __sz) {
    const _CharT* __pe = __p + __sz;
    for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)
      if (!_Traits::eq(*__ps, __c))
        return static_cast<_SizeT>(__ps - __p);
  }
  return __npos;
}


template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
__str_find_last_not_of(const _CharT* __p, _SizeT __sz, const _CharT* __s, _SizeT __pos, _SizeT __n) throw() {
  if (__pos < __sz)
    ++__pos;
  else
    __pos = __sz;
  for (const _CharT* __ps = __p + __pos; __ps != __p;)
    if (_Traits::find(__s, __n, *--__ps) == __nullptr)
      return static_cast<_SizeT>(__ps - __p);
  return __npos;
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
__str_find_last_not_of(const _CharT* __p, _SizeT __sz, _CharT __c, _SizeT __pos) throw() {
  if (__pos < __sz)
    ++__pos;
  else
    __pos = __sz;
  for (const _CharT* __ps = __p + __pos; __ps != __p;)
    if (!_Traits::eq(*--__ps, __c))
      return static_cast<_SizeT>(__ps - __p);
  return __npos;
}

template <class _Ptr>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t __do_string_hash(_Ptr __p, _Ptr __e) {
  typedef typename iterator_traits<_Ptr>::value_type value_type;
  return __murmur2_or_cityhash<size_t>()(__p, (__e - __p) * sizeof(value_type));
}

}}
# 225 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 2 3
# 243 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/data.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/data.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 47 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/data.h" 3
}}
# 244 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/empty.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/empty.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/empty.h" 3
}}
# 245 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_access.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_access.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/reverse_access.h" 3
}}
# 246 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/size.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/size.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/size.h" 3
}}
# 247 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/compare" 1 3
# 145 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/compare" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/compare_partial_order_fallback.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/compare_partial_order_fallback.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/partial_order.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/partial_order.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/weak_order.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/weak_order.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/strong_order.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/strong_order.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/bit_cast.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/bit_cast.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/bit_cast.h" 3
}}
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/strong_order.h" 2 3






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/priority_tag.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/priority_tag.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <size_t _Ip>
struct __priority_tag : __priority_tag<_Ip - 1> {};
template <>
struct __priority_tag<0> {};

}}
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/strong_order.h" 2 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/strong_order.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/strong_order.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 134 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/strong_order.h" 3
}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/weak_order.h" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/weak_order.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 99 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/weak_order.h" 3
}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/partial_order.h" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/partial_order.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/partial_order.h" 3
}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/compare_partial_order_fallback.h" 2 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/compare_partial_order_fallback.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 74 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/compare_partial_order_fallback.h" 3
}}
# 146 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/compare" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/compare_strong_order_fallback.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/compare_strong_order_fallback.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/compare_strong_order_fallback.h" 3
}}
# 147 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/compare" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/compare_weak_order_fallback.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/compare_weak_order_fallback.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/compare_weak_order_fallback.h" 3
}}
# 150 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/compare" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/is_eq.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/is_eq.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__compare/is_eq.h" 3
}}
# 151 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/compare" 2 3
# 162 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/compare" 3
# 250 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 2 3
# 253 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 257 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline size_t
__char_traits_length_checked(const typename _Traits::char_type* __s) throw() {

  return ((void)0),

         _Traits::length(__s);
}

template <class _CharT, class _Traits>
class basic_string_view {
public:

  using traits_type = _Traits;
  using value_type = _CharT;
  using pointer = _CharT*;
  using const_pointer = const _CharT*;
  using reference = _CharT&;
  using const_reference = const _CharT&;



  using const_iterator = const_pointer;

  using iterator = const_iterator;
  using const_reverse_iterator = std::reverse_iterator<const_iterator>;
  using reverse_iterator = const_reverse_iterator;
  using size_type = size_t;
  using difference_type = ptrdiff_t;
  static const size_type npos = -1;

  _Static_assert((!is_array<value_type>::value), "Character type of basic_string_view must not be an array");
  _Static_assert((is_standard_layout<value_type>::value), "Character type of basic_string_view must be standard-layout");
  _Static_assert((is_trivial<value_type>::value), "Character type of basic_string_view must be trivial");
  _Static_assert((is_same<_CharT, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT");



                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string_view() throw() : __data_(__nullptr), __size_(0) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string_view(const basic_string_view&) throw() = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string_view& operator=(const basic_string_view&) throw() = default;

                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string_view(const _CharT* __s, size_type __len) throw()
      : __data_(__s),
        __size_(__len) {
# 318 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 3
  }
# 340 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 3
                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string_view(const _CharT* __s)
      : __data_(__s), __size_(std::__char_traits_length_checked<_Traits>(__s)) {}






                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator begin() const throw() { return cbegin(); }

                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator end() const throw() { return cend(); }

                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator cbegin() const throw() {



    return __data_;

  }

                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator cend() const throw() {



    return __data_ + __size_;

  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator rbegin() const throw() {
    return const_reverse_iterator(cend());
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator rend() const throw() {
    return const_reverse_iterator(cbegin());
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator crbegin() const throw() {
    return const_reverse_iterator(cend());
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator crend() const throw() {
    return const_reverse_iterator(cbegin());
  }


                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type size() const throw() { return __size_; }

                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type length() const throw() { return __size_; }

                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type max_size() const throw() {
    return numeric_limits<size_type>::max() / sizeof(value_type);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool empty() const throw() {
    return __size_ == 0;
  }


                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference operator[](size_type __pos) const throw() {
    return ((void)0), __data_[__pos];
  }

                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference at(size_type __pos) const {
    return __pos >= size() ? (__throw_out_of_range("string_view::at"), __data_[0]) : __data_[__pos];
  }

                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference front() const throw() {
    return ((void)0), __data_[0];
  }

                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference back() const throw() {
    return ((void)0), __data_[__size_ - 1];
  }

                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_pointer data() const throw() { return __data_; }


                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void remove_prefix(size_type __n) throw() {
    ((void)0);
    __data_ += __n;
    __size_ -= __n;
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void remove_suffix(size_type __n) throw() {
    ((void)0);
    __size_ -= __n;
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(basic_string_view& __other) throw() {
    const value_type* __p = __data_;
    __data_ = __other.__data_;
    __other.__data_ = __p;

    size_type __sz = __size_;
    __size_ = __other.__size_;
    __other.__size_ = __sz;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  copy(_CharT* __s, size_type __n, size_type __pos = 0) const {
    if (__pos > size())
      __throw_out_of_range("string_view::copy");
    size_type __rlen = std::min(__n, size() - __pos);
    _Traits::copy(__s, data() + __pos, __rlen);
    return __rlen;
  }

                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string_view substr(size_type __pos = 0, size_type __n = npos) const {
    return __pos > size() ? (__throw_out_of_range("string_view::substr"), basic_string_view())
                          : basic_string_view(data() + __pos, std::min(__n, size() - __pos));
  }

                                int compare(basic_string_view __sv) const throw() {
    size_type __rlen = std::min(size(), __sv.size());
    int __retval = _Traits::compare(data(), __sv.data(), __rlen);
    if (__retval == 0)
      __retval = size() == __sv.size() ? 0 : (size() < __sv.size() ? -1 : 1);
    return __retval;
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int
  compare(size_type __pos1, size_type __n1, basic_string_view __sv) const {
    return substr(__pos1, __n1).compare(__sv);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int
  compare(size_type __pos1, size_type __n1, basic_string_view __sv, size_type __pos2, size_type __n2) const {
    return substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int compare(const _CharT* __s) const throw() {
    return compare(basic_string_view(__s));
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int
  compare(size_type __pos1, size_type __n1, const _CharT* __s) const {
    return substr(__pos1, __n1).compare(basic_string_view(__s));
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int
  compare(size_type __pos1, size_type __n1, const _CharT* __s, size_type __n2) const {
    return substr(__pos1, __n1).compare(basic_string_view(__s, __n2));
  }


                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find(basic_string_view __s, size_type __pos = 0) const throw() {
    ((void)0);
    return std::__str_find<value_type, size_type, traits_type, npos>(data(), size(), __s.data(), __pos, __s.size());
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type find(_CharT __c, size_type __pos = 0) const throw() {
    return std::__str_find<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find(const _CharT* __s, size_type __pos, size_type __n) const throw() {
    ((void)0);
    return std::__str_find<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find(const _CharT* __s, size_type __pos = 0) const throw() {
    ((void)0);
    return std::__str_find<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }


                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  rfind(basic_string_view __s, size_type __pos = npos) const throw() {
    ((void)0);
    return std::__str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __s.data(), __pos, __s.size());
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  rfind(_CharT __c, size_type __pos = npos) const throw() {
    return std::__str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  rfind(const _CharT* __s, size_type __pos, size_type __n) const throw() {
    ((void)0);
    return std::__str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  rfind(const _CharT* __s, size_type __pos = npos) const throw() {
    ((void)0);
    return std::__str_rfind<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }


                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_first_of(basic_string_view __s, size_type __pos = 0) const throw() {
    ((void)0);
    return std::__str_find_first_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s.data(), __pos, __s.size());
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_first_of(_CharT __c, size_type __pos = 0) const throw() {
    return find(__c, __pos);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_first_of(const _CharT* __s, size_type __pos, size_type __n) const throw() {
    ((void)0);
    return std::__str_find_first_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_first_of(const _CharT* __s, size_type __pos = 0) const throw() {
    ((void)0);
    return std::__str_find_first_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }


                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_last_of(basic_string_view __s, size_type __pos = npos) const throw() {
    ((void)0);
    return std::__str_find_last_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s.data(), __pos, __s.size());
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_last_of(_CharT __c, size_type __pos = npos) const throw() {
    return rfind(__c, __pos);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_last_of(const _CharT* __s, size_type __pos, size_type __n) const throw() {
    ((void)0);
    return std::__str_find_last_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_last_of(const _CharT* __s, size_type __pos = npos) const throw() {
    ((void)0);
    return std::__str_find_last_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }


                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_first_not_of(basic_string_view __s, size_type __pos = 0) const throw() {
    ((void)0);

    return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s.data(), __pos, __s.size());
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_first_not_of(_CharT __c, size_type __pos = 0) const throw() {
    return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const throw() {
    ((void)0);
    return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_first_not_of(const _CharT* __s, size_type __pos = 0) const throw() {
    ((void)0);
    return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }


                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_last_not_of(basic_string_view __s, size_type __pos = npos) const throw() {
    ((void)0);

    return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s.data(), __pos, __s.size());
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_last_not_of(_CharT __c, size_type __pos = npos) const throw() {
    return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const throw() {
    ((void)0);
    return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_last_not_of(const _CharT* __s, size_type __pos = npos) const throw() {
    ((void)0);
    return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }
# 673 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 3
private:
  const value_type* __data_;
  size_type __size_;
};
_Static_assert(true, "");
# 728 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 3
template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator==(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) throw() {
  if (__lhs.size() != __rhs.size())
    return false;
  return __lhs.compare(__rhs) == 0;
}



template <class _CharT, class _Traits, int = 1>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator==(basic_string_view<_CharT, _Traits> __lhs,
           __type_identity_t<basic_string_view<_CharT, _Traits> > __rhs) throw() {
  if (__lhs.size() != __rhs.size())
    return false;
  return __lhs.compare(__rhs) == 0;
}

template <class _CharT, class _Traits, int = 2>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator==(__type_identity_t<basic_string_view<_CharT, _Traits> > __lhs,
           basic_string_view<_CharT, _Traits> __rhs) throw() {
  if (__lhs.size() != __rhs.size())
    return false;
  return __lhs.compare(__rhs) == 0;
}


template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator!=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) throw() {
  if (__lhs.size() != __rhs.size())
    return true;
  return __lhs.compare(__rhs) != 0;
}

template <class _CharT, class _Traits, int = 1>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator!=(basic_string_view<_CharT, _Traits> __lhs,
           __type_identity_t<basic_string_view<_CharT, _Traits> > __rhs) throw() {
  if (__lhs.size() != __rhs.size())
    return true;
  return __lhs.compare(__rhs) != 0;
}

template <class _CharT, class _Traits, int = 2>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator!=(__type_identity_t<basic_string_view<_CharT, _Traits> > __lhs,
           basic_string_view<_CharT, _Traits> __rhs) throw() {
  if (__lhs.size() != __rhs.size())
    return true;
  return __lhs.compare(__rhs) != 0;
}


template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) throw() {
  return __lhs.compare(__rhs) < 0;
}

template <class _CharT, class _Traits, int = 1>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<(basic_string_view<_CharT, _Traits> __lhs,
          __type_identity_t<basic_string_view<_CharT, _Traits> > __rhs) throw() {
  return __lhs.compare(__rhs) < 0;
}

template <class _CharT, class _Traits, int = 2>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<(__type_identity_t<basic_string_view<_CharT, _Traits> > __lhs,
          basic_string_view<_CharT, _Traits> __rhs) throw() {
  return __lhs.compare(__rhs) < 0;
}


template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) throw() {
  return __lhs.compare(__rhs) > 0;
}

template <class _CharT, class _Traits, int = 1>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>(basic_string_view<_CharT, _Traits> __lhs,
          __type_identity_t<basic_string_view<_CharT, _Traits> > __rhs) throw() {
  return __lhs.compare(__rhs) > 0;
}

template <class _CharT, class _Traits, int = 2>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>(__type_identity_t<basic_string_view<_CharT, _Traits> > __lhs,
          basic_string_view<_CharT, _Traits> __rhs) throw() {
  return __lhs.compare(__rhs) > 0;
}


template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) throw() {
  return __lhs.compare(__rhs) <= 0;
}

template <class _CharT, class _Traits, int = 1>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<=(basic_string_view<_CharT, _Traits> __lhs,
           __type_identity_t<basic_string_view<_CharT, _Traits> > __rhs) throw() {
  return __lhs.compare(__rhs) <= 0;
}

template <class _CharT, class _Traits, int = 2>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<=(__type_identity_t<basic_string_view<_CharT, _Traits> > __lhs,
           basic_string_view<_CharT, _Traits> __rhs) throw() {
  return __lhs.compare(__rhs) <= 0;
}


template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>=(basic_string_view<_CharT, _Traits> __lhs, basic_string_view<_CharT, _Traits> __rhs) throw() {
  return __lhs.compare(__rhs) >= 0;
}

template <class _CharT, class _Traits, int = 1>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>=(basic_string_view<_CharT, _Traits> __lhs,
           __type_identity_t<basic_string_view<_CharT, _Traits> > __rhs) throw() {
  return __lhs.compare(__rhs) >= 0;
}

template <class _CharT, class _Traits, int = 2>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>=(__type_identity_t<basic_string_view<_CharT, _Traits> > __lhs,
           basic_string_view<_CharT, _Traits> __rhs) throw() {
  return __lhs.compare(__rhs) >= 0;
}



template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, basic_string_view<_CharT, _Traits> __str);


template <class _CharT>
struct __string_view_hash : public __unary_function<basic_string_view<_CharT, char_traits<_CharT> >, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(const basic_string_view<_CharT, char_traits<_CharT> > __val) const throw() {
    return std::__do_string_hash(__val.data(), __val.data() + __val.size());
  }
};

template <>
struct hash<basic_string_view<char, char_traits<char> > > : __string_view_hash<char> {};






template <>
struct hash<basic_string_view<char16_t, char_traits<char16_t> > > : __string_view_hash<char16_t> {};

template <>
struct hash<basic_string_view<char32_t, char_traits<char32_t> > > : __string_view_hash<char32_t> {};


template <>
struct hash<basic_string_view<wchar_t, char_traits<wchar_t> > > : __string_view_hash<wchar_t> {};
# 934 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 3
}}




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 1 3
# 1787 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/adjacent_find.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/adjacent_find.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/adjacent_find.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Iter, class _Sent, class _BinaryPredicate>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Iter
__adjacent_find(_Iter __first, _Sent __last, _BinaryPredicate&& __pred) {
  if (__first == __last)
    return __first;
  _Iter __i = __first;
  while (++__i != __last) {
    if (__pred(*__first, *__i))
      return __first;
    __first = __i;
  }
  return __i;
}

template <class _ForwardIterator, class _BinaryPredicate>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred) {
  return std::__adjacent_find(std::move(__first), std::move(__last), __pred);
}

template <class _ForwardIterator>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last) {
  return std::adjacent_find(std::move(__first), std::move(__last), __equal_to());
}

}}
# 1788 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/all_of.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/all_of.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (!__pred(*__first))
      return false;
  return true;
}

}}
# 1789 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/any_of.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/any_of.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      return true;
  return false;
}

}}
# 1790 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/binary_search.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/binary_search.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lower_bound.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lower_bound.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/half_positive.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/half_positive.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <typename _Integral, __enable_if_t<is_integral<_Integral>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Integral __half_positive(_Integral __value) {
  return static_cast<_Integral>(static_cast<__make_unsigned_t<_Integral> >(__value) / 2);
}

template <typename _Tp, __enable_if_t<!is_integral<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp __half_positive(_Tp __value) {
  return __value / 2;
}

}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lower_bound.h" 2 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/lower_bound.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Iter, class _Sent, class _Type, class _Proj, class _Comp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Iter
__lower_bound(_Iter __first, _Sent __last, const _Type& __value, _Comp& __comp, _Proj& __proj) {
  auto __len = _IterOps<_AlgPolicy>::distance(__first, __last);

  while (__len != 0) {
    auto __l2 = std::__half_positive(__len);
    _Iter __m = __first;
    _IterOps<_AlgPolicy>::advance(__m, __l2);
    if (std::__invoke(__comp, std::__invoke(__proj, *__m), __value)) {
      __first = ++__m;
      __len -= __l2 + 1;
    } else {
      __len = __l2;
    }
  }
  return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value, _Compare __comp) {
  _Static_assert(__is_callable<_Compare, __decltype(*__first), const _Tp&>::value, "The comparator has to be callable");
  auto __proj = std::__identity();
  return std::__lower_bound<_ClassicAlgPolicy>(__first, __last, __value, __comp, __proj);
}

template <class _ForwardIterator, class _Tp>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value) {
  return std::lower_bound(__first, __last, __value, __less<>());
}

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/binary_search.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/binary_search.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator, class _Tp, class _Compare>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value, _Compare __comp) {
  __first = std::lower_bound<_ForwardIterator, _Tp, __comp_ref_type<_Compare> >(__first, __last, __value, __comp);
  return __first != __last && !__comp(__value, *__first);
}

template <class _ForwardIterator, class _Tp>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value) {
  return std::binary_search(__first, __last, __value, __less<>());
}

}}
# 1791 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/clamp.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/clamp.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/clamp.h" 3
}}
# 1792 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_backward.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_backward.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_backward.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _InIter, class _Sent, class _OutIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InIter, _OutIter>
__copy_backward(_InIter __first, _Sent __last, _OutIter __result);

template <class _AlgPolicy>
struct __copy_backward_loop {
  template <class _InIter, class _Sent, class _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    auto __last_iter = _IterOps<_AlgPolicy>::next(__first, __last);
    auto __original_last_iter = __last_iter;

    while (__first != __last_iter) {
      *--__result = *--__last_iter;
    }

    return std::make_pair(std::move(__original_last_iter), std::move(__result));
  }

  template <class _InIter, class _OutIter, __enable_if_t<__is_segmented_iterator<_InIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    using _Traits = __segmented_iterator_traits<_InIter>;
    auto __sfirst = _Traits::__segment(__first);
    auto __slast = _Traits::__segment(__last);
    if (__sfirst == __slast) {
      auto __iters =
          std::__copy_backward<_AlgPolicy>(_Traits::__local(__first), _Traits::__local(__last), std::move(__result));
      return std::make_pair(__last, __iters.second);
    }

    __result =
        std::__copy_backward<_AlgPolicy>(_Traits::__begin(__slast), _Traits::__local(__last), std::move(__result))
            .second;
    --__slast;
    while (__sfirst != __slast) {
      __result =
          std::__copy_backward<_AlgPolicy>(_Traits::__begin(__slast), _Traits::__end(__slast), std::move(__result))
              .second;
      --__slast;
    }
    __result = std::__copy_backward<_AlgPolicy>(_Traits::__local(__first), _Traits::__end(__slast), std::move(__result))
                   .second;
    return std::make_pair(__last, std::move(__result));
  }

  template <class _InIter,
            class _OutIter,
            __enable_if_t<__has_random_access_iterator_category<_InIter>::value &&
                              !__is_segmented_iterator<_InIter>::value && __is_segmented_iterator<_OutIter>::value,
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    using _Traits = __segmented_iterator_traits<_OutIter>;
    auto __orig_last = __last;
    auto __segment_iterator = _Traits::__segment(__result);


    if (__first == __last)
      return std::make_pair(__first, __result);

    auto __local_last = _Traits::__local(__result);
    while (true) {
      using _DiffT = typename common_type<__iter_diff_t<_InIter>, __iter_diff_t<_OutIter> >::type;

      auto __local_first = _Traits::__begin(__segment_iterator);
      auto __size = std::min<_DiffT>(__local_last - __local_first, __last - __first);
      auto __iter = std::__copy_backward<_AlgPolicy>(__last - __size, __last, __local_last).second;
      __last -= __size;

      if (__first == __last)
        return std::make_pair(std::move(__orig_last), _Traits::__compose(__segment_iterator, std::move(__iter)));
      --__segment_iterator;
      __local_last = _Traits::__end(__segment_iterator);
    }
  }
};

struct __copy_backward_trivial {

  template <class _In, class _Out, __enable_if_t<__can_lower_copy_assignment_to_memmove<_In, _Out>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_In*, _Out*>
  operator()(_In* __first, _In* __last, _Out* __result) const {
    return std::__copy_backward_trivial_impl(__first, __last, __result);
  }
};

template <class _AlgPolicy, class _BidirectionalIterator1, class _Sentinel, class _BidirectionalIterator2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_BidirectionalIterator1, _BidirectionalIterator2>
__copy_backward(_BidirectionalIterator1 __first, _Sentinel __last, _BidirectionalIterator2 __result) {
  return std::__dispatch_copy_or_move<_AlgPolicy, __copy_backward_loop<_AlgPolicy>, __copy_backward_trivial>(
      std::move(__first), std::move(__last), std::move(__result));
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _BidirectionalIterator2
copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last, _BidirectionalIterator2 __result) {
  _Static_assert(std::is_copy_constructible<_BidirectionalIterator1>::value && std::is_copy_constructible<_BidirectionalIterator1>::value, "Iterators must be copy constructible.");



  return std::__copy_backward<_ClassicAlgPolicy>(std::move(__first), std::move(__last), std::move(__result)).second;
}

}}
# 1796 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_if.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/copy_if.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator
copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred) {
  for (; __first != __last; ++__first) {
    if (__pred(*__first)) {
      *__result = *__first;
      ++__result;
    }
  }
  return __result;
}

}}
# 1797 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/count.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/count.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/count.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


template <class _AlgPolicy, class _Iter, class _Sent, class _Tp, class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename _IterOps<_AlgPolicy>::template __difference_type<_Iter>
__count(_Iter __first, _Sent __last, const _Tp& __value, _Proj& __proj) {
  typename _IterOps<_AlgPolicy>::template __difference_type<_Iter> __r(0);
  for (; __first != __last; ++__first)
    if (std::__invoke(__proj, *__first) == __value)
      ++__r;
  return __r;
}


template <bool _ToCount, class _Cp, bool _IsConst>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n) {
  using _It = __bit_iterator<_Cp, _IsConst>;
  using __storage_type = typename _It::__storage_type;
  using difference_type = typename _It::difference_type;

  const int __bits_per_word = _It::__bits_per_word;
  difference_type __r = 0;

  if (__first.__ctz_ != 0) {
    __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
    __storage_type __dn = std::min(__clz_f, __n);
    __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
    __r = std::__libcpp_popcount(std::__invert_if<!_ToCount>(*__first.__seg_) & __m);
    __n -= __dn;
    ++__first.__seg_;
  }

  for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
    __r += std::__libcpp_popcount(std::__invert_if<!_ToCount>(*__first.__seg_));

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __r += std::__libcpp_popcount(std::__invert_if<!_ToCount>(*__first.__seg_) & __m);
  }
  return __r;
}

template <class, class _Cp, bool _IsConst, class _Tp, class _Proj, __enable_if_t<__is_identity<_Proj>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __iter_diff_t<__bit_iterator<_Cp, _IsConst> >
__count(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value, _Proj&) {
  if (__value)
    return std::__count_bool<true>(__first, static_cast<typename _Cp::size_type>(__last - __first));
  return std::__count_bool<false>(__first, static_cast<typename _Cp::size_type>(__last - __first));
}

template <class _InputIterator, class _Tp>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __iter_diff_t<_InputIterator>
count(_InputIterator __first, _InputIterator __last, const _Tp& __value) {
  __identity __proj;
  return std::__count<_ClassicAlgPolicy>(__first, __last, __value, __proj);
}

}}
# 1799 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/count_if.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/count_if.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  typename iterator_traits<_InputIterator>::difference_type __r(0);
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      ++__r;
  return __r;
}

}}
# 1800 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/equal_range.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/equal_range.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/upper_bound.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/upper_bound.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/upper_bound.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _Iter, class _Sent, class _Tp, class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Iter
__upper_bound(_Iter __first, _Sent __last, const _Tp& __value, _Compare&& __comp, _Proj&& __proj) {
  auto __len = _IterOps<_AlgPolicy>::distance(__first, __last);
  while (__len != 0) {
    auto __half_len = std::__half_positive(__len);
    auto __mid = _IterOps<_AlgPolicy>::next(__first, __half_len);
    if (std::__invoke(__comp, __value, std::__invoke(__proj, *__mid)))
      __len = __half_len;
    else {
      __first = ++__mid;
      __len -= __half_len + 1;
    }
  }
  return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value, _Compare __comp) {
  _Static_assert(is_copy_constructible<_ForwardIterator>::value, "Iterator has to be copy constructible");
  return std::__upper_bound<_ClassicAlgPolicy>(
      std::move(__first), std::move(__last), __value, std::move(__comp), std::__identity());
}

template <class _ForwardIterator, class _Tp>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value) {
  return std::upper_bound(std::move(__first), std::move(__last), __value, __less<>());
}

}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/equal_range.h" 2 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/equal_range.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/equal_range.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _Iter, class _Sent, class _Tp, class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_Iter, _Iter>
__equal_range(_Iter __first, _Sent __last, const _Tp& __value, _Compare&& __comp, _Proj&& __proj) {
  auto __len = _IterOps<_AlgPolicy>::distance(__first, __last);
  _Iter __end = _IterOps<_AlgPolicy>::next(__first, __last);
  while (__len != 0) {
    auto __half_len = std::__half_positive(__len);
    _Iter __mid = _IterOps<_AlgPolicy>::next(__first, __half_len);
    if (std::__invoke(__comp, std::__invoke(__proj, *__mid), __value)) {
      __first = ++__mid;
      __len -= __half_len + 1;
    } else if (std::__invoke(__comp, __value, std::__invoke(__proj, *__mid))) {
      __end = __mid;
      __len = __half_len;
    } else {
      _Iter __mp1 = __mid;
      return pair<_Iter, _Iter>(std::__lower_bound<_AlgPolicy>(__first, __mid, __value, __comp, __proj),
                                std::__upper_bound<_AlgPolicy>(++__mp1, __end, __value, __comp, __proj));
    }
  }
  return pair<_Iter, _Iter>(__first, __first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value, _Compare __comp) {
  _Static_assert(__is_callable<_Compare, __decltype(*__first), const _Tp&>::value, "The comparator has to be callable");
  _Static_assert(is_copy_constructible<_ForwardIterator>::value, "Iterator has to be copy constructible");
  return std::__equal_range<_ClassicAlgPolicy>(
      std::move(__first),
      std::move(__last),
      __value,
      static_cast<__comp_ref_type<_Compare> >(__comp),
      std::__identity());
}

template <class _ForwardIterator, class _Tp>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value) {
  return std::equal_range(std::move(__first), std::move(__last), __value, __less<>());
}

}}
# 1802 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/fill.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/fill.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value, forward_iterator_tag) {
  for (; __first != __last; ++__first)
    *__first = __value;
}

template <class _RandomAccessIterator, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value, random_access_iterator_tag) {
  std::fill_n(__first, __last - __first, __value);
}

template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value) {
  std::__fill(__first, __last, __value, typename iterator_traits<_ForwardIterator>::iterator_category());
}

}}
# 1803 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_if_not.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/find_if_not.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _InputIterator
find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (!__pred(*__first))
      break;
  return __first;
}

}}
# 1809 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/fold.h" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/fold.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/fold.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 126 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/fold.h" 3
}}
# 1810 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/movable_box.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/movable_box.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/optional" 1 3
# 225 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/optional" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/in_place.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/in_place.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/in_place.h" 3
}}
# 226 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/optional" 2 3
# 240 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/optional" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 244 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/optional" 2 3

namespace std
{

class __attribute__((__visibility__("default"))) __attribute__((availability(watchos, strict, introduced = 5.0))) bad_optional_access : public exception {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bad_optional_access() throw() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bad_optional_access(const bad_optional_access&) throw() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bad_optional_access& operator=(const bad_optional_access&) throw() = default;

  ~bad_optional_access() throw() override;
  const char* what() const throw() override;
};

}
# 1289 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/optional" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 1 3
# 591 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/aliases.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/aliases.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic_base.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic_base.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic_sync.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic_sync.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/contention_t.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/contention_t.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/cxx_atomic_impl.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/cxx_atomic_impl.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/is_always_lock_free.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/is_always_lock_free.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __libcpp_is_always_lock_free {

  static const bool __value = __atomic_always_lock_free(sizeof(_Tp), __nullptr);
};

}}
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/cxx_atomic_impl.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/memory_order.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/memory_order.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




enum __legacy_memory_order { __mo_relaxed, __mo_consume, __mo_acquire, __mo_release, __mo_acq_rel, __mo_seq_cst };

using __memory_order_underlying_t = underlying_type<__legacy_memory_order>::type;
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/memory_order.h" 3
enum memory_order {
  memory_order_relaxed = __mo_relaxed,
  memory_order_consume = __mo_consume,
  memory_order_acquire = __mo_acquire,
  memory_order_release = __mo_release,
  memory_order_acq_rel = __mo_acq_rel,
  memory_order_seq_cst = __mo_seq_cst,
};



}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/cxx_atomic_impl.h" 2 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/cxx_atomic_impl.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 296 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/cxx_atomic_impl.h" 3
template <typename _Tp>
struct __cxx_atomic_base_impl {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))



  __cxx_atomic_base_impl() throw() : __a_value() {
  }

                    explicit __cxx_atomic_base_impl(_Tp __value) throw() : __a_value(__value) {}
  __extension__ _Atomic(_Tp) __a_value;
};



__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline void __cxx_atomic_thread_fence(memory_order __order) throw() {
  __c11_atomic_thread_fence(static_cast<__memory_order_underlying_t>(__order));
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline void __cxx_atomic_signal_fence(memory_order __order) throw() {
  __c11_atomic_signal_fence(static_cast<__memory_order_underlying_t>(__order));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __cxx_atomic_init(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __val) throw() {
  __c11_atomic_init(std::addressof(__a->__a_value), __val);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __cxx_atomic_init(__cxx_atomic_base_impl<_Tp>* __a, _Tp __val) throw() {
  __c11_atomic_init(std::addressof(__a->__a_value), __val);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__cxx_atomic_store(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __val, memory_order __order) throw() {
  __c11_atomic_store(std::addressof(__a->__a_value), __val, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__cxx_atomic_store(__cxx_atomic_base_impl<_Tp>* __a, _Tp __val, memory_order __order) throw() {
  __c11_atomic_store(std::addressof(__a->__a_value), __val, static_cast<__memory_order_underlying_t>(__order));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
__cxx_atomic_load(__cxx_atomic_base_impl<_Tp> const volatile* __a, memory_order __order) throw() {
  using __ptr_type = __remove_const_t<__decltype(__a->__a_value)>*;
  return __c11_atomic_load(
      const_cast<__ptr_type>(std::addressof(__a->__a_value)), static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp __cxx_atomic_load(__cxx_atomic_base_impl<_Tp> const* __a, memory_order __order) throw() {
  using __ptr_type = __remove_const_t<__decltype(__a->__a_value)>*;
  return __c11_atomic_load(
      const_cast<__ptr_type>(std::addressof(__a->__a_value)), static_cast<__memory_order_underlying_t>(__order));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__cxx_atomic_load_inplace(__cxx_atomic_base_impl<_Tp> const volatile* __a, _Tp* __dst, memory_order __order) throw() {
  using __ptr_type = __remove_const_t<__decltype(__a->__a_value)>*;
  *__dst = __c11_atomic_load(
      const_cast<__ptr_type>(std::addressof(__a->__a_value)), static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__cxx_atomic_load_inplace(__cxx_atomic_base_impl<_Tp> const* __a, _Tp* __dst, memory_order __order) throw() {
  using __ptr_type = __remove_const_t<__decltype(__a->__a_value)>*;
  *__dst = __c11_atomic_load(
      const_cast<__ptr_type>(std::addressof(__a->__a_value)), static_cast<__memory_order_underlying_t>(__order));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
__cxx_atomic_exchange(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __value, memory_order __order) throw() {
  return __c11_atomic_exchange(
      std::addressof(__a->__a_value), __value, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
__cxx_atomic_exchange(__cxx_atomic_base_impl<_Tp>* __a, _Tp __value, memory_order __order) throw() {
  return __c11_atomic_exchange(
      std::addressof(__a->__a_value), __value, static_cast<__memory_order_underlying_t>(__order));
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline memory_order __to_failure_order(memory_order __order) {

  return __order == memory_order_release
           ? memory_order_relaxed
           : (__order == memory_order_acq_rel ? memory_order_acquire : __order);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __cxx_atomic_compare_exchange_strong(
    __cxx_atomic_base_impl<_Tp> volatile* __a,
    _Tp* __expected,
    _Tp __value,
    memory_order __success,
    memory_order __failure) throw() {
  return __c11_atomic_compare_exchange_strong(
      std::addressof(__a->__a_value),
      __expected,
      __value,
      static_cast<__memory_order_underlying_t>(__success),
      static_cast<__memory_order_underlying_t>(__to_failure_order(__failure)));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __cxx_atomic_compare_exchange_strong(
    __cxx_atomic_base_impl<_Tp>* __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure)
    throw() {
  return __c11_atomic_compare_exchange_strong(
      std::addressof(__a->__a_value),
      __expected,
      __value,
      static_cast<__memory_order_underlying_t>(__success),
      static_cast<__memory_order_underlying_t>(__to_failure_order(__failure)));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __cxx_atomic_compare_exchange_weak(
    __cxx_atomic_base_impl<_Tp> volatile* __a,
    _Tp* __expected,
    _Tp __value,
    memory_order __success,
    memory_order __failure) throw() {
  return __c11_atomic_compare_exchange_weak(
      std::addressof(__a->__a_value),
      __expected,
      __value,
      static_cast<__memory_order_underlying_t>(__success),
      static_cast<__memory_order_underlying_t>(__to_failure_order(__failure)));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __cxx_atomic_compare_exchange_weak(
    __cxx_atomic_base_impl<_Tp>* __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure)
    throw() {
  return __c11_atomic_compare_exchange_weak(
      std::addressof(__a->__a_value),
      __expected,
      __value,
      static_cast<__memory_order_underlying_t>(__success),
      static_cast<__memory_order_underlying_t>(__to_failure_order(__failure)));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
__cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __delta, memory_order __order) throw() {
  return __c11_atomic_fetch_add(
      std::addressof(__a->__a_value), __delta, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
__cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp>* __a, _Tp __delta, memory_order __order) throw() {
  return __c11_atomic_fetch_add(
      std::addressof(__a->__a_value), __delta, static_cast<__memory_order_underlying_t>(__order));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp*
__cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp*> volatile* __a, ptrdiff_t __delta, memory_order __order) throw() {
  return __c11_atomic_fetch_add(
      std::addressof(__a->__a_value), __delta, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp*
__cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp*>* __a, ptrdiff_t __delta, memory_order __order) throw() {
  return __c11_atomic_fetch_add(
      std::addressof(__a->__a_value), __delta, static_cast<__memory_order_underlying_t>(__order));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
__cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __delta, memory_order __order) throw() {
  return __c11_atomic_fetch_sub(
      std::addressof(__a->__a_value), __delta, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
__cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp>* __a, _Tp __delta, memory_order __order) throw() {
  return __c11_atomic_fetch_sub(
      std::addressof(__a->__a_value), __delta, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp*
__cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp*> volatile* __a, ptrdiff_t __delta, memory_order __order) throw() {
  return __c11_atomic_fetch_sub(
      std::addressof(__a->__a_value), __delta, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp*
__cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp*>* __a, ptrdiff_t __delta, memory_order __order) throw() {
  return __c11_atomic_fetch_sub(
      std::addressof(__a->__a_value), __delta, static_cast<__memory_order_underlying_t>(__order));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
__cxx_atomic_fetch_and(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __pattern, memory_order __order) throw() {
  return __c11_atomic_fetch_and(
      std::addressof(__a->__a_value), __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
__cxx_atomic_fetch_and(__cxx_atomic_base_impl<_Tp>* __a, _Tp __pattern, memory_order __order) throw() {
  return __c11_atomic_fetch_and(
      std::addressof(__a->__a_value), __pattern, static_cast<__memory_order_underlying_t>(__order));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
__cxx_atomic_fetch_or(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __pattern, memory_order __order) throw() {
  return __c11_atomic_fetch_or(
      std::addressof(__a->__a_value), __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
__cxx_atomic_fetch_or(__cxx_atomic_base_impl<_Tp>* __a, _Tp __pattern, memory_order __order) throw() {
  return __c11_atomic_fetch_or(
      std::addressof(__a->__a_value), __pattern, static_cast<__memory_order_underlying_t>(__order));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
__cxx_atomic_fetch_xor(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __pattern, memory_order __order) throw() {
  return __c11_atomic_fetch_xor(
      std::addressof(__a->__a_value), __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
__cxx_atomic_fetch_xor(__cxx_atomic_base_impl<_Tp>* __a, _Tp __pattern, memory_order __order) throw() {
  return __c11_atomic_fetch_xor(
      std::addressof(__a->__a_value), __pattern, static_cast<__memory_order_underlying_t>(__order));
}
# 813 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/cxx_atomic_impl.h" 3
template <typename _Tp, typename _Base = __cxx_atomic_base_impl<_Tp> >

struct __cxx_atomic_impl : public _Base {
  _Static_assert(is_trivially_copyable<_Tp>::value, "std::atomic<T> requires that 'T' be a trivially copyable type");

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __cxx_atomic_impl() throw() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __cxx_atomic_impl(_Tp __value) throw() : _Base(__value) {}
};

}}
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/contention_t.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/contention_t.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




using __cxx_contention_t = int64_t;


using __cxx_atomic_contention_t = __cxx_atomic_impl<__cxx_contention_t>;

}}
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic_sync.h" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/duration.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/duration.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ratio" 1 3
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ratio" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 97 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ratio" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <intmax_t _Xp, intmax_t _Yp>
struct __static_gcd {
  static const intmax_t value = __static_gcd<_Yp, _Xp % _Yp>::value;
};

template <intmax_t _Xp>
struct __static_gcd<_Xp, 0> {
  static const intmax_t value = _Xp;
};

template <>
struct __static_gcd<0, 0> {
  static const intmax_t value = 1;
};



template <intmax_t _Xp, intmax_t _Yp>
struct __static_lcm {
  static const intmax_t value = _Xp / __static_gcd<_Xp, _Yp>::value * _Yp;
};

template <intmax_t _Xp>
struct __static_abs {
  static const intmax_t value = _Xp < 0 ? -_Xp : _Xp;
};

template <intmax_t _Xp>
struct __static_sign {
  static const intmax_t value = _Xp == 0 ? 0 : (_Xp < 0 ? -1 : 1);
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_add;

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 1> {
  static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
  static const intmax_t max = -min;

  _Static_assert(_Xp <= max - _Yp, "overflow in __ll_add");

public:
  static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 0> {
public:
  static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, -1> {
  static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
  static const intmax_t max = -min;

  _Static_assert(min - _Yp <= _Xp, "overflow in __ll_add");

public:
  static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_sub;

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 1> {
  static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
  static const intmax_t max = -min;

  _Static_assert(min + _Yp <= _Xp, "overflow in __ll_sub");

public:
  static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 0> {
public:
  static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, -1> {
  static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
  static const intmax_t max = -min;

  _Static_assert(_Xp <= max + _Yp, "overflow in __ll_sub");

public:
  static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp>
class __ll_mul {
  static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
  static const intmax_t min = nan + 1;
  static const intmax_t max = -min;
  static const intmax_t __a_x = __static_abs<_Xp>::value;
  static const intmax_t __a_y = __static_abs<_Yp>::value;

  _Static_assert(_Xp != nan && _Yp != nan && __a_x <= max / __a_y, "overflow in __ll_mul");

public:
  static const intmax_t value = _Xp * _Yp;
};

template <intmax_t _Yp>
class __ll_mul<0, _Yp> {
public:
  static const intmax_t value = 0;
};

template <intmax_t _Xp>
class __ll_mul<_Xp, 0> {
public:
  static const intmax_t value = 0;
};

template <>
class __ll_mul<0, 0> {
public:
  static const intmax_t value = 0;
};


template <intmax_t _Xp, intmax_t _Yp>
class __ll_div {
  static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
  static const intmax_t min = nan + 1;
  static const intmax_t max = -min;

  _Static_assert(_Xp != nan && _Yp != nan && _Yp != 0, "overflow in __ll_div");

public:
  static const intmax_t value = _Xp / _Yp;
};

template <intmax_t _Num, intmax_t _Den = 1>
class ratio {
  _Static_assert(__static_abs<_Num>::value >= 0, "ratio numerator is out of range");
  _Static_assert(_Den != 0, "ratio divide by 0");
  _Static_assert(__static_abs<_Den>::value > 0, "ratio denominator is out of range");
  static const intmax_t __na = __static_abs<_Num>::value;
  static const intmax_t __da = __static_abs<_Den>::value;
  static const intmax_t __s = __static_sign<_Num>::value * __static_sign<_Den>::value;
  static const intmax_t __gcd = __static_gcd<__na, __da>::value;

public:
  static const intmax_t num = __s * __na / __gcd;
  static const intmax_t den = __da / __gcd;

  typedef ratio<num, den> type;
};

template <intmax_t _Num, intmax_t _Den>
                  const intmax_t ratio<_Num, _Den>::num;

template <intmax_t _Num, intmax_t _Den>
                  const intmax_t ratio<_Num, _Den>::den;

template <class _Tp>
struct __is_ratio : false_type {};
template <intmax_t _Num, intmax_t _Den>
struct __is_ratio<ratio<_Num, _Den> > : true_type {};

typedef ratio<1LL, 1000000000000000000LL> atto;
typedef ratio<1LL, 1000000000000000LL> femto;
typedef ratio<1LL, 1000000000000LL> pico;
typedef ratio<1LL, 1000000000LL> nano;
typedef ratio<1LL, 1000000LL> micro;
typedef ratio<1LL, 1000LL> milli;
typedef ratio<1LL, 100LL> centi;
typedef ratio<1LL, 10LL> deci;
typedef ratio< 10LL, 1LL> deca;
typedef ratio< 100LL, 1LL> hecto;
typedef ratio< 1000LL, 1LL> kilo;
typedef ratio< 1000000LL, 1LL> mega;
typedef ratio< 1000000000LL, 1LL> giga;
typedef ratio< 1000000000000LL, 1LL> tera;
typedef ratio< 1000000000000000LL, 1LL> peta;
typedef ratio<1000000000000000000LL, 1LL> exa;

template <class _R1, class _R2>
struct __ratio_multiply {
private:
  static const intmax_t __gcd_n1_d2 = __static_gcd<_R1::num, _R2::den>::value;
  static const intmax_t __gcd_d1_n2 = __static_gcd<_R1::den, _R2::num>::value;

public:
  typedef typename ratio< __ll_mul<_R1::num / __gcd_n1_d2, _R2::num / __gcd_d1_n2>::value,
                          __ll_mul<_R2::den / __gcd_n1_d2, _R1::den / __gcd_d1_n2>::value >::type type;
};
# 304 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct ratio_multiply : public __ratio_multiply<_R1, _R2>::type {};



template <class _R1, class _R2>
struct __ratio_divide {
private:
  static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
  static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;

public:
  typedef typename ratio< __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                          __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value >::type type;
};
# 327 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct ratio_divide : public __ratio_divide<_R1, _R2>::type {};



template <class _R1, class _R2>
struct __ratio_add {
private:
  static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
  static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;

public:
  typedef typename ratio_multiply<
      ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
      ratio< __ll_add< __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                       __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value >::value,
             _R2::den > >::type type;
};
# 353 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct ratio_add : public __ratio_add<_R1, _R2>::type {};



template <class _R1, class _R2>
struct __ratio_subtract {
private:
  static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
  static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;

public:
  typedef typename ratio_multiply<
      ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
      ratio< __ll_sub< __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                       __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value >::value,
             _R2::den > >::type type;
};
# 379 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct ratio_subtract : public __ratio_subtract<_R1, _R2>::type {};





template <class _R1, class _R2>
struct ratio_equal : _BoolConstant<(_R1::num == _R2::num && _R1::den == _R2::den)> {};

template <class _R1, class _R2>
struct ratio_not_equal : _BoolConstant<!ratio_equal<_R1, _R2>::value> {};



template <class _R1,
          class _R2,
          bool _Odd = false,
          intmax_t _Q1 = _R1::num / _R1::den,
          intmax_t _M1 = _R1::num % _R1::den,
          intmax_t _Q2 = _R2::num / _R2::den,
          intmax_t _M2 = _R2::num % _R2::den>
struct __ratio_less1 {
  static const bool value = _Odd ? _Q2 < _Q1 : _Q1 < _Q2;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, 0> {
  static const bool value = false;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, _M2> {
  static const bool value = !_Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, 0> {
  static const bool value = _Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1, intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, _M2> {
  static const bool value = __ratio_less1<ratio<_R1::den, _M1>, ratio<_R2::den, _M2>, !_Odd>::value;
};

template <class _R1,
          class _R2,
          intmax_t _S1 = __static_sign<_R1::num>::value,
          intmax_t _S2 = __static_sign<_R2::num>::value>
struct __ratio_less {
  static const bool value = _S1 < _S2;
};

template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, 1LL, 1LL> {
  static const bool value = __ratio_less1<_R1, _R2>::value;
};

template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, -1LL, -1LL> {
  static const bool value = __ratio_less1<ratio<-_R2::num, _R2::den>, ratio<-_R1::num, _R1::den> >::value;
};

template <class _R1, class _R2>
struct ratio_less : _BoolConstant<__ratio_less<_R1, _R2>::value> {};

template <class _R1, class _R2>
struct ratio_less_equal : _BoolConstant<!ratio_less<_R2, _R1>::value> {};

template <class _R1, class _R2>
struct ratio_greater : _BoolConstant<ratio_less<_R2, _R1>::value> {};

template <class _R1, class _R2>
struct ratio_greater_equal : _BoolConstant<!ratio_less<_R1, _R2>::value> {};

template <class _R1, class _R2>
struct __ratio_gcd {
  typedef ratio<__static_gcd<_R1::num, _R2::num>::value, __static_lcm<_R1::den, _R2::den>::value> type;
};
# 480 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ratio" 3
}}
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/duration.h" 2 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/duration.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/duration.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace chrono {

template <class _Rep, class _Period = ratio<1> >
class duration;

template <class _Tp>
struct __is_duration : false_type {};

template <class _Rep, class _Period>
struct __is_duration<duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<volatile duration<_Rep, _Period> > : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const volatile duration<_Rep, _Period> > : true_type {};

}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
struct common_type<chrono::duration<_Rep1, _Period1>, chrono::duration<_Rep2, _Period2> > {
  typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type, typename __ratio_gcd<_Period1, _Period2>::type>
      type;
};

namespace chrono {



template <class _FromDuration,
          class _ToDuration,
          class _Period = typename ratio_divide<typename _FromDuration::period, typename _ToDuration::period>::type,
          bool = _Period::num == 1,
          bool = _Period::den == 1>
struct __duration_cast;

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, true> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ToDuration operator()(const _FromDuration& __fd) const {
    return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));
  }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, false> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ToDuration operator()(const _FromDuration& __fd) const {
    typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
    return _ToDuration(
        static_cast<typename _ToDuration::rep>(static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));
  }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, true> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ToDuration operator()(const _FromDuration& __fd) const {
    typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
    return _ToDuration(
        static_cast<typename _ToDuration::rep>(static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));
  }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, false> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ToDuration operator()(const _FromDuration& __fd) const {
    typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
    return _ToDuration(static_cast<typename _ToDuration::rep>(
        static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num) / static_cast<_Ct>(_Period::den)));
  }
};

template <class _ToDuration, class _Rep, class _Period, __enable_if_t<__is_duration<_ToDuration>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ToDuration duration_cast(const duration<_Rep, _Period>& __fd) {
  return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);
}

template <class _Rep>
struct treat_as_floating_point : is_floating_point<_Rep> {};






template <class _Rep>
struct duration_values {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static _Rep zero() throw() { return _Rep(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static _Rep max() throw() { return numeric_limits<_Rep>::max(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static _Rep min() throw() { return numeric_limits<_Rep>::lowest(); }
};
# 159 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/duration.h" 3
template <class _Rep, class _Period>
class duration {
  _Static_assert(!__is_duration<_Rep>::value, "A duration representation can not be a duration");
  _Static_assert(__is_ratio<_Period>::value, "Second template parameter of duration must be a std::ratio");
  _Static_assert(_Period::num > 0, "duration period must be positive");

  template <class _R1, class _R2>
  struct __no_overflow {
  private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
    static const intmax_t __n1 = _R1::num / __gcd_n1_n2;
    static const intmax_t __d1 = _R1::den / __gcd_d1_d2;
    static const intmax_t __n2 = _R2::num / __gcd_n1_n2;
    static const intmax_t __d2 = _R2::den / __gcd_d1_d2;
    static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);

    template <intmax_t _Xp, intmax_t _Yp, bool __overflow>
    struct __mul
    {
      static const intmax_t value = _Xp * _Yp;
    };

    template <intmax_t _Xp, intmax_t _Yp>
    struct __mul<_Xp, _Yp, true> {
      static const intmax_t value = 1;
    };

  public:
    static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
    typedef ratio<__mul<__n1, __d2, !value>::value, __mul<__n2, __d1, !value>::value> type;
  };

public:
  typedef _Rep rep;
  typedef typename _Period::type period;

private:
  rep __rep_;

public:



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) duration() {}


  template <class _Rep2,
            __enable_if_t<is_convertible<const _Rep2&, rep>::value &&
                              (treat_as_floating_point<rep>::value || !treat_as_floating_point<_Rep2>::value),
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit duration(const _Rep2& __r) : __rep_(__r) {}


  template <class _Rep2,
            class _Period2,
            __enable_if_t<__no_overflow<_Period2, period>::value && (treat_as_floating_point<rep>::value ||
                                                                     (__no_overflow<_Period2, period>::type::den == 1 &&
                                                                      !treat_as_floating_point<_Rep2>::value)),
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) duration(const duration<_Rep2, _Period2>& __d)
      : __rep_(chrono::duration_cast<duration>(__d).count()) {}



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) rep count() const { return __rep_; }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename common_type<duration>::type operator+() const {
    return typename common_type<duration>::type(*this);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename common_type<duration>::type operator-() const {
    return typename common_type<duration>::type(-__rep_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) duration& operator++() {
    ++__rep_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) duration operator++(int) { return duration(__rep_++); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) duration& operator--() {
    --__rep_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) duration operator--(int) { return duration(__rep_--); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) duration& operator+=(const duration& __d) {
    __rep_ += __d.count();
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) duration& operator-=(const duration& __d) {
    __rep_ -= __d.count();
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) duration& operator*=(const rep& __rhs) {
    __rep_ *= __rhs;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) duration& operator/=(const rep& __rhs) {
    __rep_ /= __rhs;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) duration& operator%=(const rep& __rhs) {
    __rep_ %= __rhs;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) duration& operator%=(const duration& __rhs) {
    __rep_ %= __rhs.count();
    return *this;
  }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static duration zero() throw() {
    return duration(duration_values<rep>::zero());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static duration min() throw() {
    return duration(duration_values<rep>::min());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static duration max() throw() {
    return duration(duration_values<rep>::max());
  }
};

typedef duration<long long, nano> nanoseconds;
typedef duration<long long, micro> microseconds;
typedef duration<long long, milli> milliseconds;
typedef duration<long long > seconds;
typedef duration< long, ratio< 60> > minutes;
typedef duration< long, ratio<3600> > hours;
# 298 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/duration.h" 3
template <class _LhsDuration, class _RhsDuration>
struct __duration_eq {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const {
    typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
    return _Ct(__lhs).count() == _Ct(__rhs).count();
  }
};

template <class _LhsDuration>
struct __duration_eq<_LhsDuration, _LhsDuration> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const {
    return __lhs.count() == __rhs.count();
  }
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator==(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs) {
  return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}





template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator!=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs) {
  return !(__lhs == __rhs);
}





template <class _LhsDuration, class _RhsDuration>
struct __duration_lt {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const {
    typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
    return _Ct(__lhs).count() < _Ct(__rhs).count();
  }
};

template <class _LhsDuration>
struct __duration_lt<_LhsDuration, _LhsDuration> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const {
    return __lhs.count() < __rhs.count();
  }
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs) {
  return __duration_lt<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs) {
  return __rhs < __lhs;
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs) {
  return !(__rhs < __lhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs) {
  return !(__lhs < __rhs);
}
# 392 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/duration.h" 3
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
    typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
    operator+(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs) {
  typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
  return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
    typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
    operator-(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs) {
  typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
  return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());
}



template <class _Rep1,
          class _Period,
          class _Rep2,
          __enable_if_t<is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) duration<typename common_type<_Rep1, _Rep2>::type, _Period>
operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s) {
  typedef typename common_type<_Rep1, _Rep2>::type _Cr;
  typedef duration<_Cr, _Period> _Cd;
  return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));
}

template <class _Rep1,
          class _Period,
          class _Rep2,
          __enable_if_t<is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) duration<typename common_type<_Rep1, _Rep2>::type, _Period>
operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d) {
  return __d * __s;
}



template <class _Rep1,
          class _Period,
          class _Rep2,
          __enable_if_t<!__is_duration<_Rep2>::value &&
                            is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
                        int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) duration<typename common_type<_Rep1, _Rep2>::type, _Period>
operator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s) {
  typedef typename common_type<_Rep1, _Rep2>::type _Cr;
  typedef duration<_Cr, _Period> _Cd;
  return _Cd(_Cd(__d).count() / static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename common_type<_Rep1, _Rep2>::type
operator/(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs) {
  typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Ct;
  return _Ct(__lhs).count() / _Ct(__rhs).count();
}



template <class _Rep1,
          class _Period,
          class _Rep2,
          __enable_if_t<!__is_duration<_Rep2>::value &&
                            is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
                        int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) duration<typename common_type<_Rep1, _Rep2>::type, _Period>
operator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s) {
  typedef typename common_type<_Rep1, _Rep2>::type _Cr;
  typedef duration<_Cr, _Period> _Cd;
  return _Cd(_Cd(__d).count() % static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
    typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
    operator%(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs) {
  typedef typename common_type<_Rep1, _Rep2>::type _Cr;
  typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
  return _Cd(static_cast<_Cr>(_Cd(__lhs).count()) % static_cast<_Cr>(_Cd(__rhs).count()));
}

}
# 542 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/duration.h" 3
}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic_sync.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__thread/poll_with_backoff.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__thread/poll_with_backoff.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/high_resolution_clock.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/high_resolution_clock.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/steady_clock.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/steady_clock.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/time_point.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/time_point.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/time_point.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace chrono {

template <class _Clock, class _Duration = typename _Clock::duration>
class time_point {
  _Static_assert(__is_duration<_Duration>::value, "Second template parameter of time_point must be a std::chrono::duration");


public:
  typedef _Clock clock;
  typedef _Duration duration;
  typedef typename duration::rep rep;
  typedef typename duration::period period;

private:
  duration __d_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) time_point() : __d_(duration::zero()) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit time_point(const duration& __d) : __d_(__d) {}


  template <class _Duration2, __enable_if_t<is_convertible<_Duration2, duration>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) time_point(const time_point<clock, _Duration2>& __t)
      : __d_(__t.time_since_epoch()) {}



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) duration time_since_epoch() const { return __d_; }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) time_point& operator+=(const duration& __d) {
    __d_ += __d;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) time_point& operator-=(const duration& __d) {
    __d_ -= __d;
    return *this;
  }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static time_point min() throw() { return time_point(duration::min()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static time_point max() throw() { return time_point(duration::max()); }
};

}

template <class _Clock, class _Duration1, class _Duration2>
struct
    common_type<chrono::time_point<_Clock, _Duration1>, chrono::time_point<_Clock, _Duration2> > {
  typedef chrono::time_point<_Clock, typename common_type<_Duration1, _Duration2>::type> type;
};

namespace chrono {

template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) time_point<_Clock, _ToDuration>
time_point_cast(const time_point<_Clock, _Duration>& __t) {
  return time_point<_Clock, _ToDuration>(chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));
}
# 120 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/time_point.h" 3
template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator==(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs) {
  return __lhs.time_since_epoch() == __rhs.time_since_epoch();
}





template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator!=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs) {
  return !(__lhs == __rhs);
}





template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs) {
  return __lhs.time_since_epoch() < __rhs.time_since_epoch();
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs) {
  return __rhs < __lhs;
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs) {
  return !(__rhs < __lhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs) {
  return !(__lhs < __rhs);
}
# 182 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/time_point.h" 3
template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
    time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
    operator+(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs) {
  typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Tr;
  return _Tr(__lhs.time_since_epoch() + __rhs);
}



template <class _Rep1, class _Period1, class _Clock, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
    time_point<_Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type>
    operator+(const duration<_Rep1, _Period1>& __lhs, const time_point<_Clock, _Duration2>& __rhs) {
  return __rhs + __lhs;
}



template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
    time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
    operator-(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs) {
  typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Ret;
  return _Ret(__lhs.time_since_epoch() - __rhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename common_type<_Duration1, _Duration2>::type
operator-(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs) {
  return __lhs.time_since_epoch() - __rhs.time_since_epoch();
}

}

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/steady_clock.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/steady_clock.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace chrono {


class __attribute__((__visibility__("default"))) steady_clock {
public:
  typedef nanoseconds duration;
  typedef duration::rep rep;
  typedef duration::period period;
  typedef chrono::time_point<steady_clock, duration> time_point;
  static const bool is_steady = true;

  static time_point now() throw();
};


}

}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/high_resolution_clock.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/system_clock.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/system_clock.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ctime" 1 3
# 53 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ctime" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 1 3 4
# 54 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ctime" 2 3
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ctime" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::clock_t __attribute__((__using_if_exists__));

using ::size_t __attribute__((__using_if_exists__));

using ::time_t __attribute__((__using_if_exists__));
using ::tm __attribute__((__using_if_exists__));



using ::clock __attribute__((__using_if_exists__));
using ::difftime __attribute__((__using_if_exists__));
using ::mktime __attribute__((__using_if_exists__));
using ::time __attribute__((__using_if_exists__));
using ::asctime __attribute__((__using_if_exists__));
using ::ctime __attribute__((__using_if_exists__));
using ::gmtime __attribute__((__using_if_exists__));
using ::localtime __attribute__((__using_if_exists__));
using ::strftime __attribute__((__using_if_exists__));




}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/system_clock.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/system_clock.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace chrono {

class __attribute__((__visibility__("default"))) system_clock {
public:
  typedef microseconds duration;
  typedef duration::rep rep;
  typedef duration::period period;
  typedef chrono::time_point<system_clock> time_point;
  static const bool is_steady = false;

  static time_point now() throw();
  static time_t to_time_t(const time_point& __t) throw();
  static time_point from_time_t(time_t __t) throw();
};
# 48 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/system_clock.h" 3
}

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/high_resolution_clock.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/high_resolution_clock.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace chrono {


typedef steady_clock high_resolution_clock;




}

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__thread/poll_with_backoff.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__thread/poll_with_backoff.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

static const int __libcpp_polling_count = 64;
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__thread/poll_with_backoff.h" 3
template <class _Fn, class _BFn>
__attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __libcpp_thread_poll_with_backoff(
    _Fn&& __f, _BFn&& __bf, chrono::nanoseconds __max_elapsed = chrono::nanoseconds::zero()) {
  auto const __start = chrono::high_resolution_clock::now();
  for (int __count = 0;;) {
    if (__f())
      return true;
    if (__count < __libcpp_polling_count) {
      __count += 1;
      continue;
    }
    chrono::nanoseconds const __elapsed = chrono::high_resolution_clock::now() - __start;
    if (__max_elapsed != chrono::nanoseconds::zero() && __max_elapsed < __elapsed)
      return false;
    if (__bf(__elapsed))
      return false;
  }
}







struct __spinning_backoff_policy {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(chrono::nanoseconds const&) const { return false; }
};

}}
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic_sync.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__threading_support" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__threading_support" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/convert_to_timespec.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/convert_to_timespec.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/convert_to_timespec.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _TimeSpec>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline _TimeSpec __convert_to_timespec(const chrono::nanoseconds& __ns) {
  using namespace chrono;
  seconds __s = duration_cast<seconds>(__ns);
  _TimeSpec __ts;
  typedef __decltype(__ts.tv_sec) __ts_sec;
  const __ts_sec __ts_sec_max = numeric_limits<__ts_sec>::max();

  if (__s.count() < __ts_sec_max) {
    __ts.tv_sec = static_cast<__ts_sec>(__s.count());
    __ts.tv_nsec = static_cast<__decltype(__ts.tv_nsec)>((__ns - __s).count());
  } else {
    __ts.tv_sec = __ts_sec_max;
    __ts.tv_nsec = 999999999;
  }

  return __ts;
}

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__threading_support" 2 3




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/errno.h" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/errno.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/errno.h" 1 3 4
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/errno.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/errno.h" 1 3 4
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/errno.h" 3 4
extern "C" {
extern int * __error(void);

}
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/errno.h" 2 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/errno.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__threading_support" 2 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__threading_support" 3
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__threading_support" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/math.h" 1 3
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__threading_support" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 1 3 4
# 56 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/sched.h" 1 3 4
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/sched.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/pthread_impl.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/pthread_impl.h" 3 4
#pragma clang assume_nonnull begin
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/pthread_impl.h" 3 4
#pragma clang assume_nonnull end
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/sched.h" 2 3 4

extern "C" {




struct sched_param { int sched_priority; char __opaque[4]; };




extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);
}
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/time.h" 1 3 4
# 58 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_cond_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_cond_t.h" 3 4
typedef __darwin_pthread_cond_t pthread_cond_t;
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_condattr_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_condattr_t.h" 3 4
typedef __darwin_pthread_condattr_t pthread_condattr_t;
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_key_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_key_t.h" 3 4
typedef __darwin_pthread_key_t pthread_key_t;
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h" 3 4
typedef __darwin_pthread_mutex_t pthread_mutex_t;
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h" 3 4
typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_once_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_once_t.h" 3 4
typedef __darwin_pthread_once_t pthread_once_t;
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlock_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlock_t.h" 3 4
typedef __darwin_pthread_rwlock_t pthread_rwlock_t;
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlockattr_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlockattr_t.h" 3 4
typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_t.h" 3 4
typedef __darwin_pthread_t pthread_t;
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/qos.h" 1 3 4
# 130 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/qos.h" 3 4
enum { QOS_CLASS_USER_INTERACTIVE __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x21, QOS_CLASS_USER_INITIATED __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x19, QOS_CLASS_DEFAULT __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x15, QOS_CLASS_UTILITY __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x11, QOS_CLASS_BACKGROUND __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x09, QOS_CLASS_UNSPECIFIED __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x00, }; typedef unsigned int qos_class_t;
# 159 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/qos.h" 3 4
extern "C" {
# 170 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
qos_class_t
qos_class_self(void);
# 192 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
qos_class_t
qos_class_main(void);

}
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 2 3 4




#pragma clang assume_nonnull begin

extern "C" {
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_attr_set_qos_class_np(pthread_attr_t *__attr,
  qos_class_t __qos_class, int __relative_priority);
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_attr_get_qos_class_np(pthread_attr_t * __attr,
  qos_class_t * _Nullable __qos_class,
  int * _Nullable __relative_priority);
# 153 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_set_qos_class_self_np(qos_class_t __qos_class,
  int __relative_priority);
# 184 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_get_qos_class_np(pthread_t __pthread,
  qos_class_t * _Nullable __qos_class,
  int * _Nullable __relative_priority);
# 211 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
typedef struct pthread_override_s* pthread_override_t;
# 263 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
pthread_override_t
pthread_override_qos_class_start_np(pthread_t __pthread,
  qos_class_t __qos_class, int __relative_priority);
# 291 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_override_qos_class_end_np(pthread_override_t __override);

}
# 295 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
#pragma clang assume_nonnull end
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_mach_port_t.h" 1 3 4
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_mach_port_t.h" 3 4
typedef __darwin_mach_port_t mach_port_t;
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 103 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 3 4
#pragma clang assume_nonnull begin

extern "C" {
# 225 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 3 4
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_atfork(void (* _Nullable)(void), void (* _Nullable)(void),
  void (* _Nullable)(void));

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_destroy(pthread_attr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getdetachstate(const pthread_attr_t *, int *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getguardsize(const pthread_attr_t * , size_t * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getinheritsched(const pthread_attr_t * , int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getschedparam(const pthread_attr_t * ,
  struct sched_param * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getschedpolicy(const pthread_attr_t * , int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getscope(const pthread_attr_t * , int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getstack(const pthread_attr_t * ,
  void * _Nullable * _Nonnull , size_t * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getstackaddr(const pthread_attr_t * ,
  void * _Nullable * _Nonnull );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getstacksize(const pthread_attr_t * , size_t * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_init(pthread_attr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setdetachstate(pthread_attr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setguardsize(pthread_attr_t *, size_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setinheritsched(pthread_attr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setschedparam(pthread_attr_t * ,
  const struct sched_param * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setschedpolicy(pthread_attr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setscope(pthread_attr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setstack(pthread_attr_t *, void *, size_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setstackaddr(pthread_attr_t *, void *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setstacksize(pthread_attr_t *, size_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cancel(pthread_t) __asm("_" "pthread_cancel" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_broadcast(pthread_cond_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_destroy(pthread_cond_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_init(
  pthread_cond_t * ,
  const pthread_condattr_t * _Nullable )
  __asm("_" "pthread_cond_init" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_signal(pthread_cond_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use an asynchronous wait instead of a synchronous wait" "\")")))
int pthread_cond_timedwait(
  pthread_cond_t * , pthread_mutex_t * ,
  const struct timespec * _Nullable )
  __asm("_" "pthread_cond_timedwait" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use an asynchronous wait instead of a synchronous wait" "\")")))
int pthread_cond_wait(pthread_cond_t * ,
  pthread_mutex_t * ) __asm("_" "pthread_cond_wait" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_condattr_destroy(pthread_condattr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_condattr_init(pthread_condattr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_condattr_getpshared(const pthread_condattr_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_condattr_setpshared(pthread_condattr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))

int pthread_create(pthread_t _Nullable * _Nonnull ,
  const pthread_attr_t * _Nullable ,
  void * _Nullable (* _Nonnull)(void * _Nullable),
  void * _Nullable );






__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_detach(pthread_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_equal(pthread_t _Nullable, pthread_t _Nullable);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Thread lifecycle is owned by Swift Concurrency runtime" "\")")))
void pthread_exit(void * _Nullable) __attribute__((__noreturn__));

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_getconcurrency(void);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_getschedparam(pthread_t , int * _Nullable ,
  struct sched_param * _Nullable );

__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use Task Local Values instead" "\")")))
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
void* _Nullable pthread_getspecific(pthread_key_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use an asynchronous wait instead of a synchronous wait" "\")")))
int pthread_join(pthread_t , void * _Nullable * _Nullable)
  __asm("_" "pthread_join" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_key_create(pthread_key_t *, void (* _Nullable)(void *));

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_key_delete(pthread_key_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_destroy(pthread_mutex_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_getprioceiling(const pthread_mutex_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_init(pthread_mutex_t * ,
  const pthread_mutexattr_t * _Nullable );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use OSAllocatedUnfairLock's withLock or NSLock for async-safe scoped locking" "\")")))
int pthread_mutex_lock(pthread_mutex_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_setprioceiling(pthread_mutex_t * , int,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use OSAllocatedUnfairLock's withLockIfAvailable or NSLock for async-safe scoped locking" "\")")))
int pthread_mutex_trylock(pthread_mutex_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use OSAllocatedUnfairLock's withLock or NSLock for async-safe scoped locking" "\")")))
int pthread_mutex_unlock(pthread_mutex_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_destroy(pthread_mutexattr_t *) __asm("_" "pthread_mutexattr_destroy" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_getpshared(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_gettype(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macos,introduced=10.13.4))) __attribute__((availability(ios,introduced=11.3))) __attribute__((availability(watchos,introduced=4.3))) __attribute__((availability(tvos,introduced=11.3)))
int pthread_mutexattr_getpolicy_np(const pthread_mutexattr_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_init(pthread_mutexattr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);

__attribute__((availability(macos,introduced=10.7))) __attribute__((availability(ios,introduced=5.0)))
int pthread_mutexattr_setpolicy_np(pthread_mutexattr_t *, int);

__attribute__((availability(swift,unavailable,message="Use lazily initialized globals instead")))
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_once(pthread_once_t *, void (* _Nonnull)(void));

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlock_destroy(pthread_rwlock_t * ) __asm("_" "pthread_rwlock_destroy" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlock_init(pthread_rwlock_t * ,
  const pthread_rwlockattr_t * _Nullable )
  __asm("_" "pthread_rwlock_init" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use async-safe scoped locking instead" "\")")))
int pthread_rwlock_rdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_rdlock" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use async-safe scoped locking instead" "\")")))
int pthread_rwlock_tryrdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_tryrdlock" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use async-safe scoped locking instead" "\")")))
int pthread_rwlock_trywrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_trywrlock" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use async-safe scoped locking instead" "\")")))
int pthread_rwlock_wrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_wrlock" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use async-safe scoped locking instead" "\")")))
int pthread_rwlock_unlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_unlock" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * ,
  int * );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlockattr_init(pthread_rwlockattr_t *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
pthread_t pthread_self(void);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use Task cancellation instead" "\")")))
int pthread_setcancelstate(int , int * _Nullable)
  __asm("_" "pthread_setcancelstate" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use Task cancellation instead" "\")")))
int pthread_setcanceltype(int , int * _Nullable)
  __asm("_" "pthread_setcanceltype" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_setconcurrency(int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_setschedparam(pthread_t, int, const struct sched_param *);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use Task Local Values instead" "\")")))
int pthread_setspecific(pthread_key_t , const void * _Nullable);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use Task cancellation instead" "\")")))
void pthread_testcancel(void) __asm("_" "pthread_testcancel" );




__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_is_threaded_np(void);

__attribute__((availability(macos,introduced=10.6))) __attribute__((availability(ios,introduced=3.2)))
int pthread_threadid_np(pthread_t _Nullable,__uint64_t* _Nullable);


__attribute__((availability(macos,introduced=10.6))) __attribute__((availability(ios,introduced=3.2)))
int pthread_getname_np(pthread_t,char*,size_t);

__attribute__((availability(macos,introduced=10.6))) __attribute__((availability(ios,introduced=3.2)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Thread lifecycle is owned by Swift Concurrency runtime" "\")")))
int pthread_setname_np(const char*);


__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_main_np(void);


__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
mach_port_t pthread_mach_thread_np(pthread_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
size_t pthread_get_stacksize_np(pthread_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
void* pthread_get_stackaddr_np(pthread_t);


__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t _Nullable);


__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use an asynchronous wait instead of a synchronous wait" "\")")))
int pthread_cond_timedwait_relative_np(pthread_cond_t *, pthread_mutex_t *,
  const struct timespec * _Nullable);


__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))

int pthread_create_suspended_np(
  pthread_t _Nullable * _Nonnull, const pthread_attr_t * _Nullable,
  void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable);





__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_kill(pthread_t, int);

__attribute__((availability(macos,introduced=10.5))) __attribute__((availability(ios,introduced=2.0)))
_Nullable pthread_t pthread_from_mach_thread_np(mach_port_t);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_sigmask(int, const sigset_t * _Nullable, sigset_t * _Nullable)
  __asm("_" "pthread_sigmask" );

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use Task.yield(), or await a condition instead of spinning" "\")")))
void pthread_yield_np(void);

__attribute__((availability(macos,introduced=11.0)))
__attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(driverkit,unavailable)))
void pthread_jit_write_protect_np(int enabled);

__attribute__((availability(macos,introduced=11.0))) __attribute__((availability(ios,introduced=17.4)))
__attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(driverkit,unavailable))) __attribute__((availability(visionos,unavailable)))
int pthread_jit_write_protect_supported_np(void);
# 608 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 3 4
typedef int (*pthread_jit_write_callback_t)(void * _Nullable ctx);
# 694 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 3 4
__attribute__((availability(macos,introduced=11.4))) __attribute__((availability(ios,introduced=17.4)))
__attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(driverkit,unavailable))) __attribute__((availability(visionos,unavailable)))
__attribute__((availability(swift,unavailable,message="This interface cannot be safely used from Swift")))
int pthread_jit_write_with_callback_np(
  pthread_jit_write_callback_t _Nonnull callback, void * _Nullable ctx);
# 725 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 3 4
__attribute__((availability(macos,introduced=12.1))) __attribute__((availability(ios,introduced=17.4)))
__attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(driverkit,unavailable))) __attribute__((availability(visionos,unavailable)))
void pthread_jit_write_freeze_callbacks_np(void);
# 744 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 3 4
__attribute__((availability(macos,introduced=11.0))) __attribute__((availability(ios,introduced=14.2))) __attribute__((availability(tvos,introduced=14.2))) __attribute__((availability(watchos,introduced=7.1)))
int
pthread_cpu_number_np(size_t *cpu_number_out);


}
# 749 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/pthread.h" 3 4
#pragma clang assume_nonnull end
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__threading_support" 2 3
# 54 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__threading_support" 3
typedef ::timespec __libcpp_timespec_t;


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





typedef pthread_mutex_t __libcpp_mutex_t;


typedef pthread_mutex_t __libcpp_recursive_mutex_t;


typedef pthread_cond_t __libcpp_condvar_t;



typedef pthread_once_t __libcpp_exec_once_flag;






typedef pthread_t __libcpp_thread_id;




typedef pthread_t __libcpp_thread_t;


typedef pthread_key_t __libcpp_tls_key;
# 159 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__threading_support" 3
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t* __m);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int
__libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t* __m);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
__libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t* __m);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int
__libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t* __m);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t* __m);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int __libcpp_mutex_lock(__libcpp_mutex_t* __m);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __libcpp_mutex_trylock(__libcpp_mutex_t* __m);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int __libcpp_mutex_unlock(__libcpp_mutex_t* __m);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
int __libcpp_mutex_destroy(__libcpp_mutex_t* __m);


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
int __libcpp_condvar_signal(__libcpp_condvar_t* __cv);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
int __libcpp_condvar_broadcast(__libcpp_condvar_t* __cv);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int
__libcpp_condvar_wait(__libcpp_condvar_t* __cv, __libcpp_mutex_t* __m);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int
__libcpp_condvar_timedwait(__libcpp_condvar_t* __cv, __libcpp_mutex_t* __m, __libcpp_timespec_t* __ts);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
int __libcpp_condvar_destroy(__libcpp_condvar_t* __cv);


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
int __libcpp_execute_once(__libcpp_exec_once_flag* __flag, void (*__init_routine)());


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
bool __libcpp_thread_id_equal(__libcpp_thread_id __t1, __libcpp_thread_id __t2);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
bool __libcpp_thread_id_less(__libcpp_thread_id __t1, __libcpp_thread_id __t2);


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
bool __libcpp_thread_isnull(const __libcpp_thread_t* __t);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
int __libcpp_thread_create(__libcpp_thread_t* __t, void* (*__func)(void*), void* __arg);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
__libcpp_thread_id __libcpp_thread_get_current_id();

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t* __t);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
int __libcpp_thread_join(__libcpp_thread_t* __t);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
int __libcpp_thread_detach(__libcpp_thread_t* __t);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
void __libcpp_thread_yield();

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
void __libcpp_thread_sleep_for(const chrono::nanoseconds& __ns);


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
int __libcpp_tls_create(__libcpp_tls_key* __key, void(* __at_exit)(void*));

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
void* __libcpp_tls_get(__libcpp_tls_key __key);

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
int __libcpp_tls_set(__libcpp_tls_key __key, void* __p);





int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t* __m) {
  pthread_mutexattr_t __attr;
  int __ec = pthread_mutexattr_init(&__attr);
  if (__ec)
    return __ec;
  __ec = pthread_mutexattr_settype(&__attr, 2);
  if (__ec) {
    pthread_mutexattr_destroy(&__attr);
    return __ec;
  }
  __ec = pthread_mutex_init(__m, &__attr);
  if (__ec) {
    pthread_mutexattr_destroy(&__attr);
    return __ec;
  }
  __ec = pthread_mutexattr_destroy(&__attr);
  if (__ec) {
    pthread_mutex_destroy(__m);
    return __ec;
  }
  return 0;
}

int __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t* __m) { return pthread_mutex_lock(__m); }

bool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t* __m) { return pthread_mutex_trylock(__m) == 0; }

int __libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t* __m) { return pthread_mutex_unlock(__m); }

int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t* __m) { return pthread_mutex_destroy(__m); }

int __libcpp_mutex_lock(__libcpp_mutex_t* __m) { return pthread_mutex_lock(__m); }

bool __libcpp_mutex_trylock(__libcpp_mutex_t* __m) { return pthread_mutex_trylock(__m) == 0; }

int __libcpp_mutex_unlock(__libcpp_mutex_t* __m) { return pthread_mutex_unlock(__m); }

int __libcpp_mutex_destroy(__libcpp_mutex_t* __m) { return pthread_mutex_destroy(__m); }


int __libcpp_condvar_signal(__libcpp_condvar_t* __cv) { return pthread_cond_signal(__cv); }

int __libcpp_condvar_broadcast(__libcpp_condvar_t* __cv) { return pthread_cond_broadcast(__cv); }

int __libcpp_condvar_wait(__libcpp_condvar_t* __cv, __libcpp_mutex_t* __m) { return pthread_cond_wait(__cv, __m); }

int __libcpp_condvar_timedwait(__libcpp_condvar_t* __cv, __libcpp_mutex_t* __m, __libcpp_timespec_t* __ts) {
  return pthread_cond_timedwait(__cv, __m, __ts);
}

int __libcpp_condvar_destroy(__libcpp_condvar_t* __cv) { return pthread_cond_destroy(__cv); }


int __libcpp_execute_once(__libcpp_exec_once_flag* __flag, void (*__init_routine)()) {
  return pthread_once(__flag, __init_routine);
}



bool __libcpp_thread_id_equal(__libcpp_thread_id __t1, __libcpp_thread_id __t2) { return __t1 == __t2; }


bool __libcpp_thread_id_less(__libcpp_thread_id __t1, __libcpp_thread_id __t2) { return __t1 < __t2; }


bool __libcpp_thread_isnull(const __libcpp_thread_t* __t) { return __libcpp_thread_get_id(__t) == 0; }

int __libcpp_thread_create(__libcpp_thread_t* __t, void* (*__func)(void*), void* __arg) {
  return pthread_create(__t, __nullptr, __func, __arg);
}

__libcpp_thread_id __libcpp_thread_get_current_id() {
  const __libcpp_thread_t __current_thread = pthread_self();
  return __libcpp_thread_get_id(&__current_thread);
}

__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t* __t) {



  return *__t;

}

int __libcpp_thread_join(__libcpp_thread_t* __t) { return pthread_join(*__t, __nullptr); }

int __libcpp_thread_detach(__libcpp_thread_t* __t) { return pthread_detach(*__t); }

void __libcpp_thread_yield() { sched_yield(); }

void __libcpp_thread_sleep_for(const chrono::nanoseconds& __ns) {
  __libcpp_timespec_t __ts = std::__convert_to_timespec<__libcpp_timespec_t>(__ns);
  while (nanosleep(&__ts, &__ts) == -1 && (*__error()) == 4)
    ;
}


int __libcpp_tls_create(__libcpp_tls_key* __key, void (*__at_exit)(void*)) {
  return pthread_key_create(__key, __at_exit);
}

void* __libcpp_tls_get(__libcpp_tls_key __key) { return pthread_getspecific(__key); }

int __libcpp_tls_set(__libcpp_tls_key __key, void* __p) { return pthread_setspecific(__key, __p); }
# 456 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__threading_support" 3
}}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic_sync.h" 2 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic_sync.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



__attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("default"))) void __cxx_atomic_notify_one(void const volatile*);
__attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("default"))) void __cxx_atomic_notify_all(void const volatile*);
__attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("default"))) __cxx_contention_t __libcpp_atomic_monitor(void const volatile*);
__attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("default"))) void __libcpp_atomic_wait(void const volatile*, __cxx_contention_t);

__attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("default"))) void
__cxx_atomic_notify_one(__cxx_atomic_contention_t const volatile*);
__attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("default"))) void
__cxx_atomic_notify_all(__cxx_atomic_contention_t const volatile*);
__attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("default"))) __cxx_contention_t
__libcpp_atomic_monitor(__cxx_atomic_contention_t const volatile*);
__attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("default"))) void
__libcpp_atomic_wait(__cxx_atomic_contention_t const volatile*, __cxx_contention_t);

template <class _Atp, class _Fn>
struct __libcpp_atomic_wait_backoff_impl {
  _Atp* __a;
  _Fn __test_fn;
  __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0)))
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(chrono::nanoseconds __elapsed) const {
    if (__elapsed > chrono::microseconds(64)) {
      auto const __monitor = std::__libcpp_atomic_monitor(__a);
      if (__test_fn())
        return true;
      std::__libcpp_atomic_wait(__a, __monitor);
    } else if (__elapsed > chrono::microseconds(4))
      __libcpp_thread_yield();
    else {
    }
    return false;
  }
};

template <class _Atp, class _Fn>
__attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __cxx_atomic_wait(_Atp* __a, _Fn&& __test_fn) {
  __libcpp_atomic_wait_backoff_impl<_Atp, __decay_t<_Fn> > __backoff_fn = {__a, __test_fn};
  return std::__libcpp_thread_poll_with_backoff(__test_fn, __backoff_fn);
}
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic_sync.h" 3
template <typename _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __cxx_nonatomic_compare_equal(_Tp const& __lhs, _Tp const& __rhs) {
  return std::memcmp(std::addressof(__lhs), std::addressof(__rhs), sizeof(_Tp)) == 0;
}

template <class _Atp, class _Tp>
struct __cxx_atomic_wait_test_fn_impl {
  _Atp* __a;
  _Tp __val;
  memory_order __order;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()() const {
    return !std::__cxx_nonatomic_compare_equal(std::__cxx_atomic_load(__a, __order), __val);
  }
};

template <class _Atp, class _Tp>
__attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
__cxx_atomic_wait(_Atp* __a, _Tp const __val, memory_order __order) {
  __cxx_atomic_wait_test_fn_impl<_Atp, _Tp> __test_fn = {__a, __val, __order};
  return std::__cxx_atomic_wait(__a, __test_fn);
}

}}
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic_base.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/check_memory_order.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/check_memory_order.h" 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic_base.h" 2 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic_base.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
struct __atomic_base
{
  mutable __cxx_atomic_impl<_Tp> __a_;





  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool is_lock_free() const volatile throw() {
    return __c11_atomic_is_lock_free(sizeof(__cxx_atomic_impl<_Tp>));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool is_lock_free() const throw() {
    return static_cast<__atomic_base const volatile*>(this)->is_lock_free();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile throw()
      __attribute__((__diagnose_if__(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
    std::__cxx_atomic_store(std::addressof(__a_), __d, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void store(_Tp __d, memory_order __m = memory_order_seq_cst) throw()
      __attribute__((__diagnose_if__(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
    std::__cxx_atomic_store(std::addressof(__a_), __d, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp load(memory_order __m = memory_order_seq_cst) const volatile throw()
      __attribute__((__diagnose_if__(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
    return std::__cxx_atomic_load(std::addressof(__a_), __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp load(memory_order __m = memory_order_seq_cst) const throw()
      __attribute__((__diagnose_if__(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
    return std::__cxx_atomic_load(std::addressof(__a_), __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) operator _Tp() const volatile throw() { return load(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) operator _Tp() const throw() { return load(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile throw() {
    return std::__cxx_atomic_exchange(std::addressof(__a_), __d, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) throw() {
    return std::__cxx_atomic_exchange(std::addressof(__a_), __d, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
  compare_exchange_weak(_Tp& __e, _Tp __d, memory_order __s, memory_order __f) volatile throw()
      __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
    return std::__cxx_atomic_compare_exchange_weak(std::addressof(__a_), std::addressof(__e), __d, __s, __f);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool compare_exchange_weak(_Tp& __e, _Tp __d, memory_order __s, memory_order __f) throw()
      __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
    return std::__cxx_atomic_compare_exchange_weak(std::addressof(__a_), std::addressof(__e), __d, __s, __f);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
  compare_exchange_strong(_Tp& __e, _Tp __d, memory_order __s, memory_order __f) volatile throw()
      __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
    return std::__cxx_atomic_compare_exchange_strong(std::addressof(__a_), std::addressof(__e), __d, __s, __f);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool compare_exchange_strong(_Tp& __e, _Tp __d, memory_order __s, memory_order __f) throw()
      __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
    return std::__cxx_atomic_compare_exchange_strong(std::addressof(__a_), std::addressof(__e), __d, __s, __f);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
  compare_exchange_weak(_Tp& __e, _Tp __d, memory_order __m = memory_order_seq_cst) volatile throw() {
    return std::__cxx_atomic_compare_exchange_weak(std::addressof(__a_), std::addressof(__e), __d, __m, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
  compare_exchange_weak(_Tp& __e, _Tp __d, memory_order __m = memory_order_seq_cst) throw() {
    return std::__cxx_atomic_compare_exchange_weak(std::addressof(__a_), std::addressof(__e), __d, __m, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
  compare_exchange_strong(_Tp& __e, _Tp __d, memory_order __m = memory_order_seq_cst) volatile throw() {
    return std::__cxx_atomic_compare_exchange_strong(std::addressof(__a_), std::addressof(__e), __d, __m, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
  compare_exchange_strong(_Tp& __e, _Tp __d, memory_order __m = memory_order_seq_cst) throw() {
    return std::__cxx_atomic_compare_exchange_strong(std::addressof(__a_), std::addressof(__e), __d, __m, __m);
  }

  __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void wait(_Tp __v, memory_order __m = memory_order_seq_cst) const
      volatile throw() {
    std::__cxx_atomic_wait(std::addressof(__a_), __v, __m);
  }
  __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  wait(_Tp __v, memory_order __m = memory_order_seq_cst) const throw() {
    std::__cxx_atomic_wait(std::addressof(__a_), __v, __m);
  }
  __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void notify_one() volatile throw() {
    std::__cxx_atomic_notify_one(std::addressof(__a_));
  }
  __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void notify_one() throw() {
    std::__cxx_atomic_notify_one(std::addressof(__a_));
  }
  __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void notify_all() volatile throw() {
    std::__cxx_atomic_notify_all(std::addressof(__a_));
  }
  __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void notify_all() throw() {
    std::__cxx_atomic_notify_all(std::addressof(__a_));
  }




  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __atomic_base() throw() = default;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __atomic_base(_Tp __d) throw() : __a_(__d) {}

  __atomic_base(const __atomic_base&) = delete;
};
# 144 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic_base.h" 3
template <class _Tp>
struct __atomic_base<_Tp, true> : public __atomic_base<_Tp, false> {
  using __base = __atomic_base<_Tp, false>;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __atomic_base() throw() = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __atomic_base(_Tp __d) throw() : __base(__d) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile throw() {
    return std::__cxx_atomic_fetch_add(std::addressof(this->__a_), __op, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) throw() {
    return std::__cxx_atomic_fetch_add(std::addressof(this->__a_), __op, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile throw() {
    return std::__cxx_atomic_fetch_sub(std::addressof(this->__a_), __op, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) throw() {
    return std::__cxx_atomic_fetch_sub(std::addressof(this->__a_), __op, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile throw() {
    return std::__cxx_atomic_fetch_and(std::addressof(this->__a_), __op, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) throw() {
    return std::__cxx_atomic_fetch_and(std::addressof(this->__a_), __op, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile throw() {
    return std::__cxx_atomic_fetch_or(std::addressof(this->__a_), __op, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) throw() {
    return std::__cxx_atomic_fetch_or(std::addressof(this->__a_), __op, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile throw() {
    return std::__cxx_atomic_fetch_xor(std::addressof(this->__a_), __op, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) throw() {
    return std::__cxx_atomic_fetch_xor(std::addressof(this->__a_), __op, __m);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator++(int) volatile throw() { return fetch_add(_Tp(1)); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator++(int) throw() { return fetch_add(_Tp(1)); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator--(int) volatile throw() { return fetch_sub(_Tp(1)); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator--(int) throw() { return fetch_sub(_Tp(1)); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator++() volatile throw() { return fetch_add(_Tp(1)) + _Tp(1); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator++() throw() { return fetch_add(_Tp(1)) + _Tp(1); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator--() volatile throw() { return fetch_sub(_Tp(1)) - _Tp(1); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator--() throw() { return fetch_sub(_Tp(1)) - _Tp(1); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator+=(_Tp __op) volatile throw() { return fetch_add(__op) + __op; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator+=(_Tp __op) throw() { return fetch_add(__op) + __op; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator-=(_Tp __op) volatile throw() { return fetch_sub(__op) - __op; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator-=(_Tp __op) throw() { return fetch_sub(__op) - __op; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator&=(_Tp __op) volatile throw() { return fetch_and(__op) & __op; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator&=(_Tp __op) throw() { return fetch_and(__op) & __op; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator|=(_Tp __op) volatile throw() { return fetch_or(__op) | __op; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator|=(_Tp __op) throw() { return fetch_or(__op) | __op; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator^=(_Tp __op) volatile throw() { return fetch_xor(__op) ^ __op; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator^=(_Tp __op) throw() { return fetch_xor(__op) ^ __op; }
};

}}
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic.h" 2 3




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {






template <class _Tp>

struct plus : __binary_function<_Tp, _Tp, _Tp> {
  typedef _Tp __result_type;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator()(const _Tp& __x, const _Tp& __y) const {
    return __x + __y;
  }
};
_Static_assert(true, "");



template <class _Tp>
struct __desugars_to<__plus_tag, plus<_Tp>, _Tp, _Tp> : true_type {};

template <class _Tp, class _Up>
struct __desugars_to<__plus_tag, plus<void>, _Tp, _Up> : true_type {};
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
template <class _Tp>

struct minus : __binary_function<_Tp, _Tp, _Tp> {
  typedef _Tp __result_type;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator()(const _Tp& __x, const _Tp& __y) const {
    return __x - __y;
  }
};
_Static_assert(true, "");
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
template <class _Tp>

struct multiplies : __binary_function<_Tp, _Tp, _Tp> {
  typedef _Tp __result_type;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator()(const _Tp& __x, const _Tp& __y) const {
    return __x * __y;
  }
};
_Static_assert(true, "");
# 117 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
template <class _Tp>

struct divides : __binary_function<_Tp, _Tp, _Tp> {
  typedef _Tp __result_type;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator()(const _Tp& __x, const _Tp& __y) const {
    return __x / __y;
  }
};
_Static_assert(true, "");
# 143 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
template <class _Tp>

struct modulus : __binary_function<_Tp, _Tp, _Tp> {
  typedef _Tp __result_type;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator()(const _Tp& __x, const _Tp& __y) const {
    return __x % __y;
  }
};
_Static_assert(true, "");
# 169 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
template <class _Tp>

struct negate : __unary_function<_Tp, _Tp> {
  typedef _Tp __result_type;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator()(const _Tp& __x) const { return -__x; }
};
_Static_assert(true, "");
# 194 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
template <class _Tp>

struct bit_and : __binary_function<_Tp, _Tp, _Tp> {
  typedef _Tp __result_type;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator()(const _Tp& __x, const _Tp& __y) const {
    return __x & __y;
  }
};
_Static_assert(true, "");
# 238 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
template <class _Tp>

struct bit_or : __binary_function<_Tp, _Tp, _Tp> {
  typedef _Tp __result_type;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator()(const _Tp& __x, const _Tp& __y) const {
    return __x | __y;
  }
};
_Static_assert(true, "");
# 264 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
template <class _Tp>

struct bit_xor : __binary_function<_Tp, _Tp, _Tp> {
  typedef _Tp __result_type;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator()(const _Tp& __x, const _Tp& __y) const {
    return __x ^ __y;
  }
};
_Static_assert(true, "");
# 292 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
template <class _Tp>

struct equal_to : __binary_function<_Tp, _Tp, bool> {
  typedef bool __result_type;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _Tp& __x, const _Tp& __y) const {
    return __x == __y;
  }
};
_Static_assert(true, "");
# 317 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
template <class _Tp>
struct __desugars_to<__equal_tag, equal_to<_Tp>, _Tp, _Tp> : true_type {};


template <class _Tp, class _Up>
struct __desugars_to<__equal_tag, equal_to<void>, _Tp, _Up> : true_type {};




template <class _Tp>

struct not_equal_to : __binary_function<_Tp, _Tp, bool> {
  typedef bool __result_type;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _Tp& __x, const _Tp& __y) const {
    return __x != __y;
  }
};
_Static_assert(true, "");
# 353 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
template <class _Tp>

struct less : __binary_function<_Tp, _Tp, bool> {
  typedef bool __result_type;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _Tp& __x, const _Tp& __y) const {
    return __x < __y;
  }
};
_Static_assert(true, "");
# 379 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
template <class _Tp>

struct less_equal : __binary_function<_Tp, _Tp, bool> {
  typedef bool __result_type;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _Tp& __x, const _Tp& __y) const {
    return __x <= __y;
  }
};
_Static_assert(true, "");
# 405 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
template <class _Tp>

struct greater_equal : __binary_function<_Tp, _Tp, bool> {
  typedef bool __result_type;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _Tp& __x, const _Tp& __y) const {
    return __x >= __y;
  }
};
_Static_assert(true, "");
# 431 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
template <class _Tp>

struct greater : __binary_function<_Tp, _Tp, bool> {
  typedef bool __result_type;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _Tp& __x, const _Tp& __y) const {
    return __x > __y;
  }
};
_Static_assert(true, "");
# 459 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
template <class _Tp>

struct logical_and : __binary_function<_Tp, _Tp, bool> {
  typedef bool __result_type;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _Tp& __x, const _Tp& __y) const {
    return __x && __y;
  }
};
_Static_assert(true, "");
# 485 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
template <class _Tp>

struct logical_not : __unary_function<_Tp, bool> {
  typedef bool __result_type;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _Tp& __x) const { return !__x; }
};
_Static_assert(true, "");
# 508 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
template <class _Tp>

struct logical_or : __binary_function<_Tp, _Tp, bool> {
  typedef bool __result_type;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _Tp& __x, const _Tp& __y) const {
    return __x || __y;
  }
};
_Static_assert(true, "");
# 531 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/operations.h" 3
}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic.h" 2 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct atomic : public __atomic_base<_Tp> {
  using __base = __atomic_base<_Tp>;
  using value_type = _Tp;
  using difference_type = value_type;




  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) atomic() throw() = default;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) atomic(_Tp __d) throw() : __base(__d) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator=(_Tp __d) volatile throw() {
    __base::store(__d);
    return __d;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp operator=(_Tp __d) throw() {
    __base::store(__d);
    return __d;
  }

  atomic& operator=(const atomic&) = delete;
  atomic& operator=(const atomic&) volatile = delete;
};



template <class _Tp>
struct atomic<_Tp*> : public __atomic_base<_Tp*> {
  using __base = __atomic_base<_Tp*>;
  using value_type = _Tp*;
  using difference_type = ptrdiff_t;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) atomic() throw() = default;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) atomic(_Tp* __d) throw() : __base(__d) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* operator=(_Tp* __d) volatile throw() {
    __base::store(__d);
    return __d;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* operator=(_Tp* __d) throw() {
    __base::store(__d);
    return __d;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) volatile throw() {

    _Static_assert(!is_function<__remove_pointer_t<_Tp> >::value, "Pointer to function isn't allowed");
    return std::__cxx_atomic_fetch_add(std::addressof(this->__a_), __op, __m);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) throw() {

    _Static_assert(!is_function<__remove_pointer_t<_Tp> >::value, "Pointer to function isn't allowed");
    return std::__cxx_atomic_fetch_add(std::addressof(this->__a_), __op, __m);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) volatile throw() {

    _Static_assert(!is_function<__remove_pointer_t<_Tp> >::value, "Pointer to function isn't allowed");
    return std::__cxx_atomic_fetch_sub(std::addressof(this->__a_), __op, __m);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) throw() {

    _Static_assert(!is_function<__remove_pointer_t<_Tp> >::value, "Pointer to function isn't allowed");
    return std::__cxx_atomic_fetch_sub(std::addressof(this->__a_), __op, __m);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* operator++(int) volatile throw() { return fetch_add(1); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* operator++(int) throw() { return fetch_add(1); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* operator--(int) volatile throw() { return fetch_sub(1); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* operator--(int) throw() { return fetch_sub(1); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* operator++() volatile throw() { return fetch_add(1) + 1; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* operator++() throw() { return fetch_add(1) + 1; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* operator--() volatile throw() { return fetch_sub(1) - 1; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* operator--() throw() { return fetch_sub(1) - 1; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* operator+=(ptrdiff_t __op) volatile throw() { return fetch_add(__op) + __op; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* operator+=(ptrdiff_t __op) throw() { return fetch_add(__op) + __op; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* operator-=(ptrdiff_t __op) volatile throw() { return fetch_sub(__op) - __op; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* operator-=(ptrdiff_t __op) throw() { return fetch_sub(__op) - __op; }

  atomic& operator=(const atomic&) = delete;
  atomic& operator=(const atomic&) volatile = delete;
};
# 256 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic.h" 3
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool atomic_is_lock_free(const volatile atomic<_Tp>* __o) throw() {
  return __o->is_lock_free();
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool atomic_is_lock_free(const atomic<_Tp>* __o) throw() {
  return __o->is_lock_free();
}



template <class _Tp>
                            __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
atomic_init(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) throw() {
  std::__cxx_atomic_init(std::addressof(__o->__a_), __d);
}

template <class _Tp>
                            __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
atomic_init(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) throw() {
  std::__cxx_atomic_init(std::addressof(__o->__a_), __d);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void atomic_store(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) throw() {
  __o->store(__d);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void atomic_store(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) throw() {
  __o->store(__d);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
atomic_store_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d, memory_order __m) throw()
    __attribute__((__diagnose_if__(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
  __o->store(__d, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
atomic_store_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d, memory_order __m) throw()
    __attribute__((__diagnose_if__(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
  __o->store(__d, __m);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp atomic_load(const volatile atomic<_Tp>* __o) throw() {
  return __o->load();
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp atomic_load(const atomic<_Tp>* __o) throw() {
  return __o->load();
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp atomic_load_explicit(const volatile atomic<_Tp>* __o, memory_order __m) throw()
    __attribute__((__diagnose_if__(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
  return __o->load(__m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp atomic_load_explicit(const atomic<_Tp>* __o, memory_order __m) throw()
    __attribute__((__diagnose_if__(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
  return __o->load(__m);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp atomic_exchange(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) throw() {
  return __o->exchange(__d);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp atomic_exchange(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) throw() {
  return __o->exchange(__d);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
atomic_exchange_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d, memory_order __m) throw() {
  return __o->exchange(__d, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
atomic_exchange_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d, memory_order __m) throw() {
  return __o->exchange(__d, __m);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool atomic_compare_exchange_weak(
    volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) throw() {
  return __o->compare_exchange_weak(*__e, __d);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool atomic_compare_exchange_weak(
    atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) throw() {
  return __o->compare_exchange_weak(*__e, __d);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool atomic_compare_exchange_strong(
    volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) throw() {
  return __o->compare_exchange_strong(*__e, __d);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool atomic_compare_exchange_strong(
    atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) throw() {
  return __o->compare_exchange_strong(*__e, __d);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool atomic_compare_exchange_weak_explicit(
    volatile atomic<_Tp>* __o,
    typename atomic<_Tp>::value_type* __e,
    typename atomic<_Tp>::value_type __d,
    memory_order __s,
    memory_order __f) throw() __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
  return __o->compare_exchange_weak(*__e, __d, __s, __f);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool atomic_compare_exchange_weak_explicit(
    atomic<_Tp>* __o,
    typename atomic<_Tp>::value_type* __e,
    typename atomic<_Tp>::value_type __d,
    memory_order __s,
    memory_order __f) throw() __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
  return __o->compare_exchange_weak(*__e, __d, __s, __f);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool atomic_compare_exchange_strong_explicit(
    volatile atomic<_Tp>* __o,
    typename atomic<_Tp>::value_type* __e,
    typename atomic<_Tp>::value_type __d,
    memory_order __s,
    memory_order __f) throw() __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
  return __o->compare_exchange_strong(*__e, __d, __s, __f);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool atomic_compare_exchange_strong_explicit(
    atomic<_Tp>* __o,
    typename atomic<_Tp>::value_type* __e,
    typename atomic<_Tp>::value_type __d,
    memory_order __s,
    memory_order __f) throw() __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
  return __o->compare_exchange_strong(*__e, __d, __s, __f);
}



template <class _Tp>
__attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
atomic_wait(const volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __v) throw() {
  return __o->wait(__v);
}

template <class _Tp>
__attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
atomic_wait(const atomic<_Tp>* __o, typename atomic<_Tp>::value_type __v) throw() {
  return __o->wait(__v);
}



template <class _Tp>
__attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
atomic_wait_explicit(const volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __v, memory_order __m) throw()
    __attribute__((__diagnose_if__(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
  return __o->wait(__v, __m);
}

template <class _Tp>
__attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
atomic_wait_explicit(const atomic<_Tp>* __o, typename atomic<_Tp>::value_type __v, memory_order __m) throw()
    __attribute__((__diagnose_if__(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning"))) {
  return __o->wait(__v, __m);
}



template <class _Tp>
__attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void atomic_notify_one(volatile atomic<_Tp>* __o) throw() {
  __o->notify_one();
}
template <class _Tp>
__attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void atomic_notify_one(atomic<_Tp>* __o) throw() {
  __o->notify_one();
}



template <class _Tp>
__attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void atomic_notify_all(volatile atomic<_Tp>* __o) throw() {
  __o->notify_all();
}
template <class _Tp>
__attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void atomic_notify_all(atomic<_Tp>* __o) throw() {
  __o->notify_all();
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
atomic_fetch_add(volatile atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op) throw() {
  return __o->fetch_add(__op);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp atomic_fetch_add(atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op) throw() {
  return __o->fetch_add(__op);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp atomic_fetch_add_explicit(
    volatile atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op, memory_order __m) throw() {
  return __o->fetch_add(__op, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
atomic_fetch_add_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op, memory_order __m) throw() {
  return __o->fetch_add(__op, __m);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
atomic_fetch_sub(volatile atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op) throw() {
  return __o->fetch_sub(__op);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp atomic_fetch_sub(atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op) throw() {
  return __o->fetch_sub(__op);
}



template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp atomic_fetch_sub_explicit(
    volatile atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op, memory_order __m) throw() {
  return __o->fetch_sub(__op, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
atomic_fetch_sub_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op, memory_order __m) throw() {
  return __o->fetch_sub(__op, __m);
}



template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp atomic_fetch_and(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) throw() {
  return __o->fetch_and(__op);
}

template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp atomic_fetch_and(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) throw() {
  return __o->fetch_and(__op);
}



template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp atomic_fetch_and_explicit(
    volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) throw() {
  return __o->fetch_and(__op, __m);
}

template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
atomic_fetch_and_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) throw() {
  return __o->fetch_and(__op, __m);
}



template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp atomic_fetch_or(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) throw() {
  return __o->fetch_or(__op);
}

template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp atomic_fetch_or(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) throw() {
  return __o->fetch_or(__op);
}



template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
atomic_fetch_or_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) throw() {
  return __o->fetch_or(__op, __m);
}

template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
atomic_fetch_or_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) throw() {
  return __o->fetch_or(__op, __m);
}



template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp atomic_fetch_xor(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) throw() {
  return __o->fetch_xor(__op);
}

template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp atomic_fetch_xor(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) throw() {
  return __o->fetch_xor(__op);
}



template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp atomic_fetch_xor_explicit(
    volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) throw() {
  return __o->fetch_xor(__op, __m);
}

template <class _Tp, __enable_if_t<is_integral<_Tp>::value && !is_same<_Tp, bool>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
atomic_fetch_xor_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) throw() {
  return __o->fetch_xor(__op, __m);
}

}}
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/aliases.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic_lock_free.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic_lock_free.h" 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/aliases.h" 2 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/aliases.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using atomic_bool = atomic<bool>;
using atomic_char = atomic<char>;
using atomic_schar = atomic<signed char>;
using atomic_uchar = atomic<unsigned char>;
using atomic_short = atomic<short>;
using atomic_ushort = atomic<unsigned short>;
using atomic_int = atomic<int>;
using atomic_uint = atomic<unsigned int>;
using atomic_long = atomic<long>;
using atomic_ulong = atomic<unsigned long>;
using atomic_llong = atomic<long long>;
using atomic_ullong = atomic<unsigned long long>;



using atomic_char16_t = atomic<char16_t>;
using atomic_char32_t = atomic<char32_t>;

using atomic_wchar_t = atomic<wchar_t>;


using atomic_int_least8_t = atomic<int_least8_t>;
using atomic_uint_least8_t = atomic<uint_least8_t>;
using atomic_int_least16_t = atomic<int_least16_t>;
using atomic_uint_least16_t = atomic<uint_least16_t>;
using atomic_int_least32_t = atomic<int_least32_t>;
using atomic_uint_least32_t = atomic<uint_least32_t>;
using atomic_int_least64_t = atomic<int_least64_t>;
using atomic_uint_least64_t = atomic<uint_least64_t>;

using atomic_int_fast8_t = atomic<int_fast8_t>;
using atomic_uint_fast8_t = atomic<uint_fast8_t>;
using atomic_int_fast16_t = atomic<int_fast16_t>;
using atomic_uint_fast16_t = atomic<uint_fast16_t>;
using atomic_int_fast32_t = atomic<int_fast32_t>;
using atomic_uint_fast32_t = atomic<uint_fast32_t>;
using atomic_int_fast64_t = atomic<int_fast64_t>;
using atomic_uint_fast64_t = atomic<uint_fast64_t>;

using atomic_int8_t = atomic< int8_t>;
using atomic_uint8_t = atomic<uint8_t>;
using atomic_int16_t = atomic< int16_t>;
using atomic_uint16_t = atomic<uint16_t>;
using atomic_int32_t = atomic< int32_t>;
using atomic_uint32_t = atomic<uint32_t>;
using atomic_int64_t = atomic< int64_t>;
using atomic_uint64_t = atomic<uint64_t>;

using atomic_intptr_t = atomic<intptr_t>;
using atomic_uintptr_t = atomic<uintptr_t>;
using atomic_size_t = atomic<size_t>;
using atomic_ptrdiff_t = atomic<ptrdiff_t>;
using atomic_intmax_t = atomic<intmax_t>;
using atomic_uintmax_t = atomic<uintmax_t>;
# 109 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/aliases.h" 3
}}
# 592 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic_flag.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic_flag.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct atomic_flag {
  __cxx_atomic_impl<bool> __a_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool test(memory_order __m = memory_order_seq_cst) const volatile throw() {
    return bool(true) == __cxx_atomic_load(&__a_, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool test(memory_order __m = memory_order_seq_cst) const throw() {
    return bool(true) == __cxx_atomic_load(&__a_, __m);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool test_and_set(memory_order __m = memory_order_seq_cst) volatile throw() {
    return __cxx_atomic_exchange(&__a_, bool(true), __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool test_and_set(memory_order __m = memory_order_seq_cst) throw() {
    return __cxx_atomic_exchange(&__a_, bool(true), __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void clear(memory_order __m = memory_order_seq_cst) volatile throw() {
    __cxx_atomic_store(&__a_, bool(false), __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void clear(memory_order __m = memory_order_seq_cst) throw() {
    __cxx_atomic_store(&__a_, bool(false), __m);
  }

  __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void wait(bool __v, memory_order __m = memory_order_seq_cst) const
      volatile throw() {
    __cxx_atomic_wait(&__a_, bool(__v), __m);
  }
  __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  wait(bool __v, memory_order __m = memory_order_seq_cst) const throw() {
    __cxx_atomic_wait(&__a_, bool(__v), __m);
  }
  __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void notify_one() volatile throw() {
    __cxx_atomic_notify_one(&__a_);
  }
  __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void notify_one() throw() { __cxx_atomic_notify_one(&__a_); }
  __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void notify_all() volatile throw() {
    __cxx_atomic_notify_all(&__a_);
  }
  __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void notify_all() throw() { __cxx_atomic_notify_all(&__a_); }




  atomic_flag() throw() = default;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) atomic_flag(bool __b) throw() : __a_(__b) {}

  atomic_flag(const atomic_flag&) = delete;
  atomic_flag& operator=(const atomic_flag&) = delete;
  atomic_flag& operator=(const atomic_flag&) volatile = delete;
};

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool atomic_flag_test(const volatile atomic_flag* __o) throw() { return __o->test(); }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool atomic_flag_test(const atomic_flag* __o) throw() { return __o->test(); }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
atomic_flag_test_explicit(const volatile atomic_flag* __o, memory_order __m) throw() {
  return __o->test(__m);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool atomic_flag_test_explicit(const atomic_flag* __o, memory_order __m) throw() {
  return __o->test(__m);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool atomic_flag_test_and_set(volatile atomic_flag* __o) throw() {
  return __o->test_and_set();
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool atomic_flag_test_and_set(atomic_flag* __o) throw() { return __o->test_and_set(); }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
atomic_flag_test_and_set_explicit(volatile atomic_flag* __o, memory_order __m) throw() {
  return __o->test_and_set(__m);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool atomic_flag_test_and_set_explicit(atomic_flag* __o, memory_order __m) throw() {
  return __o->test_and_set(__m);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void atomic_flag_clear(volatile atomic_flag* __o) throw() { __o->clear(); }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void atomic_flag_clear(atomic_flag* __o) throw() { __o->clear(); }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void atomic_flag_clear_explicit(volatile atomic_flag* __o, memory_order __m) throw() {
  __o->clear(__m);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void atomic_flag_clear_explicit(atomic_flag* __o, memory_order __m) throw() {
  __o->clear(__m);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) void
atomic_flag_wait(const volatile atomic_flag* __o, bool __v) throw() {
  __o->wait(__v);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) void
atomic_flag_wait(const atomic_flag* __o, bool __v) throw() {
  __o->wait(__v);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) void
atomic_flag_wait_explicit(const volatile atomic_flag* __o, bool __v, memory_order __m) throw() {
  __o->wait(__v, __m);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) void
atomic_flag_wait_explicit(const atomic_flag* __o, bool __v, memory_order __m) throw() {
  __o->wait(__v, __m);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) void
atomic_flag_notify_one(volatile atomic_flag* __o) throw() {
  __o->notify_one();
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) void atomic_flag_notify_one(atomic_flag* __o) throw() {
  __o->notify_one();
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) void
atomic_flag_notify_all(volatile atomic_flag* __o) throw() {
  __o->notify_all();
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((availability(macos, strict, introduced = 11.0))) __attribute__((availability(ios, strict, introduced = 14.0))) __attribute__((availability(tvos, strict, introduced = 14.0))) __attribute__((availability(watchos, strict, introduced = 7.0))) void atomic_flag_notify_all(atomic_flag* __o) throw() {
  __o->notify_all();
}

}}
# 595 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic_init.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/atomic_init.h" 3
# 596 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 2 3





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/fence.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/fence.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void atomic_thread_fence(memory_order __m) throw() { __cxx_atomic_thread_fence(__m); }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void atomic_signal_fence(memory_order __m) throw() { __cxx_atomic_signal_fence(__m); }

}}
# 602 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/kill_dependency.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__atomic/kill_dependency.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp kill_dependency(_Tp __y) throw() {
  return __y;
}

}}
# 604 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 2 3
# 610 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/atomic" 3
# 1290 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/optional" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/concepts" 1 3
# 138 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/concepts" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/common_with.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/common_with.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__concepts/common_with.h" 3
}}
# 139 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/concepts" 2 3
# 164 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/concepts" 3
# 1292 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/optional" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 1 3
# 681 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/back_insert_iterator.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/back_insert_iterator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/back_insert_iterator.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

#pragma GCC diagnostic push
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/back_insert_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/back_insert_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Container>
class back_insert_iterator

    : public iterator<output_iterator_tag, void, void, void, void>

{
#pragma GCC diagnostic pop

protected:
  _Container* container;

public:
  typedef output_iterator_tag iterator_category;
  typedef void value_type;



  typedef void difference_type;

  typedef void pointer;
  typedef void reference;
  typedef _Container container_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit back_insert_iterator(_Container& __x)
      : container(std::addressof(__x)) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) back_insert_iterator&
  operator=(const typename _Container::value_type& __value) {
    container->push_back(__value);
    return *this;
  }







  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) back_insert_iterator& operator*() { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) back_insert_iterator& operator++() { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) back_insert_iterator operator++(int) { return *this; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Container* __get_container() const { return container; }
};
_Static_assert(true, "");

template <class _Container>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) back_insert_iterator<_Container>
back_inserter(_Container& __x) {
  return back_insert_iterator<_Container>(__x);
}

}}
# 682 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/common_iterator.h" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/common_iterator.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 1 3
# 244 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/forward_like.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/forward_like.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/forward_like.h" 3
}}
# 245 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__variant/monostate.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__variant/monostate.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__variant/monostate.h" 3
}}
# 249 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 2 3




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/tuple" 1 3
# 216 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/tuple" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_arg_t.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_arg_t.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/uses_allocator.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/uses_allocator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct __has_allocator_type {
private:
  template <class _Up>
  static false_type __test(...);
  template <class _Up>
  static true_type __test(typename _Up::allocator_type* = 0);

public:
  static const bool value = __decltype(__test<_Tp>(0))::value;
};

template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
struct __uses_allocator : public integral_constant<bool, is_convertible<_Alloc, typename _Tp::allocator_type>::value> {
};

template <class _Tp, class _Alloc>
struct __uses_allocator<_Tp, _Alloc, false> : public false_type {};

template <class _Tp, class _Alloc>
struct uses_allocator : public __uses_allocator<_Tp, _Alloc> {};






}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_arg_t.h" 2 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_arg_t.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct allocator_arg_t {
  explicit allocator_arg_t() = default;
};
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_arg_t.h" 3
}}
# 217 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/tuple" 2 3
# 276 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/tuple" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 280 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/tuple" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 1448 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/tuple" 3
}}
# 1460 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/tuple" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 1 3
# 251 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/as_const.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/as_const.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/as_const.h" 3
}}
# 252 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/as_lvalue.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/as_lvalue.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/as_lvalue.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/as_lvalue.h" 3
}}
# 253 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/cmp.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/cmp.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/cmp.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/cmp.h" 3
}}
# 255 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/exception_guard.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/exception_guard.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/exception_guard.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/exception_guard.h" 3
template <class _Rollback>
struct __exception_guard_exceptions {
  __exception_guard_exceptions() = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __exception_guard_exceptions(_Rollback __rollback)
      : __rollback_(std::move(__rollback)), __completed_(false) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  __exception_guard_exceptions(__exception_guard_exceptions&& __other)

      : __rollback_(std::move(__other.__rollback_)), __completed_(__other.__completed_) {
    __other.__completed_ = true;
  }

  __exception_guard_exceptions(__exception_guard_exceptions const&) = delete;
  __exception_guard_exceptions& operator=(__exception_guard_exceptions const&) = delete;
  __exception_guard_exceptions& operator=(__exception_guard_exceptions&&) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __complete() throw() { __completed_ = true; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~__exception_guard_exceptions() {
    if (!__completed_)
      __rollback_();
  }

private:
  _Rollback __rollback_;
  bool __completed_;
};

_Static_assert(true, "");

template <class _Rollback>
struct __exception_guard_noexceptions {
  __exception_guard_noexceptions() = delete;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
      __attribute__((__nodebug__)) explicit __exception_guard_noexceptions(_Rollback) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__nodebug__))
  __exception_guard_noexceptions(__exception_guard_noexceptions&& __other)

      : __completed_(__other.__completed_) {
    __other.__completed_ = true;
  }

  __exception_guard_noexceptions(__exception_guard_noexceptions const&) = delete;
  __exception_guard_noexceptions& operator=(__exception_guard_noexceptions const&) = delete;
  __exception_guard_noexceptions& operator=(__exception_guard_noexceptions&&) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__nodebug__)) void __complete() throw() {
    __completed_ = true;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__nodebug__)) ~__exception_guard_noexceptions() {
    ((void)0);
  }

private:
  bool __completed_ = false;
};

_Static_assert(true, "");





template <class _Rollback>
using __exception_guard = __exception_guard_exceptions<_Rollback>;


template <class _Rollback>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __exception_guard<_Rollback> __make_exception_guard(_Rollback __rollback) {
  return __exception_guard<_Rollback>(std::move(__rollback));
}

}}
# 257 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 2 3
# 266 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/rel_ops.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/rel_ops.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace rel_ops {

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const _Tp& __x, const _Tp& __y) {
  return !(__x == __y);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>(const _Tp& __x, const _Tp& __y) {
  return __y < __x;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<=(const _Tp& __x, const _Tp& __y) {
  return !(__y < __x);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>=(const _Tp& __x, const _Tp& __y) {
  return !(__x < __y);
}

}

}}
# 267 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/to_underlying.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/to_underlying.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/to_underlying.h" 3
}}
# 269 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 2 3
# 284 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/utility" 3
# 1461 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/tuple" 2 3
# 254 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 2 3
# 263 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 267 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 2 3

namespace std {

class __attribute__((__visibility__("default"))) __attribute__((availability(watchos, strict, introduced = 5.0))) bad_variant_access : public exception {
public:
  const char* what() const throw() override;
};

}

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 1623 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/variant" 3
}}
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/common_iterator.h" 2 3
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/common_iterator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/common_iterator.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 295 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/common_iterator.h" 3
}}
# 684 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/counted_iterator.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/counted_iterator.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/default_sentinel.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/default_sentinel.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/default_sentinel.h" 3
}}
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/counted_iterator.h" 2 3
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/counted_iterator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/counted_iterator.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 285 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/counted_iterator.h" 3
}}
# 686 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/erase_if_container.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/erase_if_container.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/erase_if_container.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Container, class _Predicate>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename _Container::size_type __libcpp_erase_if_container(_Container& __c, _Predicate& __pred) {
  typename _Container::size_type __old_size = __c.size();

  const typename _Container::iterator __last = __c.end();
  for (typename _Container::iterator __iter = __c.begin(); __iter != __last;) {
    if (__pred(*__iter))
      __iter = __c.erase(__iter);
    else
      ++__iter;
  }

  return __old_size - __c.size();
}

}}
# 691 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/front_insert_iterator.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/front_insert_iterator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/front_insert_iterator.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

#pragma GCC diagnostic push
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/front_insert_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/front_insert_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Container>
class front_insert_iterator

    : public iterator<output_iterator_tag, void, void, void, void>

{
#pragma GCC diagnostic pop

protected:
  _Container* container;

public:
  typedef output_iterator_tag iterator_category;
  typedef void value_type;



  typedef void difference_type;

  typedef void pointer;
  typedef void reference;
  typedef _Container container_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit front_insert_iterator(_Container& __x)
      : container(std::addressof(__x)) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) front_insert_iterator&
  operator=(const typename _Container::value_type& __value) {
    container->push_front(__value);
    return *this;
  }







  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) front_insert_iterator& operator*() { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) front_insert_iterator& operator++() { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) front_insert_iterator operator++(int) { return *this; }
};
_Static_assert(true, "");

template <class _Container>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) front_insert_iterator<_Container>
front_inserter(_Container& __x) {
  return front_insert_iterator<_Container>(__x);
}

}}
# 692 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/indirectly_comparable.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/indirectly_comparable.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/projected.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/projected.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 51 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/projected.h" 3
}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/indirectly_comparable.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/indirectly_comparable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/indirectly_comparable.h" 3
}}
# 694 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/insert_iterator.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/insert_iterator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/insert_iterator.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _Container>
using __insert_iterator_iter_t = typename _Container::iterator;


#pragma GCC diagnostic push
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/insert_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/insert_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Container>
class insert_iterator

    : public iterator<output_iterator_tag, void, void, void, void>

{
#pragma GCC diagnostic pop

protected:
  _Container* container;
  __insert_iterator_iter_t<_Container> iter;

public:
  typedef output_iterator_tag iterator_category;
  typedef void value_type;



  typedef void difference_type;

  typedef void pointer;
  typedef void reference;
  typedef _Container container_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  insert_iterator(_Container& __x, __insert_iterator_iter_t<_Container> __i)
      : container(std::addressof(__x)), iter(__i) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) insert_iterator&
  operator=(const typename _Container::value_type& __value) {
    iter = container->insert(iter, __value);
    ++iter;
    return *this;
  }
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/insert_iterator.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) insert_iterator& operator*() { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) insert_iterator& operator++() { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) insert_iterator& operator++(int) { return *this; }
};

template <class _Container>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) insert_iterator<_Container>
inserter(_Container& __x, __insert_iterator_iter_t<_Container> __i) {
  return insert_iterator<_Container>(__x, __i);
}

}}
# 695 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/istream_iterator.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/istream_iterator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

#pragma GCC diagnostic push
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/istream_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/istream_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>
class istream_iterator

    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>

{
#pragma GCC diagnostic pop

public:
  typedef input_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef _Distance difference_type;
  typedef const _Tp* pointer;
  typedef const _Tp& reference;
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef basic_istream<_CharT, _Traits> istream_type;

private:
  istream_type* __in_stream_;
  _Tp __value_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) istream_iterator() : __in_stream_(__nullptr), __value_() {}



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) istream_iterator(istream_type& __s) : __in_stream_(std::addressof(__s)) {
    if (!(*__in_stream_ >> __value_))
      __in_stream_ = __nullptr;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _Tp& operator*() const { return __value_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _Tp* operator->() const { return std::addressof((operator*())); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) istream_iterator& operator++() {
    if (!(*__in_stream_ >> __value_))
      __in_stream_ = __nullptr;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) istream_iterator operator++(int) {
    istream_iterator __t(*this);
    ++(*this);
    return __t;
  }

  template <class _Up, class _CharU, class _TraitsU, class _DistanceU>
  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __x,
                                               const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __y);






};

template <class _Tp, class _CharT, class _Traits, class _Distance>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __x,
                                             const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __y) {
  return __x.__in_stream_ == __y.__in_stream_;
}


template <class _Tp, class _CharT, class _Traits, class _Distance>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __x,
                                             const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __y) {
  return !(__x == __y);
}


}}
# 696 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/istreambuf_iterator.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/istreambuf_iterator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

#pragma GCC diagnostic push
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/istreambuf_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/istreambuf_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _CharT, class _Traits>
class istreambuf_iterator

    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type, _CharT*, _CharT>

{
#pragma GCC diagnostic pop

public:
  typedef input_iterator_tag iterator_category;
  typedef _CharT value_type;
  typedef typename _Traits::off_type difference_type;
  typedef _CharT* pointer;
  typedef _CharT reference;
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef typename _Traits::int_type int_type;
  typedef basic_streambuf<_CharT, _Traits> streambuf_type;
  typedef basic_istream<_CharT, _Traits> istream_type;

private:
  mutable streambuf_type* __sbuf_;

  class __proxy {
    char_type __keep_;
    streambuf_type* __sbuf_;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __proxy(char_type __c, streambuf_type* __s) : __keep_(__c), __sbuf_(__s) {}
    friend class istreambuf_iterator;

  public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type operator*() const { return __keep_; }
  };

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __test_for_eof() const {
    if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))
      __sbuf_ = __nullptr;
    return __sbuf_ == __nullptr;
  }

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) istreambuf_iterator() throw() : __sbuf_(__nullptr) {}



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) istreambuf_iterator(istream_type& __s) throw() : __sbuf_(__s.rdbuf()) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) istreambuf_iterator(streambuf_type* __s) throw() : __sbuf_(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) istreambuf_iterator(const __proxy& __p) throw() : __sbuf_(__p.__sbuf_) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type operator*() const { return static_cast<char_type>(__sbuf_->sgetc()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) istreambuf_iterator& operator++() {
    __sbuf_->sbumpc();
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __proxy operator++(int) { return __proxy(__sbuf_->sbumpc(), __sbuf_); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool equal(const istreambuf_iterator& __b) const {
    return __test_for_eof() == __b.__test_for_eof();
  }






};

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator==(const istreambuf_iterator<_CharT, _Traits>& __a, const istreambuf_iterator<_CharT, _Traits>& __b) {
  return __a.equal(__b);
}


template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator!=(const istreambuf_iterator<_CharT, _Traits>& __a, const istreambuf_iterator<_CharT, _Traits>& __b) {
  return !__a.equal(__b);
}


}}
# 697 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/mergeable.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/mergeable.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/ranges_operations.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/ranges_operations.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 105 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/ranges_operations.h" 3
}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/mergeable.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/mergeable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/mergeable.h" 3
}}
# 702 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_iterator.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_iterator.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_sentinel.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_sentinel.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_sentinel.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_sentinel.h" 3
}}
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_iterator.h" 2 3
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_iterator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_iterator.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_iterator.h" 3
template <class _Iter>
class move_iterator



{
# 88 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_iterator.h" 3
public:
# 98 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_iterator.h" 3
  typedef _Iter iterator_type;
  typedef _If< __has_random_access_iterator_category<_Iter>::value,
               random_access_iterator_tag,
               typename iterator_traits<_Iter>::iterator_category >
      iterator_category;
  typedef typename iterator_traits<iterator_type>::value_type value_type;
  typedef typename iterator_traits<iterator_type>::difference_type difference_type;
  typedef iterator_type pointer;

  typedef typename iterator_traits<iterator_type>::reference __reference;
  typedef typename conditional< is_reference<__reference>::value,
                                __libcpp_remove_reference_t<__reference>&&,
                                __reference >::type reference;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit move_iterator(_Iter __i) : __current_(std::move(__i)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) move_iterator& operator++() {
    ++__current_;
    return *this;
  }

                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer operator->() const {
    return __current_;
  }
# 158 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_iterator.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) move_iterator() : __current_() {}

  template <class _Up,
            class = __enable_if_t< !is_same<_Up, _Iter>::value && is_convertible<const _Up&, _Iter>::value > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) move_iterator(const move_iterator<_Up>& __u)
      : __current_(__u.base()) {}

  template <class _Up,
            class = __enable_if_t< !is_same<_Up, _Iter>::value && is_convertible<const _Up&, _Iter>::value &&
                                   is_assignable<_Iter&, const _Up&>::value > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) move_iterator& operator=(const move_iterator<_Up>& __u) {
    __current_ = __u.base();
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Iter base() const { return __current_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator*() const {
    return static_cast<reference>(*__current_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator[](difference_type __n) const {
    return static_cast<reference>(__current_[__n]);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) move_iterator operator++(int) {
    move_iterator __tmp(*this);
    ++__current_;
    return __tmp;
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) move_iterator& operator--() {
    --__current_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) move_iterator operator--(int) {
    move_iterator __tmp(*this);
    --__current_;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) move_iterator operator+(difference_type __n) const {
    return move_iterator(__current_ + __n);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) move_iterator& operator+=(difference_type __n) {
    __current_ += __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) move_iterator operator-(difference_type __n) const {
    return move_iterator(__current_ - __n);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) move_iterator& operator-=(difference_type __n) {
    __current_ -= __n;
    return *this;
  }
# 246 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_iterator.h" 3
private:
  template <class _It2>
  friend class move_iterator;

  _Iter __current_;
};
_Static_assert(true, "");

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y) {
  return __x.base() == __y.base();
}


template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y) {
  return __x.base() != __y.base();
}


template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y) {
  return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y) {
  return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y) {
  return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y) {
  return __x.base() >= __y.base();
}
# 308 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_iterator.h" 3
template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename move_iterator<_Iter1>::difference_type
operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y) {
  return __x.base() - __y.base();
}
# 326 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/move_iterator.h" 3
template <class _Iter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) move_iterator<_Iter>
operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x) {
  return move_iterator<_Iter>(__x.base() + __n);
}


template <class _Iter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) move_iterator<_Iter> make_move_iterator(_Iter __i) {
  return move_iterator<_Iter>(std::move(__i));
}

}}
# 703 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ostream_iterator.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ostream_iterator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

#pragma GCC diagnostic push
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ostream_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ostream_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >
class ostream_iterator

    : public iterator<output_iterator_tag, void, void, void, void>

{
#pragma GCC diagnostic pop

public:
  typedef output_iterator_tag iterator_category;
  typedef void value_type;



  typedef void difference_type;

  typedef void pointer;
  typedef void reference;
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef basic_ostream<_CharT, _Traits> ostream_type;

private:
  ostream_type* __out_stream_;
  const char_type* __delim_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ostream_iterator(ostream_type& __s) throw()
      : __out_stream_(std::addressof(__s)),
        __delim_(__nullptr) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ostream_iterator(ostream_type& __s, const _CharT* __delimiter) throw()
      : __out_stream_(std::addressof(__s)),
        __delim_(__delimiter) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ostream_iterator& operator=(const _Tp& __value) {
    *__out_stream_ << __value;
    if (__delim_)
      *__out_stream_ << __delim_;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ostream_iterator& operator*() { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ostream_iterator& operator++() { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ostream_iterator& operator++(int) { return *this; }
};

}}
# 706 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ostreambuf_iterator.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ostreambuf_iterator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

#pragma GCC diagnostic push
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ostreambuf_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ostreambuf_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _CharT, class _Traits>
class ostreambuf_iterator

    : public iterator<output_iterator_tag, void, void, void, void>

{
#pragma GCC diagnostic pop

public:
  typedef output_iterator_tag iterator_category;
  typedef void value_type;



  typedef void difference_type;

  typedef void pointer;
  typedef void reference;
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef basic_streambuf<_CharT, _Traits> streambuf_type;
  typedef basic_ostream<_CharT, _Traits> ostream_type;

private:
  streambuf_type* __sbuf_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ostreambuf_iterator(ostream_type& __s) throw() : __sbuf_(__s.rdbuf()) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ostreambuf_iterator(streambuf_type* __s) throw() : __sbuf_(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ostreambuf_iterator& operator=(_CharT __c) {
    if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))
      __sbuf_ = __nullptr;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ostreambuf_iterator& operator*() { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ostreambuf_iterator& operator++() { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ostreambuf_iterator& operator++(int) { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool failed() const throw() { return __sbuf_ == __nullptr; }

  template <class _Ch, class _Tr>
  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ostreambuf_iterator<_Ch, _Tr> __pad_and_output(
      ostreambuf_iterator<_Ch, _Tr> __s, const _Ch* __ob, const _Ch* __op, const _Ch* __oe, ios_base& __iob, _Ch __fl);
};

}}
# 707 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/permutable.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/permutable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/permutable.h" 3
}}
# 708 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/sortable.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/sortable.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/sortable.h" 3
}}
# 715 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/unreachable_sentinel.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/unreachable_sentinel.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/unreachable_sentinel.h" 3
}}
# 716 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/wrap_iter.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/wrap_iter.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Iter>
class __wrap_iter {
public:
  typedef _Iter iterator_type;
  typedef typename iterator_traits<iterator_type>::value_type value_type;
  typedef typename iterator_traits<iterator_type>::difference_type difference_type;
  typedef typename iterator_traits<iterator_type>::pointer pointer;
  typedef typename iterator_traits<iterator_type>::reference reference;
  typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;




private:
  iterator_type __i_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __wrap_iter() throw() : __i_() {}
  template <class _Up, __enable_if_t<is_convertible<_Up, iterator_type>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __wrap_iter(const __wrap_iter<_Up>& __u) throw()
      : __i_(__u.base()) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator*() const throw() { return *__i_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer operator->() const throw() {
    return std::__to_address(__i_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __wrap_iter& operator++() throw() {
    ++__i_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __wrap_iter operator++(int) throw() {
    __wrap_iter __tmp(*this);
    ++(*this);
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __wrap_iter& operator--() throw() {
    --__i_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __wrap_iter operator--(int) throw() {
    __wrap_iter __tmp(*this);
    --(*this);
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __wrap_iter operator+(difference_type __n) const throw() {
    __wrap_iter __w(*this);
    __w += __n;
    return __w;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __wrap_iter& operator+=(difference_type __n) throw() {
    __i_ += __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __wrap_iter operator-(difference_type __n) const throw() {
    return *this + (-__n);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __wrap_iter& operator-=(difference_type __n) throw() {
    *this += -__n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator[](difference_type __n) const throw() {
    return __i_[__n];
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator_type base() const throw() { return __i_; }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __wrap_iter(iterator_type __x) throw() : __i_(__x) {}

  template <class _Up>
  friend class __wrap_iter;
  template <class _CharT, class _Traits, class _Alloc>
  friend class basic_string;
  template <class _Tp, class _Alloc>
  friend class vector;
  template <class _Tp, size_t>
  friend class span;
};

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw() {
  return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw() {
  return __x.base() == __y.base();
}

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw() {
  return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw() {
  return __x.base() < __y.base();
}

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw() {
  return !(__x == __y);
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw() {
  return !(__x == __y);
}

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw() {
  return __y < __x;
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw() {
  return __y < __x;
}

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw() {
  return !(__x < __y);
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw() {
  return !(__x < __y);
}

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) throw() {
  return !(__y < __x);
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw() {
  return !(__y < __x);
}

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))





    typename __wrap_iter<_Iter1>::difference_type
    operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) throw()

{
  return __x.base() - __y.base();
}

template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __wrap_iter<_Iter1>
operator+(typename __wrap_iter<_Iter1>::difference_type __n, __wrap_iter<_Iter1> __x) throw() {
  __x += __n;
  return __x;
}


template <class _It>
struct __libcpp_is_contiguous_iterator<__wrap_iter<_It> > : true_type {};


template <class _It>
struct pointer_traits<__wrap_iter<_It> > {
  typedef __wrap_iter<_It> pointer;
  typedef typename pointer_traits<_It>::element_type element_type;
  typedef typename pointer_traits<_It>::difference_type difference_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static element_type* to_address(pointer __w) throw() {
    return std::__to_address(__w.base());
  }
};

}}
# 717 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 2 3
# 729 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iterator" 3
# 1294 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/optional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 924 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/align.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/align.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

__attribute__((__visibility__("default"))) void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);

}}
# 925 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocate_at_least.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocate_at_least.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
template <class _Tp, class = void> struct __has_pointer : false_type {}; template <class _Tp> struct __has_pointer<_Tp, __void_t<typename _Tp::pointer > > : true_type {};
template <class _Tp,
          class _Alloc,
          class _RawAlloc = __libcpp_remove_reference_t<_Alloc>,
          bool = __has_pointer<_RawAlloc>::value>
struct __pointer {
  using type __attribute__((__nodebug__)) = typename _RawAlloc::pointer;
};
template <class _Tp, class _Alloc, class _RawAlloc>
struct __pointer<_Tp, _Alloc, _RawAlloc, false> {
  using type __attribute__((__nodebug__)) = _Tp*;
};


template <class _Tp, class = void> struct __has_const_pointer : false_type {}; template <class _Tp> struct __has_const_pointer<_Tp, __void_t<typename _Tp::const_pointer > > : true_type {};
template <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>
struct __const_pointer {
  using type __attribute__((__nodebug__)) = typename _Alloc::const_pointer;
};
template <class _Tp, class _Ptr, class _Alloc>
struct __const_pointer<_Tp, _Ptr, _Alloc, false> {

  using type = typename pointer_traits<_Ptr>::template rebind<const _Tp>::other;



};


template <class _Tp, class = void> struct __has_void_pointer : false_type {}; template <class _Tp> struct __has_void_pointer<_Tp, __void_t<typename _Tp::void_pointer > > : true_type {};
template <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>
struct __void_pointer {
  using type __attribute__((__nodebug__)) = typename _Alloc::void_pointer;
};
template <class _Ptr, class _Alloc>
struct __void_pointer<_Ptr, _Alloc, false> {

  using type __attribute__((__nodebug__)) = typename pointer_traits<_Ptr>::template rebind<void>::other;



};


template <class _Tp, class = void> struct __has_const_void_pointer : false_type {}; template <class _Tp> struct __has_const_void_pointer<_Tp, __void_t<typename _Tp::const_void_pointer > > : true_type {};
template <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>
struct __const_void_pointer {
  using type __attribute__((__nodebug__)) = typename _Alloc::const_void_pointer;
};
template <class _Ptr, class _Alloc>
struct __const_void_pointer<_Ptr, _Alloc, false> {

  using type __attribute__((__nodebug__)) = typename pointer_traits<_Ptr>::template rebind<const void>::other;



};


template <class _Tp, class = void> struct __has_size_type : false_type {}; template <class _Tp> struct __has_size_type<_Tp, __void_t<typename _Tp::size_type > > : true_type {};
template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>
struct __size_type : make_unsigned<_DiffType> {};
template <class _Alloc, class _DiffType>
struct __size_type<_Alloc, _DiffType, true> {
  using type __attribute__((__nodebug__)) = typename _Alloc::size_type;
};


template <class _Tp, class = void> struct __has_alloc_traits_difference_type : false_type {}; template <class _Tp> struct __has_alloc_traits_difference_type<_Tp, __void_t<typename _Tp::difference_type > > : true_type {};
template <class _Alloc, class _Ptr, bool = __has_alloc_traits_difference_type<_Alloc>::value>
struct __alloc_traits_difference_type {
  using type __attribute__((__nodebug__)) = typename pointer_traits<_Ptr>::difference_type;
};
template <class _Alloc, class _Ptr>
struct __alloc_traits_difference_type<_Alloc, _Ptr, true> {
  using type __attribute__((__nodebug__)) = typename _Alloc::difference_type;
};


template <class _Tp, class = void> struct __has_propagate_on_container_copy_assignment : false_type {}; template <class _Tp> struct __has_propagate_on_container_copy_assignment<_Tp, __void_t<typename _Tp::propagate_on_container_copy_assignment > > : true_type {};
template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>
struct __propagate_on_container_copy_assignment : false_type {};
template <class _Alloc>
struct __propagate_on_container_copy_assignment<_Alloc, true> {
  using type __attribute__((__nodebug__)) = typename _Alloc::propagate_on_container_copy_assignment;
};


template <class _Tp, class = void> struct __has_propagate_on_container_move_assignment : false_type {}; template <class _Tp> struct __has_propagate_on_container_move_assignment<_Tp, __void_t<typename _Tp::propagate_on_container_move_assignment > > : true_type {};
template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>
struct __propagate_on_container_move_assignment : false_type {};
template <class _Alloc>
struct __propagate_on_container_move_assignment<_Alloc, true> {
  using type __attribute__((__nodebug__)) = typename _Alloc::propagate_on_container_move_assignment;
};


template <class _Tp, class = void> struct __has_propagate_on_container_swap : false_type {}; template <class _Tp> struct __has_propagate_on_container_swap<_Tp, __void_t<typename _Tp::propagate_on_container_swap > > : true_type {};
template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>
struct __propagate_on_container_swap : false_type {};
template <class _Alloc>
struct __propagate_on_container_swap<_Alloc, true> {
  using type __attribute__((__nodebug__)) = typename _Alloc::propagate_on_container_swap;
};


template <class _Tp, class = void> struct __has_is_always_equal : false_type {}; template <class _Tp> struct __has_is_always_equal<_Tp, __void_t<typename _Tp::is_always_equal > > : true_type {};
template <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>
struct __is_always_equal : is_empty<_Alloc> {};
template <class _Alloc>
struct __is_always_equal<_Alloc, true> {
  using type __attribute__((__nodebug__)) = typename _Alloc::is_always_equal;
};


#pragma GCC diagnostic push
# 158 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 158 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp, class _Up, class = void>
struct __has_rebind_other : false_type {};
template <class _Tp, class _Up>
struct __has_rebind_other<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>::other> > : true_type {};

template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>
struct __allocator_traits_rebind {
  _Static_assert(__has_rebind_other<_Tp, _Up>::value, "This allocator has to implement rebind");
  using type __attribute__((__nodebug__)) = typename _Tp::template rebind<_Up>::other;
};
template <template <class, class...> class _Alloc, class _Tp, class... _Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true> {
  using type __attribute__((__nodebug__)) = typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other;
};
template <template <class, class...> class _Alloc, class _Tp, class... _Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false> {
  using type __attribute__((__nodebug__)) = _Alloc<_Up, _Args...>;
};
#pragma GCC diagnostic pop

template <class _Alloc, class _Tp>
using __allocator_traits_rebind_t = typename __allocator_traits_rebind<_Alloc, _Tp>::type;

#pragma GCC diagnostic push
# 182 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 182 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"


template <class _Alloc, class _SizeType, class _ConstVoidPtr, class = void>
struct __has_allocate_hint : false_type {};

template <class _Alloc, class _SizeType, class _ConstVoidPtr>
struct __has_allocate_hint<
    _Alloc,
    _SizeType,
    _ConstVoidPtr,
    __decltype((void)std::declval<_Alloc>().allocate(std::declval<_SizeType>(), std::declval<_ConstVoidPtr>()))>
    : true_type {};


template <class, class _Alloc, class... _Args>
struct __has_construct_impl : false_type {};

template <class _Alloc, class... _Args>
struct __has_construct_impl<__decltype((void)std::declval<_Alloc>().construct(std::declval<_Args>()...)),
                            _Alloc,
                            _Args...> : true_type {};

template <class _Alloc, class... _Args>
struct __has_construct : __has_construct_impl<void, _Alloc, _Args...> {};


template <class _Alloc, class _Pointer, class = void>
struct __has_destroy : false_type {};

template <class _Alloc, class _Pointer>
struct __has_destroy<_Alloc, _Pointer, __decltype((void)std::declval<_Alloc>().destroy(std::declval<_Pointer>()))>
    : true_type {};


template <class _Alloc, class = void>
struct __has_max_size : false_type {};

template <class _Alloc>
struct __has_max_size<_Alloc, __decltype((void)std::declval<_Alloc&>().max_size())> : true_type {};


template <class _Alloc, class = void>
struct __has_select_on_container_copy_construction : false_type {};

template <class _Alloc>
struct __has_select_on_container_copy_construction<
    _Alloc,
    __decltype((void)std::declval<_Alloc>().select_on_container_copy_construction())> : true_type {};

#pragma GCC diagnostic pop

template <class _Alloc>
struct allocator_traits {
  using allocator_type = _Alloc;
  using value_type = typename allocator_type::value_type;
  using pointer = typename __pointer<value_type, allocator_type>::type;
  using const_pointer = typename __const_pointer<value_type, pointer, allocator_type>::type;
  using void_pointer = typename __void_pointer<pointer, allocator_type>::type;
  using const_void_pointer = typename __const_void_pointer<pointer, allocator_type>::type;
  using difference_type = typename __alloc_traits_difference_type<allocator_type, pointer>::type;
  using size_type = typename __size_type<allocator_type, difference_type>::type;
  using propagate_on_container_copy_assignment =
      typename __propagate_on_container_copy_assignment<allocator_type>::type;
  using propagate_on_container_move_assignment =
      typename __propagate_on_container_move_assignment<allocator_type>::type;
  using propagate_on_container_swap = typename __propagate_on_container_swap<allocator_type>::type;
  using is_always_equal = typename __is_always_equal<allocator_type>::type;







  template <class _Tp>
  struct rebind_alloc {
    using other = __allocator_traits_rebind_t<allocator_type, _Tp>;
  };
  template <class _Tp>
  struct rebind_traits {
    using other = allocator_traits<typename rebind_alloc<_Tp>::other>;
  };


                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static pointer
  allocate(allocator_type& __a, size_type __n) {
    return __a.allocate(__n);
  }

  template <class _Ap = _Alloc, class = __enable_if_t<__has_allocate_hint<_Ap, size_type, const_void_pointer>::value> >
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static pointer
  allocate(allocator_type& __a, size_type __n, const_void_pointer __hint) {
#pragma GCC diagnostic push
# 275 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 275 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    return __a.allocate(__n, __hint);
#pragma GCC diagnostic pop
  }
  template <class _Ap = _Alloc,
            class = void,
            class = __enable_if_t<!__has_allocate_hint<_Ap, size_type, const_void_pointer>::value> >
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static pointer
  allocate(allocator_type& __a, size_type __n, const_void_pointer) {
    return __a.allocate(__n);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static void
  deallocate(allocator_type& __a, pointer __p, size_type __n) throw() {
    __a.deallocate(__p, __n);
  }

  template <class _Tp, class... _Args, class = __enable_if_t<__has_construct<allocator_type, _Tp*, _Args...>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static void
  construct(allocator_type& __a, _Tp* __p, _Args&&... __args) {
#pragma GCC diagnostic push
# 295 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 295 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    __a.construct(__p, std::forward<_Args>(__args)...);
#pragma GCC diagnostic pop
  }
  template <class _Tp,
            class... _Args,
            class = void,
            class = __enable_if_t<!__has_construct<allocator_type, _Tp*, _Args...>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static void
  construct(allocator_type&, _Tp* __p, _Args&&... __args) {
    std::__construct_at(__p, std::forward<_Args>(__args)...);
  }

  template <class _Tp, class = __enable_if_t<__has_destroy<allocator_type, _Tp*>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static void destroy(allocator_type& __a, _Tp* __p) {
#pragma GCC diagnostic push
# 310 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 310 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    __a.destroy(__p);
#pragma GCC diagnostic pop
  }
  template <class _Tp, class = void, class = __enable_if_t<!__has_destroy<allocator_type, _Tp*>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static void destroy(allocator_type&, _Tp* __p) {
    std::__destroy_at(__p);
  }

  template <class _Ap = _Alloc, class = __enable_if_t<__has_max_size<const _Ap>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static size_type max_size(const allocator_type& __a) throw() {
#pragma GCC diagnostic push
# 321 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 321 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    return __a.max_size();
#pragma GCC diagnostic pop
  }
  template <class _Ap = _Alloc, class = void, class = __enable_if_t<!__has_max_size<const _Ap>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static size_type max_size(const allocator_type&) throw() {
    return numeric_limits<size_type>::max() / sizeof(value_type);
  }

  template <class _Ap = _Alloc, class = __enable_if_t<__has_select_on_container_copy_construction<const _Ap>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static allocator_type
  select_on_container_copy_construction(const allocator_type& __a) {
    return __a.select_on_container_copy_construction();
  }
  template <class _Ap = _Alloc,
            class = void,
            class = __enable_if_t<!__has_select_on_container_copy_construction<const _Ap>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static allocator_type
  select_on_container_copy_construction(const allocator_type& __a) {
    return __a;
  }
};





template <class _Traits, class _Tp>
using __rebind_alloc = typename _Traits::template rebind_alloc<_Tp>::other;



template <class _Tp>
struct __is_default_allocator : false_type {};

template <class>
class allocator;

template <class _Tp>
struct __is_default_allocator<allocator<_Tp> > : true_type {};


template <class _Alloc, class = void>
struct __is_cpp17_move_insertable : is_move_constructible<typename _Alloc::value_type> {};

template <class _Alloc>
struct __is_cpp17_move_insertable<
    _Alloc,
    __enable_if_t< !__is_default_allocator<_Alloc>::value &&
                   __has_construct<_Alloc, typename _Alloc::value_type*, typename _Alloc::value_type&&>::value > >
    : true_type {};


template <class _Alloc, class = void>
struct __is_cpp17_copy_insertable
    : integral_constant<bool,
                        is_copy_constructible<typename _Alloc::value_type>::value &&
                            __is_cpp17_move_insertable<_Alloc>::value > {};

template <class _Alloc>
struct __is_cpp17_copy_insertable<
    _Alloc,
    __enable_if_t< !__is_default_allocator<_Alloc>::value &&
                   __has_construct<_Alloc, typename _Alloc::value_type*, const typename _Alloc::value_type&>::value > >
    : __is_cpp17_move_insertable<_Alloc> {};
# 401 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_traits.h" 3
}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocate_at_least.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocate_at_least.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocate_at_least.h" 3
template <class _Pointer>
struct __allocation_result {
  _Pointer ptr;
  size_t count;
};

template <class _Alloc>
                  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
    __allocation_result<typename allocator_traits<_Alloc>::pointer>
    __allocate_at_least(_Alloc& __alloc, size_t __n) {
  return {__alloc.allocate(__n), __n};
}



}}
# 926 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocation_guard.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocation_guard.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocation_guard.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 47 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocation_guard.h" 3
template <class _Alloc>
struct __allocation_guard {
  using _Pointer = typename allocator_traits<_Alloc>::pointer;
  using _Size = typename allocator_traits<_Alloc>::size_type;

  template <class _AllocT>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __allocation_guard(_AllocT __alloc, _Size __n)
      : __alloc_(std::move(__alloc)),
        __n_(__n),
        __ptr_(allocator_traits<_Alloc>::allocate(__alloc_, __n_))
  {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~__allocation_guard() throw() { __destroy(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __allocation_guard(const __allocation_guard&) = delete;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __allocation_guard(__allocation_guard&& __other) throw()
      : __alloc_(std::move(__other.__alloc_)),
        __n_(__other.__n_),
        __ptr_(__other.__ptr_) {
    __other.__ptr_ = __nullptr;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __allocation_guard& operator=(const __allocation_guard& __other) = delete;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __allocation_guard& operator=(__allocation_guard&& __other) throw() {
    if (std::addressof(__other) != this) {
      __destroy();

      __alloc_ = std::move(__other.__alloc_);
      __n_ = __other.__n_;
      __ptr_ = __other.__ptr_;
      __other.__ptr_ = __nullptr;
    }

    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Pointer
  __release_ptr() throw() {
    _Pointer __tmp = __ptr_;
    __ptr_ = __nullptr;
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Pointer __get() const throw() { return __ptr_; }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __destroy() throw() {
    if (__ptr_ != __nullptr) {
      allocator_traits<_Alloc>::deallocate(__alloc_, __ptr_, __n_);
    }
  }

  _Alloc __alloc_;
  _Size __n_;
  _Pointer __ptr_;
};

}}
# 927 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator.h" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
class allocator;
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator.h" 3
template <>
class allocator<void> {


public:
                              typedef void* pointer;
                              typedef const void* const_pointer;
                              typedef void value_type;

  template <class _Up>
  struct rebind {
    typedef allocator<_Up> other;
  };

};

template <>
class allocator<const void> {


public:
                              typedef const void* pointer;
                              typedef const void* const_pointer;
                              typedef const void value_type;

  template <class _Up>
  struct rebind {
    typedef allocator<_Up> other;
  };

};
# 88 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator.h" 3
template <bool _Cond, class _Unique>
struct __non_trivial_if {};

template <class _Unique>
struct __non_trivial_if<true, _Unique> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __non_trivial_if() throw() {}
};






template <class _Tp>
class allocator : private __non_trivial_if<!is_void<_Tp>::value, allocator<_Tp> > {
  _Static_assert(!is_volatile<_Tp>::value, "std::allocator does not support volatile types");

public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef _Tp value_type;
  typedef true_type propagate_on_container_move_assignment;

                              typedef true_type is_always_equal;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) allocator() throw() = default;

  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) allocator(const allocator<_Up>&) throw() {}

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* allocate(size_t __n) {
    if (__n > allocator_traits<allocator>::max_size(*this))
      __throw_bad_array_new_length();
    if (__libcpp_is_constant_evaluated()) {
      return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
    } else {
      return static_cast<_Tp*>(std::__libcpp_allocate(__n * sizeof(_Tp), _Alignof(_Tp)));
    }
  }







  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void deallocate(_Tp* __p, size_t __n) throw() {
    if (__libcpp_is_constant_evaluated()) {
      ::operator delete(__p);
    } else {
      std::__libcpp_deallocate((void*)__p, __n * sizeof(_Tp), _Alignof(_Tp));
    }
  }



                              typedef _Tp* pointer;
                              typedef const _Tp* const_pointer;
                              typedef _Tp& reference;
                              typedef const _Tp& const_reference;

  template <class _Up>
  struct rebind {
    typedef allocator<_Up> other;
  };

                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer address(reference __x) const throw() {
    return std::addressof(__x);
  }
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_pointer address(const_reference __x) const throw() {
    return std::addressof(__x);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp*
  allocate(size_t __n, const void*) {
    return allocate(__n);
  }

                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type max_size() const throw() {
    return size_type(~0) / sizeof(_Tp);
  }

  template <class _Up, class... _Args>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void construct(_Up* __p, _Args&&... __args) {
    ::new ((void*)__p) _Up(std::forward<_Args>(__args)...);
  }

                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void destroy(pointer __p) { __p->~_Tp(); }

};

template <class _Tp>
class allocator<const _Tp>
    : private __non_trivial_if<!is_void<_Tp>::value, allocator<const _Tp> > {
  _Static_assert(!is_volatile<_Tp>::value, "std::allocator does not support volatile types");

public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef const _Tp value_type;
  typedef true_type propagate_on_container_move_assignment;

                              typedef true_type is_always_equal;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) allocator() throw() = default;

  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) allocator(const allocator<_Up>&) throw() {}

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _Tp* allocate(size_t __n) {
    if (__n > allocator_traits<allocator>::max_size(*this))
      __throw_bad_array_new_length();
    if (__libcpp_is_constant_evaluated()) {
      return static_cast<const _Tp*>(::operator new(__n * sizeof(_Tp)));
    } else {
      return static_cast<const _Tp*>(std::__libcpp_allocate(__n * sizeof(_Tp), _Alignof(_Tp)));
    }
  }







  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void deallocate(const _Tp* __p, size_t __n) {
    if (__libcpp_is_constant_evaluated()) {
      ::operator delete(const_cast<_Tp*>(__p));
    } else {
      std::__libcpp_deallocate((void*)const_cast<_Tp*>(__p), __n * sizeof(_Tp), _Alignof(_Tp));
    }
  }



                              typedef const _Tp* pointer;
                              typedef const _Tp* const_pointer;
                              typedef const _Tp& reference;
                              typedef const _Tp& const_reference;

  template <class _Up>
  struct rebind {
    typedef allocator<_Up> other;
  };

                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_pointer address(const_reference __x) const throw() {
    return std::addressof(__x);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _Tp*
  allocate(size_t __n, const void*) {
    return allocate(__n);
  }

                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type max_size() const throw() {
    return size_type(~0) / sizeof(_Tp);
  }

  template <class _Up, class... _Args>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void construct(_Up* __p, _Args&&... __args) {
    ::new ((void*)__p) _Up(std::forward<_Args>(__args)...);
  }

                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void destroy(pointer __p) { __p->~_Tp(); }

};

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator==(const allocator<_Tp>&, const allocator<_Up>&) throw() {
  return true;
}



template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const allocator<_Tp>&, const allocator<_Up>&) throw() {
  return false;
}



}}
# 928 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/assume_aligned.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/assume_aligned.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <size_t _Np, class _Tp>
                  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* __assume_aligned(_Tp* __ptr) {
  _Static_assert(_Np != 0 && (_Np & (_Np - 1)) == 0, "std::assume_aligned<N>(p) requires N to be a power of two");

  if (__libcpp_is_constant_evaluated()) {
    (void)__builtin_assume_aligned(__ptr, _Np);
    return __ptr;
  } else {
    ((void)0);

    return static_cast<_Tp*>(__builtin_assume_aligned(__ptr, _Np));
  }
}
# 48 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/assume_aligned.h" 3
}}
# 931 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/auto_ptr.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/auto_ptr.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct auto_ptr_ref {
  _Tp* __ptr_;
};

template <class _Tp>
class auto_ptr {
private:
  _Tp* __ptr_;

public:
  typedef _Tp element_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}
  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) auto_ptr(auto_ptr<_Up>& __p) throw() : __ptr_(__p.release()) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) auto_ptr& operator=(auto_ptr& __p) throw() {
    reset(__p.release());
    return *this;
  }
  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) auto_ptr& operator=(auto_ptr<_Up>& __p) throw() {
    reset(__p.release());
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw() {
    reset(__p.__ptr_);
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~auto_ptr() throw() { delete __ptr_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp& operator*() const throw() { return *__ptr_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* operator->() const throw() { return __ptr_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* get() const throw() { return __ptr_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* release() throw() {
    _Tp* __t = __ptr_;
    __ptr_ = __nullptr;
    return __t;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void reset(_Tp* __p = 0) throw() {
    if (__ptr_ != __p)
      delete __ptr_;
    __ptr_ = __p;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}
  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) operator auto_ptr_ref<_Up>() throw() {
    auto_ptr_ref<_Up> __t;
    __t.__ptr_ = release();
    return __t;
  }
  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) operator auto_ptr<_Up>() throw() {
    return auto_ptr<_Up>(release());
  }
};

template <>
class auto_ptr<void> {
public:
  typedef void element_type;
};

}}
# 932 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/compressed_pair.h" 1 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/compressed_pair.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/compressed_pair.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


struct __default_init_tag {};
struct __value_init_tag {};

template <class _Tp, int _Idx, bool _CanBeEmptyBase = is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value>
struct __compressed_pair_elem {
  using _ParamT = _Tp;
  using reference = _Tp&;
  using const_reference = const _Tp&;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __compressed_pair_elem(__default_init_tag) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __compressed_pair_elem(__value_init_tag) : __value_() {}

  template <class _Up, class = __enable_if_t<!is_same<__compressed_pair_elem, __decay_t<_Up> >::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __compressed_pair_elem(_Up&& __u)
      : __value_(std::forward<_Up>(__u)) {}
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/compressed_pair.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference __get() throw() { return __value_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference __get() const throw() { return __value_; }

private:
  _Tp __value_;
};

template <class _Tp, int _Idx>
struct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp {
  using _ParamT = _Tp;
  using reference = _Tp&;
  using const_reference = const _Tp&;
  using __value_type = _Tp;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __compressed_pair_elem() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __compressed_pair_elem(__default_init_tag) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __compressed_pair_elem(__value_init_tag) : __value_type() {}

  template <class _Up, class = __enable_if_t<!is_same<__compressed_pair_elem, __decay_t<_Up> >::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __compressed_pair_elem(_Up&& __u)
      : __value_type(std::forward<_Up>(__u)) {}
# 92 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/compressed_pair.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference __get() throw() { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference __get() const throw() { return *this; }
};

template <class _T1, class _T2>
class __compressed_pair : private __compressed_pair_elem<_T1, 0>, private __compressed_pair_elem<_T2, 1> {
public:




  _Static_assert((!is_same<_T1, _T2>::value), "__compressed_pair cannot be instantiated when T1 and T2 are the same type; " "The current implementation is NOT ABI-compatible with the previous implementation for this configuration");




  using _Base1 __attribute__((__nodebug__)) = __compressed_pair_elem<_T1, 0>;
  using _Base2 __attribute__((__nodebug__)) = __compressed_pair_elem<_T2, 1>;

  template <bool _Dummy = true,
            class = __enable_if_t< __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&
                                   __dependent_type<is_default_constructible<_T2>, _Dummy>::value > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __compressed_pair()
      : _Base1(__value_init_tag()), _Base2(__value_init_tag()) {}

  template <class _U1, class _U2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __compressed_pair(_U1&& __t1, _U2&& __t2)
      : _Base1(std::forward<_U1>(__t1)), _Base2(std::forward<_U2>(__t2)) {}
# 129 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/compressed_pair.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename _Base1::reference first() throw() {
    return static_cast<_Base1&>(*this).__get();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename _Base1::const_reference first() const throw() {
    return static_cast<_Base1 const&>(*this).__get();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename _Base2::reference second() throw() {
    return static_cast<_Base2&>(*this).__get();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename _Base2::const_reference second() const throw() {
    return static_cast<_Base2 const&>(*this).__get();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static _Base1* __get_first_base(__compressed_pair* __pair) throw() {
    return static_cast<_Base1*>(__pair);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static _Base2* __get_second_base(__compressed_pair* __pair) throw() {
    return static_cast<_Base2*>(__pair);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(__compressed_pair& __x)
                                                                                          {
    using std::swap;
    swap(first(), __x.first());
    swap(second(), __x.second());
  }
};

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)
                                                                                        {
  __x.swap(__y);
}

}}
# 933 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/concepts.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/concepts.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/concepts.h" 3
}}
# 934 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/ranges_construct_at.h" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/ranges_construct_at.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/ranges_construct_at.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 120 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/ranges_construct_at.h" 3
}}
# 937 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/ranges_uninitialized_algorithms.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/ranges_uninitialized_algorithms.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_out_result.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_out_result.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_out_result.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_out_result.h" 3
}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/ranges_uninitialized_algorithms.h" 2 3








# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/uninitialized_algorithms.h" 1 3
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/uninitialized_algorithms.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 47 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/uninitialized_algorithms.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct __always_false {
  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(_Args&&...) const throw() {
    return false;
  }
};



template <class _ValueType, class _InputIterator, class _Sentinel1, class _ForwardIterator, class _EndPredicate>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InputIterator, _ForwardIterator> __uninitialized_copy(
    _InputIterator __ifirst, _Sentinel1 __ilast, _ForwardIterator __ofirst, _EndPredicate __stop_copying) {
  _ForwardIterator __idx = __ofirst;

  try {

    for (; __ifirst != __ilast && !__stop_copying(__idx); ++__ifirst, (void)++__idx)
      ::new (std::__voidify(*__idx)) _ValueType(*__ifirst);

  } catch (...) {
    std::__destroy(__ofirst, __idx);
    throw;
  }


  return pair<_InputIterator, _ForwardIterator>(std::move(__ifirst), std::move(__idx));
}

template <class _InputIterator, class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
uninitialized_copy(_InputIterator __ifirst, _InputIterator __ilast, _ForwardIterator __ofirst) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  auto __result = std::__uninitialized_copy<_ValueType>(
      std::move(__ifirst), std::move(__ilast), std::move(__ofirst), __always_false());
  return std::move(__result.second);
}



template <class _ValueType, class _InputIterator, class _Size, class _ForwardIterator, class _EndPredicate>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InputIterator, _ForwardIterator>
__uninitialized_copy_n(_InputIterator __ifirst, _Size __n, _ForwardIterator __ofirst, _EndPredicate __stop_copying) {
  _ForwardIterator __idx = __ofirst;

  try {

    for (; __n > 0 && !__stop_copying(__idx); ++__ifirst, (void)++__idx, (void)--__n)
      ::new (std::__voidify(*__idx)) _ValueType(*__ifirst);

  } catch (...) {
    std::__destroy(__ofirst, __idx);
    throw;
  }


  return pair<_InputIterator, _ForwardIterator>(std::move(__ifirst), std::move(__idx));
}

template <class _InputIterator, class _Size, class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
uninitialized_copy_n(_InputIterator __ifirst, _Size __n, _ForwardIterator __ofirst) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  auto __result =
      std::__uninitialized_copy_n<_ValueType>(std::move(__ifirst), __n, std::move(__ofirst), __always_false());
  return std::move(__result.second);
}



template <class _ValueType, class _ForwardIterator, class _Sentinel, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
__uninitialized_fill(_ForwardIterator __first, _Sentinel __last, const _Tp& __x) {
  _ForwardIterator __idx = __first;

  try {

    for (; __idx != __last; ++__idx)
      ::new (std::__voidify(*__idx)) _ValueType(__x);

  } catch (...) {
    std::__destroy(__first, __idx);
    throw;
  }


  return __idx;
}

template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __x) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  (void)std::__uninitialized_fill<_ValueType>(__first, __last, __x);
}



template <class _ValueType, class _ForwardIterator, class _Size, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
__uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x) {
  _ForwardIterator __idx = __first;

  try {

    for (; __n > 0; ++__idx, (void)--__n)
      ::new (std::__voidify(*__idx)) _ValueType(__x);

  } catch (...) {
    std::__destroy(__first, __idx);
    throw;
  }


  return __idx;
}

template <class _ForwardIterator, class _Size, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  return std::__uninitialized_fill_n<_ValueType>(__first, __n, __x);
}
# 515 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/uninitialized_algorithms.h" 3
template <class _Alloc, class _Iter, class _Sent>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__allocator_destroy(_Alloc& __alloc, _Iter __first, _Sent __last) {
  for (; __first != __last; ++__first)
    allocator_traits<_Alloc>::destroy(__alloc, std::__to_address(__first));
}

template <class _Alloc, class _Iter>
class _AllocatorDestroyRangeReverse {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  _AllocatorDestroyRangeReverse(_Alloc& __alloc, _Iter& __first, _Iter& __last)
      : __alloc_(__alloc), __first_(__first), __last_(__last) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator()() const {
    std::__allocator_destroy(__alloc_, std::reverse_iterator<_Iter>(__last_), std::reverse_iterator<_Iter>(__first_));
  }

private:
  _Alloc& __alloc_;
  _Iter& __first_;
  _Iter& __last_;
};





template <class _Alloc, class _Iter1, class _Sent1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Iter2
__uninitialized_allocator_copy_impl(_Alloc& __alloc, _Iter1 __first1, _Sent1 __last1, _Iter2 __first2) {
  auto __destruct_first = __first2;
  auto __guard =
      std::__make_exception_guard(_AllocatorDestroyRangeReverse<_Alloc, _Iter2>(__alloc, __destruct_first, __first2));
  while (__first1 != __last1) {
    allocator_traits<_Alloc>::construct(__alloc, std::__to_address(__first2), *__first1);
    ++__first1;
    ++__first2;
  }
  __guard.__complete();
  return __first2;
}

template <class _Alloc, class _Type>
struct __allocator_has_trivial_copy_construct : _Not<__has_construct<_Alloc, _Type*, const _Type&> > {};

template <class _Type>
struct __allocator_has_trivial_copy_construct<allocator<_Type>, _Type> : true_type {};

template <class _Alloc,
          class _In,
          class _RawTypeIn = __remove_const_t<_In>,
          class _Out,
          __enable_if_t<

              is_trivially_copy_constructible<_RawTypeIn>::value && is_trivially_copy_assignable<_RawTypeIn>::value &&
              is_same<__remove_const_t<_In>, __remove_const_t<_Out> >::value &&
              __allocator_has_trivial_copy_construct<_Alloc, _RawTypeIn>::value>* = __nullptr>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Out*
__uninitialized_allocator_copy_impl(_Alloc&, _In* __first1, _In* __last1, _Out* __first2) {

  if (__libcpp_is_constant_evaluated()) {
    while (__first1 != __last1) {
      std::__construct_at(std::__to_address(__first2), *__first1);
      ++__first1;
      ++__first2;
    }
    return __first2;
  } else {
    return std::copy(__first1, __last1, const_cast<_RawTypeIn*>(__first2));
  }
}

template <class _Alloc, class _Iter1, class _Sent1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Iter2
__uninitialized_allocator_copy(_Alloc& __alloc, _Iter1 __first1, _Sent1 __last1, _Iter2 __first2) {
  auto __unwrapped_range = std::__unwrap_range(__first1, __last1);
  auto __result = std::__uninitialized_allocator_copy_impl(
      __alloc, __unwrapped_range.first, __unwrapped_range.second, std::__unwrap_iter(__first2));
  return std::__rewrap_iter(__first2, __result);
}






template <class _Alloc, class _Iter1, class _Sent1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Iter2
__uninitialized_allocator_move_if_noexcept(_Alloc& __alloc, _Iter1 __first1, _Sent1 __last1, _Iter2 __first2) {
  _Static_assert(__is_cpp17_move_insertable<_Alloc>::value, "The specified type does not meet the requirements of Cpp17MoveInsertable");

  auto __destruct_first = __first2;
  auto __guard =
      std::__make_exception_guard(_AllocatorDestroyRangeReverse<_Alloc, _Iter2>(__alloc, __destruct_first, __first2));
  while (__first1 != __last1) {

    allocator_traits<_Alloc>::construct(__alloc, std::__to_address(__first2), std::move_if_noexcept(*__first1));



    ++__first1;
    ++__first2;
  }
  __guard.__complete();
  return __first2;
}

template <class _Alloc, class _Type>
struct __allocator_has_trivial_move_construct : _Not<__has_construct<_Alloc, _Type*, _Type&&> > {};

template <class _Type>
struct __allocator_has_trivial_move_construct<allocator<_Type>, _Type> : true_type {};


template <
    class _Alloc,
    class _Iter1,
    class _Iter2,
    class _Type = typename iterator_traits<_Iter1>::value_type,
    class = __enable_if_t<is_trivially_move_constructible<_Type>::value && is_trivially_move_assignable<_Type>::value &&
                          __allocator_has_trivial_move_construct<_Alloc, _Type>::value> >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Iter2
__uninitialized_allocator_move_if_noexcept(_Alloc&, _Iter1 __first1, _Iter1 __last1, _Iter2 __first2) {
  if (__libcpp_is_constant_evaluated()) {
    while (__first1 != __last1) {
      std::__construct_at(std::__to_address(__first2), std::move(*__first1));
      ++__first1;
      ++__first2;
    }
    return __first2;
  } else {
    return std::move(__first1, __last1, __first2);
  }
}


}}
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/ranges_uninitialized_algorithms.h" 2 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/ranges_uninitialized_algorithms.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/ranges_uninitialized_algorithms.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 321 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/ranges_uninitialized_algorithms.h" 3
}}
# 938 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/raw_storage_iterator.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/raw_storage_iterator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/raw_storage_iterator.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



#pragma GCC diagnostic push
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/raw_storage_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/raw_storage_iterator.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _OutputIterator, class _Tp>
class raw_storage_iterator

    : public iterator<output_iterator_tag, void, void, void, void>

{
#pragma GCC diagnostic pop

private:
  _OutputIterator __x_;

public:
  typedef output_iterator_tag iterator_category;
  typedef void value_type;



  typedef void difference_type;

  typedef void pointer;
  typedef void reference;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) raw_storage_iterator& operator*() { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) raw_storage_iterator& operator=(const _Tp& __element) {
    ::new ((void*)std::addressof(*__x_)) _Tp(__element);
    return *this;
  }






  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) raw_storage_iterator& operator++() {
    ++__x_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) raw_storage_iterator operator++(int) {
    raw_storage_iterator __t(*this);
    ++__x_;
    return __t;
  }



};



}}
# 939 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_destructor.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/allocator_destructor.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Alloc>
class __allocator_destructor {
  typedef __attribute__((__nodebug__)) allocator_traits<_Alloc> __alloc_traits;

public:
  typedef __attribute__((__nodebug__)) typename __alloc_traits::pointer pointer;
  typedef __attribute__((__nodebug__)) typename __alloc_traits::size_type size_type;

private:
  _Alloc& __alloc_;
  size_type __s_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __allocator_destructor(_Alloc& __a, size_type __s) throw() : __alloc_(__a), __s_(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator()(pointer __p) throw() { __alloc_traits::deallocate(__alloc_, __p, __s_); }
};

}}
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 2 3






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/unique_ptr.h" 1 3
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/unique_ptr.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/unique_ptr.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct default_delete {
  _Static_assert(!is_function<_Tp>::value, "default_delete cannot be instantiated for function types");



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) default_delete() {}

  template <class _Up, __enable_if_t<is_convertible<_Up*, _Tp*>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) default_delete(const default_delete<_Up>&) throw() {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator()(_Tp* __ptr) const throw() {
    _Static_assert(sizeof(_Tp) >= 0, "cannot delete an incomplete type");
    _Static_assert(!is_void<_Tp>::value, "cannot delete an incomplete type");
    delete __ptr;
  }
};

template <class _Tp>
struct default_delete<_Tp[]> {
private:
  template <class _Up>
  struct _EnableIfConvertible : enable_if<is_convertible<_Up (*)[], _Tp (*)[]>::value> {};

public:



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) default_delete() {}


  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  default_delete(const default_delete<_Up[]>&, typename _EnableIfConvertible<_Up>::type* = 0) throw() {}

  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename _EnableIfConvertible<_Up>::type
  operator()(_Up* __ptr) const throw() {
    _Static_assert(sizeof(_Up) >= 0, "cannot delete an incomplete type");
    delete[] __ptr;
  }
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae {
  _Static_assert(!is_reference<_Deleter>::value, "incorrect specialization");
  typedef const _Deleter& __lval_ref_type;
  typedef _Deleter&& __good_rval_ref_type;
  typedef true_type __enable_rval_overload;
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter const&> {
  typedef const _Deleter& __lval_ref_type;
  typedef const _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};

template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter&> {
  typedef _Deleter& __lval_ref_type;
  typedef _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};







template <class _Tp, class _Dp = default_delete<_Tp> >
class unique_ptr {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef __attribute__((__nodebug__)) typename __pointer<_Tp, deleter_type>::type pointer;

  _Static_assert(!is_rvalue_reference<deleter_type>::value, "the specified deleter type cannot be an rvalue reference");

private:
  __compressed_pair<pointer, deleter_type> __ptr_;

  typedef __attribute__((__nodebug__)) __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType __attribute__((__nodebug__)) = typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType __attribute__((__nodebug__)) = typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType __attribute__((__nodebug__)) = typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type< __type_identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible __attribute__((__nodebug__)) =
      __enable_if_t<is_default_constructible<_Deleter>::value && !is_pointer<_Deleter>::value>;

  template <class _ArgType>
  using _EnableIfDeleterConstructible __attribute__((__nodebug__)) = __enable_if_t<is_constructible<deleter_type, _ArgType>::value>;

  template <class _UPtr, class _Up>
  using _EnableIfMoveConvertible __attribute__((__nodebug__)) =
      __enable_if_t< is_convertible<typename _UPtr::pointer, pointer>::value && !is_array<_Up>::value >;

  template <class _UDel>
  using _EnableIfDeleterConvertible __attribute__((__nodebug__)) =
      __enable_if_t< (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
                     (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value) >;

  template <class _UDel>
  using _EnableIfDeleterAssignable = __enable_if_t< is_assignable<_Dp&, _UDel&&>::value >;

public:
  template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr() throw() : __ptr_(__value_init_tag(), __value_init_tag()) {}

  template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr(nullptr_t) throw()
      : __ptr_(__value_init_tag(), __value_init_tag()) {}

  template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit unique_ptr(pointer __p) throw()
      : __ptr_(__p, __value_init_tag()) {}

  template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr(pointer __p, _LValRefType<_Dummy> __d) throw()
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) throw()
      : __ptr_(__p, std::move(__d)) {
    _Static_assert(!is_reference<deleter_type>::value, "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr(pointer __p, _BadRValRefType<_Dummy> __d) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr(unique_ptr&& __u) throw()
      : __ptr_(__u.release(), std::forward<deleter_type>(__u.get_deleter())) {}

  template <class _Up,
            class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterConvertible<_Ep> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr(unique_ptr<_Up, _Ep>&& __u) throw()
      : __ptr_(__u.release(), std::forward<_Ep>(__u.get_deleter())) {}


  template <class _Up,
            __enable_if_t<is_convertible<_Up*, _Tp*>::value && is_same<_Dp, default_delete<_Tp> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr(auto_ptr<_Up>&& __p) throw() : __ptr_(__p.release(), __value_init_tag()) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr& operator=(unique_ptr&& __u) throw() {
    reset(__u.release());
    __ptr_.second() = std::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up,
            class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterAssignable<_Ep> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) throw() {
    reset(__u.release());
    __ptr_.second() = std::forward<_Ep>(__u.get_deleter());
    return *this;
  }


  template <class _Up,
            __enable_if_t<is_convertible<_Up*, _Tp*>::value && is_same<_Dp, default_delete<_Tp> >::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr& operator=(auto_ptr<_Up> __p) {
    reset(__p.release());
    return *this;
  }



  unique_ptr(unique_ptr const&) = delete;
  unique_ptr& operator=(unique_ptr const&) = delete;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~unique_ptr() { reset(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr& operator=(nullptr_t) throw() {
    reset();
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __add_lvalue_reference_t<_Tp> operator*() const {
    return *__ptr_.first();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer operator->() const throw() { return __ptr_.first(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer get() const throw() { return __ptr_.first(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) deleter_type& get_deleter() throw() { return __ptr_.second(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const deleter_type& get_deleter() const throw() {
    return __ptr_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit operator bool() const throw() {
    return __ptr_.first() != __nullptr;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer release() throw() {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void reset(pointer __p = pointer()) throw() {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(unique_ptr& __u) throw() { __ptr_.swap(__u.__ptr_); }
};

template <class _Tp, class _Dp>
class unique_ptr<_Tp[], _Dp> {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer<_Tp, deleter_type>::type pointer;

private:
  __compressed_pair<pointer, deleter_type> __ptr_;

  template <class _From>
  struct _CheckArrayPointerConversion : is_same<_From, pointer> {};

  template <class _FromElem>
  struct _CheckArrayPointerConversion<_FromElem*>
      : integral_constant<bool,
                          is_same<_FromElem*, pointer>::value ||
                              (is_same<pointer, element_type*>::value &&
                               is_convertible<_FromElem (*)[], element_type (*)[]>::value) > {};

  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType __attribute__((__nodebug__)) = typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType __attribute__((__nodebug__)) = typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType __attribute__((__nodebug__)) = typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type< __type_identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible __attribute__((__nodebug__)) =
      __enable_if_t<is_default_constructible<_Deleter>::value && !is_pointer<_Deleter>::value>;

  template <class _ArgType>
  using _EnableIfDeleterConstructible __attribute__((__nodebug__)) = __enable_if_t<is_constructible<deleter_type, _ArgType>::value>;

  template <class _Pp>
  using _EnableIfPointerConvertible __attribute__((__nodebug__)) = __enable_if_t< _CheckArrayPointerConversion<_Pp>::value >;

  template <class _UPtr, class _Up, class _ElemT = typename _UPtr::element_type>
  using _EnableIfMoveConvertible __attribute__((__nodebug__)) =
      __enable_if_t< is_array<_Up>::value && is_same<pointer, element_type*>::value &&
                     is_same<typename _UPtr::pointer, _ElemT*>::value &&
                     is_convertible<_ElemT (*)[], element_type (*)[]>::value >;

  template <class _UDel>
  using _EnableIfDeleterConvertible __attribute__((__nodebug__)) =
      __enable_if_t< (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
                     (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value) >;

  template <class _UDel>
  using _EnableIfDeleterAssignable __attribute__((__nodebug__)) = __enable_if_t< is_assignable<_Dp&, _UDel&&>::value >;

public:
  template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr() throw() : __ptr_(__value_init_tag(), __value_init_tag()) {}

  template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr(nullptr_t) throw()
      : __ptr_(__value_init_tag(), __value_init_tag()) {}

  template <class _Pp,
            bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit unique_ptr(_Pp __p) throw()
      : __ptr_(__p, __value_init_tag()) {}

  template <class _Pp,
            bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr(_Pp __p, _LValRefType<_Dummy> __d) throw()
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr(nullptr_t, _LValRefType<_Dummy> __d) throw()
      : __ptr_(__nullptr, __d) {}

  template <class _Pp,
            bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr(_Pp __p, _GoodRValRefType<_Dummy> __d) throw()
      : __ptr_(__p, std::move(__d)) {
    _Static_assert(!is_reference<deleter_type>::value, "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr(nullptr_t, _GoodRValRefType<_Dummy> __d) throw()
      : __ptr_(__nullptr, std::move(__d)) {
    _Static_assert(!is_reference<deleter_type>::value, "rvalue deleter bound to reference");
  }

  template <class _Pp,
            bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr(_Pp __p, _BadRValRefType<_Dummy> __d) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr(unique_ptr&& __u) throw()
      : __ptr_(__u.release(), std::forward<deleter_type>(__u.get_deleter())) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr& operator=(unique_ptr&& __u) throw() {
    reset(__u.release());
    __ptr_.second() = std::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up,
            class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterConvertible<_Ep> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr(unique_ptr<_Up, _Ep>&& __u) throw()
      : __ptr_(__u.release(), std::forward<_Ep>(__u.get_deleter())) {}

  template <class _Up,
            class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterAssignable<_Ep> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) throw() {
    reset(__u.release());
    __ptr_.second() = std::forward<_Ep>(__u.get_deleter());
    return *this;
  }


  unique_ptr(unique_ptr const&) = delete;
  unique_ptr& operator=(unique_ptr const&) = delete;


public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~unique_ptr() { reset(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_ptr& operator=(nullptr_t) throw() {
    reset();
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __add_lvalue_reference_t<_Tp> operator[](size_t __i) const {
    return __ptr_.first()[__i];
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer get() const throw() { return __ptr_.first(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) deleter_type& get_deleter() throw() { return __ptr_.second(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const deleter_type& get_deleter() const throw() {
    return __ptr_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit operator bool() const throw() {
    return __ptr_.first() != __nullptr;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer release() throw() {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  template <class _Pp, __enable_if_t<_CheckArrayPointerConversion<_Pp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void reset(_Pp __p) throw() {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void reset(nullptr_t = __nullptr) throw() {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __nullptr;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(unique_ptr& __u) throw() { __ptr_.swap(__u.__ptr_); }
};

template <class _Tp, class _Dp, __enable_if_t<__is_swappable<_Dp>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
swap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) throw() {
  __x.swap(__y);
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {
  return __x.get() == __y.get();
}


template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {
  return !(__x == __y);
}


template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {
  typedef typename unique_ptr<_T1, _D1>::pointer _P1;
  typedef typename unique_ptr<_T2, _D2>::pointer _P2;
  typedef typename common_type<_P1, _P2>::type _Vp;
  return less<_Vp>()(__x.get(), __y.get());
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {
  return __y < __x;
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {
  return !(__y < __x);
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {
  return !(__x < __y);
}
# 503 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/unique_ptr.h" 3
template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) throw() {
  return !__x;
}


template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) throw() {
  return !__x;
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) throw() {
  return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) throw() {
  return static_cast<bool>(__x);
}


template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<(const unique_ptr<_T1, _D1>& __x, nullptr_t) {
  typedef typename unique_ptr<_T1, _D1>::pointer _P1;
  return less<_P1>()(__x.get(), __nullptr);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<(nullptr_t, const unique_ptr<_T1, _D1>& __x) {
  typedef typename unique_ptr<_T1, _D1>::pointer _P1;
  return less<_P1>()(__nullptr, __x.get());
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>(const unique_ptr<_T1, _D1>& __x, nullptr_t) {
  return __nullptr < __x;
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>(nullptr_t, const unique_ptr<_T1, _D1>& __x) {
  return __x < __nullptr;
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t) {
  return !(__nullptr < __x);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x) {
  return !(__x < __nullptr);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t) {
  return !(__x < __nullptr);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x) {
  return !(__nullptr < __x);
}
# 631 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/unique_ptr.h" 3
template <class _Tp>
struct hash;

template <class _Tp, class _Dp>

struct hash<unique_ptr<_Tp, _Dp> >



{

                              typedef unique_ptr<_Tp, _Dp> argument_type;
                              typedef size_t result_type;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(const unique_ptr<_Tp, _Dp>& __ptr) const {
    typedef typename unique_ptr<_Tp, _Dp>::pointer pointer;
    return hash<pointer>()(__ptr.get());
  }
};

}}
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 2 3
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
template <class _ValueType>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ValueType __libcpp_relaxed_load(_ValueType const* __value) {


  return __atomic_load_n(__value, 0);



}

template <class _ValueType>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ValueType __libcpp_acquire_load(_ValueType const* __value) {


  return __atomic_load_n(__value, 2);



}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp __libcpp_atomic_refcount_increment(_Tp& __t) throw() {

  return __atomic_add_fetch(&__t, 1, 0);



}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp __libcpp_atomic_refcount_decrement(_Tp& __t) throw() {

  return __atomic_add_fetch(&__t, -1, 4);



}

class __attribute__((__visibility__("default"))) bad_weak_ptr : public std::exception {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bad_weak_ptr() throw() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bad_weak_ptr(const bad_weak_ptr&) throw() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bad_weak_ptr& operator=(const bad_weak_ptr&) throw() = default;
  ~bad_weak_ptr() throw() override;
  const char* what() const throw() override;
};

__attribute__((__noreturn__)) inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __throw_bad_weak_ptr() {

  throw bad_weak_ptr();



}

template <class _Tp>
class weak_ptr;

class __attribute__((__visibility__("default"))) __shared_count {
  __shared_count(const __shared_count&);
  __shared_count& operator=(const __shared_count&);

protected:
  long __shared_owners_;
  virtual ~__shared_count();

private:
  virtual void __on_zero_shared() throw() = 0;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __shared_count(long __refs = 0) throw() : __shared_owners_(__refs) {}





  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __add_shared() throw() { __libcpp_atomic_refcount_increment(__shared_owners_); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __release_shared() throw() {
    if (__libcpp_atomic_refcount_decrement(__shared_owners_) == -1) {
      __on_zero_shared();
      return true;
    }
    return false;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long use_count() const throw() { return __libcpp_relaxed_load(&__shared_owners_) + 1; }
};

class __attribute__((__visibility__("default"))) __shared_weak_count : private __shared_count {
  long __shared_weak_owners_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __shared_weak_count(long __refs = 0) throw()
      : __shared_count(__refs),
        __shared_weak_owners_(__refs) {}

protected:
  ~__shared_weak_count() override;

public:





  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __add_shared() throw() { __shared_count::__add_shared(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __add_weak() throw() { __libcpp_atomic_refcount_increment(__shared_weak_owners_); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __release_shared() throw() {
    if (__shared_count::__release_shared())
      __release_weak();
  }

  void __release_weak() throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long use_count() const throw() { return __shared_count::use_count(); }
  __shared_weak_count* lock() throw();

  virtual const void* __get_deleter(const type_info&) const throw();

private:
  virtual void __on_zero_shared_weak() throw() = 0;
};

template <class _Tp, class _Dp, class _Alloc>
class __shared_ptr_pointer : public __shared_weak_count {
  __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
      : __data_(__compressed_pair<_Tp, _Dp>(__p, std::move(__d)), std::move(__a)) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) const void* __get_deleter(const type_info&) const throw() override;


private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __on_zero_shared() throw() override;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __on_zero_shared_weak() throw() override;
};



template <class _Tp, class _Dp, class _Alloc>
const void* __shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const throw() {
  return __t == typeid(_Dp) ? std::addressof(__data_.first().second()) : __nullptr;
}



template <class _Tp, class _Dp, class _Alloc>
void __shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() throw() {
  __data_.first().second()(__data_.first().first());
  __data_.first().second().~_Dp();
}

template <class _Tp, class _Dp, class _Alloc>
void __shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() throw() {
  typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;
  typedef allocator_traits<_Al> _ATraits;
  typedef pointer_traits<typename _ATraits::pointer> _PTraits;

  _Al __a(__data_.second());
  __data_.second().~_Alloc();
  __a.deallocate(_PTraits::pointer_to(*this), 1);
}




struct __for_overwrite_tag {};

template <class _Tp, class _Alloc>
struct __shared_ptr_emplace : __shared_weak_count {
  template <class... _Args,
            class _Allocator = _Alloc,
            __enable_if_t<is_same<typename _Allocator::value_type, __for_overwrite_tag>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __shared_ptr_emplace(_Alloc __a, _Args&&...) : __storage_(std::move(__a)) {
    _Static_assert(sizeof...(_Args) == 0, "No argument should be provided to the control block when using _for_overwrite");

    ::new ((void*)__get_elem()) _Tp;
  }

  template <class... _Args,
            class _Allocator = _Alloc,
            __enable_if_t<!is_same<typename _Allocator::value_type, __for_overwrite_tag>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __shared_ptr_emplace(_Alloc __a, _Args&&... __args) : __storage_(std::move(__a)) {
    using _TpAlloc = typename __allocator_traits_rebind<_Alloc, _Tp>::type;
    _TpAlloc __tmp(*__get_alloc());
    allocator_traits<_TpAlloc>::construct(__tmp, __get_elem(), std::forward<_Args>(__args)...);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Alloc* __get_alloc() throw() { return __storage_.__get_alloc(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* __get_elem() throw() { return __storage_.__get_elem(); }

private:
  template <class _Allocator = _Alloc,
            __enable_if_t<is_same<typename _Allocator::value_type, __for_overwrite_tag>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __on_zero_shared_impl() throw() {
    __get_elem()->~_Tp();
  }

  template <class _Allocator = _Alloc,
            __enable_if_t<!is_same<typename _Allocator::value_type, __for_overwrite_tag>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __on_zero_shared_impl() throw() {
    using _TpAlloc = typename __allocator_traits_rebind<_Allocator, _Tp>::type;
    _TpAlloc __tmp(*__get_alloc());
    allocator_traits<_TpAlloc>::destroy(__tmp, __get_elem());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __on_zero_shared() throw() override { __on_zero_shared_impl(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __on_zero_shared_weak() throw() override {
    using _ControlBlockAlloc = typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type;
    using _ControlBlockPointer = typename allocator_traits<_ControlBlockAlloc>::pointer;
    _ControlBlockAlloc __tmp(*__get_alloc());
    __storage_.~_Storage();
    allocator_traits<_ControlBlockAlloc>::deallocate(__tmp, pointer_traits<_ControlBlockPointer>::pointer_to(*this), 1);
  }
# 305 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
  using _CompressedPair = __compressed_pair<_Alloc, _Tp>;
  struct __attribute__((__aligned__(_Alignof(_CompressedPair)))) _Storage {
    char __blob_[sizeof(_CompressedPair)];

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit _Storage(_Alloc&& __a) { ::new ((void*)__get_alloc()) _Alloc(std::move(__a)); }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~_Storage() { __get_alloc()->~_Alloc(); }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Alloc* __get_alloc() throw() {
      _CompressedPair* __as_pair = reinterpret_cast<_CompressedPair*>(__blob_);
      typename _CompressedPair::_Base1* __first = _CompressedPair::__get_first_base(__as_pair);
      _Alloc* __alloc = reinterpret_cast<_Alloc*>(__first);
      return __alloc;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__no_sanitize__("cfi"))) _Tp* __get_elem() throw() {
      _CompressedPair* __as_pair = reinterpret_cast<_CompressedPair*>(__blob_);
      typename _CompressedPair::_Base2* __second = _CompressedPair::__get_second_base(__as_pair);
      _Tp* __elem = reinterpret_cast<_Tp*>(__second);
      return __elem;
    }
  };

  _Static_assert(_Alignof(_Storage) == _Alignof(_CompressedPair), "");
  _Static_assert(sizeof(_Storage) == sizeof(_CompressedPair), "");
  _Storage __storage_;
};

struct __shared_ptr_dummy_rebind_allocator_type;
template <>
class allocator<__shared_ptr_dummy_rebind_allocator_type> {
public:
  template <class _Other>
  struct rebind {
    typedef allocator<_Other> other;
  };
};

template <class _Tp>
class enable_shared_from_this;
# 356 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
template <class _Yp, class _Tp>
struct __compatible_with : is_convertible<_Yp*, _Tp*> {};
# 378 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
template <class _Yp, class _Tp>
struct __raw_pointer_compatible_with : is_convertible<_Yp*, _Tp*> {};


template <class _Ptr, class = void>
struct __is_deletable : false_type {};
template <class _Ptr>
struct __is_deletable<_Ptr, __decltype(delete std::declval<_Ptr>())> : true_type {};

template <class _Ptr, class = void>
struct __is_array_deletable : false_type {};
template <class _Ptr>
struct __is_array_deletable<_Ptr, __decltype(delete[] std::declval<_Ptr>())> : true_type {};

template <class _Dp, class _Pt, class = __decltype(std::declval<_Dp>()(std::declval<_Pt>()))>
true_type __well_formed_deleter_test(int);

template <class, class>
false_type __well_formed_deleter_test(...);

template <class _Dp, class _Pt>
struct __well_formed_deleter : __decltype(std::__well_formed_deleter_test<_Dp, _Pt>(0)) {};

template <class _Dp, class _Yp, class _Tp>
struct __shared_ptr_deleter_ctor_reqs {
  static const bool value = __raw_pointer_compatible_with<_Yp, _Tp>::value && is_move_constructible<_Dp>::value &&
                            __well_formed_deleter<_Dp, _Yp*>::value;
};







template <class _Tp>
class shared_ptr {
public:




  typedef _Tp element_type;


private:
  element_type* __ptr_;
  __shared_weak_count* __cntrl_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr() throw() : __ptr_(__nullptr), __cntrl_(__nullptr) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr(nullptr_t) throw() : __ptr_(__nullptr), __cntrl_(__nullptr) {}

  template <class _Yp,
            class = __enable_if_t< _And< __raw_pointer_compatible_with<_Yp, _Tp>







                                         >::value > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit shared_ptr(_Yp* __p) : __ptr_(__p) {
    unique_ptr<_Yp> __hold(__p);
    typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
    typedef __shared_ptr_pointer<_Yp*, __shared_ptr_default_delete<_Tp, _Yp>, _AllocT> _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__p, __shared_ptr_default_delete<_Tp, _Yp>(), _AllocT());
    __hold.release();
    __enable_weak_this(__p, __p);
  }

  template <class _Yp, class _Dp, class = __enable_if_t<__shared_ptr_deleter_ctor_reqs<_Dp, _Yp, _Tp>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr(_Yp* __p, _Dp __d) : __ptr_(__p) {

    try {

      typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
      typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT> _CntrlBlk;



    __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());

      __enable_weak_this(__p, __p);

    } catch (...) {
      __d(__p);
      throw;
    }

  }

  template <class _Yp,
            class _Dp,
            class _Alloc,
            class = __enable_if_t<__shared_ptr_deleter_ctor_reqs<_Dp, _Yp, _Tp>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr(_Yp* __p, _Dp __d, _Alloc __a) : __ptr_(__p) {

    try {

      typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;
      typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
      typedef __allocator_destructor<_A2> _D2;
      _A2 __a2(__a);
      unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
      ::new ((void*)std::addressof(*__hold2.get()))



        _CntrlBlk(__p, __d, __a);

      __cntrl_ = std::addressof(*__hold2.release());
      __enable_weak_this(__p, __p);

    } catch (...) {
      __d(__p);
      throw;
    }

  }

  template <class _Dp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr(nullptr_t __p, _Dp __d) : __ptr_(__nullptr) {

    try {

      typedef typename __shared_ptr_default_allocator<_Tp>::type _AllocT;
      typedef __shared_ptr_pointer<nullptr_t, _Dp, _AllocT> _CntrlBlk;



    __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());


    } catch (...) {
      __d(__p);
      throw;
    }

  }

  template <class _Dp, class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a) : __ptr_(__nullptr) {

    try {

      typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
      typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
      typedef __allocator_destructor<_A2> _D2;
      _A2 __a2(__a);
      unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
      ::new ((void*)std::addressof(*__hold2.get()))



        _CntrlBlk(__p, __d, __a);

      __cntrl_ = std::addressof(*__hold2.release());

    } catch (...) {
      __d(__p);
      throw;
    }

  }

  template <class _Yp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) throw()
      : __ptr_(__p),
        __cntrl_(__r.__cntrl_) {
    if (__cntrl_)
      __cntrl_->__add_shared();
  }
# 565 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr(const shared_ptr& __r) throw() : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
    if (__cntrl_)
      __cntrl_->__add_shared();
  }

  template <class _Yp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr(const shared_ptr<_Yp>& __r) throw() : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
    if (__cntrl_)
      __cntrl_->__add_shared();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr(shared_ptr&& __r) throw() : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
    __r.__ptr_ = __nullptr;
    __r.__cntrl_ = __nullptr;
  }

  template <class _Yp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr(shared_ptr<_Yp>&& __r) throw() : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
    __r.__ptr_ = __nullptr;
    __r.__cntrl_ = __nullptr;
  }

  template <class _Yp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit shared_ptr(const weak_ptr<_Yp>& __r)
      : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_) {
    if (__cntrl_ == __nullptr)
      __throw_bad_weak_ptr();
  }


  template <class _Yp, class = __enable_if_t<is_convertible<_Yp*, element_type*>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr(auto_ptr<_Yp>&& __r) : __ptr_(__r.get()) {
    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());
    __enable_weak_this(__r.get(), __r.get());
    __r.release();
  }


  template <class _Yp,
            class _Dp,
            class = __enable_if_t< !is_lvalue_reference<_Dp>::value && __compatible_with<_Yp, _Tp>::value &&
                                   is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr(unique_ptr<_Yp, _Dp>&& __r) : __ptr_(__r.get()) {





    {
      typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
      typedef __shared_ptr_pointer<typename unique_ptr<_Yp, _Dp>::pointer, _Dp, _AllocT> _CntrlBlk;
      __cntrl_ = new _CntrlBlk(__r.get(), std::move(__r.get_deleter()), _AllocT());
      __enable_weak_this(__r.get(), __r.get());
    }
    __r.release();
  }

  template <class _Yp,
            class _Dp,
            class = void,
            class = __enable_if_t< is_lvalue_reference<_Dp>::value && __compatible_with<_Yp, _Tp>::value &&
                                   is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr(unique_ptr<_Yp, _Dp>&& __r) : __ptr_(__r.get()) {





    {
      typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
      typedef __shared_ptr_pointer<typename unique_ptr<_Yp, _Dp>::pointer,
                                   reference_wrapper<__libcpp_remove_reference_t<_Dp> >,
                                   _AllocT>
          _CntrlBlk;
      __cntrl_ = new _CntrlBlk(__r.get(), std::ref(__r.get_deleter()), _AllocT());
      __enable_weak_this(__r.get(), __r.get());
    }
    __r.release();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~shared_ptr() {
    if (__cntrl_)
      __cntrl_->__release_shared();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr<_Tp>& operator=(const shared_ptr& __r) throw() {
    shared_ptr(__r).swap(*this);
    return *this;
  }

  template <class _Yp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr<_Tp>& operator=(const shared_ptr<_Yp>& __r) throw() {
    shared_ptr(__r).swap(*this);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr<_Tp>& operator=(shared_ptr&& __r) throw() {
    shared_ptr(std::move(__r)).swap(*this);
    return *this;
  }

  template <class _Yp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr<_Tp>& operator=(shared_ptr<_Yp>&& __r) {
    shared_ptr(std::move(__r)).swap(*this);
    return *this;
  }


  template <class _Yp,
            class = __enable_if_t< !is_array<_Yp>::value &&
                                   is_convertible<_Yp*, typename shared_ptr<_Tp>::element_type*>::value > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr<_Tp>& operator=(auto_ptr<_Yp>&& __r) {
    shared_ptr(std::move(__r)).swap(*this);
    return *this;
  }


  template <
      class _Yp,
      class _Dp,
      class = __enable_if_t<_And< __compatible_with<_Yp, _Tp>,
                                  is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*> >::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr<_Tp>& operator=(unique_ptr<_Yp, _Dp>&& __r) {
    shared_ptr(std::move(__r)).swap(*this);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(shared_ptr& __r) throw() {
    std::swap(__ptr_, __r.__ptr_);
    std::swap(__cntrl_, __r.__cntrl_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void reset() throw() { shared_ptr().swap(*this); }

  template <class _Yp, class = __enable_if_t< __raw_pointer_compatible_with<_Yp, _Tp>::value > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void reset(_Yp* __p) {
    shared_ptr(__p).swap(*this);
  }

  template <class _Yp, class _Dp, class = __enable_if_t< __shared_ptr_deleter_ctor_reqs<_Dp, _Yp, _Tp>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void reset(_Yp* __p, _Dp __d) {
    shared_ptr(__p, __d).swap(*this);
  }

  template <class _Yp,
            class _Dp,
            class _Alloc,
            class = __enable_if_t< __shared_ptr_deleter_ctor_reqs<_Dp, _Yp, _Tp>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void reset(_Yp* __p, _Dp __d, _Alloc __a) {
    shared_ptr(__p, __d, __a).swap(*this);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) element_type* get() const throw() { return __ptr_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __add_lvalue_reference_t<element_type> operator*() const throw() { return *__ptr_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) element_type* operator->() const throw() {
    _Static_assert(!is_array<_Tp>::value, "std::shared_ptr<T>::operator-> is only valid when T is not an array type.");
    return __ptr_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long use_count() const throw() { return __cntrl_ ? __cntrl_->use_count() : 0; }


                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool unique() const throw() { return use_count() == 1; }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit operator bool() const throw() { return get() != __nullptr; }

  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool owner_before(shared_ptr<_Up> const& __p) const throw() {
    return __cntrl_ < __p.__cntrl_;
  }

  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool owner_before(weak_ptr<_Up> const& __p) const throw() {
    return __cntrl_ < __p.__cntrl_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __owner_equivalent(const shared_ptr& __p) const { return __cntrl_ == __p.__cntrl_; }
# 755 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
  template <class _Dp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Dp* __get_deleter() const throw() {
    return static_cast<_Dp*>(__cntrl_ ? const_cast<void*>(__cntrl_->__get_deleter(typeid(_Dp))) : __nullptr);
  }


  template <class _Yp, class _CntrlBlk>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static shared_ptr<_Tp> __create_with_control_block(_Yp* __p, _CntrlBlk* __cntrl) throw() {
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __p;
    __r.__cntrl_ = __cntrl;
    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
    return __r;
  }

private:
  template <class _Yp, bool = is_function<_Yp>::value>
  struct __shared_ptr_default_allocator {
    typedef allocator<_Yp> type;
  };

  template <class _Yp>
  struct __shared_ptr_default_allocator<_Yp, true> {
    typedef allocator<__shared_ptr_dummy_rebind_allocator_type> type;
  };

  template <class _Yp,
            class _OrigPtr,
            class = __enable_if_t< is_convertible<_OrigPtr*, const enable_shared_from_this<_Yp>*>::value > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __enable_weak_this(const enable_shared_from_this<_Yp>* __e, _OrigPtr* __ptr) throw() {
    typedef __remove_cv_t<_Yp> _RawYp;
    if (__e && __e->__weak_this_.expired()) {
      __e->__weak_this_ = shared_ptr<_RawYp>(*this, const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));
    }
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __enable_weak_this(...) throw() {}

  template <class, class _Yp>
  struct __shared_ptr_default_delete : default_delete<_Yp> {};

  template <class _Yp, class _Un, size_t _Sz>
  struct __shared_ptr_default_delete<_Yp[_Sz], _Un> : default_delete<_Yp[]> {};

  template <class _Yp, class _Un>
  struct __shared_ptr_default_delete<_Yp[], _Un> : default_delete<_Yp[]> {};

  template <class _Up>
  friend class shared_ptr;
  template <class _Up>
  friend class weak_ptr;
};
# 818 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
template <class _Tp, class _Alloc, class... _Args, class = __enable_if_t<!is_array<_Tp>::value> >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr<_Tp> allocate_shared(const _Alloc& __a, _Args&&... __args) {
  using _ControlBlock = __shared_ptr_emplace<_Tp, _Alloc>;
  using _ControlBlockAllocator = typename __allocator_traits_rebind<_Alloc, _ControlBlock>::type;
  __allocation_guard<_ControlBlockAllocator> __guard(__a, 1);
  ::new ((void*)std::addressof(*__guard.__get())) _ControlBlock(__a, std::forward<_Args>(__args)...);
  auto __control_block = __guard.__release_ptr();
  return shared_ptr<_Tp>::__create_with_control_block(
      (*__control_block).__get_elem(), std::addressof(*__control_block));
}

template <class _Tp, class... _Args, class = __enable_if_t<!is_array<_Tp>::value> >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr<_Tp> make_shared(_Args&&... __args) {
  return std::allocate_shared<_Tp>(allocator<_Tp>(), std::forward<_Args>(__args)...);
}
# 1102 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw() {
  return __x.get() == __y.get();
}



template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw() {
  return !(__x == __y);
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw() {

  typedef typename common_type<_Tp*, _Up*>::type _Vp;
  return less<_Vp>()(__x.get(), __y.get());



}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw() {
  return __y < __x;
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw() {
  return !(__y < __x);
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) throw() {
  return !(__x < __y);
}
# 1148 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const shared_ptr<_Tp>& __x, nullptr_t) throw() {
  return !__x;
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(nullptr_t, const shared_ptr<_Tp>& __x) throw() {
  return !__x;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const shared_ptr<_Tp>& __x, nullptr_t) throw() {
  return static_cast<bool>(__x);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(nullptr_t, const shared_ptr<_Tp>& __x) throw() {
  return static_cast<bool>(__x);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<(const shared_ptr<_Tp>& __x, nullptr_t) throw() {
  return less<typename shared_ptr<_Tp>::element_type*>()(__x.get(), __nullptr);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<(nullptr_t, const shared_ptr<_Tp>& __x) throw() {
  return less<typename shared_ptr<_Tp>::element_type*>()(__nullptr, __x.get());
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>(const shared_ptr<_Tp>& __x, nullptr_t) throw() {
  return __nullptr < __x;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>(nullptr_t, const shared_ptr<_Tp>& __x) throw() {
  return __x < __nullptr;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<=(const shared_ptr<_Tp>& __x, nullptr_t) throw() {
  return !(__nullptr < __x);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<=(nullptr_t, const shared_ptr<_Tp>& __x) throw() {
  return !(__x < __nullptr);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>=(const shared_ptr<_Tp>& __x, nullptr_t) throw() {
  return !(__x < __nullptr);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>=(nullptr_t, const shared_ptr<_Tp>& __x) throw() {
  return !(__nullptr < __x);
}
# 1219 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) throw() {
  __x.swap(__y);
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr<_Tp> static_pointer_cast(const shared_ptr<_Up>& __r) throw() {
  return shared_ptr<_Tp>(__r, static_cast< typename shared_ptr<_Tp>::element_type*>(__r.get()));
}
# 1238 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr<_Tp> dynamic_pointer_cast(const shared_ptr<_Up>& __r) throw() {
  typedef typename shared_ptr<_Tp>::element_type _ET;
  _ET* __p = dynamic_cast<_ET*>(__r.get());
  return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
}
# 1255 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr<_Tp> const_pointer_cast(const shared_ptr<_Up>& __r) throw() {
  typedef typename shared_ptr<_Tp>::element_type _RTp;
  return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));
}
# 1270 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
template <class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr<_Tp> reinterpret_pointer_cast(const shared_ptr<_Up>& __r) throw() {
  return shared_ptr<_Tp>(__r, reinterpret_cast< typename shared_ptr<_Tp>::element_type*>(__r.get()));
}
# 1286 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
template <class _Dp, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Dp* get_deleter(const shared_ptr<_Tp>& __p) throw() {
  return __p.template __get_deleter<_Dp>();
}



template <class _Tp>
class weak_ptr {
public:



  typedef _Tp element_type;


private:
  element_type* __ptr_;
  __shared_weak_count* __cntrl_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) weak_ptr() throw();

  template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) weak_ptr(shared_ptr<_Yp> const& __r) throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) weak_ptr(weak_ptr const& __r) throw();

  template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) weak_ptr(weak_ptr<_Yp> const& __r) throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) weak_ptr(weak_ptr&& __r) throw();

  template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) weak_ptr(weak_ptr<_Yp>&& __r) throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~weak_ptr();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) weak_ptr& operator=(weak_ptr const& __r) throw();
  template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) weak_ptr& operator=(weak_ptr<_Yp> const& __r) throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) weak_ptr& operator=(weak_ptr&& __r) throw();
  template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) weak_ptr& operator=(weak_ptr<_Yp>&& __r) throw();

  template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) weak_ptr& operator=(shared_ptr<_Yp> const& __r) throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(weak_ptr& __r) throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void reset() throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long use_count() const throw() { return __cntrl_ ? __cntrl_->use_count() : 0; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool expired() const throw() { return __cntrl_ == __nullptr || __cntrl_->use_count() == 0; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr<_Tp> lock() const throw();
  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool owner_before(const shared_ptr<_Up>& __r) const throw() {
    return __cntrl_ < __r.__cntrl_;
  }
  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool owner_before(const weak_ptr<_Up>& __r) const throw() {
    return __cntrl_ < __r.__cntrl_;
  }

  template <class _Up>
  friend class weak_ptr;
  template <class _Up>
  friend class shared_ptr;
};






template <class _Tp>
inline weak_ptr<_Tp>::weak_ptr() throw() : __ptr_(__nullptr), __cntrl_(__nullptr) {}

template <class _Tp>
inline weak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) throw() : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_weak();
}

template <class _Tp>
template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> >
inline weak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r) throw() : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_weak();
}

template <class _Tp>
template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> >
inline weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r) throw() : __ptr_(__nullptr), __cntrl_(__nullptr) {
  shared_ptr<_Yp> __s = __r.lock();
  *this = weak_ptr<_Tp>(__s);
}

template <class _Tp>
inline weak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) throw() : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
  __r.__ptr_ = __nullptr;
  __r.__cntrl_ = __nullptr;
}

template <class _Tp>
template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> >
inline weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r) throw() : __ptr_(__nullptr), __cntrl_(__nullptr) {
  shared_ptr<_Yp> __s = __r.lock();
  *this = weak_ptr<_Tp>(__s);
  __r.reset();
}

template <class _Tp>
weak_ptr<_Tp>::~weak_ptr() {
  if (__cntrl_)
    __cntrl_->__release_weak();
}

template <class _Tp>
inline weak_ptr<_Tp>& weak_ptr<_Tp>::operator=(weak_ptr const& __r) throw() {
  weak_ptr(__r).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> >
inline weak_ptr<_Tp>& weak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) throw() {
  weak_ptr(__r).swap(*this);
  return *this;
}

template <class _Tp>
inline weak_ptr<_Tp>& weak_ptr<_Tp>::operator=(weak_ptr&& __r) throw() {
  weak_ptr(std::move(__r)).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> >
inline weak_ptr<_Tp>& weak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) throw() {
  weak_ptr(std::move(__r)).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp, __enable_if_t<__compatible_with<_Yp, _Tp>::value, int> >
inline weak_ptr<_Tp>& weak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) throw() {
  weak_ptr(__r).swap(*this);
  return *this;
}

template <class _Tp>
inline void weak_ptr<_Tp>::swap(weak_ptr& __r) throw() {
  std::swap(__ptr_, __r.__ptr_);
  std::swap(__cntrl_, __r.__cntrl_);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) throw() {
  __x.swap(__y);
}

template <class _Tp>
inline void weak_ptr<_Tp>::reset() throw() {
  weak_ptr().swap(*this);
}

template <class _Tp>
shared_ptr<_Tp> weak_ptr<_Tp>::lock() const throw() {
  shared_ptr<_Tp> __r;
  __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;
  if (__r.__cntrl_)
    __r.__ptr_ = __ptr_;
  return __r;
}





template <class _Tp>
struct owner_less;


template <class _Tp>
struct owner_less<shared_ptr<_Tp> > : __binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const throw() {
    return __x.owner_before(__y);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const throw() {
    return __x.owner_before(__y);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const throw() {
    return __x.owner_before(__y);
  }
};

template <class _Tp>
struct owner_less<weak_ptr<_Tp> > : __binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(weak_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const throw() {
    return __x.owner_before(__y);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const throw() {
    return __x.owner_before(__y);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const throw() {
    return __x.owner_before(__y);
  }
};
# 1519 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/shared_ptr.h" 3
template <class _Tp>
class enable_shared_from_this {
  mutable weak_ptr<_Tp> __weak_this_;

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) enable_shared_from_this() throw() {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) enable_shared_from_this(enable_shared_from_this const&) throw() {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) enable_shared_from_this& operator=(enable_shared_from_this const&) throw() { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~enable_shared_from_this() {}

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr<_Tp> shared_from_this() { return shared_ptr<_Tp>(__weak_this_); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr<_Tp const> shared_from_this() const { return shared_ptr<const _Tp>(__weak_this_); }







  template <class _Up>
  friend class shared_ptr;
};

template <class _Tp>
struct hash;

template <class _Tp>
struct hash<shared_ptr<_Tp> > {

                              typedef shared_ptr<_Tp> argument_type;
                              typedef size_t result_type;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(const shared_ptr<_Tp>& __ptr) const throw() {
    return hash<typename shared_ptr<_Tp>::element_type*>()(__ptr.get());
  }
};

template <class _CharT, class _Traits, class _Yp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);



class __attribute__((__visibility__("default"))) __sp_mut {
  void* __lx_;

public:
  void lock() throw();
  void unlock() throw();

private:
                    __sp_mut(void*) throw();
  __sp_mut(const __sp_mut&);
  __sp_mut& operator=(const __sp_mut&);

  friend __attribute__((__visibility__("default"))) __sp_mut& __get_sp_mut(const void*);
};

__attribute__((__visibility__("default"))) __sp_mut& __get_sp_mut(const void*);

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool atomic_is_lock_free(const shared_ptr<_Tp>*) {
  return false;
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr<_Tp> atomic_load(const shared_ptr<_Tp>* __p) {
  __sp_mut& __m = std::__get_sp_mut(__p);
  __m.lock();
  shared_ptr<_Tp> __q = *__p;
  __m.unlock();
  return __q;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr<_Tp> atomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order) {
  return std::atomic_load(__p);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void atomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r) {
  __sp_mut& __m = std::__get_sp_mut(__p);
  __m.lock();
  __p->swap(__r);
  __m.unlock();
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void atomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order) {
  std::atomic_store(__p, __r);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr<_Tp> atomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r) {
  __sp_mut& __m = std::__get_sp_mut(__p);
  __m.lock();
  __p->swap(__r);
  __m.unlock();
  return __r;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) shared_ptr<_Tp>
atomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order) {
  return std::atomic_exchange(__p, __r);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
atomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w) {
  shared_ptr<_Tp> __temp;
  __sp_mut& __m = std::__get_sp_mut(__p);
  __m.lock();
  if (__p->__owner_equivalent(*__v)) {
    std::swap(__temp, *__p);
    *__p = __w;
    __m.unlock();
    return true;
  }
  std::swap(__temp, *__v);
  *__v = *__p;
  __m.unlock();
  return false;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
atomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w) {
  return std::atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool atomic_compare_exchange_strong_explicit(
    shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w, memory_order, memory_order) {
  return std::atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool atomic_compare_exchange_weak_explicit(
    shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w, memory_order, memory_order) {
  return std::atomic_compare_exchange_weak(__p, __v, __w);
}



}}
# 940 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/temporary_buffer.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/temporary_buffer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__no_sanitize__("cfi"))) pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __n) throw() {
  pair<_Tp*, ptrdiff_t> __r(0, 0);
  const ptrdiff_t __m =
      (~ptrdiff_t(0) ^ ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * 8 - 1))) / sizeof(_Tp);
  if (__n > __m)
    __n = __m;
  while (__n > 0) {
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/temporary_buffer.h" 3
    if (__is_overaligned_for_new(_Alignof(_Tp))) {


      return __r;
    }

    __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));


    if (__r.first) {
      __r.second = __n;
      break;
    }
    __n /= 2;
  }
  return __r;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void return_temporary_buffer(_Tp* __p) throw() {
  std::__libcpp_deallocate_unsized((void*)__p, _Alignof(_Tp));
}

struct __return_temporary_buffer {
#pragma GCC diagnostic push
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/temporary_buffer.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/temporary_buffer.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  template <class _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator()(_Tp* __p) const {
    std::return_temporary_buffer(__p);
  }
#pragma GCC diagnostic pop
};

}}
# 941 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/uses_allocator_construction.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/uses_allocator_construction.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/uses_allocator_construction.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 251 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/uses_allocator_construction.h" 3
}}
# 945 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 954 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1295 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/optional" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/movable_box.h" 2 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/movable_box.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/movable_box.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 245 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/movable_box.h" 3
}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each.h" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _Function>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Function
for_each(_InputIterator __first, _InputIterator __last, _Function __f) {
  for (; __first != __last; ++__first)
    __f(*__first);
  return __f;
}
# 53 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each.h" 3
}}
# 1811 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each_n.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each_n.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/for_each_n.h" 3
}}
# 1812 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/generate.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/generate.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator, class _Generator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen) {
  for (; __first != __last; ++__first)
    *__first = __gen();
}

}}
# 1813 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/generate_n.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/generate_n.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _OutputIterator, class _Size, class _Generator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator
generate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen) {
  typedef __decltype(std::__convert_to_integral(__orig_n)) _IntegralSize;
  _IntegralSize __n = __orig_n;
  for (; __n > 0; ++__first, (void)--__n)
    *__first = __gen();
  return __first;
}

}}
# 1814 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_found_result.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_found_result.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_found_result.h" 2 3
# 1816 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_fun_result.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_fun_result.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_fun_result.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_fun_result.h" 3
}}
# 1817 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_in_out_result.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_in_out_result.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_in_out_result.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_in_out_result.h" 3
}}
# 1818 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_in_result.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_in_result.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_in_result.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_in_result.h" 3
}}
# 1819 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_out_out_result.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_out_out_result.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_out_out_result.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 53 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/in_out_out_result.h" 3
}}
# 1820 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/includes.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/includes.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/includes.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class _Comp, class _Proj1, class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __includes(
    _Iter1 __first1,
    _Sent1 __last1,
    _Iter2 __first2,
    _Sent2 __last2,
    _Comp&& __comp,
    _Proj1&& __proj1,
    _Proj2&& __proj2) {
  for (; __first2 != __last2; ++__first1) {
    if (__first1 == __last1 ||
        std::__invoke(__comp, std::__invoke(__proj2, *__first2), std::__invoke(__proj1, *__first1)))
      return false;
    if (!std::__invoke(__comp, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
      ++__first2;
  }
  return true;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
includes(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _Compare __comp) {
  _Static_assert(__is_callable<_Compare, __decltype(*__first1), __decltype(*__first2)>::value, "Comparator has to be callable");


  return std::__includes(
      std::move(__first1),
      std::move(__last1),
      std::move(__first2),
      std::move(__last2),
      static_cast<__comp_ref_type<_Compare> >(__comp),
      __identity(),
      __identity());
}

template <class _InputIterator1, class _InputIterator2>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) {
  return std::includes(std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2), __less<>());
}

}}
# 1822 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/inplace_merge.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/inplace_merge.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/destruct_n.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/destruct_n.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct __destruct_n {
private:
  size_t __size_;

  template <class _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __process(_Tp* __p, false_type) throw() {
    for (size_t __i = 0; __i < __size_; ++__i, ++__p)
      __p->~_Tp();
  }

  template <class _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __process(_Tp*, true_type) throw() {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __incr(false_type) throw() { ++__size_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __incr(true_type) throw() {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __set(size_t __s, false_type) throw() { __size_ = __s; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __set(size_t, true_type) throw() {}

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __destruct_n(size_t __s) throw() : __size_(__s) {}

  template <class _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __incr() throw() {
    __incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());
  }

  template <class _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __set(size_t __s, _Tp*) throw() {
    __set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());
  }

  template <class _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator()(_Tp* __p) throw() {
    __process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());
  }
};

}}
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/inplace_merge.h" 2 3
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/inplace_merge.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/inplace_merge.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Predicate>
class __invert
{
private:
  _Predicate __p_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __invert() {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __invert(_Predicate __p) : __p_(__p) {}

  template <class _T1>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _T1& __x) {
    return !__p_(__x);
  }

  template <class _T1, class _T2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _T1& __x, const _T2& __y) {
    return __p_(__y, __x);
  }
};

template <class _AlgPolicy,
          class _Compare,
          class _InputIterator1,
          class _Sent1,
          class _InputIterator2,
          class _Sent2,
          class _OutputIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __half_inplace_merge(
    _InputIterator1 __first1,
    _Sent1 __last1,
    _InputIterator2 __first2,
    _Sent2 __last2,
    _OutputIterator __result,
    _Compare&& __comp) {
  for (; __first1 != __last1; ++__result) {
    if (__first2 == __last2) {
      std::__move<_AlgPolicy>(__first1, __last1, __result);
      return;
    }

    if (__comp(*__first2, *__first1)) {
      *__result = _IterOps<_AlgPolicy>::__iter_move(__first2);
      ++__first2;
    } else {
      *__result = _IterOps<_AlgPolicy>::__iter_move(__first1);
      ++__first1;
    }
  }

}

template <class _AlgPolicy, class _Compare, class _BidirectionalIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __buffered_inplace_merge(
    _BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare&& __comp,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
    typename iterator_traits<_BidirectionalIterator>::value_type* __buff) {
  typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
  __destruct_n __d(0);
  unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
  if (__len1 <= __len2) {
    value_type* __p = __buff;
    for (_BidirectionalIterator __i = __first; __i != __middle;
         __d.template __incr<value_type>(), (void)++__i, (void)++__p)
      ::new ((void*)__p) value_type(_IterOps<_AlgPolicy>::__iter_move(__i));
    std::__half_inplace_merge<_AlgPolicy>(__buff, __p, __middle, __last, __first, __comp);
  } else {
    value_type* __p = __buff;
    for (_BidirectionalIterator __i = __middle; __i != __last;
         __d.template __incr<value_type>(), (void)++__i, (void)++__p)
      ::new ((void*)__p) value_type(_IterOps<_AlgPolicy>::__iter_move(__i));
    typedef __unconstrained_reverse_iterator<_BidirectionalIterator> _RBi;
    typedef __unconstrained_reverse_iterator<value_type*> _Rv;
    typedef __invert<_Compare> _Inverted;
    std::__half_inplace_merge<_AlgPolicy>(
        _Rv(__p), _Rv(__buff), _RBi(__middle), _RBi(__first), _RBi(__last), _Inverted(__comp));
  }
}

template <class _AlgPolicy, class _Compare, class _BidirectionalIterator>
void __inplace_merge(
    _BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare&& __comp,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
    typename iterator_traits<_BidirectionalIterator>::value_type* __buff,
    ptrdiff_t __buff_size) {
  using _Ops = _IterOps<_AlgPolicy>;

  typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
  while (true) {

    if (__len2 == 0)
      return;
    if (__len1 <= __buff_size || __len2 <= __buff_size)
      return std::__buffered_inplace_merge<_AlgPolicy>(__first, __middle, __last, __comp, __len1, __len2, __buff);

    for (; true; ++__first, (void)--__len1) {
      if (__len1 == 0)
        return;
      if (__comp(*__middle, *__first))
        break;
    }
# 159 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/inplace_merge.h" 3
    _BidirectionalIterator __m1;
    _BidirectionalIterator __m2;
    difference_type __len11;
    difference_type __len21;

    if (__len1 < __len2) {
      __len21 = __len2 / 2;
      __m2 = __middle;
      _Ops::advance(__m2, __len21);
      __m1 = std::__upper_bound<_AlgPolicy>(__first, __middle, *__m2, __comp, std::__identity());
      __len11 = _Ops::distance(__first, __m1);
    } else {
      if (__len1 == 1) {

        _Ops::iter_swap(__first, __middle);
        return;
      }

      __len11 = __len1 / 2;
      __m1 = __first;
      _Ops::advance(__m1, __len11);
      __m2 = std::lower_bound(__middle, __last, *__m1, __comp);
      __len21 = _Ops::distance(__middle, __m2);
    }
    difference_type __len12 = __len1 - __len11;
    difference_type __len22 = __len2 - __len21;


    __middle = std::__rotate<_AlgPolicy>(__m1, __middle, __m2).first;


    if (__len11 + __len21 < __len12 + __len22) {
      std::__inplace_merge<_AlgPolicy>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);
      __first = __middle;
      __middle = __m2;
      __len1 = __len12;
      __len2 = __len22;
    } else {
      std::__inplace_merge<_AlgPolicy>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);
      __last = __middle;
      __middle = __m1;
      __len1 = __len11;
      __len2 = __len21;
    }
  }
}

template <class _AlgPolicy, class _BidirectionalIterator, class _Compare>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __inplace_merge(
    _BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare&& __comp) {
  typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
  typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
  difference_type __len1 = _IterOps<_AlgPolicy>::distance(__first, __middle);
  difference_type __len2 = _IterOps<_AlgPolicy>::distance(__middle, __last);
  difference_type __buf_size = std::min(__len1, __len2);

#pragma GCC diagnostic push
# 215 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/inplace_merge.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 215 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/inplace_merge.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  pair<value_type*, ptrdiff_t> __buf = std::get_temporary_buffer<value_type>(__buf_size);
#pragma GCC diagnostic pop
  unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);
  return std::__inplace_merge<_AlgPolicy>(
      std::move(__first), std::move(__middle), std::move(__last), __comp, __len1, __len2, __buf.first, __buf.second);
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void inplace_merge(
    _BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp) {
  std::__inplace_merge<_ClassicAlgPolicy>(
      std::move(__first), std::move(__middle), std::move(__last), static_cast<__comp_ref_type<_Compare> >(__comp));
}

template <class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last) {
  std::inplace_merge(std::move(__first), std::move(__middle), std::move(__last), __less<>());
}

}}
# 1823 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_heap.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_heap.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_heap_until.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_heap_until.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Compare, class _RandomAccessIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _RandomAccessIterator
__is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare&& __comp) {
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  difference_type __len = __last - __first;
  difference_type __p = 0;
  difference_type __c = 1;
  _RandomAccessIterator __pp = __first;
  while (__c < __len) {
    _RandomAccessIterator __cp = __first + __c;
    if (__comp(*__pp, *__cp))
      return __cp;
    ++__c;
    ++__cp;
    if (__c == __len)
      return __last;
    if (__comp(*__pp, *__cp))
      return __cp;
    ++__p;
    ++__pp;
    __c = 2 * __p + 1;
  }
  return __last;
}

template <class _RandomAccessIterator, class _Compare>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  return std::__is_heap_until(__first, __last, static_cast<__comp_ref_type<_Compare> >(__comp));
}

template <class _RandomAccessIterator>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  return std::__is_heap_until(__first, __last, __less<>());
}

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_heap.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_heap.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _RandomAccessIterator, class _Compare>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  return std::__is_heap_until(__first, __last, static_cast<__comp_ref_type<_Compare> >(__comp)) == __last;
}

template <class _RandomAccessIterator>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  return std::is_heap(__first, __last, __less<>());
}

}}
# 1824 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_partitioned.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_partitioned.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
is_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (!__pred(*__first))
      break;
  if (__first == __last)
    return true;
  ++__first;
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      return false;
  return true;
}

}}
# 1826 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_permutation.h" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_permutation.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_permutation.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class = void>
struct _ConstTimeDistance : false_type {};
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_permutation.h" 3
template <class _Iter1, class _Iter2>
struct _ConstTimeDistance<
    _Iter1,
    _Iter1,
    _Iter2,
    _Iter2,
    __enable_if_t< is_same<typename iterator_traits<_Iter1>::iterator_category, random_access_iterator_tag>::value &&
                   is_same<typename iterator_traits<_Iter2>::iterator_category, random_access_iterator_tag>::value > >
    : true_type {};






template <class _AlgPolicy,
          class _Iter1,
          class _Sent1,
          class _Iter2,
          class _Sent2,
          class _Proj1,
          class _Proj2,
          class _Pred>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __is_permutation_impl(
    _Iter1 __first1,
    _Sent1 __last1,
    _Iter2 __first2,
    _Sent2 __last2,
    _Pred&& __pred,
    _Proj1&& __proj1,
    _Proj2&& __proj2) {
  using _D1 = __iter_diff_t<_Iter1>;

  for (auto __i = __first1; __i != __last1; ++__i) {

    auto __match = __first1;
    for (; __match != __i; ++__match) {
      if (std::__invoke(__pred, std::__invoke(__proj1, *__match), std::__invoke(__proj1, *__i)))
        break;
    }

    if (__match == __i) {

      _D1 __c2 = 0;
      for (auto __j = __first2; __j != __last2; ++__j) {
        if (std::__invoke(__pred, std::__invoke(__proj1, *__i), std::__invoke(__proj2, *__j)))
          ++__c2;
      }
      if (__c2 == 0)
        return false;


      _D1 __c1 = 1;
      for (auto __j = _IterOps<_AlgPolicy>::next(__i); __j != __last1; ++__j) {
        if (std::__invoke(__pred, std::__invoke(__proj1, *__i), std::__invoke(__proj1, *__j)))
          ++__c1;
      }
      if (__c1 != __c2)
        return false;
    }
  }

  return true;
}


template <class _AlgPolicy, class _ForwardIterator1, class _Sentinel1, class _ForwardIterator2, class _BinaryPredicate>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __is_permutation(
    _ForwardIterator1 __first1, _Sentinel1 __last1, _ForwardIterator2 __first2, _BinaryPredicate&& __pred) {

  for (; __first1 != __last1; ++__first1, (void)++__first2) {
    if (!__pred(*__first1, *__first2))
      break;
  }

  if (__first1 == __last1)
    return true;


  using _D1 = __iter_diff_t<_ForwardIterator1>;
  _D1 __l1 = _IterOps<_AlgPolicy>::distance(__first1, __last1);
  if (__l1 == _D1(1))
    return false;
  auto __last2 = _IterOps<_AlgPolicy>::next(__first2, __l1);

  return std::__is_permutation_impl<_AlgPolicy>(
      std::move(__first1),
      std::move(__last1),
      std::move(__first2),
      std::move(__last2),
      __pred,
      __identity(),
      __identity());
}


template <class _AlgPolicy,
          class _Iter1,
          class _Sent1,
          class _Iter2,
          class _Sent2,
          class _Proj1,
          class _Proj2,
          class _Pred>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __is_permutation(
    _Iter1 __first1,
    _Sent1 __last1,
    _Iter2 __first2,
    _Sent2 __last2,
    _Pred&& __pred,
    _Proj1&& __proj1,
    _Proj2&& __proj2,
                           false_type) {

  while (__first1 != __last1 && __first2 != __last2) {
    if (!std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
      break;
    ++__first1;
    ++__first2;
  }

  if (__first1 == __last1)
    return __first2 == __last2;
  if (__first2 == __last2)
    return false;

  using _D1 = __iter_diff_t<_Iter1>;
  _D1 __l1 = _IterOps<_AlgPolicy>::distance(__first1, __last1);

  using _D2 = __iter_diff_t<_Iter2>;
  _D2 __l2 = _IterOps<_AlgPolicy>::distance(__first2, __last2);
  if (__l1 != __l2)
    return false;

  return std::__is_permutation_impl<_AlgPolicy>(
      std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2), __pred, __proj1, __proj2);
}


template <class _AlgPolicy,
          class _Iter1,
          class _Sent1,
          class _Iter2,
          class _Sent2,
          class _Proj1,
          class _Proj2,
          class _Pred>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __is_permutation(
    _Iter1 __first1,
    _Sent1 __last1,
    _Iter2 __first2,
    _Sent2 __last2,
    _Pred&& __pred,
    _Proj1&& __proj1,
    _Proj2&& __proj2,
                           true_type) {
  if (std::distance(__first1, __last1) != std::distance(__first2, __last2))
    return false;
  return std::__is_permutation<_AlgPolicy>(
      std::move(__first1),
      std::move(__last1),
      std::move(__first2),
      std::move(__last2),
      __pred,
      __proj1,
      __proj2,
                             false_type());
}


template <class _AlgPolicy,
          class _Iter1,
          class _Sent1,
          class _Iter2,
          class _Sent2,
          class _Proj1,
          class _Proj2,
          class _Pred>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __is_permutation(
    _Iter1 __first1,
    _Sent1 __last1,
    _Iter2 __first2,
    _Sent2 __last2,
    _Pred&& __pred,
    _Proj1&& __proj1,
    _Proj2&& __proj2) {
  return std::__is_permutation<_AlgPolicy>(
      std::move(__first1),
      std::move(__last1),
      std::move(__first2),
      std::move(__last2),
      __pred,
      __proj1,
      __proj2,
      _ConstTimeDistance<_Iter1, _Sent1, _Iter2, _Sent2>());
}




template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool is_permutation(
    _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _BinaryPredicate __pred) {
  _Static_assert(__is_callable<_BinaryPredicate, __decltype(*__first1), __decltype(*__first2)>::value, "The predicate has to be callable");


  return std::__is_permutation<_ClassicAlgPolicy>(std::move(__first1), std::move(__last1), std::move(__first2), __pred);
}


template <class _ForwardIterator1, class _ForwardIterator2>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2) {
  return std::is_permutation(__first1, __last1, __first2, __equal_to());
}
# 304 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_permutation.h" 3
}}
# 1827 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_sorted.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_sorted.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_sorted_until.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_sorted_until.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Compare, class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
__is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
  if (__first != __last) {
    _ForwardIterator __i = __first;
    while (++__i != __last) {
      if (__comp(*__i, *__first))
        return __i;
      __first = __i;
    }
  }
  return __last;
}

template <class _ForwardIterator, class _Compare>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
  return std::__is_sorted_until<__comp_ref_type<_Compare> >(__first, __last, __comp);
}

template <class _ForwardIterator>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last) {
  return std::is_sorted_until(__first, __last, __less<>());
}

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_sorted.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/is_sorted.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator, class _Compare>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
  return std::__is_sorted_until<__comp_ref_type<_Compare> >(__first, __last, __comp) == __last;
}

template <class _ForwardIterator>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last) {
  return std::is_sorted(__first, __last, __less<>());
}

}}
# 1828 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/make_heap.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/make_heap.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sift_down.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sift_down.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sift_down.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__sift_down(_RandomAccessIterator __first,
            _Compare&& __comp,
            typename iterator_traits<_RandomAccessIterator>::difference_type __len,
            _RandomAccessIterator __start) {
  using _Ops = _IterOps<_AlgPolicy>;

  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;


  difference_type __child = __start - __first;

  if (__len < 2 || (__len - 2) / 2 < __child)
    return;

  __child = 2 * __child + 1;
  _RandomAccessIterator __child_i = __first + __child;

  if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + difference_type(1)))) {

    ++__child_i;
    ++__child;
  }


  if (__comp(*__child_i, *__start))

    return;

  value_type __top(_Ops::__iter_move(__start));
  do {

    *__start = _Ops::__iter_move(__child_i);
    __start = __child_i;

    if ((__len - 2) / 2 < __child)
      break;


    __child = 2 * __child + 1;
    __child_i = __first + __child;

    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + difference_type(1)))) {

      ++__child_i;
      ++__child;
    }


  } while (!__comp(*__child_i, __top));
  *__start = std::move(__top);
}

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _RandomAccessIterator __floyd_sift_down(
    _RandomAccessIterator __first,
    _Compare&& __comp,
    typename iterator_traits<_RandomAccessIterator>::difference_type __len) {
  using difference_type = typename iterator_traits<_RandomAccessIterator>::difference_type;
  ((void)0);

  _RandomAccessIterator __hole = __first;
  _RandomAccessIterator __child_i = __first;
  difference_type __child = 0;

  while (true) {
    __child_i += difference_type(__child + 1);
    __child = 2 * __child + 1;

    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + difference_type(1)))) {

      ++__child_i;
      ++__child;
    }


    *__hole = _IterOps<_AlgPolicy>::__iter_move(__child_i);
    __hole = __child_i;


    if (__child > (__len - 2) / 2)
      return __hole;
  }
}

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/make_heap.h" 2 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/make_heap.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/make_heap.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare&& __comp) {
  __comp_ref_type<_Compare> __comp_ref = __comp;

  using difference_type = typename iterator_traits<_RandomAccessIterator>::difference_type;
  difference_type __n = __last - __first;
  if (__n > 1) {

    for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start) {
      std::__sift_down<_AlgPolicy>(__first, __comp_ref, __n, __first + __start);
    }
  }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  std::__make_heap<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::make_heap(std::move(__first), std::move(__last), __less<>());
}

}}
# 1834 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max_element.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max_element.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Compare, class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
__max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
  _Static_assert(__has_forward_iterator_category<_ForwardIterator>::value, "std::max_element requires a ForwardIterator");

  if (__first != __last) {
    _ForwardIterator __i = __first;
    while (++__i != __last)
      if (__comp(*__first, *__i))
        __first = __i;
  }
  return __first;
}

template <class _ForwardIterator, class _Compare>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
  return std::__max_element<__comp_ref_type<_Compare> >(__first, __last, __comp);
}

template <class _ForwardIterator>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last) {
  return std::max_element(__first, __last, __less<>());
}

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Compare>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _Tp&
max( const _Tp& __a, const _Tp& __b, _Compare __comp) {
  return __comp(__a, __b) ? __b : __a;
}

template <class _Tp>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _Tp&
max( const _Tp& __a, const _Tp& __b) {
  return std::max(__a, __b, __less<>());
}
# 54 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/max.h" 3
}}
# 1835 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/merge.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/merge.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator __merge(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result,
    _Compare __comp) {
  for (; __first1 != __last1; ++__result) {
    if (__first2 == __last2)
      return std::copy(__first1, __last1, __result);
    if (__comp(*__first2, *__first1)) {
      *__result = *__first2;
      ++__first2;
    } else {
      *__result = *__first1;
      ++__first1;
    }
  }
  return std::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator
merge(_InputIterator1 __first1,
      _InputIterator1 __last1,
      _InputIterator2 __first2,
      _InputIterator2 __last2,
      _OutputIterator __result,
      _Compare __comp) {
  return std::__merge<__comp_ref_type<_Compare> >(__first1, __last1, __first2, __last2, __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator
merge(_InputIterator1 __first1,
      _InputIterator1 __last1,
      _InputIterator2 __first2,
      _InputIterator2 __last2,
      _OutputIterator __result) {
  return std::merge(__first1, __last1, __first2, __last2, __result, __less<>());
}

}}
# 1837 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min_max_result.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min_max_result.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min_max_result.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/min_max_result.h" 3
}}
# 1840 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/minmax.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/minmax.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/minmax_element.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/minmax_element.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Comp, class _Proj>
class _MinmaxElementLessFunc {
  _Comp& __comp_;
  _Proj& __proj_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _MinmaxElementLessFunc(_Comp& __comp, _Proj& __proj)
      : __comp_(__comp), __proj_(__proj) {}

  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(_Iter& __it1, _Iter& __it2) {
    return std::__invoke(__comp_, std::__invoke(__proj_, *__it1), std::__invoke(__proj_, *__it2));
  }
};

template <class _Iter, class _Sent, class _Proj, class _Comp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_Iter, _Iter>
__minmax_element_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
  auto __less = _MinmaxElementLessFunc<_Comp, _Proj>(__comp, __proj);

  pair<_Iter, _Iter> __result(__first, __first);
  if (__first == __last || ++__first == __last)
    return __result;

  if (__less(__first, __result.first))
    __result.first = __first;
  else
    __result.second = __first;

  while (++__first != __last) {
    _Iter __i = __first;
    if (++__first == __last) {
      if (__less(__i, __result.first))
        __result.first = __i;
      else if (!__less(__i, __result.second))
        __result.second = __i;
      return __result;
    }

    if (__less(__first, __i)) {
      if (__less(__first, __result.first))
        __result.first = __first;
      if (!__less(__i, __result.second))
        __result.second = __i;
    } else {
      if (__less(__i, __result.first))
        __result.first = __i;
      if (!__less(__first, __result.second))
        __result.second = __first;
    }
  }

  return __result;
}

template <class _ForwardIterator, class _Compare>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
  _Static_assert(__has_forward_iterator_category<_ForwardIterator>::value, "std::minmax_element requires a ForwardIterator");

  _Static_assert(__is_callable<_Compare, __decltype(*__first), __decltype(*__first)>::value, "The comparator has to be callable");

  auto __proj = __identity();
  return std::__minmax_element_impl(__first, __last, __comp, __proj);
}

template <class _ForwardIterator>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
    pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last) {
  return std::minmax_element(__first, __last, __less<>());
}

}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/minmax.h" 2 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/minmax.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Compare>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<const _Tp&, const _Tp&>
minmax( const _Tp& __a, const _Tp& __b, _Compare __comp) {
  return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) : pair<const _Tp&, const _Tp&>(__a, __b);
}

template <class _Tp>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<const _Tp&, const _Tp&>
minmax( const _Tp& __a, const _Tp& __b) {
  return std::minmax(__a, __b, __less<>());
}
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/minmax.h" 3
}}
# 1841 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/mismatch.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/mismatch.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred) {
  for (; __first1 != __last1; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      break;
  return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2) {
  return std::mismatch(__first1, __last1, __first2, __equal_to());
}
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/mismatch.h" 3
}}
# 1843 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/next_permutation.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/next_permutation.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/reverse.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/reverse.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/reverse.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__reverse_impl(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag) {
  while (__first != __last) {
    if (__first == --__last)
      break;
    _IterOps<_AlgPolicy>::iter_swap(__first, __last);
    ++__first;
  }
}

template <class _AlgPolicy, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__reverse_impl(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag) {
  if (__first != __last)
    for (; __first < --__last; ++__first)
      _IterOps<_AlgPolicy>::iter_swap(__first, __last);
}

template <class _AlgPolicy, class _BidirectionalIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __reverse(_BidirectionalIterator __first, _Sentinel __last) {
  using _IterCategory = typename _IterOps<_AlgPolicy>::template __iterator_category<_BidirectionalIterator>;
  std::__reverse_impl<_AlgPolicy>(std::move(__first), std::move(__last), _IterCategory());
}

template <class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
reverse(_BidirectionalIterator __first, _BidirectionalIterator __last) {
  std::__reverse<_ClassicAlgPolicy>(std::move(__first), std::move(__last));
}

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/next_permutation.h" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/next_permutation.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/next_permutation.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _BidirectionalIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_BidirectionalIterator, bool>
__next_permutation(_BidirectionalIterator __first, _Sentinel __last, _Compare&& __comp) {
  using _Result = pair<_BidirectionalIterator, bool>;

  _BidirectionalIterator __last_iter = _IterOps<_AlgPolicy>::next(__first, __last);
  _BidirectionalIterator __i = __last_iter;
  if (__first == __last || __first == --__i)
    return _Result(std::move(__last_iter), false);

  while (true) {
    _BidirectionalIterator __ip1 = __i;
    if (__comp(*--__i, *__ip1)) {
      _BidirectionalIterator __j = __last_iter;
      while (!__comp(*__i, *--__j))
        ;
      _IterOps<_AlgPolicy>::iter_swap(__i, __j);
      std::__reverse<_AlgPolicy>(__ip1, __last_iter);
      return _Result(std::move(__last_iter), true);
    }
    if (__i == __first) {
      std::__reverse<_AlgPolicy>(__first, __last_iter);
      return _Result(std::move(__last_iter), false);
    }
  }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp) {
  return std::__next_permutation<_ClassicAlgPolicy>(
             std::move(__first), std::move(__last), static_cast<__comp_ref_type<_Compare> >(__comp))
      .second;
}

template <class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last) {
  return std::next_permutation(__first, __last, __less<>());
}

}}
# 1846 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/none_of.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/none_of.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _Predicate>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      return false;
  return true;
}

}}
# 1847 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/nth_element.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/nth_element.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort_heap.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort_heap.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pop_heap.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pop_heap.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/push_heap.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/push_heap.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/push_heap.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__sift_up(_RandomAccessIterator __first,
          _RandomAccessIterator __last,
          _Compare&& __comp,
          typename iterator_traits<_RandomAccessIterator>::difference_type __len) {
  using value_type = typename iterator_traits<_RandomAccessIterator>::value_type;

  if (__len > 1) {
    __len = (__len - 2) / 2;
    _RandomAccessIterator __ptr = __first + __len;

    if (__comp(*__ptr, *--__last)) {
      value_type __t(_IterOps<_AlgPolicy>::__iter_move(__last));
      do {
        *__last = _IterOps<_AlgPolicy>::__iter_move(__ptr);
        __last = __ptr;
        if (__len == 0)
          break;
        __len = (__len - 1) / 2;
        __ptr = __first + __len;
      } while (__comp(*__ptr, __t));

      *__last = std::move(__t);
    }
  }
}

template <class _AlgPolicy, class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare& __comp) {
  typename iterator_traits<_RandomAccessIterator>::difference_type __len = __last - __first;
  std::__sift_up<_AlgPolicy, __comp_ref_type<_Compare> >(std::move(__first), std::move(__last), __comp, __len);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  _Static_assert(std::is_copy_constructible<_RandomAccessIterator>::value, "Iterators must be copy constructible.");
  _Static_assert(std::is_copy_assignable<_RandomAccessIterator>::value, "Iterators must be copy assignable.");

  std::__push_heap<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::push_heap(std::move(__first), std::move(__last), __less<>());
}

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pop_heap.h" 2 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pop_heap.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pop_heap.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__pop_heap(_RandomAccessIterator __first,
           _RandomAccessIterator __last,
           _Compare& __comp,
           typename iterator_traits<_RandomAccessIterator>::difference_type __len) {

  ((void)0);

  __comp_ref_type<_Compare> __comp_ref = __comp;

  using value_type = typename iterator_traits<_RandomAccessIterator>::value_type;
  if (__len > 1) {
    value_type __top = _IterOps<_AlgPolicy>::__iter_move(__first);
    _RandomAccessIterator __hole = std::__floyd_sift_down<_AlgPolicy>(__first, __comp_ref, __len);
    --__last;

    if (__hole == __last) {
      *__hole = std::move(__top);
    } else {
      *__hole = _IterOps<_AlgPolicy>::__iter_move(__last);
      ++__hole;
      *__last = std::move(__top);
      std::__sift_up<_AlgPolicy>(__first, __hole, __comp_ref, __hole - __first);
    }
  }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  _Static_assert(std::is_copy_constructible<_RandomAccessIterator>::value, "Iterators must be copy constructible.");
  _Static_assert(std::is_copy_assignable<_RandomAccessIterator>::value, "Iterators must be copy assignable.");

  typename iterator_traits<_RandomAccessIterator>::difference_type __len = __last - __first;
  std::__pop_heap<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp, __len);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::pop_heap(std::move(__first), std::move(__last), __less<>());
}

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort_heap.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__debug_utils/strict_weak_ordering_check.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__debug_utils/strict_weak_ordering_check.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _RandomAccessIterator, class _Comp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__check_strict_weak_ordering_sorted(_RandomAccessIterator __first, _RandomAccessIterator __last, _Comp& __comp) {
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__debug_utils/strict_weak_ordering_check.h" 3
  (void)__first;
  (void)__last;
  (void)__comp;

}

}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort_heap.h" 2 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort_heap.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort_heap.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare&& __comp) {
  _RandomAccessIterator __saved_last = __last;
  __comp_ref_type<_Compare> __comp_ref = __comp;

  using difference_type = typename iterator_traits<_RandomAccessIterator>::difference_type;
  for (difference_type __n = __last - __first; __n > 1; --__last, (void)--__n)
    std::__pop_heap<_AlgPolicy>(__first, __last, __comp_ref, __n);
  std::__check_strict_weak_ordering_sorted(__first, __saved_last, __comp_ref);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  _Static_assert(std::is_copy_constructible<_RandomAccessIterator>::value, "Iterators must be copy constructible.");
  _Static_assert(std::is_copy_assignable<_RandomAccessIterator>::value, "Iterators must be copy assignable.");

  std::__sort_heap<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::sort_heap(std::move(__first), std::move(__last), __less<>());
}

}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__debug_utils/randomize_range.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__debug_utils/randomize_range.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Iterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __debug_randomize_range(_Iterator __first, _Sentinel __last) {
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__debug_utils/randomize_range.h" 3
  (void)__first;
  (void)__last;

}

}}
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort.h" 2 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _RandomAccessIterator __partial_sort_impl(
    _RandomAccessIterator __first, _RandomAccessIterator __middle, _Sentinel __last, _Compare&& __comp) {
  if (__first == __middle) {
    return _IterOps<_AlgPolicy>::next(__middle, __last);
  }

  std::__make_heap<_AlgPolicy>(__first, __middle, __comp);

  typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;
  _RandomAccessIterator __i = __middle;
  for (; __i != __last; ++__i) {
    if (__comp(*__i, *__first)) {
      _IterOps<_AlgPolicy>::iter_swap(__i, __first);
      std::__sift_down<_AlgPolicy>(__first, __comp, __len, __first);
    }
  }
  std::__sort_heap<_AlgPolicy>(std::move(__first), std::move(__middle), __comp);

  return __i;
}

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _RandomAccessIterator
__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _Sentinel __last, _Compare& __comp) {
  if (__first == __middle)
    return _IterOps<_AlgPolicy>::next(__middle, __last);

  std::__debug_randomize_range<_AlgPolicy>(__first, __last);

  auto __last_iter =
      std::__partial_sort_impl<_AlgPolicy>(__first, __middle, __last, static_cast<__comp_ref_type<_Compare> >(__comp));

  std::__debug_randomize_range<_AlgPolicy>(__middle, __last);

  return __last_iter;
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void partial_sort(
    _RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp) {
  _Static_assert(std::is_copy_constructible<_RandomAccessIterator>::value, "Iterators must be copy constructible.");
  _Static_assert(std::is_copy_assignable<_RandomAccessIterator>::value, "Iterators must be copy assignable.");

  (void)std::__partial_sort<_ClassicAlgPolicy>(std::move(__first), std::move(__middle), std::move(__last), __comp);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last) {
  std::partial_sort(__first, __middle, __last, __less<>());
}

}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/blsr.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/blsr.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned __libcpp_blsr(unsigned __x) throw() {
  return __x ^ (__x & -__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long __libcpp_blsr(unsigned long __x) throw() {
  return __x ^ (__x & -__x);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long long __libcpp_blsr(unsigned long long __x) throw() {
  return __x ^ (__x & -__x);
}

}}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/countl.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/countl.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/countl.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

                  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int __libcpp_clz(unsigned __x) throw() {
  return __builtin_clz(__x);
}

                  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int __libcpp_clz(unsigned long __x) throw() {
  return __builtin_clzl(__x);
}

                  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int __libcpp_clz(unsigned long long __x) throw() {
  return __builtin_clzll(__x);
}


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int __libcpp_clz(__uint128_t __x) throw() {
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/countl.h" 3
  return ((__x >> 64) == 0) ? (64 + __builtin_clzll(static_cast<unsigned long long>(__x)))
                            : __builtin_clzll(static_cast<unsigned long long>(__x >> 64));
}


template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int __countl_zero(_Tp __t) throw() {
  _Static_assert(__libcpp_is_unsigned_integer<_Tp>::value, "__countl_zero requires an unsigned integer type");
  if (__t == 0)
    return numeric_limits<_Tp>::digits;

  if (sizeof(_Tp) <= sizeof(unsigned int))
    return std::__libcpp_clz(static_cast<unsigned int>(__t)) -
           (numeric_limits<unsigned int>::digits - numeric_limits<_Tp>::digits);
  else if (sizeof(_Tp) <= sizeof(unsigned long))
    return std::__libcpp_clz(static_cast<unsigned long>(__t)) -
           (numeric_limits<unsigned long>::digits - numeric_limits<_Tp>::digits);
  else if (sizeof(_Tp) <= sizeof(unsigned long long))
    return std::__libcpp_clz(static_cast<unsigned long long>(__t)) -
           (numeric_limits<unsigned long long>::digits - numeric_limits<_Tp>::digits);
  else {
    int __ret = 0;
    int __iter = 0;
    const unsigned int __ulldigits = numeric_limits<unsigned long long>::digits;
    while (true) {
      __t = std::__rotl(__t, __ulldigits);
      if ((__iter = std::__countl_zero(static_cast<unsigned long long>(__t))) != __ulldigits)
        break;
      __ret += __iter;
    }
    return __ret + __iter;
  }
}
# 98 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/countl.h" 3
}}
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort.h" 2 3
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _AlgPolicy, class _Compare, class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned
__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c) {
  using _Ops = _IterOps<_AlgPolicy>;

  unsigned __r = 0;
  if (!__c(*__y, *__x))
  {
    if (!__c(*__z, *__y))
      return __r;

    _Ops::iter_swap(__y, __z);
    __r = 1;
    if (__c(*__y, *__x))
    {
      _Ops::iter_swap(__x, __y);
      __r = 2;
    }
    return __r;
  }
  if (__c(*__z, *__y))
  {
    _Ops::iter_swap(__x, __z);
    __r = 1;
    return __r;
  }
  _Ops::iter_swap(__x, __y);
  __r = 1;
  if (__c(*__z, *__y))
  {
    _Ops::iter_swap(__y, __z);
    __r = 2;
  }
  return __r;
}



template <class _AlgPolicy, class _Compare, class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3, _ForwardIterator __x4, _Compare __c) {
  using _Ops = _IterOps<_AlgPolicy>;
  std::__sort3<_AlgPolicy, _Compare>(__x1, __x2, __x3, __c);
  if (__c(*__x4, *__x3)) {
    _Ops::iter_swap(__x3, __x4);
    if (__c(*__x3, *__x2)) {
      _Ops::iter_swap(__x2, __x3);
      if (__c(*__x2, *__x1)) {
        _Ops::iter_swap(__x1, __x2);
      }
    }
  }
}



template <class _AlgPolicy, class _Comp, class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__sort5(_ForwardIterator __x1,
        _ForwardIterator __x2,
        _ForwardIterator __x3,
        _ForwardIterator __x4,
        _ForwardIterator __x5,
        _Comp __comp) {
  using _Ops = _IterOps<_AlgPolicy>;

  std::__sort4<_AlgPolicy, _Comp>(__x1, __x2, __x3, __x4, __comp);
  if (__comp(*__x5, *__x4)) {
    _Ops::iter_swap(__x4, __x5);
    if (__comp(*__x4, *__x3)) {
      _Ops::iter_swap(__x3, __x4);
      if (__comp(*__x3, *__x2)) {
        _Ops::iter_swap(__x2, __x3);
        if (__comp(*__x2, *__x1)) {
          _Ops::iter_swap(__x1, __x2);
        }
      }
    }
  }
}


template <class _Tp>
struct __is_simple_comparator : false_type {};
template <>
struct __is_simple_comparator<__less<>&> : true_type {};
template <class _Tp>
struct __is_simple_comparator<less<_Tp>&> : true_type {};
template <class _Tp>
struct __is_simple_comparator<greater<_Tp>&> : true_type {};







template <class _Compare, class _Iter, class _Tp = typename iterator_traits<_Iter>::value_type>
using __use_branchless_sort =
    integral_constant<bool,
                      __libcpp_is_contiguous_iterator<_Iter>::value && sizeof(_Tp) <= sizeof(void*) &&
                          is_arithmetic<_Tp>::value && __is_simple_comparator<_Compare>::value>;

namespace __detail {


enum { __block_size = sizeof(uint64_t) * 8 };

}


template <class _Compare, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __cond_swap(_RandomAccessIterator __x, _RandomAccessIterator __y, _Compare __c) {

  using value_type = typename iterator_traits<_RandomAccessIterator>::value_type;
  bool __r = __c(*__x, *__y);
  value_type __tmp = __r ? *__x : *__y;
  *__y = __r ? *__y : *__x;
  *__x = __tmp;
}



template <class _Compare, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__partially_sorted_swap(_RandomAccessIterator __x, _RandomAccessIterator __y, _RandomAccessIterator __z, _Compare __c) {

  using value_type = typename iterator_traits<_RandomAccessIterator>::value_type;
  bool __r = __c(*__z, *__x);
  value_type __tmp = __r ? *__z : *__x;
  *__z = __r ? *__x : *__z;
  __r = __c(__tmp, *__y);
  *__x = __r ? *__x : *__y;
  *__y = __r ? *__y : __tmp;
}

template <class,
          class _Compare,
          class _RandomAccessIterator,
          __enable_if_t<__use_branchless_sort<_Compare, _RandomAccessIterator>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __sort3_maybe_branchless(
    _RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3, _Compare __c) {
  std::__cond_swap<_Compare>(__x2, __x3, __c);
  std::__partially_sorted_swap<_Compare>(__x1, __x2, __x3, __c);
}

template <class _AlgPolicy,
          class _Compare,
          class _RandomAccessIterator,
          __enable_if_t<!__use_branchless_sort<_Compare, _RandomAccessIterator>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __sort3_maybe_branchless(
    _RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3, _Compare __c) {
  std::__sort3<_AlgPolicy, _Compare>(__x1, __x2, __x3, __c);
}

template <class,
          class _Compare,
          class _RandomAccessIterator,
          __enable_if_t<__use_branchless_sort<_Compare, _RandomAccessIterator>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __sort4_maybe_branchless(
    _RandomAccessIterator __x1,
    _RandomAccessIterator __x2,
    _RandomAccessIterator __x3,
    _RandomAccessIterator __x4,
    _Compare __c) {
  std::__cond_swap<_Compare>(__x1, __x3, __c);
  std::__cond_swap<_Compare>(__x2, __x4, __c);
  std::__cond_swap<_Compare>(__x1, __x2, __c);
  std::__cond_swap<_Compare>(__x3, __x4, __c);
  std::__cond_swap<_Compare>(__x2, __x3, __c);
}

template <class _AlgPolicy,
          class _Compare,
          class _RandomAccessIterator,
          __enable_if_t<!__use_branchless_sort<_Compare, _RandomAccessIterator>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __sort4_maybe_branchless(
    _RandomAccessIterator __x1,
    _RandomAccessIterator __x2,
    _RandomAccessIterator __x3,
    _RandomAccessIterator __x4,
    _Compare __c) {
  std::__sort4<_AlgPolicy, _Compare>(__x1, __x2, __x3, __x4, __c);
}

template <class _AlgPolicy,
          class _Compare,
          class _RandomAccessIterator,
          __enable_if_t<__use_branchless_sort<_Compare, _RandomAccessIterator>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __sort5_maybe_branchless(
    _RandomAccessIterator __x1,
    _RandomAccessIterator __x2,
    _RandomAccessIterator __x3,
    _RandomAccessIterator __x4,
    _RandomAccessIterator __x5,
    _Compare __c) {
  std::__cond_swap<_Compare>(__x1, __x2, __c);
  std::__cond_swap<_Compare>(__x4, __x5, __c);
  std::__partially_sorted_swap<_Compare>(__x3, __x4, __x5, __c);
  std::__cond_swap<_Compare>(__x2, __x5, __c);
  std::__partially_sorted_swap<_Compare>(__x1, __x3, __x4, __c);
  std::__partially_sorted_swap<_Compare>(__x2, __x3, __x4, __c);
}

template <class _AlgPolicy,
          class _Compare,
          class _RandomAccessIterator,
          __enable_if_t<!__use_branchless_sort<_Compare, _RandomAccessIterator>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __sort5_maybe_branchless(
    _RandomAccessIterator __x1,
    _RandomAccessIterator __x2,
    _RandomAccessIterator __x3,
    _RandomAccessIterator __x4,
    _RandomAccessIterator __x5,
    _Compare __c) {
  std::__sort5<_AlgPolicy, _Compare, _RandomAccessIterator>(
      std::move(__x1), std::move(__x2), std::move(__x3), std::move(__x4), std::move(__x5), __c);
}


template <class _AlgPolicy, class _Compare, class _BidirectionalIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__selection_sort(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp) {
  _BidirectionalIterator __lm1 = __last;
  for (--__lm1; __first != __lm1; ++__first) {
    _BidirectionalIterator __i = std::__min_element<_Compare>(__first, __last, __comp);
    if (__i != __first)
      _IterOps<_AlgPolicy>::iter_swap(__first, __i);
  }
}



template <class _AlgPolicy, class _Compare, class _BidirectionalIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__insertion_sort(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp) {
  using _Ops = _IterOps<_AlgPolicy>;

  typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
  if (__first == __last)
    return;
  _BidirectionalIterator __i = __first;
  for (++__i; __i != __last; ++__i) {
    _BidirectionalIterator __j = __i;
    --__j;
    if (__comp(*__i, *__j)) {
      value_type __t(_Ops::__iter_move(__i));
      _BidirectionalIterator __k = __j;
      __j = __i;
      do {
        *__j = _Ops::__iter_move(__k);
        __j = __k;
      } while (__j != __first && __comp(__t, *--__k));
      *__j = std::move(__t);
    }
  }
}






template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__insertion_sort_unguarded(_RandomAccessIterator const __first, _RandomAccessIterator __last, _Compare __comp) {
  using _Ops = _IterOps<_AlgPolicy>;
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  if (__first == __last)
    return;
  const _RandomAccessIterator __leftmost = __first - difference_type(1);
  (void)__leftmost;
  for (_RandomAccessIterator __i = __first + difference_type(1); __i != __last; ++__i) {
    _RandomAccessIterator __j = __i - difference_type(1);
    if (__comp(*__i, *__j)) {
      value_type __t(_Ops::__iter_move(__i));
      _RandomAccessIterator __k = __j;
      __j = __i;
      do {
        *__j = _Ops::__iter_move(__k);
        __j = __k;
        ((void)0);


      } while (__comp(__t, *--__k));
      *__j = std::move(__t);
    }
  }
}

template <class _AlgPolicy, class _Comp, class _RandomAccessIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Comp __comp) {
  using _Ops = _IterOps<_AlgPolicy>;

  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  switch (__last - __first) {
  case 0:
  case 1:
    return true;
  case 2:
    if (__comp(*--__last, *__first))
      _Ops::iter_swap(__first, __last);
    return true;
  case 3:
    std::__sort3_maybe_branchless<_AlgPolicy, _Comp>(__first, __first + difference_type(1), --__last, __comp);
    return true;
  case 4:
    std::__sort4_maybe_branchless<_AlgPolicy, _Comp>(
        __first, __first + difference_type(1), __first + difference_type(2), --__last, __comp);
    return true;
  case 5:
    std::__sort5_maybe_branchless<_AlgPolicy, _Comp>(
        __first,
        __first + difference_type(1),
        __first + difference_type(2),
        __first + difference_type(3),
        --__last,
        __comp);
    return true;
  }
  typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  _RandomAccessIterator __j = __first + difference_type(2);
  std::__sort3_maybe_branchless<_AlgPolicy, _Comp>(__first, __first + difference_type(1), __j, __comp);
  const unsigned __limit = 8;
  unsigned __count = 0;
  for (_RandomAccessIterator __i = __j + difference_type(1); __i != __last; ++__i) {
    if (__comp(*__i, *__j)) {
      value_type __t(_Ops::__iter_move(__i));
      _RandomAccessIterator __k = __j;
      __j = __i;
      do {
        *__j = _Ops::__iter_move(__k);
        __j = __k;
      } while (__j != __first && __comp(__t, *--__k));
      *__j = std::move(__t);
      if (++__count == __limit)
        return ++__i == __last;
    }
    __j = __i;
  }
  return true;
}

template <class _AlgPolicy, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __swap_bitmap_pos(
    _RandomAccessIterator __first, _RandomAccessIterator __last, uint64_t& __left_bitset, uint64_t& __right_bitset) {
  using _Ops = _IterOps<_AlgPolicy>;
  typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type difference_type;


  while (__left_bitset != 0 && __right_bitset != 0) {
    difference_type __tz_left = __libcpp_ctz(__left_bitset);
    __left_bitset = __libcpp_blsr(__left_bitset);
    difference_type __tz_right = __libcpp_ctz(__right_bitset);
    __right_bitset = __libcpp_blsr(__right_bitset);
    _Ops::iter_swap(__first + __tz_left, __last - __tz_right);
  }
}

template <class _Compare,
          class _RandomAccessIterator,
          class _ValueType = typename iterator_traits<_RandomAccessIterator>::value_type>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__populate_left_bitset(_RandomAccessIterator __first, _Compare __comp, _ValueType& __pivot, uint64_t& __left_bitset) {


  _RandomAccessIterator __iter = __first;
  for (int __j = 0; __j < __detail::__block_size;) {
    bool __comp_result = !__comp(*__iter, __pivot);
    __left_bitset |= (static_cast<uint64_t>(__comp_result) << __j);
    __j++;
    ++__iter;
  }
}

template <class _Compare,
          class _RandomAccessIterator,
          class _ValueType = typename iterator_traits<_RandomAccessIterator>::value_type>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__populate_right_bitset(_RandomAccessIterator __lm1, _Compare __comp, _ValueType& __pivot, uint64_t& __right_bitset) {


  _RandomAccessIterator __iter = __lm1;
  for (int __j = 0; __j < __detail::__block_size;) {
    bool __comp_result = __comp(*__iter, __pivot);
    __right_bitset |= (static_cast<uint64_t>(__comp_result) << __j);
    __j++;
    --__iter;
  }
}

template <class _AlgPolicy,
          class _Compare,
          class _RandomAccessIterator,
          class _ValueType = typename iterator_traits<_RandomAccessIterator>::value_type>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __bitset_partition_partial_blocks(
    _RandomAccessIterator& __first,
    _RandomAccessIterator& __lm1,
    _Compare __comp,
    _ValueType& __pivot,
    uint64_t& __left_bitset,
    uint64_t& __right_bitset) {
  typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  difference_type __remaining_len = __lm1 - __first + 1;
  difference_type __l_size;
  difference_type __r_size;
  if (__left_bitset == 0 && __right_bitset == 0) {
    __l_size = __remaining_len / 2;
    __r_size = __remaining_len - __l_size;
  } else if (__left_bitset == 0) {

    __l_size = __remaining_len - __detail::__block_size;
    __r_size = __detail::__block_size;
  } else {
    __l_size = __detail::__block_size;
    __r_size = __remaining_len - __detail::__block_size;
  }

  if (__left_bitset == 0) {
    _RandomAccessIterator __iter = __first;
    for (int __j = 0; __j < __l_size; __j++) {
      bool __comp_result = !__comp(*__iter, __pivot);
      __left_bitset |= (static_cast<uint64_t>(__comp_result) << __j);
      ++__iter;
    }
  }


  if (__right_bitset == 0) {
    _RandomAccessIterator __iter = __lm1;
    for (int __j = 0; __j < __r_size; __j++) {
      bool __comp_result = __comp(*__iter, __pivot);
      __right_bitset |= (static_cast<uint64_t>(__comp_result) << __j);
      --__iter;
    }
  }
  std::__swap_bitmap_pos<_AlgPolicy, _RandomAccessIterator>(__first, __lm1, __left_bitset, __right_bitset);
  __first += (__left_bitset == 0) ? __l_size : 0;
  __lm1 -= (__right_bitset == 0) ? __r_size : 0;
}

template <class _AlgPolicy, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __swap_bitmap_pos_within(
    _RandomAccessIterator& __first, _RandomAccessIterator& __lm1, uint64_t& __left_bitset, uint64_t& __right_bitset) {
  using _Ops = _IterOps<_AlgPolicy>;
  typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  if (__left_bitset) {


    while (__left_bitset != 0) {
      difference_type __tz_left = __detail::__block_size - 1 - __libcpp_clz(__left_bitset);
      __left_bitset &= (static_cast<uint64_t>(1) << __tz_left) - 1;
      _RandomAccessIterator __it = __first + __tz_left;
      if (__it != __lm1) {
        _Ops::iter_swap(__it, __lm1);
      }
      --__lm1;
    }
    __first = __lm1 + difference_type(1);
  } else if (__right_bitset) {


    while (__right_bitset != 0) {
      difference_type __tz_right = __detail::__block_size - 1 - __libcpp_clz(__right_bitset);
      __right_bitset &= (static_cast<uint64_t>(1) << __tz_right) - 1;
      _RandomAccessIterator __it = __lm1 - __tz_right;
      if (__it != __first) {
        _Ops::iter_swap(__it, __first);
      }
      ++__first;
    }
  }
}
# 533 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort.h" 3
template <class _AlgPolicy, class _RandomAccessIterator, class _Compare>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) std::pair<_RandomAccessIterator, bool>
__bitset_partition(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  using _Ops = _IterOps<_AlgPolicy>;
  typedef typename std::iterator_traits<_RandomAccessIterator>::value_type value_type;
  typedef typename std::iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  ((void)0);
  const _RandomAccessIterator __begin = __first;
  const _RandomAccessIterator __end = __last;
  (void)__end;

  value_type __pivot(_Ops::__iter_move(__first));

  if (__comp(__pivot, *(__last - difference_type(1)))) {

    do {
      ++__first;
      ((void)0);


    } while (!__comp(__pivot, *__first));
  } else {
    while (++__first < __last && !__comp(__pivot, *__first)) {
    }
  }

  if (__first < __last) {


    do {
      ((void)0);


      --__last;
    } while (__comp(__pivot, *__last));
  }




  bool __already_partitioned = __first >= __last;
  if (!__already_partitioned) {
    _Ops::iter_swap(__first, __last);
    ++__first;
  }



  _RandomAccessIterator __lm1 = __last - difference_type(1);
  uint64_t __left_bitset = 0;
  uint64_t __right_bitset = 0;


  while (__lm1 - __first >= 2 * __detail::__block_size - 1) {


    if (__left_bitset == 0)
      std::__populate_left_bitset<_Compare>(__first, __comp, __pivot, __left_bitset);


    if (__right_bitset == 0)
      std::__populate_right_bitset<_Compare>(__lm1, __comp, __pivot, __right_bitset);


    std::__swap_bitmap_pos<_AlgPolicy, _RandomAccessIterator>(__first, __lm1, __left_bitset, __right_bitset);


    __first += (__left_bitset == 0) ? difference_type(__detail::__block_size) : difference_type(0);
    __lm1 -= (__right_bitset == 0) ? difference_type(__detail::__block_size) : difference_type(0);
  }


  std::__bitset_partition_partial_blocks<_AlgPolicy, _Compare>(
      __first, __lm1, __comp, __pivot, __left_bitset, __right_bitset);


  std::__swap_bitmap_pos_within<_AlgPolicy>(__first, __lm1, __left_bitset, __right_bitset);


  _RandomAccessIterator __pivot_pos = __first - difference_type(1);
  if (__begin != __pivot_pos) {
    *__begin = _Ops::__iter_move(__pivot_pos);
  }
  *__pivot_pos = std::move(__pivot);
  return std::make_pair(__pivot_pos, __already_partitioned);
}






template <class _AlgPolicy, class _RandomAccessIterator, class _Compare>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) std::pair<_RandomAccessIterator, bool>
__partition_with_equals_on_right(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  using _Ops = _IterOps<_AlgPolicy>;
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  typedef typename std::iterator_traits<_RandomAccessIterator>::value_type value_type;
  ((void)0);
  const _RandomAccessIterator __begin = __first;
  const _RandomAccessIterator __end = __last;
  (void)__end;
  value_type __pivot(_Ops::__iter_move(__first));



  do {
    ++__first;
    ((void)0);


  } while (__comp(*__first, __pivot));


  if (__begin == __first - difference_type(1)) {
    while (__first < __last && !__comp(*--__last, __pivot))
      ;
  } else {

    do {
      ((void)0);


      --__last;
    } while (!__comp(*__last, __pivot));
  }




  bool __already_partitioned = __first >= __last;



  while (__first < __last) {
    _Ops::iter_swap(__first, __last);
    do {
      ++__first;
      ((void)0);


    } while (__comp(*__first, __pivot));
    do {
      ((void)0);


      --__last;
    } while (!__comp(*__last, __pivot));
  }

  _RandomAccessIterator __pivot_pos = __first - difference_type(1);
  if (__begin != __pivot_pos) {
    *__begin = _Ops::__iter_move(__pivot_pos);
  }
  *__pivot_pos = std::move(__pivot);
  return std::make_pair(__pivot_pos, __already_partitioned);
}



template <class _AlgPolicy, class _RandomAccessIterator, class _Compare>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _RandomAccessIterator
__partition_with_equals_on_left(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  using _Ops = _IterOps<_AlgPolicy>;
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  typedef typename std::iterator_traits<_RandomAccessIterator>::value_type value_type;

  _RandomAccessIterator __begin = __first;
  const _RandomAccessIterator __end = __last;
  (void)__end;
  value_type __pivot(_Ops::__iter_move(__first));
  if (__comp(__pivot, *(__last - difference_type(1)))) {

    do {
      ++__first;
      ((void)0);


    } while (!__comp(__pivot, *__first));
  } else {
    while (++__first < __last && !__comp(__pivot, *__first)) {
    }
  }

  if (__first < __last) {


    do {
      ((void)0);


      --__last;
    } while (__comp(__pivot, *__last));
  }
  while (__first < __last) {
    _Ops::iter_swap(__first, __last);
    do {
      ++__first;
      ((void)0);


    } while (!__comp(__pivot, *__first));
    do {
      ((void)0);


      --__last;
    } while (__comp(__pivot, *__last));
  }
  _RandomAccessIterator __pivot_pos = __first - difference_type(1);
  if (__begin != __pivot_pos) {
    *__begin = _Ops::__iter_move(__pivot_pos);
  }
  *__pivot_pos = std::move(__pivot);
  return __first;
}
# 757 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort.h" 3
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator, bool _UseBitSetPartition>
void __introsort(_RandomAccessIterator __first,
                 _RandomAccessIterator __last,
                 _Compare __comp,
                 typename iterator_traits<_RandomAccessIterator>::difference_type __depth,
                 bool __leftmost = true) {
  using _Ops = _IterOps<_AlgPolicy>;
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  using _Comp_ref = __comp_ref_type<_Compare>;

                    difference_type __limit = 24;

                    difference_type __ninther_threshold = 128;
  while (true) {
    difference_type __len = __last - __first;
    switch (__len) {
    case 0:
    case 1:
      return;
    case 2:
      if (__comp(*--__last, *__first))
        _Ops::iter_swap(__first, __last);
      return;
    case 3:
      std::__sort3_maybe_branchless<_AlgPolicy, _Compare>(__first, __first + difference_type(1), --__last, __comp);
      return;
    case 4:
      std::__sort4_maybe_branchless<_AlgPolicy, _Compare>(
          __first, __first + difference_type(1), __first + difference_type(2), --__last, __comp);
      return;
    case 5:
      std::__sort5_maybe_branchless<_AlgPolicy, _Compare>(
          __first,
          __first + difference_type(1),
          __first + difference_type(2),
          __first + difference_type(3),
          --__last,
          __comp);
      return;
    }

    if (__len < __limit) {
      if (__leftmost) {
        std::__insertion_sort<_AlgPolicy, _Compare>(__first, __last, __comp);
      } else {
        std::__insertion_sort_unguarded<_AlgPolicy, _Compare>(__first, __last, __comp);
      }
      return;
    }
    if (__depth == 0) {

      std::__partial_sort<_AlgPolicy, _Compare>(__first, __last, __last, __comp);
      return;
    }
    --__depth;
    {
      difference_type __half_len = __len / 2;


      if (__len > __ninther_threshold) {
        std::__sort3<_AlgPolicy, _Compare>(__first, __first + __half_len, __last - difference_type(1), __comp);
        std::__sort3<_AlgPolicy, _Compare>(
            __first + difference_type(1), __first + (__half_len - 1), __last - difference_type(2), __comp);
        std::__sort3<_AlgPolicy, _Compare>(
            __first + difference_type(2), __first + (__half_len + 1), __last - difference_type(3), __comp);
        std::__sort3<_AlgPolicy, _Compare>(
            __first + (__half_len - 1), __first + __half_len, __first + (__half_len + 1), __comp);
        _Ops::iter_swap(__first, __first + __half_len);
      } else {
        std::__sort3<_AlgPolicy, _Compare>(__first + __half_len, __first, __last - difference_type(1), __comp);
      }
    }
# 837 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort.h" 3
    if (!__leftmost && !__comp(*(__first - difference_type(1)), *__first)) {
      __first = std::__partition_with_equals_on_left<_AlgPolicy, _RandomAccessIterator, _Comp_ref>(
          __first, __last, _Comp_ref(__comp));
      continue;
    }

    auto __ret = _UseBitSetPartition
                                  ? std::__bitset_partition<_AlgPolicy, _RandomAccessIterator, _Compare>(__first, __last, __comp)
                                  : std::__partition_with_equals_on_right<_AlgPolicy, _RandomAccessIterator, _Compare>(
                         __first, __last, __comp);
    _RandomAccessIterator __i = __ret.first;


    if (__ret.second) {
      bool __fs = std::__insertion_sort_incomplete<_AlgPolicy, _Compare>(__first, __i, __comp);
      if (std::__insertion_sort_incomplete<_AlgPolicy, _Compare>(__i + difference_type(1), __last, __comp)) {
        if (__fs)
          return;
        __last = __i;
        continue;
      } else {
        if (__fs) {
          __first = ++__i;
          continue;
        }
      }
    }

    std::__introsort<_AlgPolicy, _Compare, _RandomAccessIterator, _UseBitSetPartition>(
        __first, __i, __comp, __depth, __leftmost);
    __leftmost = false;
    __first = ++__i;
  }
}

template <typename _Number>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Number __log2i(_Number __n) {
  if (__n == 0)
    return 0;
  if (sizeof(__n) <= sizeof(unsigned))
    return sizeof(unsigned) * 8 - 1 - __libcpp_clz(static_cast<unsigned>(__n));
  if (sizeof(__n) <= sizeof(unsigned long))
    return sizeof(unsigned long) * 8 - 1 - __libcpp_clz(static_cast<unsigned long>(__n));
  if (sizeof(__n) <= sizeof(unsigned long long))
    return sizeof(unsigned long long) * 8 - 1 - __libcpp_clz(static_cast<unsigned long long>(__n));

  _Number __log2 = 0;
  while (__n > 1) {
    __log2++;
    __n >>= 1;
  }
  return __log2;
}

template <class _Comp, class _RandomAccessIterator>
void __sort(_RandomAccessIterator, _RandomAccessIterator, _Comp);

extern template __attribute__((__visibility__("default"))) void __sort<__less<char>&, char*>(char*, char*, __less<char>&);

extern template __attribute__((__visibility__("default"))) void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&);

extern template __attribute__((__visibility__("default"))) void
__sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&);
extern template __attribute__((__visibility__("default"))) void
__sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<short>&, short*>(short*, short*, __less<short>&);
extern template __attribute__((__visibility__("default"))) void
__sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<int>&, int*>(int*, int*, __less<int>&);
extern template __attribute__((__visibility__("default"))) void
__sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<long>&, long*>(long*, long*, __less<long>&);
extern template __attribute__((__visibility__("default"))) void
__sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&);
extern template __attribute__((__visibility__("default"))) void
__sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<unsigned long long>&, unsigned long long*>(
    unsigned long long*, unsigned long long*, __less<unsigned long long>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<float>&, float*>(float*, float*, __less<float>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<double>&, double*>(double*, double*, __less<double>&);
extern template __attribute__((__visibility__("default"))) void
__sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&);

template <class _AlgPolicy, class _RandomAccessIterator, class _Comp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__sort_dispatch(_RandomAccessIterator __first, _RandomAccessIterator __last, _Comp& __comp) {
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  difference_type __depth_limit = 2 * std::__log2i(__last - __first);




  std::__introsort<_AlgPolicy,
                   _Comp&,
                   _RandomAccessIterator,
                   __use_branchless_sort<_Comp, _RandomAccessIterator>::value>(__first, __last, __comp, __depth_limit);
}

template <class _Type, class... _Options>
using __is_any_of = _Or<is_same<_Type, _Options>...>;

template <class _Type>
using __sort_is_specialized_in_library = __is_any_of<
    _Type,
    char,

    wchar_t,

    signed char,
    unsigned char,
    short,
    unsigned short,
    int,
    unsigned int,
    long,
    unsigned long,
    long long,
    unsigned long long,
    float,
    double,
    long double>;

template <class _AlgPolicy, class _Type, __enable_if_t<__sort_is_specialized_in_library<_Type>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __sort_dispatch(_Type* __first, _Type* __last, __less<>&) {
  __less<_Type> __comp;
  std::__sort<__less<_Type>&, _Type*>(__first, __last, __comp);
}

template <class _AlgPolicy, class _Type, __enable_if_t<__sort_is_specialized_in_library<_Type>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __sort_dispatch(_Type* __first, _Type* __last, less<_Type>&) {
  __less<_Type> __comp;
  std::__sort<__less<_Type>&, _Type*>(__first, __last, __comp);
}
# 987 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sort.h" 3
template <class _AlgPolicy, class _RandomAccessIterator, class _Comp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__sort_impl(_RandomAccessIterator __first, _RandomAccessIterator __last, _Comp& __comp) {
  std::__debug_randomize_range<_AlgPolicy>(__first, __last);

  if (__libcpp_is_constant_evaluated()) {
    std::__partial_sort<_AlgPolicy>(
        std::__unwrap_iter(__first), std::__unwrap_iter(__last), std::__unwrap_iter(__last), __comp);
  } else {
    std::__sort_dispatch<_AlgPolicy>(std::__unwrap_iter(__first), std::__unwrap_iter(__last), __comp);
  }
  std::__check_strict_weak_ordering_sorted(std::__unwrap_iter(__first), std::__unwrap_iter(__last), __comp);
}

template <class _RandomAccessIterator, class _Comp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Comp __comp) {
  std::__sort_impl<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::sort(__first, __last, __less<>());
}

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/nth_element.h" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/nth_element.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/nth_element.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Compare, class _RandomAccessIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __nth_element_find_guard(
    _RandomAccessIterator& __i, _RandomAccessIterator& __j, _RandomAccessIterator __m, _Compare __comp) {

  while (true) {
    if (__i == --__j) {
      return false;
    }
    if (__comp(*__j, *__m)) {
      return true;
    }
  }
}

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void

__nth_element(
    _RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp) {
  using _Ops = _IterOps<_AlgPolicy>;


  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  const difference_type __limit = 7;
  while (true) {
    if (__nth == __last)
      return;
    difference_type __len = __last - __first;
    switch (__len) {
    case 0:
    case 1:
      return;
    case 2:
      if (__comp(*--__last, *__first))
        _Ops::iter_swap(__first, __last);
      return;
    case 3: {
      _RandomAccessIterator __m = __first;
      std::__sort3<_AlgPolicy, _Compare>(__first, ++__m, --__last, __comp);
      return;
    }
    }
    if (__len <= __limit) {
      std::__selection_sort<_AlgPolicy, _Compare>(__first, __last, __comp);
      return;
    }

    _RandomAccessIterator __m = __first + __len / 2;
    _RandomAccessIterator __lm1 = __last;
    unsigned __n_swaps = std::__sort3<_AlgPolicy, _Compare>(__first, __m, --__lm1, __comp);



    _RandomAccessIterator __i = __first;
    _RandomAccessIterator __j = __lm1;



    if (!__comp(*__i, *__m))
    {

      if (std::__nth_element_find_guard<_Compare>(__i, __j, __m, __comp)) {
        _Ops::iter_swap(__i, __j);
        ++__n_swaps;
      } else {


        ++__i;
        __j = __last;
        if (!__comp(*__first, *--__j)) {
          while (true) {
            if (__i == __j) {
              return;
            } else if (__comp(*__first, *__i)) {
              _Ops::iter_swap(__i, __j);
              ++__n_swaps;
              ++__i;
              break;
            }
            ++__i;
          }
        }

        if (__i == __j) {
          return;
        }
        while (true) {
          while (!__comp(*__first, *__i)) {
            ++__i;
            ((void)0);


          }
          do {
            ((void)0);


            --__j;
          } while (__comp(*__first, *__j));
          if (__i >= __j)
            break;
          _Ops::iter_swap(__i, __j);
          ++__n_swaps;
          ++__i;
        }


        if (__nth < __i) {
          return;
        }


        __first = __i;
        continue;
      }
    }
    ++__i;


    if (__i < __j) {

      while (true) {

        while (__comp(*__i, *__m)) {
          ++__i;
          ((void)0);


        }

        do {
          ((void)0);


          --__j;
        } while (!__comp(*__j, *__m));
        if (__i >= __j)
          break;
        _Ops::iter_swap(__i, __j);
        ++__n_swaps;


        if (__m == __i)
          __m = __j;
        ++__i;
      }
    }

    if (__i != __m && __comp(*__m, *__i)) {
      _Ops::iter_swap(__i, __m);
      ++__n_swaps;
    }

    if (__nth == __i)
      return;
    if (__n_swaps == 0) {

      if (__nth < __i) {

        __j = __m = __first;
        while (true) {
          if (++__j == __i) {

            return;
          }
          if (__comp(*__j, *__m)) {

            break;
          }
          __m = __j;
        }
      } else {

        __j = __m = __i;
        while (true) {
          if (++__j == __last) {

            return;
          }
          if (__comp(*__j, *__m)) {

            break;
          }
          __m = __j;
        }
      }
    }

    if (__nth < __i) {

      __last = __i;
    } else {

      __first = ++__i;
    }
  }
}

template <class _AlgPolicy, class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __nth_element_impl(
    _RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare& __comp) {
  if (__nth == __last)
    return;

  std::__debug_randomize_range<_AlgPolicy>(__first, __last);

  std::__nth_element<_AlgPolicy, __comp_ref_type<_Compare> >(__first, __nth, __last, __comp);

  std::__debug_randomize_range<_AlgPolicy>(__first, __nth);
  if (__nth != __last) {
    std::__debug_randomize_range<_AlgPolicy>(++__nth, __last);
  }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp) {
  std::__nth_element_impl<_ClassicAlgPolicy>(std::move(__first), std::move(__nth), std::move(__last), __comp);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last) {
  std::nth_element(std::move(__first), std::move(__nth), std::move(__last), __less<>());
}

}}
# 1848 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort_copy.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort_copy.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/make_projected.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/make_projected.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Pred, class _Proj>
struct _ProjectedPred {
  _Pred& __pred;
  _Proj& __proj;

                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ProjectedPred(_Pred& __pred_arg, _Proj& __proj_arg)
      : __pred(__pred_arg), __proj(__proj_arg) {}

  template <class _Tp>
  typename __invoke_of<_Pred&, __decltype(std::__invoke(std::declval<_Proj&>(), std::declval<_Tp>())) >::
      type __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
      operator()(_Tp&& __v) const {
    return std::__invoke(__pred, std::__invoke(__proj, std::forward<_Tp>(__v)));
  }

  template <class _T1, class _T2>
  typename __invoke_of<_Pred&,
                       __decltype(std::__invoke(std::declval<_Proj&>(), std::declval<_T1>())),
                       __decltype(std::__invoke(std::declval<_Proj&>(), std::declval<_T2>())) >::type __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))

  operator()(_T1&& __lhs, _T2&& __rhs) const {
    return std::__invoke(
        __pred, std::__invoke(__proj, std::forward<_T1>(__lhs)), std::__invoke(__proj, std::forward<_T2>(__rhs)));
  }
};

template <
    class _Pred,
    class _Proj,
    __enable_if_t<!(!is_member_pointer<__decay_t<_Pred> >::value && __is_identity<__decay_t<_Proj> >::value), int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ProjectedPred<_Pred, _Proj> __make_projected(_Pred& __pred, _Proj& __proj) {
  return _ProjectedPred<_Pred, _Proj>(__pred, __proj);
}




template <
    class _Pred,
    class _Proj,
    __enable_if_t<!is_member_pointer<__decay_t<_Pred> >::value && __is_identity<__decay_t<_Proj> >::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Pred& __make_projected(_Pred& __pred, _Proj&) {
  return __pred;
}

}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort_copy.h" 2 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort_copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partial_sort_copy.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy,
          class _Compare,
          class _InputIterator,
          class _Sentinel1,
          class _RandomAccessIterator,
          class _Sentinel2,
          class _Proj1,
          class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InputIterator, _RandomAccessIterator> __partial_sort_copy(
    _InputIterator __first,
    _Sentinel1 __last,
    _RandomAccessIterator __result_first,
    _Sentinel2 __result_last,
    _Compare&& __comp,
    _Proj1&& __proj1,
    _Proj2&& __proj2) {
  _RandomAccessIterator __r = __result_first;
  auto&& __projected_comp = std::__make_projected(__comp, __proj2);

  if (__r != __result_last) {
    for (; __first != __last && __r != __result_last; ++__first, (void)++__r)
      *__r = *__first;
    std::__make_heap<_AlgPolicy>(__result_first, __r, __projected_comp);
    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;
    for (; __first != __last; ++__first)
      if (std::__invoke(__comp, std::__invoke(__proj1, *__first), std::__invoke(__proj2, *__result_first))) {
        *__result_first = *__first;
        std::__sift_down<_AlgPolicy>(__result_first, __projected_comp, __len, __result_first);
      }
    std::__sort_heap<_AlgPolicy>(__result_first, __r, __projected_comp);
  }

  return pair<_InputIterator, _RandomAccessIterator>(
      _IterOps<_AlgPolicy>::next(std::move(__first), std::move(__last)), std::move(__r));
}

template <class _InputIterator, class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _RandomAccessIterator partial_sort_copy(
    _InputIterator __first,
    _InputIterator __last,
    _RandomAccessIterator __result_first,
    _RandomAccessIterator __result_last,
    _Compare __comp) {
  _Static_assert(__is_callable<_Compare, __decltype(*__first), __decltype(*__result_first)>::value, "Comparator has to be callable");


  auto __result = std::__partial_sort_copy<_ClassicAlgPolicy>(
      __first,
      __last,
      __result_first,
      __result_last,
      static_cast<__comp_ref_type<_Compare> >(__comp),
      __identity(),
      __identity());
  return __result.second;
}

template <class _InputIterator, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _RandomAccessIterator partial_sort_copy(
    _InputIterator __first,
    _InputIterator __last,
    _RandomAccessIterator __result_first,
    _RandomAccessIterator __result_last) {
  return std::partial_sort_copy(__first, __last, __result_first, __result_last, __less<>());
}

}}
# 1850 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partition.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partition.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partition.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Predicate, class _AlgPolicy, class _ForwardIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_ForwardIterator, _ForwardIterator>
__partition_impl(_ForwardIterator __first, _Sentinel __last, _Predicate __pred, forward_iterator_tag) {
  while (true) {
    if (__first == __last)
      return std::make_pair(std::move(__first), std::move(__first));
    if (!__pred(*__first))
      break;
    ++__first;
  }

  _ForwardIterator __p = __first;
  while (++__p != __last) {
    if (__pred(*__p)) {
      _IterOps<_AlgPolicy>::iter_swap(__first, __p);
      ++__first;
    }
  }
  return std::make_pair(std::move(__first), std::move(__p));
}

template <class _Predicate, class _AlgPolicy, class _BidirectionalIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_BidirectionalIterator, _BidirectionalIterator>
__partition_impl(_BidirectionalIterator __first, _Sentinel __sentinel, _Predicate __pred, bidirectional_iterator_tag) {
  _BidirectionalIterator __original_last = _IterOps<_AlgPolicy>::next(__first, __sentinel);
  _BidirectionalIterator __last = __original_last;

  while (true) {
    while (true) {
      if (__first == __last)
        return std::make_pair(std::move(__first), std::move(__original_last));
      if (!__pred(*__first))
        break;
      ++__first;
    }
    do {
      if (__first == --__last)
        return std::make_pair(std::move(__first), std::move(__original_last));
    } while (!__pred(*__last));
    _IterOps<_AlgPolicy>::iter_swap(__first, __last);
    ++__first;
  }
}

template <class _AlgPolicy, class _ForwardIterator, class _Sentinel, class _Predicate, class _IterCategory>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_ForwardIterator, _ForwardIterator>
__partition(_ForwardIterator __first, _Sentinel __last, _Predicate&& __pred, _IterCategory __iter_category) {
  return std::__partition_impl<__remove_cvref_t<_Predicate>&, _AlgPolicy>(
      std::move(__first), std::move(__last), __pred, __iter_category);
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {
  using _IterCategory = typename iterator_traits<_ForwardIterator>::iterator_category;
  auto __result = std::__partition<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __pred, _IterCategory());
  return __result.first;
}

}}
# 1851 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partition_copy.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partition_copy.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _OutputIterator1, class _OutputIterator2, class _Predicate>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_OutputIterator1, _OutputIterator2> partition_copy(
    _InputIterator __first,
    _InputIterator __last,
    _OutputIterator1 __out_true,
    _OutputIterator2 __out_false,
    _Predicate __pred) {
  for (; __first != __last; ++__first) {
    if (__pred(*__first)) {
      *__out_true = *__first;
      ++__out_true;
    } else {
      *__out_false = *__first;
      ++__out_false;
    }
  }
  return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
}

}}
# 1852 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partition_point.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/partition_point.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator, class _Predicate>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
partition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {
  typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
  difference_type __len = std::distance(__first, __last);
  while (__len != 0) {
    difference_type __l2 = std::__half_positive(__len);
    _ForwardIterator __m = __first;
    std::advance(__m, __l2);
    if (__pred(*__m)) {
      __first = ++__m;
      __len -= __l2 + 1;
    } else
      __len = __l2;
  }
  return __first;
}

}}
# 1853 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/prev_permutation.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/prev_permutation.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/prev_permutation.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _BidirectionalIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_BidirectionalIterator, bool>
__prev_permutation(_BidirectionalIterator __first, _Sentinel __last, _Compare&& __comp) {
  using _Result = pair<_BidirectionalIterator, bool>;

  _BidirectionalIterator __last_iter = _IterOps<_AlgPolicy>::next(__first, __last);
  _BidirectionalIterator __i = __last_iter;
  if (__first == __last || __first == --__i)
    return _Result(std::move(__last_iter), false);

  while (true) {
    _BidirectionalIterator __ip1 = __i;
    if (__comp(*__ip1, *--__i)) {
      _BidirectionalIterator __j = __last_iter;
      while (!__comp(*--__j, *__i))
        ;
      _IterOps<_AlgPolicy>::iter_swap(__i, __j);
      std::__reverse<_AlgPolicy>(__ip1, __last_iter);
      return _Result(std::move(__last_iter), true);
    }
    if (__i == __first) {
      std::__reverse<_AlgPolicy>(__first, __last_iter);
      return _Result(std::move(__last_iter), false);
    }
  }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp) {
  return std::__prev_permutation<_ClassicAlgPolicy>(
             std::move(__first), std::move(__last), static_cast<__comp_ref_type<_Compare> >(__comp))
      .second;
}

template <class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last) {
  return std::prev_permutation(__first, __last, __less<>());
}

}}
# 1855 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_any_all_none_of.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_any_all_none_of.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_find.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_find.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backend.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backend.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backend.h" 1 3
# 58 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backend.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/any_of.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/any_of.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/backend.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/backend.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/libdispatch.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/libdispatch.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__numeric/reduce.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__numeric/reduce.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__numeric/reduce.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__numeric/reduce.h" 3
}}
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/libdispatch.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/empty.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/empty.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct __empty {};

}}
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/libdispatch.h" 2 3








# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/libdispatch.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/backend.h" 2 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/backend.h" 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/any_of.h" 2 3





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_execution_policy.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_execution_policy.h" 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/any_of.h" 2 3
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backend.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/fill.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/fill.h" 3
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backend.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/find_if.h" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/find_if.h" 3
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backend.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/for_each.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/for_each.h" 3
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backend.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/merge.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/merge.h" 3
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backend.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/stable_sort.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/stable_sort.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_sort.h" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_sort.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_sort.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Compare, class _BidirectionalIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __insertion_sort_move(
    _BidirectionalIterator __first1,
    _BidirectionalIterator __last1,
    typename iterator_traits<_BidirectionalIterator>::value_type* __first2,
    _Compare __comp) {
  using _Ops = _IterOps<_AlgPolicy>;

  typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
  if (__first1 != __last1) {
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h(__first2, __d);
    value_type* __last2 = __first2;
    ::new ((void*)__last2) value_type(_Ops::__iter_move(__first1));
    __d.template __incr<value_type>();
    for (++__last2; ++__first1 != __last1; ++__last2) {
      value_type* __j2 = __last2;
      value_type* __i2 = __j2;
      if (__comp(*__first1, *--__i2)) {
        ::new ((void*)__j2) value_type(std::move(*__i2));
        __d.template __incr<value_type>();
        for (--__j2; __i2 != __first2 && __comp(*__first1, *--__i2); --__j2)
          *__j2 = std::move(*__i2);
        *__j2 = _Ops::__iter_move(__first1);
      } else {
        ::new ((void*)__j2) value_type(_Ops::__iter_move(__first1));
        __d.template __incr<value_type>();
      }
    }
    __h.release();
  }
}

template <class _AlgPolicy, class _Compare, class _InputIterator1, class _InputIterator2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __merge_move_construct(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    typename iterator_traits<_InputIterator1>::value_type* __result,
    _Compare __comp) {
  using _Ops = _IterOps<_AlgPolicy>;

  typedef typename iterator_traits<_InputIterator1>::value_type value_type;
  __destruct_n __d(0);
  unique_ptr<value_type, __destruct_n&> __h(__result, __d);
  for (; true; ++__result) {
    if (__first1 == __last1) {
      for (; __first2 != __last2; ++__first2, (void)++__result, __d.template __incr<value_type>())
        ::new ((void*)__result) value_type(_Ops::__iter_move(__first2));
      __h.release();
      return;
    }
    if (__first2 == __last2) {
      for (; __first1 != __last1; ++__first1, (void)++__result, __d.template __incr<value_type>())
        ::new ((void*)__result) value_type(_Ops::__iter_move(__first1));
      __h.release();
      return;
    }
    if (__comp(*__first2, *__first1)) {
      ::new ((void*)__result) value_type(_Ops::__iter_move(__first2));
      __d.template __incr<value_type>();
      ++__first2;
    } else {
      ::new ((void*)__result) value_type(_Ops::__iter_move(__first1));
      __d.template __incr<value_type>();
      ++__first1;
    }
  }
}

template <class _AlgPolicy, class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __merge_move_assign(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result,
    _Compare __comp) {
  using _Ops = _IterOps<_AlgPolicy>;

  for (; __first1 != __last1; ++__result) {
    if (__first2 == __last2) {
      for (; __first1 != __last1; ++__first1, (void)++__result)
        *__result = _Ops::__iter_move(__first1);
      return;
    }
    if (__comp(*__first2, *__first1)) {
      *__result = _Ops::__iter_move(__first2);
      ++__first2;
    } else {
      *__result = _Ops::__iter_move(__first1);
      ++__first1;
    }
  }
  for (; __first2 != __last2; ++__first2, (void)++__result)
    *__result = _Ops::__iter_move(__first2);
}

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
void __stable_sort(_RandomAccessIterator __first,
                   _RandomAccessIterator __last,
                   _Compare __comp,
                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,
                   typename iterator_traits<_RandomAccessIterator>::value_type* __buff,
                   ptrdiff_t __buff_size);

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
void __stable_sort_move(_RandomAccessIterator __first1,
                        _RandomAccessIterator __last1,
                        _Compare __comp,
                        typename iterator_traits<_RandomAccessIterator>::difference_type __len,
                        typename iterator_traits<_RandomAccessIterator>::value_type* __first2) {
  using _Ops = _IterOps<_AlgPolicy>;

  typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  switch (__len) {
  case 0:
    return;
  case 1:
    ::new ((void*)__first2) value_type(_Ops::__iter_move(__first1));
    return;
  case 2:
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);
    if (__comp(*--__last1, *__first1)) {
      ::new ((void*)__first2) value_type(_Ops::__iter_move(__last1));
      __d.template __incr<value_type>();
      ++__first2;
      ::new ((void*)__first2) value_type(_Ops::__iter_move(__first1));
    } else {
      ::new ((void*)__first2) value_type(_Ops::__iter_move(__first1));
      __d.template __incr<value_type>();
      ++__first2;
      ::new ((void*)__first2) value_type(_Ops::__iter_move(__last1));
    }
    __h2.release();
    return;
  }
  if (__len <= 8) {
    std::__insertion_sort_move<_AlgPolicy, _Compare>(__first1, __last1, __first2, __comp);
    return;
  }
  typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
  _RandomAccessIterator __m = __first1 + __l2;
  std::__stable_sort<_AlgPolicy, _Compare>(__first1, __m, __comp, __l2, __first2, __l2);
  std::__stable_sort<_AlgPolicy, _Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);
  std::__merge_move_construct<_AlgPolicy, _Compare>(__first1, __m, __m, __last1, __first2, __comp);
}

template <class _Tp>
struct __stable_sort_switch {
  static const unsigned value = 128 * is_trivially_copy_assignable<_Tp>::value;
};

template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
void __stable_sort(_RandomAccessIterator __first,
                   _RandomAccessIterator __last,
                   _Compare __comp,
                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,
                   typename iterator_traits<_RandomAccessIterator>::value_type* __buff,
                   ptrdiff_t __buff_size) {
  typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  switch (__len) {
  case 0:
  case 1:
    return;
  case 2:
    if (__comp(*--__last, *__first))
      _IterOps<_AlgPolicy>::iter_swap(__first, __last);
    return;
  }
  if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value)) {
    std::__insertion_sort<_AlgPolicy, _Compare>(__first, __last, __comp);
    return;
  }
  typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
  _RandomAccessIterator __m = __first + __l2;
  if (__len <= __buff_size) {
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
    std::__stable_sort_move<_AlgPolicy, _Compare>(__first, __m, __comp, __l2, __buff);
    __d.__set(__l2, (value_type*)__nullptr);
    std::__stable_sort_move<_AlgPolicy, _Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);
    __d.__set(__len, (value_type*)__nullptr);
    std::__merge_move_assign<_AlgPolicy, _Compare>(
        __buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);





    return;
  }
  std::__stable_sort<_AlgPolicy, _Compare>(__first, __m, __comp, __l2, __buff, __buff_size);
  std::__stable_sort<_AlgPolicy, _Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);
  std::__inplace_merge<_AlgPolicy>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);
}

template <class _AlgPolicy, class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__stable_sort_impl(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare& __comp) {
  using value_type = typename iterator_traits<_RandomAccessIterator>::value_type;
  using difference_type = typename iterator_traits<_RandomAccessIterator>::difference_type;

  difference_type __len = __last - __first;
  pair<value_type*, ptrdiff_t> __buf(0, 0);
  unique_ptr<value_type, __return_temporary_buffer> __h;
  if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value)) {

#pragma GCC diagnostic push
# 248 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_sort.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 248 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_sort.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    __buf = std::get_temporary_buffer<value_type>(__len);
#pragma GCC diagnostic pop
    __h.reset(__buf.first);
  }

  std::__stable_sort<_AlgPolicy, __comp_ref_type<_Compare> >(__first, __last, __comp, __len, __buf.first, __buf.second);
  std::__check_strict_weak_ordering_sorted(__first, __last, __comp);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  std::__stable_sort_impl<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::stable_sort(__first, __last, __less<>());
}

}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/stable_sort.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/stable_sort.h" 3
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backend.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/transform.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/transform.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/transform.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/transform.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _OutputIterator, class _UnaryOperation>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator
transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op) {
  for (; __first != __last; ++__first, (void)++__result)
    *__result = __op(*__first);
  return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator transform(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _OutputIterator __result,
    _BinaryOperation __binary_op) {
  for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
    *__result = __binary_op(*__first1, *__first2);
  return __result;
}

}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/transform.h" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/transform.h" 3
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backend.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/transform_reduce.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/transform_reduce.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__numeric/transform_reduce.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__numeric/transform_reduce.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__numeric/transform_reduce.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__numeric/transform_reduce.h" 3
}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/transform_reduce.h" 2 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/transform_reduce.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backends/transform_reduce.h" 2 3
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backends/cpu_backend.h" 2 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backend.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/execution" 1 3
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/execution" 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backend.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_backend.h" 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_find.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_frontend_dispatch.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_frontend_dispatch.h" 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_find.h" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/cpp17_iterator_concepts.h" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/cpp17_iterator_concepts.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/cpp17_iterator_concepts.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_find.h" 2 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_find.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_find.h" 2 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_any_all_none_of.h" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_any_all_none_of.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_any_all_none_of.h" 2 3
# 1856 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_copy.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_copy.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_transform.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_transform.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_transform.h" 2 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_copy.h" 2 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_copy.h" 2 3
# 1857 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_count.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_count.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_for_each.h" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_for_each.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_for_each.h" 2 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_count.h" 2 3





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__numeric/pstl_transform_reduce.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__numeric/pstl_transform_reduce.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__numeric/pstl_transform_reduce.h" 2 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_count.h" 2 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_count.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_count.h" 2 3
# 1858 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_equal.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_equal.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_equal.h" 2 3
# 1859 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_fill.h" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_fill.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_fill.h" 2 3
# 1860 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_generate.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_generate.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_generate.h" 2 3
# 1863 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_is_partitioned.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_is_partitioned.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_is_partitioned.h" 2 3
# 1864 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_merge.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_merge.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_merge.h" 2 3
# 1865 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_move.h" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_move.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_move.h" 2 3
# 1866 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_replace.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_replace.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_replace.h" 2 3
# 1867 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_rotate_copy.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_rotate_copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_rotate_copy.h" 2 3
# 1868 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_sort.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_sort.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_stable_sort.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_stable_sort.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_stable_sort.h" 2 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_sort.h" 2 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_sort.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/pstl_sort.h" 2 3
# 1869 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_adjacent_find.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_adjacent_find.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_adjacent_find.h" 2 3
# 1873 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_all_of.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_all_of.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_all_of.h" 2 3
# 1874 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_any_of.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_any_of.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_any_of.h" 2 3
# 1875 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_binary_search.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_binary_search.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_binary_search.h" 2 3
# 1876 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_clamp.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_clamp.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_clamp.h" 2 3
# 1877 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_contains.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_contains.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_find.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_find.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_find_if.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_find_if.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_find_if.h" 2 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_find.h" 2 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_find.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_find.h" 2 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_contains.h" 2 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_contains.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_contains.h" 2 3
# 1878 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_copy.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_copy.h" 2 3
# 1879 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_copy_backward.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_copy_backward.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_copy_backward.h" 2 3
# 1880 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_copy_if.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_copy_if.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_copy_if.h" 2 3
# 1881 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_copy_n.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_copy_n.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_copy_n.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_copy_n.h" 3
}}
# 1882 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_count.h" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_count.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_count.h" 2 3
# 1883 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_count_if.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_count_if.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_count_if.h" 2 3
# 1884 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_ends_with.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_ends_with.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_equal.h" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_equal.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_equal.h" 2 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_ends_with.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_starts_with.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_starts_with.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_mismatch.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_mismatch.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_mismatch.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 90 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_mismatch.h" 3
}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_starts_with.h" 2 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_starts_with.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_starts_with.h" 2 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_ends_with.h" 2 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_ends_with.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_ends_with.h" 2 3
# 1885 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_equal_range.h" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_equal_range.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_equal_range.h" 2 3
# 1887 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_fill.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_fill.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_fill_n.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_fill_n.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_fill_n.h" 2 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_fill.h" 2 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_fill.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_fill.h" 2 3
# 1888 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_find_end.h" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_find_end.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_find_end.h" 2 3
# 1891 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_find_first_of.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_find_first_of.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_find_first_of.h" 2 3
# 1892 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_find_if_not.h" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_find_if_not.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_find_if_not.h" 2 3
# 1894 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_for_each.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_for_each.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_for_each.h" 2 3
# 1895 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_for_each_n.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_for_each_n.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_for_each_n.h" 2 3
# 1896 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_generate.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_generate.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_generate.h" 2 3
# 1897 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_generate_n.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_generate_n.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_generate_n.h" 2 3
# 1898 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_includes.h" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_includes.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_includes.h" 2 3
# 1899 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_inplace_merge.h" 1 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_inplace_merge.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_inplace_merge.h" 2 3
# 1900 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_is_heap.h" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_is_heap.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_is_heap.h" 2 3
# 1901 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_is_heap_until.h" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_is_heap_until.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_is_heap_until.h" 2 3
# 1902 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_is_partitioned.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_is_partitioned.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_is_partitioned.h" 2 3
# 1903 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_is_permutation.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_is_permutation.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_is_permutation.h" 2 3
# 1904 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_is_sorted.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_is_sorted.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_is_sorted_until.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_is_sorted_until.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_is_sorted_until.h" 2 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_is_sorted.h" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_is_sorted.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_is_sorted.h" 2 3
# 1905 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_lexicographical_compare.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_lexicographical_compare.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_lexicographical_compare.h" 2 3
# 1907 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_lower_bound.h" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_lower_bound.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_lower_bound.h" 2 3
# 1908 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_make_heap.h" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_make_heap.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_make_heap.h" 2 3
# 1909 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_max.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_max.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_min_element.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_min_element.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_min_element.h" 2 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_max.h" 2 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_max.h" 3
# 1910 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_max_element.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_max_element.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_max_element.h" 2 3
# 1911 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_merge.h" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_merge.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_merge.h" 2 3
# 1912 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_min.h" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_min.h" 3
# 1913 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_minmax.h" 1 3
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_minmax.h" 3
# 1915 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_minmax_element.h" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_minmax_element.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_minmax_element.h" 2 3
# 1916 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_move.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_move.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_move.h" 2 3
# 1918 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_move_backward.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_move_backward.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_move_backward.h" 2 3
# 1919 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_next_permutation.h" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_next_permutation.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_next_permutation.h" 2 3
# 1920 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_none_of.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_none_of.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_none_of.h" 2 3
# 1921 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_nth_element.h" 1 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_nth_element.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_nth_element.h" 2 3
# 1922 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_partial_sort.h" 1 3
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_partial_sort.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_partial_sort.h" 2 3
# 1923 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_partial_sort_copy.h" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_partial_sort_copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_partial_sort_copy.h" 2 3
# 1924 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_partition.h" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_partition.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_partition.h" 2 3
# 1925 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_partition_copy.h" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_partition_copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_partition_copy.h" 2 3
# 1926 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_partition_point.h" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_partition_point.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_partition_point.h" 2 3
# 1927 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_pop_heap.h" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_pop_heap.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_pop_heap.h" 2 3
# 1928 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_prev_permutation.h" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_prev_permutation.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_prev_permutation.h" 2 3
# 1929 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_push_heap.h" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_push_heap.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_push_heap.h" 2 3
# 1930 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_remove.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_remove.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_remove_if.h" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_remove_if.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_remove_if.h" 2 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_remove.h" 2 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_remove.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_remove.h" 2 3
# 1931 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_remove_copy.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_remove_copy.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_remove_copy_if.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_remove_copy_if.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove_copy_if.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove_copy_if.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator
remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred) {
  for (; __first != __last; ++__first) {
    if (!__pred(*__first)) {
      *__result = *__first;
      ++__result;
    }
  }
  return __result;
}

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_remove_copy_if.h" 2 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_remove_copy_if.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_remove_copy_if.h" 2 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_remove_copy.h" 2 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_remove_copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_remove_copy.h" 2 3
# 1932 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_replace.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_replace.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_replace_if.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_replace_if.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_replace_if.h" 2 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_replace.h" 2 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_replace.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_replace.h" 2 3
# 1935 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_replace_copy.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_replace_copy.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_replace_copy_if.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_replace_copy_if.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_replace_copy_if.h" 2 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_replace_copy.h" 2 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_replace_copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_replace_copy.h" 2 3
# 1936 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_reverse.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_reverse.h" 3
# 1939 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_reverse_copy.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_reverse_copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_reverse_copy.h" 2 3
# 1940 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_rotate.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_rotate.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_rotate.h" 2 3
# 1941 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_rotate_copy.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_rotate_copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_rotate_copy.h" 2 3
# 1942 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_sample.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_sample.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sample.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sample.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__random/uniform_int_distribution.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__random/uniform_int_distribution.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__random/is_valid.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__random/is_valid.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {






template <class>
struct __libcpp_random_is_valid_realtype : false_type {};
template <>
struct __libcpp_random_is_valid_realtype<float> : true_type {};
template <>
struct __libcpp_random_is_valid_realtype<double> : true_type {};
template <>
struct __libcpp_random_is_valid_realtype<long double> : true_type {};







template <class>
struct __libcpp_random_is_valid_inttype : false_type {};
template <>
struct __libcpp_random_is_valid_inttype<int8_t> : true_type {};
template <>
struct __libcpp_random_is_valid_inttype<short> : true_type {};
template <>
struct __libcpp_random_is_valid_inttype<int> : true_type {};
template <>
struct __libcpp_random_is_valid_inttype<long> : true_type {};
template <>
struct __libcpp_random_is_valid_inttype<long long> : true_type {};
template <>
struct __libcpp_random_is_valid_inttype<uint8_t> : true_type {};
template <>
struct __libcpp_random_is_valid_inttype<unsigned short> : true_type {};
template <>
struct __libcpp_random_is_valid_inttype<unsigned int> : true_type {};
template <>
struct __libcpp_random_is_valid_inttype<unsigned long> : true_type {};
template <>
struct __libcpp_random_is_valid_inttype<unsigned long long> : true_type {};


template <>
struct __libcpp_random_is_valid_inttype<__int128_t> : true_type {};
template <>
struct __libcpp_random_is_valid_inttype<__uint128_t> : true_type {};
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__random/is_valid.h" 3
template <class, class = void>
struct __libcpp_random_is_valid_urng : false_type {};
template <class _Gp>
struct __libcpp_random_is_valid_urng<
    _Gp,
    __enable_if_t< is_unsigned<typename _Gp::result_type>::value &&
                   _IsSame<__decltype(std::declval<_Gp&>()()), typename _Gp::result_type>::value > > : true_type {};

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__random/uniform_int_distribution.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__random/log2.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__random/log2.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _UIntType, _UIntType _Xp, size_t _Rp>
struct __log2_imp;

template <unsigned long long _Xp, size_t _Rp>
struct __log2_imp<unsigned long long, _Xp, _Rp> {
  static const size_t value =
      _Xp & ((unsigned long long)(1) << _Rp) ? _Rp : __log2_imp<unsigned long long, _Xp, _Rp - 1>::value;
};

template <unsigned long long _Xp>
struct __log2_imp<unsigned long long, _Xp, 0> {
  static const size_t value = 0;
};

template <size_t _Rp>
struct __log2_imp<unsigned long long, 0, _Rp> {
  static const size_t value = _Rp + 1;
};



template <__uint128_t _Xp, size_t _Rp>
struct __log2_imp<__uint128_t, _Xp, _Rp> {
  static const size_t value =
      (_Xp >> 64) ? (64 + __log2_imp<unsigned long long, (_Xp >> 64), 63>::value)
                  : __log2_imp<unsigned long long, _Xp, 63>::value;
};



template <class _UIntType, _UIntType _Xp>
struct __log2 {
  static const size_t value = __log2_imp<

      __conditional_t<sizeof(_UIntType) <= sizeof(unsigned long long), unsigned long long, __uint128_t>,



      _Xp,
      sizeof(_UIntType) * 8 - 1>::value;
};

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__random/uniform_int_distribution.h" 2 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__random/uniform_int_distribution.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__random/uniform_int_distribution.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Engine, class _UIntType>
class __independent_bits_engine {
public:

  typedef _UIntType result_type;

private:
  typedef typename _Engine::result_type _Engine_result_type;
  typedef __conditional_t<sizeof(_Engine_result_type) <= sizeof(result_type), result_type, _Engine_result_type>
      _Working_result_type;

  _Engine& __e_;
  size_t __w_;
  size_t __w0_;
  size_t __n_;
  size_t __n0_;
  _Working_result_type __y0_;
  _Working_result_type __y1_;
  _Engine_result_type __mask0_;
  _Engine_result_type __mask1_;


  static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min + _Working_result_type(1);



  static const size_t __m = __log2<_Working_result_type, _Rp>::value;
  static const size_t _WDt = numeric_limits<_Working_result_type>::digits;
  static const size_t _EDt = numeric_limits<_Engine_result_type>::digits;

public:

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __independent_bits_engine(_Engine& __e, size_t __w);


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result_type operator()() { return __eval(integral_constant<bool, _Rp != 0>()); }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result_type __eval(false_type);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result_type __eval(true_type);
};

template <class _Engine, class _UIntType>
__independent_bits_engine<_Engine, _UIntType>::__independent_bits_engine(_Engine& __e, size_t __w)
    : __e_(__e), __w_(__w) {
  __n_ = __w_ / __m + (__w_ % __m != 0);
  __w0_ = __w_ / __n_;
  if (_Rp == 0)
    __y0_ = _Rp;
  else if (__w0_ < _WDt)
    __y0_ = (_Rp >> __w0_) << __w0_;
  else
    __y0_ = 0;
  if (_Rp - __y0_ > __y0_ / __n_) {
    ++__n_;
    __w0_ = __w_ / __n_;
    if (__w0_ < _WDt)
      __y0_ = (_Rp >> __w0_) << __w0_;
    else
      __y0_ = 0;
  }
  __n0_ = __n_ - __w_ % __n_;
  if (__w0_ < _WDt - 1)
    __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);
  else
    __y1_ = 0;
  __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) : _Engine_result_type(0);
  __mask1_ = __w0_ < _EDt - 1 ? _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) : _Engine_result_type(~0);
}

template <class _Engine, class _UIntType>
inline _UIntType __independent_bits_engine<_Engine, _UIntType>::__eval(false_type) {
  return static_cast<result_type>(__e_() & __mask0_);
}

template <class _Engine, class _UIntType>
_UIntType __independent_bits_engine<_Engine, _UIntType>::__eval(true_type) {
  const size_t __w_rt = numeric_limits<result_type>::digits;
  result_type __sp = 0;
  for (size_t __k = 0; __k < __n0_; ++__k) {
    _Engine_result_type __u;
    do {
      __u = __e_() - _Engine::min();
    } while (__u >= __y0_);
    if (__w0_ < __w_rt)
      __sp <<= __w0_;
    else
      __sp = 0;
    __sp += __u & __mask0_;
  }
  for (size_t __k = __n0_; __k < __n_; ++__k) {
    _Engine_result_type __u;
    do {
      __u = __e_() - _Engine::min();
    } while (__u >= __y1_);
    if (__w0_ < __w_rt - 1)
      __sp <<= __w0_ + 1;
    else
      __sp = 0;
    __sp += __u & __mask1_;
  }
  return __sp;
}

template <class _IntType = int>
class uniform_int_distribution {
  _Static_assert(__libcpp_random_is_valid_inttype<_IntType>::value, "IntType must be a supported integer type");

public:

  typedef _IntType result_type;

  class param_type {
    result_type __a_;
    result_type __b_;

  public:
    typedef uniform_int_distribution distribution_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit param_type(result_type __a = 0, result_type __b = numeric_limits<result_type>::max())
        : __a_(__a), __b_(__b) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result_type a() const { return __a_; }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result_type b() const { return __b_; }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool operator==(const param_type& __x, const param_type& __y) {
      return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool operator!=(const param_type& __x, const param_type& __y) { return !(__x == __y); }
  };

private:
  param_type __p_;

public:







  explicit uniform_int_distribution(result_type __a = 0, result_type __b = numeric_limits<result_type>::max())
      : __p_(param_type(__a, __b)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void reset() {}


  template <class _URNG>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result_type operator()(_URNG& __g) {
    return (*this)(__g, __p_);
  }
  template <class _URNG>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result_type operator()(_URNG& __g, const param_type& __p);


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result_type a() const { return __p_.a(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result_type b() const { return __p_.b(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) param_type param() const { return __p_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void param(const param_type& __p) { __p_ = __p; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result_type min() const { return a(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result_type max() const { return b(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool
  operator==(const uniform_int_distribution& __x, const uniform_int_distribution& __y) {
    return __x.__p_ == __y.__p_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool
  operator!=(const uniform_int_distribution& __x, const uniform_int_distribution& __y) {
    return !(__x == __y);
  }
};

template <class _IntType>
template <class _URNG>
typename uniform_int_distribution<_IntType>::result_type uniform_int_distribution<_IntType>::operator()(
    _URNG& __g, const param_type& __p) __attribute__((__no_sanitize__("unsigned-integer-overflow"))) {
  _Static_assert(__libcpp_random_is_valid_urng<_URNG>::value, "");
  typedef __conditional_t<sizeof(result_type) <= sizeof(uint32_t), uint32_t, __make_unsigned_t<result_type> > _UIntType;
  const _UIntType __rp = _UIntType(__p.b()) - _UIntType(__p.a()) + _UIntType(1);
  if (__rp == 1)
    return __p.a();
  const size_t __dt = numeric_limits<_UIntType>::digits;
  typedef __independent_bits_engine<_URNG, _UIntType> _Eng;
  if (__rp == 0)
    return static_cast<result_type>(_Eng(__g, __dt)());
  size_t __w = __dt - std::__countl_zero(__rp) - 1;
  if ((__rp & (numeric_limits<_UIntType>::max() >> (__dt - __w))) != 0)
    ++__w;
  _Eng __e(__g, __w);
  _UIntType __u;
  do {
    __u = __e();
  } while (__u >= __rp);
  return static_cast<result_type>(__u + __p.a());
}

template <class _CharT, class _Traits, class _IT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const uniform_int_distribution<_IT>& __x) {
  __save_flags<_CharT, _Traits> __lx(__os);
  typedef basic_ostream<_CharT, _Traits> _Ostream;
  __os.flags(_Ostream::dec | _Ostream::left);
  _CharT __sp = __os.widen(' ');
  __os.fill(__sp);
  return __os << __x.a() << __sp << __x.b();
}

template <class _CharT, class _Traits, class _IT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, uniform_int_distribution<_IT>& __x) {
  typedef uniform_int_distribution<_IT> _Eng;
  typedef typename _Eng::result_type result_type;
  typedef typename _Eng::param_type param_type;
  __save_flags<_CharT, _Traits> __lx(__is);
  typedef basic_istream<_CharT, _Traits> _Istream;
  __is.flags(_Istream::dec | _Istream::skipws);
  result_type __a;
  result_type __b;
  __is >> __a >> __b;
  if (!__is.fail())
    __x.param(param_type(__a, __b));
  return __is;
}

}}
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sample.h" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sample.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sample.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy,
          class _PopulationIterator,
          class _PopulationSentinel,
          class _SampleIterator,
          class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _SampleIterator __sample(
    _PopulationIterator __first,
    _PopulationSentinel __last,
    _SampleIterator __output_iter,
    _Distance __n,
    _UniformRandomNumberGenerator& __g,
    input_iterator_tag) {
  _Distance __k = 0;
  for (; __first != __last && __k < __n; ++__first, (void)++__k)
    __output_iter[__k] = *__first;
  _Distance __sz = __k;
  for (; __first != __last; ++__first, (void)++__k) {
    _Distance __r = uniform_int_distribution<_Distance>(0, __k)(__g);
    if (__r < __sz)
      __output_iter[__r] = *__first;
  }
  return __output_iter + std::min(__n, __k);
}

template <class _AlgPolicy,
          class _PopulationIterator,
          class _PopulationSentinel,
          class _SampleIterator,
          class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _SampleIterator __sample(
    _PopulationIterator __first,
    _PopulationSentinel __last,
    _SampleIterator __output_iter,
    _Distance __n,
    _UniformRandomNumberGenerator& __g,
    forward_iterator_tag) {
  _Distance __unsampled_sz = _IterOps<_AlgPolicy>::distance(__first, __last);
  for (__n = std::min(__n, __unsampled_sz); __n != 0; ++__first) {
    _Distance __r = uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);
    if (__r < __n) {
      *__output_iter++ = *__first;
      --__n;
    }
  }
  return __output_iter;
}

template <class _AlgPolicy,
          class _PopulationIterator,
          class _PopulationSentinel,
          class _SampleIterator,
          class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _SampleIterator __sample(
    _PopulationIterator __first,
    _PopulationSentinel __last,
    _SampleIterator __output_iter,
    _Distance __n,
    _UniformRandomNumberGenerator& __g) {
  ((void)0);

  using _PopIterCategory = typename _IterOps<_AlgPolicy>::template __iterator_category<_PopulationIterator>;
  using _Difference = typename _IterOps<_AlgPolicy>::template __difference_type<_PopulationIterator>;
  using _CommonType = typename common_type<_Distance, _Difference>::type;

  return std::__sample<_AlgPolicy>(
      std::move(__first), std::move(__last), std::move(__output_iter), _CommonType(__n), __g, _PopIterCategory());
}
# 119 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/sample.h" 3
}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_sample.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/uniform_random_bit_generator_adaptor.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/uniform_random_bit_generator_adaptor.h" 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_sample.h" 2 3




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__random/uniform_random_bit_generator.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__random/uniform_random_bit_generator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__random/uniform_random_bit_generator.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__random/uniform_random_bit_generator.h" 3
}}
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_sample.h" 2 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_sample.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_sample.h" 2 3
# 1943 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_search.h" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_search.h" 3
# 1944 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_search_n.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_search_n.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/search_n.h" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/search_n.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Pred, class _Iter, class _Sent, class _SizeT, class _Type, class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_Iter, _Iter> __search_n_forward_impl(
    _Iter __first, _Sent __last, _SizeT __count, const _Type& __value, _Pred& __pred, _Proj& __proj) {
  if (__count <= 0)
    return std::make_pair(__first, __first);
  while (true) {

    while (true) {
      if (__first == __last) {
        _IterOps<_AlgPolicy>::__advance_to(__first, __last);
        return std::make_pair(__first, __first);
      }
      if (std::__invoke(__pred, std::__invoke(__proj, *__first), __value))
        break;
      ++__first;
    }

    _Iter __m = __first;
    _SizeT __c(0);
    while (true) {
      if (++__c == __count)
        return std::make_pair(__first, ++__m);
      if (++__m == __last) {
        _IterOps<_AlgPolicy>::__advance_to(__first, __last);
        return std::make_pair(__first, __first);
      }


      if (!std::__invoke(__pred, std::__invoke(__proj, *__m), __value)) {
        __first = __m;
        ++__first;
        break;
      }
    }
  }
}

template <class _AlgPolicy, class _Pred, class _Iter, class _Sent, class _SizeT, class _Type, class _Proj, class _DiffT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) std::pair<_Iter, _Iter> __search_n_random_access_impl(
    _Iter __first, _Sent __last, _SizeT __count, const _Type& __value, _Pred& __pred, _Proj& __proj, _DiffT __size1) {
  using difference_type = typename iterator_traits<_Iter>::difference_type;
  if (__count == 0)
    return std::make_pair(__first, __first);
  if (__size1 < static_cast<_DiffT>(__count)) {
    _IterOps<_AlgPolicy>::__advance_to(__first, __last);
    return std::make_pair(__first, __first);
  }

  const auto __s = __first + __size1 - difference_type(__count - 1);
  while (true) {

    while (true) {
      if (__first >= __s) {
        _IterOps<_AlgPolicy>::__advance_to(__first, __last);
        return std::make_pair(__first, __first);
      }
      if (std::__invoke(__pred, std::__invoke(__proj, *__first), __value))
        break;
      ++__first;
    }

    auto __m = __first;
    _SizeT __c(0);
    while (true) {
      if (++__c == __count)
        return std::make_pair(__first, __first + _DiffT(__count));
      ++__m;


      if (!std::__invoke(__pred, std::__invoke(__proj, *__m), __value)) {
        __first = __m;
        ++__first;
        break;
      }
    }
  }
}

template <class _Iter, class _Sent, class _DiffT, class _Type, class _Pred, class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_Iter, _Iter> __search_n_impl(
    _Iter __first,
    _Sent __last,
    _DiffT __count,
    const _Type& __value,
    _Pred& __pred,
    _Proj& __proj,
    __enable_if_t<__has_random_access_iterator_category<_Iter>::value>* = __nullptr) {
  return std::__search_n_random_access_impl<_ClassicAlgPolicy>(
      __first, __last, __count, __value, __pred, __proj, __last - __first);
}

template <class _Iter1, class _Sent1, class _DiffT, class _Type, class _Pred, class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_Iter1, _Iter1> __search_n_impl(
    _Iter1 __first,
    _Sent1 __last,
    _DiffT __count,
    const _Type& __value,
    _Pred& __pred,
    _Proj& __proj,
    __enable_if_t<__has_forward_iterator_category<_Iter1>::value &&
                  !__has_random_access_iterator_category<_Iter1>::value>* = __nullptr) {
  return std::__search_n_forward_impl<_ClassicAlgPolicy>(__first, __last, __count, __value, __pred, __proj);
}

template <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator search_n(
    _ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value, _BinaryPredicate __pred) {
  _Static_assert(__is_callable<_BinaryPredicate, __decltype(*__first), const _Tp&>::value, "BinaryPredicate has to be callable");

  auto __proj = __identity();
  return std::__search_n_impl(__first, __last, std::__convert_to_integral(__count), __value, __pred, __proj).first;
}

template <class _ForwardIterator, class _Size, class _Tp>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value) {
  return std::search_n(__first, __last, std::__convert_to_integral(__count), __value, __equal_to());
}

}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_search_n.h" 2 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_search_n.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_search_n.h" 2 3
# 1945 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_set_difference.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_set_difference.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_difference.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_difference.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_difference.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Comp, class _InIter1, class _Sent1, class _InIter2, class _Sent2, class _OutIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<__remove_cvref_t<_InIter1>, __remove_cvref_t<_OutIter> >
__set_difference(
    _InIter1&& __first1, _Sent1&& __last1, _InIter2&& __first2, _Sent2&& __last2, _OutIter&& __result, _Comp&& __comp) {
  while (__first1 != __last1 && __first2 != __last2) {
    if (__comp(*__first1, *__first2)) {
      *__result = *__first1;
      ++__first1;
      ++__result;
    } else if (__comp(*__first2, *__first1)) {
      ++__first2;
    } else {
      ++__first1;
      ++__first2;
    }
  }
  return std::__copy<_AlgPolicy>(std::move(__first1), std::move(__last1), std::move(__result));
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator set_difference(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result,
    _Compare __comp) {
  return std::__set_difference<_ClassicAlgPolicy, __comp_ref_type<_Compare> >(
             __first1, __last1, __first2, __last2, __result, __comp)
      .second;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator set_difference(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result) {
  return std::__set_difference<_ClassicAlgPolicy>(__first1, __last1, __first2, __last2, __result, __less<>()).second;
}

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_set_difference.h" 2 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_set_difference.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_set_difference.h" 2 3
# 1946 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_set_intersection.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_set_intersection.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_intersection.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_intersection.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_intersection.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InIter1, class _InIter2, class _OutIter>
struct __set_intersection_result {
  _InIter1 __in1_;
  _InIter2 __in2_;
  _OutIter __out_;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  __set_intersection_result(_InIter1&& __in_iter1, _InIter2&& __in_iter2, _OutIter&& __out_iter)
      : __in1_(std::move(__in_iter1)), __in2_(std::move(__in_iter2)), __out_(std::move(__out_iter)) {}
};

template <class _AlgPolicy, class _Compare, class _InIter1, class _Sent1, class _InIter2, class _Sent2, class _OutIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __set_intersection_result<_InIter1, _InIter2, _OutIter>
__set_intersection(
    _InIter1 __first1, _Sent1 __last1, _InIter2 __first2, _Sent2 __last2, _OutIter __result, _Compare&& __comp) {
  while (__first1 != __last1 && __first2 != __last2) {
    if (__comp(*__first1, *__first2))
      ++__first1;
    else {
      if (!__comp(*__first2, *__first1)) {
        *__result = *__first1;
        ++__result;
        ++__first1;
      }
      ++__first2;
    }
  }

  return __set_intersection_result<_InIter1, _InIter2, _OutIter>(
      _IterOps<_AlgPolicy>::next(std::move(__first1), std::move(__last1)),
      _IterOps<_AlgPolicy>::next(std::move(__first2), std::move(__last2)),
      std::move(__result));
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator set_intersection(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result,
    _Compare __comp) {
  return std::__set_intersection<_ClassicAlgPolicy, __comp_ref_type<_Compare> >(
             std::move(__first1),
             std::move(__last1),
             std::move(__first2),
             std::move(__last2),
             std::move(__result),
             __comp)
      .__out_;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator set_intersection(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result) {
  return std::__set_intersection<_ClassicAlgPolicy>(
             std::move(__first1),
             std::move(__last1),
             std::move(__first2),
             std::move(__last2),
             std::move(__result),
             __less<>())
      .__out_;
}

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_set_intersection.h" 2 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_set_intersection.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_set_intersection.h" 2 3
# 1947 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_set_symmetric_difference.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_set_symmetric_difference.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_symmetric_difference.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_symmetric_difference.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_symmetric_difference.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InIter1, class _InIter2, class _OutIter>
struct __set_symmetric_difference_result {
  _InIter1 __in1_;
  _InIter2 __in2_;
  _OutIter __out_;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  __set_symmetric_difference_result(_InIter1&& __in_iter1, _InIter2&& __in_iter2, _OutIter&& __out_iter)
      : __in1_(std::move(__in_iter1)), __in2_(std::move(__in_iter2)), __out_(std::move(__out_iter)) {}
};

template <class _AlgPolicy, class _Compare, class _InIter1, class _Sent1, class _InIter2, class _Sent2, class _OutIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __set_symmetric_difference_result<_InIter1, _InIter2, _OutIter>
__set_symmetric_difference(
    _InIter1 __first1, _Sent1 __last1, _InIter2 __first2, _Sent2 __last2, _OutIter __result, _Compare&& __comp) {
  while (__first1 != __last1) {
    if (__first2 == __last2) {
      auto __ret1 = std::__copy<_AlgPolicy>(std::move(__first1), std::move(__last1), std::move(__result));
      return __set_symmetric_difference_result<_InIter1, _InIter2, _OutIter>(
          std::move(__ret1.first), std::move(__first2), std::move((__ret1.second)));
    }
    if (__comp(*__first1, *__first2)) {
      *__result = *__first1;
      ++__result;
      ++__first1;
    } else {
      if (__comp(*__first2, *__first1)) {
        *__result = *__first2;
        ++__result;
      } else {
        ++__first1;
      }
      ++__first2;
    }
  }
  auto __ret2 = std::__copy<_AlgPolicy>(std::move(__first2), std::move(__last2), std::move(__result));
  return __set_symmetric_difference_result<_InIter1, _InIter2, _OutIter>(
      std::move(__first1), std::move(__ret2.first), std::move((__ret2.second)));
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator set_symmetric_difference(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result,
    _Compare __comp) {
  return std::__set_symmetric_difference<_ClassicAlgPolicy, __comp_ref_type<_Compare> >(
             std::move(__first1),
             std::move(__last1),
             std::move(__first2),
             std::move(__last2),
             std::move(__result),
             __comp)
      .__out_;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator set_symmetric_difference(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result) {
  return std::set_symmetric_difference(
      std::move(__first1),
      std::move(__last1),
      std::move(__first2),
      std::move(__last2),
      std::move(__result),
      __less<>());
}

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_set_symmetric_difference.h" 2 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_set_symmetric_difference.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_set_symmetric_difference.h" 2 3
# 1948 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_set_union.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_set_union.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_union.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_union.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/set_union.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InIter1, class _InIter2, class _OutIter>
struct __set_union_result {
  _InIter1 __in1_;
  _InIter2 __in2_;
  _OutIter __out_;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  __set_union_result(_InIter1&& __in_iter1, _InIter2&& __in_iter2, _OutIter&& __out_iter)
      : __in1_(std::move(__in_iter1)), __in2_(std::move(__in_iter2)), __out_(std::move(__out_iter)) {}
};

template <class _AlgPolicy, class _Compare, class _InIter1, class _Sent1, class _InIter2, class _Sent2, class _OutIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __set_union_result<_InIter1, _InIter2, _OutIter> __set_union(
    _InIter1 __first1, _Sent1 __last1, _InIter2 __first2, _Sent2 __last2, _OutIter __result, _Compare&& __comp) {
  for (; __first1 != __last1; ++__result) {
    if (__first2 == __last2) {
      auto __ret1 = std::__copy<_AlgPolicy>(std::move(__first1), std::move(__last1), std::move(__result));
      return __set_union_result<_InIter1, _InIter2, _OutIter>(
          std::move(__ret1.first), std::move(__first2), std::move((__ret1.second)));
    }
    if (__comp(*__first2, *__first1)) {
      *__result = *__first2;
      ++__first2;
    } else {
      if (!__comp(*__first1, *__first2)) {
        ++__first2;
      }
      *__result = *__first1;
      ++__first1;
    }
  }
  auto __ret2 = std::__copy<_AlgPolicy>(std::move(__first2), std::move(__last2), std::move(__result));
  return __set_union_result<_InIter1, _InIter2, _OutIter>(
      std::move(__first1), std::move(__ret2.first), std::move((__ret2.second)));
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator set_union(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result,
    _Compare __comp) {
  return std::__set_union<_ClassicAlgPolicy, __comp_ref_type<_Compare> >(
             std::move(__first1),
             std::move(__last1),
             std::move(__first2),
             std::move(__last2),
             std::move(__result),
             __comp)
      .__out_;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator set_union(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result) {
  return std::set_union(
      std::move(__first1),
      std::move(__last1),
      std::move(__first2),
      std::move(__last2),
      std::move(__result),
      __less<>());
}

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_set_union.h" 2 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_set_union.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_set_union.h" 2 3
# 1949 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_shuffle.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_shuffle.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shuffle.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shuffle.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shuffle.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

class __attribute__((__visibility__("default"))) __libcpp_debug_randomizer {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __libcpp_debug_randomizer() {
    __state_ = __seed();
    __inc_ = __state_ + 0xda3e39cb94b95bdbULL;
    __inc_ = (__inc_ << 1) | 1;
  }
  typedef uint_fast32_t result_type;

  static const result_type _Min = 0;
  static const result_type _Max = 0xFFFFFFFF;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result_type operator()() {
    uint_fast64_t __oldstate = __state_;
    __state_ = __oldstate * 6364136223846793005ULL + __inc_;
    return __oldstate >> 32;
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result_type min() { return _Min; }
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result_type max() { return _Max; }

private:
  uint_fast64_t __state_;
  uint_fast64_t __inc_;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static uint_fast64_t __seed() {



    static char __x;
    return reinterpret_cast<uintptr_t>(&__x);

  }
};


class __attribute__((__visibility__("default"))) __rs_default;

__attribute__((__visibility__("default"))) __rs_default __rs_get();

class __attribute__((__visibility__("default"))) __rs_default {
  static unsigned __c_;

  __rs_default();

public:
  typedef uint_fast32_t result_type;

  static const result_type _Min = 0;
  static const result_type _Max = 0xFFFFFFFF;

  __rs_default(const __rs_default&);
  ~__rs_default();

  result_type operator()();

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result_type min() { return _Min; }
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result_type max() { return _Max; }

  friend __attribute__((__visibility__("default"))) __rs_default __rs_get();
};

__attribute__((__visibility__("default"))) __rs_default __rs_get();

template <class _RandomAccessIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  typedef uniform_int_distribution<ptrdiff_t> _Dp;
  typedef typename _Dp::param_type _Pp;
  difference_type __d = __last - __first;
  if (__d > 1) {
    _Dp __uid;
    __rs_default __g = __rs_get();
    for (--__last, (void)--__d; __first < __last; ++__first, (void)--__d) {
      difference_type __i = __uid(__g, _Pp(0, __d));
      if (__i != difference_type(0))
        swap(*__first, *(__first + __i));
    }
  }
}

template <class _RandomAccessIterator, class _RandomNumberGenerator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
random_shuffle(_RandomAccessIterator __first,
               _RandomAccessIterator __last,



               _RandomNumberGenerator& __rand)

{
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  difference_type __d = __last - __first;
  if (__d > 1) {
    for (--__last; __first < __last; ++__first, (void)--__d) {
      difference_type __i = __rand(__d);
      if (__i != difference_type(0))
        swap(*__first, *(__first + __i));
    }
  }
}


template <class _AlgPolicy, class _RandomAccessIterator, class _Sentinel, class _UniformRandomNumberGenerator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _RandomAccessIterator
__shuffle(_RandomAccessIterator __first, _Sentinel __last_sentinel, _UniformRandomNumberGenerator&& __g) {
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  typedef uniform_int_distribution<ptrdiff_t> _Dp;
  typedef typename _Dp::param_type _Pp;

  auto __original_last = _IterOps<_AlgPolicy>::next(__first, __last_sentinel);
  auto __last = __original_last;
  difference_type __d = __last - __first;
  if (__d > 1) {
    _Dp __uid;
    for (--__last, (void)--__d; __first < __last; ++__first, (void)--__d) {
      difference_type __i = __uid(__g, _Pp(0, __d));
      if (__i != difference_type(0))
        _IterOps<_AlgPolicy>::iter_swap(__first, __first + __i);
    }
  }

  return __original_last;
}

template <class _RandomAccessIterator, class _UniformRandomNumberGenerator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last, _UniformRandomNumberGenerator&& __g) {
  (void)std::__shuffle<_ClassicAlgPolicy>(
      std::move(__first), std::move(__last), std::forward<_UniformRandomNumberGenerator>(__g));
}

}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_shuffle.h" 2 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_shuffle.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_shuffle.h" 2 3
# 1950 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_sort.h" 1 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_sort.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_sort.h" 2 3
# 1951 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_sort_heap.h" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_sort_heap.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_sort_heap.h" 2 3
# 1952 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_stable_partition.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_stable_partition.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_partition.h" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_partition.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_partition.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _AlgPolicy, class _Predicate, class _ForwardIterator, class _Distance, class _Pair>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator __stable_partition_impl(
    _ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred,
    _Distance __len,
    _Pair __p,
    forward_iterator_tag __fit) {
  using _Ops = _IterOps<_AlgPolicy>;



  if (__len == 1)
    return __first;
  if (__len == 2) {
    _ForwardIterator __m = __first;
    if (__pred(*++__m)) {
      _Ops::iter_swap(__first, __m);
      return __m;
    }
    return __first;
  }
  if (__len <= __p.second) {
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);


    value_type* __t = __p.first;
    ::new ((void*)__t) value_type(_Ops::__iter_move(__first));
    __d.template __incr<value_type>();
    ++__t;
    _ForwardIterator __i = __first;
    while (++__i != __last) {
      if (__pred(*__i)) {
        *__first = _Ops::__iter_move(__i);
        ++__first;
      } else {
        ::new ((void*)__t) value_type(_Ops::__iter_move(__i));
        __d.template __incr<value_type>();
        ++__t;
      }
    }


    __i = __first;
    for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, (void)++__i)
      *__i = _Ops::__iter_move(__t2);

    return __first;
  }


  _ForwardIterator __m = __first;
  _Distance __len2 = __len / 2;
  _Ops::advance(__m, __len2);



  _ForwardIterator __first_false =
      std::__stable_partition_impl<_AlgPolicy, _Predicate&>(__first, __m, __pred, __len2, __p, __fit);



  _ForwardIterator __m1 = __m;
  _ForwardIterator __second_false = __last;
  _Distance __len_half = __len - __len2;
  while (__pred(*__m1)) {
    if (++__m1 == __last)
      goto __second_half_done;
    --__len_half;
  }


  __second_false = std::__stable_partition_impl<_AlgPolicy, _Predicate&>(__m1, __last, __pred, __len_half, __p, __fit);
__second_half_done:


  return std::__rotate<_AlgPolicy>(__first_false, __m, __second_false).first;


}

template <class _AlgPolicy, class _Predicate, class _ForwardIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
__stable_partition_impl(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag) {
  typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
  typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

  const difference_type __alloc_limit = 3;

  while (true) {
    if (__first == __last)
      return __first;
    if (!__pred(*__first))
      break;
    ++__first;
  }


  difference_type __len = _IterOps<_AlgPolicy>::distance(__first, __last);
  pair<value_type*, ptrdiff_t> __p(0, 0);
  unique_ptr<value_type, __return_temporary_buffer> __h;
  if (__len >= __alloc_limit) {

#pragma GCC diagnostic push
# 139 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_partition.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 139 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_partition.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    __p = std::get_temporary_buffer<value_type>(__len);
#pragma GCC diagnostic pop
    __h.reset(__p.first);
  }
  return std::__stable_partition_impl<_AlgPolicy, _Predicate&>(
      std::move(__first), std::move(__last), __pred, __len, __p, forward_iterator_tag());
}

template <class _AlgPolicy, class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>
_BidirectionalIterator __stable_partition_impl(
    _BidirectionalIterator __first,
    _BidirectionalIterator __last,
    _Predicate __pred,
    _Distance __len,
    _Pair __p,
    bidirectional_iterator_tag __bit) {
  using _Ops = _IterOps<_AlgPolicy>;




  if (__len == 2) {
    _Ops::iter_swap(__first, __last);
    return __last;
  }
  if (__len == 3) {
    _BidirectionalIterator __m = __first;
    if (__pred(*++__m)) {
      _Ops::iter_swap(__first, __m);
      _Ops::iter_swap(__m, __last);
      return __last;
    }
    _Ops::iter_swap(__m, __last);
    _Ops::iter_swap(__first, __m);
    return __m;
  }
  if (__len <= __p.second) {
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);


    value_type* __t = __p.first;
    ::new ((void*)__t) value_type(_Ops::__iter_move(__first));
    __d.template __incr<value_type>();
    ++__t;
    _BidirectionalIterator __i = __first;
    while (++__i != __last) {
      if (__pred(*__i)) {
        *__first = _Ops::__iter_move(__i);
        ++__first;
      } else {
        ::new ((void*)__t) value_type(_Ops::__iter_move(__i));
        __d.template __incr<value_type>();
        ++__t;
      }
    }

    *__first = _Ops::__iter_move(__i);
    __i = ++__first;


    for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, (void)++__i)
      *__i = _Ops::__iter_move(__t2);

    return __first;
  }


  _BidirectionalIterator __m = __first;
  _Distance __len2 = __len / 2;
  _Ops::advance(__m, __len2);



  _BidirectionalIterator __m1 = __m;
  _BidirectionalIterator __first_false = __first;
  _Distance __len_half = __len2;
  while (!__pred(*--__m1)) {
    if (__m1 == __first)
      goto __first_half_done;
    --__len_half;
  }


  __first_false = std::__stable_partition_impl<_AlgPolicy, _Predicate&>(__first, __m1, __pred, __len_half, __p, __bit);
__first_half_done:



  __m1 = __m;
  _BidirectionalIterator __second_false = __last;
  ++__second_false;
  __len_half = __len - __len2;
  while (__pred(*__m1)) {
    if (++__m1 == __last)
      goto __second_half_done;
    --__len_half;
  }


  __second_false = std::__stable_partition_impl<_AlgPolicy, _Predicate&>(__m1, __last, __pred, __len_half, __p, __bit);
__second_half_done:


  return std::__rotate<_AlgPolicy>(__first_false, __m, __second_false).first;


}

template <class _AlgPolicy, class _Predicate, class _BidirectionalIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _BidirectionalIterator __stable_partition_impl(
    _BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred, bidirectional_iterator_tag) {
  typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
  typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
  const difference_type __alloc_limit = 4;

  while (true) {
    if (__first == __last)
      return __first;
    if (!__pred(*__first))
      break;
    ++__first;
  }


  do {
    if (__first == --__last)
      return __first;
  } while (!__pred(*__last));




  difference_type __len = _IterOps<_AlgPolicy>::distance(__first, __last) + 1;
  pair<value_type*, ptrdiff_t> __p(0, 0);
  unique_ptr<value_type, __return_temporary_buffer> __h;
  if (__len >= __alloc_limit) {

#pragma GCC diagnostic push
# 279 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_partition.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 279 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/stable_partition.h" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    __p = std::get_temporary_buffer<value_type>(__len);
#pragma GCC diagnostic pop
    __h.reset(__p.first);
  }
  return std::__stable_partition_impl<_AlgPolicy, _Predicate&>(
      std::move(__first), std::move(__last), __pred, __len, __p, bidirectional_iterator_tag());
}

template <class _AlgPolicy, class _Predicate, class _ForwardIterator, class _IterCategory>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator __stable_partition(
    _ForwardIterator __first, _ForwardIterator __last, _Predicate&& __pred, _IterCategory __iter_category) {
  return std::__stable_partition_impl<_AlgPolicy, __remove_cvref_t<_Predicate>&>(
      std::move(__first), std::move(__last), __pred, __iter_category);
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {
  using _IterCategory = typename iterator_traits<_ForwardIterator>::iterator_category;
  return std::__stable_partition<_ClassicAlgPolicy, _Predicate&>(
      std::move(__first), std::move(__last), __pred, _IterCategory());
}

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_stable_partition.h" 2 3
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_stable_partition.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_stable_partition.h" 2 3
# 1953 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_stable_sort.h" 1 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_stable_sort.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_stable_sort.h" 2 3
# 1954 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_swap_ranges.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_swap_ranges.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_swap_ranges.h" 2 3
# 1956 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_transform.h" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_transform.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_transform.h" 2 3
# 1957 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_unique.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_unique.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unique.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unique.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unique.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _AlgPolicy, class _Iter, class _Sent, class _BinaryPredicate>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) std::pair<_Iter, _Iter>
__unique(_Iter __first, _Sent __last, _BinaryPredicate&& __pred) {
  __first = std::__adjacent_find(__first, __last, __pred);
  if (__first != __last) {


    _Iter __i = __first;
    for (++__i; ++__i != __last;)
      if (!__pred(*__first, *__i))
        *++__first = _IterOps<_AlgPolicy>::__iter_move(__i);
    ++__first;
    return std::pair<_Iter, _Iter>(std::move(__first), std::move(__i));
  }
  return std::pair<_Iter, _Iter>(__first, __first);
}

template <class _ForwardIterator, class _BinaryPredicate>
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred) {
  return std::__unique<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __pred).first;
}

template <class _ForwardIterator>
                      inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last) {
  return std::unique(__first, __last, __equal_to());
}

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_unique.h" 2 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_unique.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_unique.h" 2 3
# 1958 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_unique_copy.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_unique_copy.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unique_copy.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unique_copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/unique_copy.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __unique_copy_tags {

struct __reread_from_input_tag {};
struct __reread_from_output_tag {};
struct __read_from_tmp_value_tag {};

}

template <class _AlgPolicy, class _BinaryPredicate, class _InputIterator, class _Sent, class _OutputIterator>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InputIterator, _OutputIterator>
__unique_copy(_InputIterator __first,
              _Sent __last,
              _OutputIterator __result,
              _BinaryPredicate&& __pred,
              __unique_copy_tags::__read_from_tmp_value_tag) {
  if (__first != __last) {
    typename _IterOps<_AlgPolicy>::template __value_type<_InputIterator> __t(*__first);
    *__result = __t;
    ++__result;
    while (++__first != __last) {
      if (!__pred(__t, *__first)) {
        __t = *__first;
        *__result = __t;
        ++__result;
      }
    }
  }
  return pair<_InputIterator, _OutputIterator>(std::move(__first), std::move(__result));
}

template <class _AlgPolicy, class _BinaryPredicate, class _ForwardIterator, class _Sent, class _OutputIterator>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_ForwardIterator, _OutputIterator>
__unique_copy(_ForwardIterator __first,
              _Sent __last,
              _OutputIterator __result,
              _BinaryPredicate&& __pred,
              __unique_copy_tags::__reread_from_input_tag) {
  if (__first != __last) {
    _ForwardIterator __i = __first;
    *__result = *__i;
    ++__result;
    while (++__first != __last) {
      if (!__pred(*__i, *__first)) {
        *__result = *__first;
        ++__result;
        __i = __first;
      }
    }
  }
  return pair<_ForwardIterator, _OutputIterator>(std::move(__first), std::move(__result));
}

template <class _AlgPolicy, class _BinaryPredicate, class _InputIterator, class _Sent, class _InputAndOutputIterator>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<_InputIterator, _InputAndOutputIterator>
__unique_copy(_InputIterator __first,
              _Sent __last,
              _InputAndOutputIterator __result,
              _BinaryPredicate&& __pred,
              __unique_copy_tags::__reread_from_output_tag) {
  if (__first != __last) {
    *__result = *__first;
    while (++__first != __last)
      if (!__pred(*__result, *__first))
        *++__result = *__first;
    ++__result;
  }
  return pair<_InputIterator, _InputAndOutputIterator>(std::move(__first), std::move(__result));
}

template <class _InputIterator, class _OutputIterator, class _BinaryPredicate>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred) {
  using __algo_tag = __conditional_t<
      is_base_of<forward_iterator_tag, typename iterator_traits<_InputIterator>::iterator_category>::value,
      __unique_copy_tags::__reread_from_input_tag,
      __conditional_t<
          is_base_of<forward_iterator_tag, typename iterator_traits<_OutputIterator>::iterator_category>::value &&
              is_same< typename iterator_traits<_InputIterator>::value_type,
                       typename iterator_traits<_OutputIterator>::value_type>::value,
          __unique_copy_tags::__reread_from_output_tag,
          __unique_copy_tags::__read_from_tmp_value_tag> >;
  return std::__unique_copy<_ClassicAlgPolicy>(
             std::move(__first), std::move(__last), std::move(__result), __pred, __algo_tag())
      .second;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result) {
  return std::unique_copy(std::move(__first), std::move(__last), std::move(__result), __equal_to());
}

}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_unique_copy.h" 2 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_unique_copy.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_unique_copy.h" 2 3
# 1959 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_upper_bound.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/ranges_upper_bound.h" 3
# 1960 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove_copy.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/remove_copy.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator
remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value) {
  for (; __first != __last; ++__first) {
    if (!(*__first == __value)) {
      *__result = *__first;
      ++__result;
    }
  }
  return __result;
}

}}
# 1962 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/replace.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/replace.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value) {
  for (; __first != __last; ++__first)
    if (*__first == __old_value)
      *__first = __new_value;
}

}}
# 1965 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/replace_copy.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/replace_copy.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator replace_copy(
    _InputIterator __first,
    _InputIterator __last,
    _OutputIterator __result,
    const _Tp& __old_value,
    const _Tp& __new_value) {
  for (; __first != __last; ++__first, (void)++__result)
    if (*__first == __old_value)
      *__result = __new_value;
    else
      *__result = *__first;
  return __result;
}

}}
# 1966 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/replace_copy_if.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/replace_copy_if.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator replace_copy_if(
    _InputIterator __first,
    _InputIterator __last,
    _OutputIterator __result,
    _Predicate __pred,
    const _Tp& __new_value) {
  for (; __first != __last; ++__first, (void)++__result)
    if (__pred(*__first))
      *__result = __new_value;
    else
      *__result = *__first;
  return __result;
}

}}
# 1967 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/replace_if.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/replace_if.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator, class _Predicate, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      *__first = __new_value;
}

}}
# 1968 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/reverse_copy.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/reverse_copy.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator
reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result) {
  for (; __first != __last; ++__result)
    *__result = *--__last;
  return __result;
}

}}
# 1970 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/rotate_copy.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/rotate_copy.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _ForwardIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator
rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result) {
  return std::copy(__first, __middle, std::copy(__middle, __last, __result));
}

}}
# 1972 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shift_left.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shift_left.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shift_left.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shift_left.h" 3
}}
# 1980 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shift_right.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shift_right.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shift_right.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 101 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__algorithm/shift_right.h" 3
}}
# 1981 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 2001 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 3




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bit" 1 3
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bit" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/bit_ceil.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/bit_ceil.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/bit_ceil.h" 3
}}
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bit" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/bit_floor.h" 1 3
# 12 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/bit_floor.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/bit_log2.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/bit_log2.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/bit_log2.h" 3
}}
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/bit_floor.h" 2 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/bit_floor.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/bit_floor.h" 3
}}
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bit" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/bit_width.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/bit_width.h" 3
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bit" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/byteswap.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/byteswap.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 51 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/byteswap.h" 3
}}
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bit" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/endian.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/endian.h" 3
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bit" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/has_single_bit.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/has_single_bit.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit/has_single_bit.h" 2 3
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bit" 2 3
# 83 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bit" 3
# 2006 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/algorithm" 2 3
# 940 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string_view" 2 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_parse_context.h" 2 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_parse_context.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 103 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_parse_context.h" 3
}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/concepts.h" 2 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/concepts.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/concepts.h" 3
}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_bool.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_integral.h" 1 3
# 13 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_integral.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_integral.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_integral.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/tables.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/tables.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 161 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/tables.h" 3
}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_integral.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_base_10.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_base_10.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_base_10.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 183 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_base_10.h" 3
}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_integral.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_result.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_result.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__system_error/errc.h" 1 3
# 104 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__system_error/errc.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cerrno" 1 3
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cerrno" 3
# 105 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__system_error/errc.h" 2 3
# 108 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__system_error/errc.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





struct __attribute__((__visibility__("default"))) errc { enum __lx{
    address_family_not_supported = 47,
    address_in_use = 48,
    address_not_available = 49,
    already_connected = 56,
    argument_list_too_long = 7,
    argument_out_of_domain = 33,
    bad_address = 14,
    bad_file_descriptor = 9,
    bad_message = 94,
    broken_pipe = 32,
    connection_aborted = 53,
    connection_already_in_progress = 37,
    connection_refused = 61,
    connection_reset = 54,
    cross_device_link = 18,
    destination_address_required = 39,
    device_or_resource_busy = 16,
    directory_not_empty = 66,
    executable_format_error = 8,
    file_exists = 17,
    file_too_large = 27,
    filename_too_long = 63,
    function_not_supported = 78,
    host_unreachable = 65,
    identifier_removed = 90,
    illegal_byte_sequence = 92,
    inappropriate_io_control_operation = 25,
    interrupted = 4,
    invalid_argument = 22,
    invalid_seek = 29,
    io_error = 5,
    is_a_directory = 21,
    message_size = 40,
    network_down = 50,
    network_reset = 52,
    network_unreachable = 51,
    no_buffer_space = 55,
    no_child_process = 10,
    no_link = 97,
    no_lock_available = 77,

    no_message_available = 96,



    no_message = 91,
    no_protocol_option = 42,
    no_space_on_device = 28,

    no_stream_resources = 98,



    no_such_device_or_address = 6,
    no_such_device = 19,
    no_such_file_or_directory = 2,
    no_such_process = 3,
    not_a_directory = 20,
    not_a_socket = 38,

    not_a_stream = 99,



    not_connected = 57,
    not_enough_memory = 12,
    not_supported = 45,
    operation_canceled = 89,
    operation_in_progress = 36,
    operation_not_permitted = 1,
    operation_not_supported = 102,
    operation_would_block = 35,
    owner_dead = 105,
    permission_denied = 13,
    protocol_error = 100,
    protocol_not_supported = 43,
    read_only_file_system = 30,
    resource_deadlock_would_occur = 11,
    resource_unavailable_try_again = 35,
    result_out_of_range = 34,
    state_not_recoverable = 104,

    stream_timeout = 101,



    text_file_busy = 26,
    timed_out = 60,
    too_many_files_open_in_system = 23,
    too_many_files_open = 24,
    too_many_links = 31,
    too_many_symbolic_link_levels = 62,
    value_too_large = 84,
    wrong_protocol_type = 41};
__lx __v_; __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) errc(__lx __v) : __v_(__v) {} __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit errc(int __v) : __v_(static_cast<__lx>(__v)) {} __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) operator int() const { return __v_; } };

}}
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_result.h" 2 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_result.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_result.h" 3
}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_integral.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/traits.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/traits.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/traits.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 195 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/traits.h" 3
}}
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_integral.h" 2 3





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/make_32_64_or_128_bit.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/make_32_64_or_128_bit.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




template <class _Tp>




using __make_32_64_or_128_bit_t =
    __copy_unsigned_t<_Tp,
        __conditional_t<sizeof(_Tp) <= sizeof(int32_t), int32_t,
        __conditional_t<sizeof(_Tp) <= sizeof(int64_t), int64_t,

        __conditional_t<sizeof(_Tp) <= sizeof(__int128_t), __int128_t,
                                                           void>



    > > >;


}}
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_integral.h" 2 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_integral.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_integral.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 322 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_integral.h" 3
}}
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_integral.h" 2 3







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_output.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_output.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/buffer.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/buffer.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_to_n_result.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_to_n_result.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_to_n_result.h" 3
}}
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/buffer.h" 2 3
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/buffer.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/buffer.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 651 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/buffer.h" 3
}}
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_output.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/parser_std_format_spec.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/parser_std_format_spec.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_arg.h" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_arg.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_arg.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 293 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_arg.h" 3
}}
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/parser_std_format_spec.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_string.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_string.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 158 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_string.h" 3
}}
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/parser_std_format_spec.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/unicode.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/unicode.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/extended_grapheme_cluster_table.h" 1 3
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/extended_grapheme_cluster_table.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 1661 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/extended_grapheme_cluster_table.h" 3
}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/unicode.h" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/unicode.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 477 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/unicode.h" 3
}}
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/parser_std_format_spec.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/width_estimation_table.h" 1 3
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/width_estimation_table.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 269 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/width_estimation_table.h" 3
}}
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/parser_std_format_spec.h" 2 3








# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 1 3
# 581 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ios/fpos.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ios/fpos.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _StateT>
class fpos {
private:
  _StateT __st_;
  streamoff __off_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) operator streamoff() const { return __off_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _StateT state() const { return __st_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void state(_StateT __st) { __st_ = __st; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) fpos& operator+=(streamoff __off) {
    __off_ += __off;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) fpos operator+(streamoff __off) const {
    fpos __t(*this);
    __t += __off;
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) fpos& operator-=(streamoff __off) {
    __off_ -= __off;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) fpos operator-(streamoff __off) const {
    fpos __t(*this);
    __t -= __off;
    return __t;
  }
};

template <class _StateT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) streamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y) {
  return streamoff(__x) - streamoff(__y);
}

template <class _StateT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y) {
  return streamoff(__x) == streamoff(__y);
}

template <class _StateT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y) {
  return streamoff(__x) != streamoff(__y);
}

}}
# 582 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 2 3
# 593 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/swap_allocator.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/swap_allocator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <typename _Alloc>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __swap_allocator(_Alloc& __a1, _Alloc& __a2, true_type)





{
  using std::swap;
  swap(__a1, __a2);
}

template <typename _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__swap_allocator(_Alloc&, _Alloc&, false_type) throw() {}

template <typename _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __swap_allocator(_Alloc& __a1, _Alloc& __a2)





{
  std::__swap_allocator(
      __a1, __a2, integral_constant<bool, allocator_traits<_Alloc>::propagate_on_container_swap::value>());
}

}}
# 594 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory_resource/polymorphic_allocator.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory_resource/polymorphic_allocator.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory_resource/memory_resource.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory_resource/memory_resource.h" 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory_resource/polymorphic_allocator.h" 2 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory_resource/polymorphic_allocator.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory_resource/polymorphic_allocator.h" 2 3
# 595 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/container_compatible_range.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/container_compatible_range.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/container_compatible_range.h" 3
}}
# 598 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/from_range.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/from_range.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/from_range.h" 3
}}
# 599 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/extern_template_lists.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__string/extern_template_lists.h" 3
# 602 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_allocator.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_allocator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <typename _Alloc, typename = void, typename = void>
struct __is_allocator : false_type {};

template <typename _Alloc>
struct __is_allocator<_Alloc,
                      __void_t<typename _Alloc::value_type>,
                      __void_t<__decltype(std::declval<_Alloc&>().allocate(size_t(0)))> > : true_type {};

}}
# 603 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 2 3







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/noexcept_move_assign_container.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/noexcept_move_assign_container.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <typename _Alloc, typename _Traits = allocator_traits<_Alloc> >
struct __noexcept_move_assign_container
    : public integral_constant<bool,
                               _Traits::propagate_on_container_move_assignment::value



                                   && is_nothrow_move_assignable<_Alloc>::value

                               > {
};

}}
# 611 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 2 3
# 647 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 651 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 2 3
# 664 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const basic_string<_CharT, _Traits, _Allocator>& __y);

template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __x, const basic_string<_CharT, _Traits, _Allocator>& __y);

template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __x, const basic_string<_CharT, _Traits, _Allocator>& __y);

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);

template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);

extern template __attribute__((__visibility__("default"))) string operator+
    <char, char_traits<char>, allocator<char> >(char const*, string const&);

template <class _Iter>
struct __string_is_trivial_iterator : public false_type {};

template <class _Tp>
struct __string_is_trivial_iterator<_Tp*> : public is_arithmetic<_Tp> {};

template <class _Iter>
struct __string_is_trivial_iterator<__wrap_iter<_Iter> > : public __string_is_trivial_iterator<_Iter> {};

template <class _CharT, class _Traits, class _Tp>
struct __can_be_converted_to_string_view
    : public _BoolConstant< is_convertible<const _Tp&, basic_string_view<_CharT, _Traits> >::value &&
                            !is_convertible<const _Tp&, const _CharT*>::value > {};

struct __uninitialized_size_tag {};
struct __init_with_sentinel_tag {};

template <class _CharT, class _Traits, class _Allocator>
class basic_string {
private:
  using __default_allocator_type = allocator<_CharT>;

public:
  typedef basic_string __self;
  typedef basic_string_view<_CharT, _Traits> __self_view;
  typedef _Traits traits_type;
  typedef _CharT value_type;
  typedef _Allocator allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;

  _Static_assert((!is_array<value_type>::value), "Character type of basic_string must not be an array");
  _Static_assert((is_standard_layout<value_type>::value), "Character type of basic_string must be standard-layout");
  _Static_assert((is_trivial<value_type>::value), "Character type of basic_string must be trivial");
  _Static_assert((is_same<_CharT, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT");

  _Static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");


  _Static_assert(is_same<allocator_type, __rebind_alloc<__alloc_traits, value_type> >::value, "[allocator.requirements] states that rebinding an allocator to the same type should result in the " "original allocator");




  typedef __wrap_iter<pointer> iterator;
  typedef __wrap_iter<const_pointer> const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

private:
  _Static_assert(8 == 8, "This implementation assumes that one byte contains 8 bits");



  struct __long {
    pointer __data_;
    size_type __size_;
    size_type __cap_ : sizeof(size_type) * 8 - 1;
    size_type __is_long_ : 1;
  };

  enum { __min_cap = (sizeof(__long) - 1) / sizeof(value_type) > 2 ? (sizeof(__long) - 1) / sizeof(value_type) : 2 };

  struct __short {
    value_type __data_[__min_cap];
    unsigned char __padding_[sizeof(value_type) - 1];
    unsigned char __size_ : 7;
    unsigned char __is_long_ : 1;
  };
# 782 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
  static const size_type __endian_factor = 1;
# 819 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
  _Static_assert(sizeof(__short) == (sizeof(value_type) * (__min_cap + 1)), "__short has an unexpected size.");

  union __ulx {
    __long __lx;
    __short __lxx;
  };

  enum { __n_words = sizeof(__ulx) / sizeof(size_type) };

  struct __raw {
    size_type __words[__n_words];
  };

  struct __rep {
    union {
      __short __s;
      __long __l;
      __raw __r;
    };
  };

  __compressed_pair<__rep, allocator_type> __r_;




  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit basic_string(
      __uninitialized_size_tag, size_type __size, const allocator_type& __a)
      : __r_(__default_init_tag(), __a) {
    if (__size > max_size())
      __throw_length_error();
    if (__fits_in_sso(__size)) {
      __r_.first() = __rep();
      __set_short_size(__size);
    } else {
      auto __capacity = __recommend(__size) + 1;
      auto __allocation = __alloc_traits::allocate(__alloc(), __capacity);
      __begin_lifetime(__allocation, __capacity);
      __set_long_cap(__capacity);
      __set_long_pointer(__allocation);
      __set_long_size(__size);
    }
    __annotate_new(__size);
  }

  template <class _Iter, class _Sent>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  basic_string(__init_with_sentinel_tag, _Iter __first, _Sent __last, const allocator_type& __a)
      : __r_(__default_init_tag(), __a) {
    __init_with_sentinel(std::move(__first), std::move(__last));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator __make_iterator(pointer __p) { return iterator(__p); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator __make_const_iterator(const_pointer __p) const {
    return const_iterator(__p);
  }

public:
  __attribute__((__visibility__("default"))) static const size_type npos = -1;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string()

      : __r_(__value_init_tag(), __default_init_tag()) {
    __annotate_new(0);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit basic_string(const allocator_type& __a)





      : __r_(__value_init_tag(), __a) {
    __annotate_new(0);
  }

                                                                      basic_string(const basic_string& __str)
      : __r_(__default_init_tag(), __alloc_traits::select_on_container_copy_construction(__str.__alloc())) {
    if (!__str.__is_long()) {
      __r_.first() = __str.__r_.first();
      __annotate_new(__get_short_size());
    } else
      __init_copy_ctor_external(std::__to_address(__str.__get_long_pointer()), __str.__get_long_size());
  }


  basic_string(const basic_string& __str, const allocator_type& __a)
      : __r_(__default_init_tag(), __a) {
    if (!__str.__is_long()) {
      __r_.first() = __str.__r_.first();
      __annotate_new(__get_short_size());
    } else
      __init_copy_ctor_external(std::__to_address(__str.__get_long_pointer()), __str.__get_long_size());
  }
# 950 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
  template <__enable_if_t<__is_allocator<_Allocator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string(const _CharT* __s)
      : __r_(__default_init_tag(), __default_init_tag()) {
    ((void)0);
    __init(__s, traits_type::length(__s));
  }

  template <__enable_if_t<__is_allocator<_Allocator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string(const _CharT* __s, const _Allocator& __a)
      : __r_(__default_init_tag(), __a) {
    ((void)0);
    __init(__s, traits_type::length(__s));
  }





  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string(const _CharT* __s, size_type __n)
      : __r_(__default_init_tag(), __default_init_tag()) {
    ((void)0);
    __init(__s, __n);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  basic_string(const _CharT* __s, size_type __n, const _Allocator& __a)
      : __r_(__default_init_tag(), __a) {
    ((void)0);
    __init(__s, __n);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string(size_type __n, _CharT __c)
      : __r_(__default_init_tag(), __default_init_tag()) {
    __init(__n, __c);
  }
# 1007 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
  template <__enable_if_t<__is_allocator<_Allocator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string(size_type __n, _CharT __c, const _Allocator& __a)
      : __r_(__default_init_tag(), __a) {
    __init(__n, __c);
  }


  basic_string(const basic_string& __str, size_type __pos, size_type __n, const _Allocator& __a = _Allocator())
      : __r_(__default_init_tag(), __a) {
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
      __throw_out_of_range();
    __init(__str.data() + __pos, std::min(__n, __str_sz - __pos));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  basic_string(const basic_string& __str, size_type __pos, const _Allocator& __a = _Allocator())
      : __r_(__default_init_tag(), __a) {
    size_type __str_sz = __str.size();
    if (__pos > __str_sz)
      __throw_out_of_range();
    __init(__str.data() + __pos, __str_sz - __pos);
  }

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden")))
  basic_string(const _Tp& __t, size_type __pos, size_type __n, const allocator_type& __a = allocator_type())
      : __r_(__default_init_tag(), __a) {
    __self_view __sv0 = __t;
    __self_view __sv = __sv0.substr(__pos, __n);
    __init(__sv.data(), __sv.size());
  }

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) explicit basic_string(const _Tp& __t)
      : __r_(__default_init_tag(), __default_init_tag()) {
    __self_view __sv = __t;
    __init(__sv.data(), __sv.size());
  }

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) explicit basic_string(
      const _Tp& __t, const allocator_type& __a)
      : __r_(__default_init_tag(), __a) {
    __self_view __sv = __t;
    __init(__sv.data(), __sv.size());
  }

  template <class _InputIterator, __enable_if_t<__has_input_iterator_category<_InputIterator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string(_InputIterator __first, _InputIterator __last)
      : __r_(__default_init_tag(), __default_init_tag()) {
    __init(__first, __last);
  }

  template <class _InputIterator, __enable_if_t<__has_input_iterator_category<_InputIterator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a)
      : __r_(__default_init_tag(), __a) {
    __init(__first, __last);
  }
# 1102 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
  inline ~basic_string() {
    __annotate_delete();
    if (__is_long())
      __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) operator __self_view() const throw() {
    return __self_view(data(), size());
  }

                                                                      basic_string&
  operator=(const basic_string& __str);

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
                                basic_string& operator=(const _Tp& __t) {
    __self_view __sv = __t;
    return assign(__sv);
  }
# 1135 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string& operator=(const value_type* __s) {
    return assign(__s);
  }



                                                                      basic_string& operator=(value_type __c);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator begin() throw() {
    return __make_iterator(__get_pointer());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator begin() const throw() {
    return __make_const_iterator(__get_pointer());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator end() throw() {
    return __make_iterator(__get_pointer() + size());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator end() const throw() {
    return __make_const_iterator(__get_pointer() + size());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator rbegin() throw() {
    return reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator rbegin() const throw() {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator rend() throw() {
    return reverse_iterator(begin());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator rend() const throw() {
    return const_reverse_iterator(begin());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator cbegin() const throw() { return begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator cend() const throw() { return end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator crbegin() const throw() {
    return rbegin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator crend() const throw() { return rend(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type size() const throw() {
    return __is_long() ? __get_long_size() : __get_short_size();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type length() const throw() { return size(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type max_size() const throw() {
    size_type __m = __alloc_traits::max_size(__alloc());
    if (__m <= std::numeric_limits<size_type>::max() / 2) {
      return __m - __alignment;
    } else {
      bool __uses_lsb = __endian_factor == 2;
      return __uses_lsb ? __m - __alignment : (__m / 2) - __alignment;
    }
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type capacity() const throw() {
    return (__is_long() ? __get_long_cap() : static_cast<size_type>(__min_cap)) - 1;
  }

                                void resize(size_type __n, value_type __c);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void resize(size_type __n) { resize(__n, value_type()); }

                                void reserve(size_type __requested_capacity);
# 1208 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __resize_default_init(size_type __n);


                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void reserve() throw() { shrink_to_fit(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void shrink_to_fit() throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void clear() throw();

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool empty() const throw() {
    return size() == 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference operator[](size_type __pos) const throw() {
    ((void)0);
    if (__builtin_constant_p(__pos) && !__fits_in_sso(__pos)) {
      return *(__get_long_pointer() + __pos);
    }
    return *(data() + __pos);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator[](size_type __pos) throw() {
    ((void)0);
    if (__builtin_constant_p(__pos) && !__fits_in_sso(__pos)) {
      return *(__get_long_pointer() + __pos);
    }
    return *(__get_pointer() + __pos);
  }

                                const_reference at(size_type __n) const;
                                reference at(size_type __n);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string& operator+=(const basic_string& __str) {
    return append(__str);
  }

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string >::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) basic_string&
  operator+=(const _Tp& __t) {
    __self_view __sv = __t;
    return append(__sv);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string& operator+=(const value_type* __s) {
    return append(__s);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string& operator+=(value_type __c) {
    push_back(__c);
    return *this;
  }







  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string& append(const basic_string& __str) {
    return append(__str.data(), __str.size());
  }

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) basic_string&
  append(const _Tp& __t) {
    __self_view __sv = __t;
    return append(__sv.data(), __sv.size());
  }

                                basic_string& append(const basic_string& __str, size_type __pos, size_type __n = npos);

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden")))

      basic_string&
      append(const _Tp& __t, size_type __pos, size_type __n = npos);

                                basic_string& append(const value_type* __s, size_type __n);
                                basic_string& append(const value_type* __s);
                                basic_string& append(size_type __n, value_type __c);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __append_default_init(size_type __n);

  template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string&
  append(_InputIterator __first, _InputIterator __last) {
    const basic_string __temp(__first, __last, __alloc());
    append(__temp.data(), __temp.size());
    return *this;
  }

  template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string&
  append(_ForwardIterator __first, _ForwardIterator __last);
# 1325 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
                                void push_back(value_type __c);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void pop_back();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference front() throw() {
    ((void)0);
    return *__get_pointer();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference front() const throw() {
    ((void)0);
    return *data();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference back() throw() {
    ((void)0);
    return *(__get_pointer() + size() - 1);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference back() const throw() {
    ((void)0);
    return *(data() + size() - 1);
  }

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) basic_string&
  assign(const _Tp& __t) {
    __self_view __sv = __t;
    return assign(__sv.data(), __sv.size());
  }
# 1378 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string& assign(const basic_string& __str) {
    return *this = __str;
  }







                                basic_string& assign(const basic_string& __str, size_type __pos, size_type __n = npos);

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) basic_string&
  assign(const _Tp& __t, size_type __pos, size_type __n = npos);

                                basic_string& assign(const value_type* __s, size_type __n);
                                basic_string& assign(const value_type* __s);
                                basic_string& assign(size_type __n, value_type __c);
  template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) basic_string&
  assign(_InputIterator __first, _InputIterator __last);

  template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) basic_string&
  assign(_ForwardIterator __first, _ForwardIterator __last);
# 1430 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string&
  insert(size_type __pos1, const basic_string& __str) {
    return insert(__pos1, __str.data(), __str.size());
  }

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) basic_string&
  insert(size_type __pos1, const _Tp& __t) {
    __self_view __sv = __t;
    return insert(__pos1, __sv.data(), __sv.size());
  }

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) basic_string&
  insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n = npos);

                                basic_string&
  insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n = npos);
                                basic_string& insert(size_type __pos, const value_type* __s, size_type __n);
                                basic_string& insert(size_type __pos, const value_type* __s);
                                basic_string& insert(size_type __pos, size_type __n, value_type __c);
                                iterator insert(const_iterator __pos, value_type __c);
# 1470 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator
  insert(const_iterator __pos, size_type __n, value_type __c) {
    difference_type __p = __pos - begin();
    insert(static_cast<size_type>(__p), __n, __c);
    return begin() + __p;
  }

  template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) iterator
  insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);

  template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) iterator
  insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);
# 1492 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
                                basic_string& erase(size_type __pos = 0, size_type __n = npos);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator erase(const_iterator __pos);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator erase(const_iterator __first, const_iterator __last);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string&
  replace(size_type __pos1, size_type __n1, const basic_string& __str) {
    return replace(__pos1, __n1, __str.data(), __str.size());
  }

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) basic_string&
  replace(size_type __pos1, size_type __n1, const _Tp& __t) {
    __self_view __sv = __t;
    return replace(__pos1, __n1, __sv.data(), __sv.size());
  }

                                basic_string&
  replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2 = npos);

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) basic_string&
  replace(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2 = npos);

                                basic_string&
  replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);
                                basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);
                                basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string&
  replace(const_iterator __i1, const_iterator __i2, const basic_string& __str) {
    return replace(
        static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __str.data(), __str.size());
  }

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) basic_string&
  replace(const_iterator __i1, const_iterator __i2, const _Tp& __t) {
    __self_view __sv = __t;
    return replace(__i1 - begin(), __i2 - __i1, __sv);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string&
  replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n) {
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string&
  replace(const_iterator __i1, const_iterator __i2, const value_type* __s) {
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string&
  replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c) {
    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);
  }

  template <class _InputIterator, __enable_if_t<__has_input_iterator_category<_InputIterator>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) basic_string&
  replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);
# 1571 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
                                size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string
  substr(size_type __pos = 0, size_type __n = npos) const {
    return basic_string(*this, __pos, __n);
  }
# 1588 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(basic_string& __str)



                                                                                                                      ;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const value_type* c_str() const throw() { return data(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const value_type* data() const throw() {
    return std::__to_address(__get_pointer());
  }






  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) allocator_type get_allocator() const throw() {
    return __alloc();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find(const basic_string& __str, size_type __pos = 0) const throw();

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) size_type
  find(const _Tp& __t, size_type __pos = 0) const throw();

                                size_type find(const value_type* __s, size_type __pos, size_type __n) const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find(const value_type* __s, size_type __pos = 0) const throw();
                                size_type find(value_type __c, size_type __pos = 0) const throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  rfind(const basic_string& __str, size_type __pos = npos) const throw();

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) size_type
  rfind(const _Tp& __t, size_type __pos = npos) const throw();

                                size_type rfind(const value_type* __s, size_type __pos, size_type __n) const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  rfind(const value_type* __s, size_type __pos = npos) const throw();
                                size_type rfind(value_type __c, size_type __pos = npos) const throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_first_of(const basic_string& __str, size_type __pos = 0) const throw();

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) size_type
  find_first_of(const _Tp& __t, size_type __pos = 0) const throw();

                                size_type
  find_first_of(const value_type* __s, size_type __pos, size_type __n) const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_first_of(const value_type* __s, size_type __pos = 0) const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_first_of(value_type __c, size_type __pos = 0) const throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_last_of(const basic_string& __str, size_type __pos = npos) const throw();

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) size_type
  find_last_of(const _Tp& __t, size_type __pos = npos) const throw();

                                size_type
  find_last_of(const value_type* __s, size_type __pos, size_type __n) const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_last_of(const value_type* __s, size_type __pos = npos) const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_last_of(value_type __c, size_type __pos = npos) const throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_first_not_of(const basic_string& __str, size_type __pos = 0) const throw();

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) size_type
  find_first_not_of(const _Tp& __t, size_type __pos = 0) const throw();

                                size_type
  find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_first_not_of(const value_type* __s, size_type __pos = 0) const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_first_not_of(value_type __c, size_type __pos = 0) const throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_last_not_of(const basic_string& __str, size_type __pos = npos) const throw();

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) size_type
  find_last_not_of(const _Tp& __t, size_type __pos = npos) const throw();

                                size_type
  find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_last_not_of(const value_type* __s, size_type __pos = npos) const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  find_last_not_of(value_type __c, size_type __pos = npos) const throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int compare(const basic_string& __str) const throw();

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) int
  compare(const _Tp& __t) const throw();

  template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> = 0>
  inline __attribute__((__visibility__("hidden"))) int
  compare(size_type __pos1, size_type __n1, const _Tp& __t) const;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int
  compare(size_type __pos1, size_type __n1, const basic_string& __str) const;
                                int
  compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2 = npos) const;

  template <class _Tp,
            __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                              !__is_same_uncvref<_Tp, basic_string>::value,
                          int> = 0>
  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int
  compare(size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2 = npos) const;

                                int compare(const value_type* __s) const throw();
                                int compare(size_type __pos1, size_type __n1, const value_type* __s) const;
                                int
  compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;
# 1756 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __invariants() const;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __clear_and_shrink() throw();

private:
  template <class _Alloc>
  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool friend
  operator==(const basic_string<char, char_traits<char>, _Alloc>& __lhs,
             const basic_string<char, char_traits<char>, _Alloc>& __rhs) throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __shrink_or_extend(size_type __target_capacity);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
  __is_long() const throw() {
    if (__libcpp_is_constant_evaluated() && __builtin_constant_p(__r_.first().__l.__is_long_)) {
      return __r_.first().__l.__is_long_;
    }
    return __r_.first().__s.__is_long_;
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __begin_lifetime(pointer __begin, size_type __n) {






    (void)__begin;
    (void)__n;

  }

                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static bool __fits_in_sso(size_type __sz) { return __sz < __min_cap; }

  template <class _Iterator, class _Sentinel>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __assign_trivial(_Iterator __first, _Sentinel __last, size_type __n);

  template <class _Iterator, class _Sentinel>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __assign_with_sentinel(_Iterator __first, _Sentinel __last);

  template <class _ForwardIterator, class _Sentinel>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator
  __insert_from_safe_copy(size_type __n, size_type __ip, _ForwardIterator __first, _Sentinel __last) {
    size_type __sz = size();
    size_type __cap = capacity();
    value_type* __p;
    if (__cap - __sz >= __n) {
      __annotate_increase(__n);
      __p = std::__to_address(__get_pointer());
      size_type __n_move = __sz - __ip;
      if (__n_move != 0)
        traits_type::move(__p + __ip + __n, __p + __ip, __n_move);
    } else {
      __grow_by_without_replace(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);
      __p = std::__to_address(__get_long_pointer());
    }
    __sz += __n;
    __set_size(__sz);
    traits_type::assign(__p[__sz], value_type());
    for (__p += __ip; __first != __last; ++__p, ++__first)
      traits_type::assign(*__p, *__first);

    return begin() + __ip;
  }

  template <class _Iterator, class _Sentinel>
                                iterator
  __insert_with_size(const_iterator __pos, _Iterator __first, _Sentinel __last, size_type __n);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) allocator_type& __alloc() throw() { return __r_.second(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const allocator_type& __alloc() const throw() { return __r_.second(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __set_short_size(size_type __s) throw() {
    ((void)0);
    __r_.first().__s.__size_ = __s;
    __r_.first().__s.__is_long_ = false;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type
  __get_short_size() const throw() {
    ((void)0);
    return __r_.first().__s.__size_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __set_long_size(size_type __s) throw() {
    __r_.first().__l.__size_ = __s;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type __get_long_size() const throw() {
    return __r_.first().__l.__size_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __set_size(size_type __s) throw() {
    if (__is_long())
      __set_long_size(__s);
    else
      __set_short_size(__s);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __set_long_cap(size_type __s) throw() {
    __r_.first().__l.__cap_ = __s / __endian_factor;
    __r_.first().__l.__is_long_ = true;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type __get_long_cap() const throw() {
    return __r_.first().__l.__cap_ * __endian_factor;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __set_long_pointer(pointer __p) throw() {
    __r_.first().__l.__data_ = __p;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer __get_long_pointer() throw() {
    return __r_.first().__l.__data_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_pointer __get_long_pointer() const throw() {
    return __r_.first().__l.__data_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer __get_short_pointer() throw() {
    return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_pointer __get_short_pointer() const throw() {
    return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer __get_pointer() throw() {
    return __is_long() ? __get_long_pointer() : __get_short_pointer();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_pointer __get_pointer() const throw() {
    return __is_long() ? __get_long_pointer() : __get_short_pointer();
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __annotate_contiguous_container(const void* __old_mid, const void* __new_mid) const {
    (void)__old_mid;
    (void)__new_mid;






  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __asan_short_string_is_annotated() const throw() {
    return false && !__libcpp_is_constant_evaluated();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __annotate_new(size_type __current_size) const throw() {
    (void) __current_size;




  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __annotate_delete() const throw() {




  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __annotate_increase(size_type __n) const throw() {
    (void) __n;




  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __annotate_shrink(size_type __old_size) const throw() {
    (void) __old_size;




  }

  template <size_type __a>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type __align_it(size_type __s) throw() {
    return (__s + (__a - 1)) & ~(__a - 1);
  }
  enum {
    __alignment = 8
  };
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type __recommend(size_type __s) throw() {
    if (__s < __min_cap) {
      return static_cast<size_type>(__min_cap) - 1;
    }
    size_type __guess =
        __align_it < sizeof(value_type) < __alignment ? __alignment / sizeof(value_type) : 1 > (__s + 1) - 1;
    if (__guess == __min_cap)
      ++__guess;
    return __guess;
  }

  inline void __init(const value_type* __s, size_type __sz, size_type __reserve);
  inline void __init(const value_type* __s, size_type __sz);
  inline void __init(size_type __n, value_type __c);
# 1965 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
                                __attribute__((__noinline__)) void __init_copy_ctor_external(const value_type* __s, size_type __sz);

  template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> = 0>
  inline void __init(_InputIterator __first, _InputIterator __last);

  template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
  inline void __init(_ForwardIterator __first, _ForwardIterator __last);

  template <class _InputIterator, class _Sentinel>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __init_with_sentinel(_InputIterator __first, _Sentinel __last);
  template <class _InputIterator, class _Sentinel>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __init_with_size(_InputIterator __first, _Sentinel __last, size_type __sz);





          __attribute__((__deprecated__("use __grow_by_without_replace"))) void __grow_by(
              size_type __old_cap,
              size_type __delta_cap,
              size_type __old_sz,
              size_type __n_copy,
              size_type __n_del,
              size_type __n_add = 0);
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __grow_by_without_replace(
      size_type __old_cap,
      size_type __delta_cap,
      size_type __old_sz,
      size_type __n_copy,
      size_type __n_del,
      size_type __n_add = 0);
                                void __grow_by_and_replace(
      size_type __old_cap,
      size_type __delta_cap,
      size_type __old_sz,
      size_type __n_copy,
      size_type __n_del,
      size_type __n_add,
      const value_type* __p_new_stuff);




  template <bool __is_short>
                                __attribute__((__noinline__)) basic_string& __assign_no_alias(const value_type* __s, size_type __n);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __erase_to_end(size_type __pos) {
    __null_terminate_at(std::__to_address(__get_pointer()), __pos);
  }



                                __attribute__((__noinline__)) void __erase_external_with_move(size_type __pos, size_type __n);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __copy_assign_alloc(const basic_string& __str) {
    __copy_assign_alloc(
        __str, integral_constant<bool, __alloc_traits::propagate_on_container_copy_assignment::value>());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __copy_assign_alloc(const basic_string& __str, true_type) {
    if (__alloc() == __str.__alloc())
      __alloc() = __str.__alloc();
    else {
      if (!__str.__is_long()) {
        __clear_and_shrink();
        __alloc() = __str.__alloc();
      } else {
        __annotate_delete();
        allocator_type __a = __str.__alloc();
        auto __allocation = std::__allocate_at_least(__a, __str.__get_long_cap());
        __begin_lifetime(__allocation.ptr, __allocation.count);
        if (__is_long())
          __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
        __alloc() = std::move(__a);
        __set_long_pointer(__allocation.ptr);
        __set_long_cap(__allocation.count);
        __set_long_size(__str.size());
        __annotate_new(__get_long_size());
      }
    }
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __copy_assign_alloc(const basic_string&, false_type) throw() {}
# 2064 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign_alloc(basic_string& __str)

                                                                    {
    __move_assign_alloc(
        __str, integral_constant<bool, __alloc_traits::propagate_on_container_move_assignment::value>());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign_alloc(basic_string& __c, true_type)
                                                                    {
    __alloc() = std::move(__c.__alloc());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign_alloc(basic_string&, false_type) throw() {}

                                __attribute__((__noinline__)) basic_string& __assign_external(const value_type* __s);
                                __attribute__((__noinline__)) basic_string& __assign_external(const value_type* __s, size_type __n);


  inline basic_string& __assign_short(const value_type* __s, size_type __n) {
    size_type __old_size = size();
    if (__n > __old_size)
      __annotate_increase(__n - __old_size);
    pointer __p =
        __is_long() ? (__set_long_size(__n), __get_long_pointer()) : (__set_short_size(__n), __get_short_pointer());
    traits_type::move(std::__to_address(__p), __s, __n);
    traits_type::assign(__p[__n], value_type());
    if (__old_size > __n)
      __annotate_shrink(__old_size);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string&
  __null_terminate_at(value_type* __p, size_type __newsz) {
    size_type __old_size = size();
    if (__newsz > __old_size)
      __annotate_increase(__newsz - __old_size);
    __set_size(__newsz);
    traits_type::assign(__p[__newsz], value_type());
    if (__old_size > __newsz)
      __annotate_shrink(__old_size);
    return *this;
  }

  template <class _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __addr_in_range(const _Tp& __v) const {
    return std::__is_pointer_in_range(data(), data() + size() + 1, std::addressof(__v));
  }

  __attribute__((__noreturn__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __throw_length_error() const {
    std::__throw_length_error("basic_string");
  }

  __attribute__((__noreturn__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __throw_out_of_range() const {
    std::__throw_out_of_range("basic_string");
  }

  friend basic_string operator+ <>(const basic_string&, const basic_string&);
  friend basic_string operator+ <>(const value_type*, const basic_string&);
  friend basic_string operator+ <>(value_type, const basic_string&);
  friend basic_string operator+ <>(const basic_string&, const value_type*);
  friend basic_string operator+ <>(const basic_string&, value_type);
};
# 2136 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, value_type const*, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::rfind(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) void basic_string<char>::__init(value_type const*, size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>::basic_string(basic_string const&); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<char>::basic_string(basic_string const&, allocator<char> const&); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_last_not_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<char>::~basic_string(); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_first_not_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::operator=(value_type); extern template __attribute__((__visibility__("default"))) void basic_string<char>::__init(value_type const*, size_type); extern template __attribute__((__visibility__("default"))) const char& basic_string<char>::at(size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, value_type const*, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_first_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(value_type const*, size_type); extern template __attribute__((__visibility__("default"))) void basic_string<char>::reserve(size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::append(value_type const*, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(basic_string const&, size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::copy(value_type*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<char>::basic_string(basic_string const&, size_type, size_type, allocator<char> const&); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find(value_type, size_type) const; extern template __attribute__((__visibility__("default"))) void basic_string<char>::__init(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find_last_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) void basic_string<char>::__grow_by(size_type, size_type, size_type, size_type, size_type, size_type); extern template __attribute__((__visibility__("default"))) void basic_string<char>::__grow_by_and_replace(size_type, size_type, size_type, size_type, size_type, size_type, value_type const*); extern template __attribute__((__visibility__("default"))) void basic_string<char>::push_back(value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::append(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::rfind(value_type, size_type) const; extern template __attribute__((__visibility__("default"))) const basic_string<char>::size_type basic_string<char>::npos; extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::erase(size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::append(basic_string const&, size_type, size_type); extern template __attribute__((__visibility__("default"))) int basic_string<char>::compare(value_type const*) const; extern template __attribute__((__visibility__("default"))) int basic_string<char>::compare(size_type, size_type, value_type const*) const; extern template __attribute__((__visibility__("default"))) char& basic_string<char>::at(size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::assign(value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<char>::size_type basic_string<char>::find(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) int basic_string<char>::compare(size_type, size_type, basic_string const&, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) int basic_string<char>::compare(size_type, size_type, value_type const*, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::operator=(basic_string const&); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::append(value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::replace(size_type, size_type, basic_string const&, size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<char>::iterator basic_string<char>::insert(basic_string::const_iterator, value_type); extern template __attribute__((__visibility__("default"))) void basic_string<char>::resize(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<char>& basic_string<char>::insert(size_type, basic_string const&, size_type, size_type);

extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, value_type const*, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::rfind(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::__init(value_type const*, size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::basic_string(basic_string const&); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::basic_string(basic_string const&, allocator<wchar_t> const&); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_last_not_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::~basic_string(); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_first_not_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::operator=(value_type); extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::__init(value_type const*, size_type); extern template __attribute__((__visibility__("default"))) const wchar_t& basic_string<wchar_t>::at(size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, value_type const*, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_first_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(value_type const*, size_type); extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::reserve(size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(value_type const*, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(basic_string const&, size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::copy(value_type*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::basic_string(basic_string const&, size_type, size_type, allocator<wchar_t> const&); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find(value_type, size_type) const; extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::__init(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find_last_of(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::__grow_by(size_type, size_type, size_type, size_type, size_type, size_type); extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::__grow_by_and_replace(size_type, size_type, size_type, size_type, size_type, size_type, value_type const*); extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::push_back(value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::rfind(value_type, size_type) const; extern template __attribute__((__visibility__("default"))) const basic_string<wchar_t>::size_type basic_string<wchar_t>::npos; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::erase(size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(basic_string const&, size_type, size_type); extern template __attribute__((__visibility__("default"))) int basic_string<wchar_t>::compare(value_type const*) const; extern template __attribute__((__visibility__("default"))) int basic_string<wchar_t>::compare(size_type, size_type, value_type const*) const; extern template __attribute__((__visibility__("default"))) wchar_t& basic_string<wchar_t>::at(size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::assign(value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::size_type basic_string<wchar_t>::find(value_type const*, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) int basic_string<wchar_t>::compare(size_type, size_type, basic_string const&, size_type, size_type) const; extern template __attribute__((__visibility__("default"))) int basic_string<wchar_t>::compare(size_type, size_type, value_type const*, size_type) const; extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::operator=(basic_string const&); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::append(value_type const*); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::replace(size_type, size_type, basic_string const&, size_type, size_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>::iterator basic_string<wchar_t>::insert(basic_string::const_iterator, value_type); extern template __attribute__((__visibility__("default"))) void basic_string<wchar_t>::resize(size_type, value_type); extern template __attribute__((__visibility__("default"))) basic_string<wchar_t>& basic_string<wchar_t>::insert(size_type, basic_string const&, size_type, size_type);
# 2176 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
template <class _CharT, class _Traits, class _Allocator>
                              void
basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz, size_type __reserve) {
  if (__libcpp_is_constant_evaluated())
    __r_.first() = __rep();
  if (__reserve > max_size())
    __throw_length_error();
  pointer __p;
  if (__fits_in_sso(__reserve)) {
    __set_short_size(__sz);
    __p = __get_short_pointer();
  } else {
    auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__reserve) + 1);
    __p = __allocation.ptr;
    __begin_lifetime(__p, __allocation.count);
    __set_long_pointer(__p);
    __set_long_cap(__allocation.count);
    __set_long_size(__sz);
  }
  traits_type::copy(std::__to_address(__p), __s, __sz);
  traits_type::assign(__p[__sz], value_type());
  __annotate_new(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
                              void
basic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz) {
  if (__libcpp_is_constant_evaluated())
    __r_.first() = __rep();
  if (__sz > max_size())
    __throw_length_error();
  pointer __p;
  if (__fits_in_sso(__sz)) {
    __set_short_size(__sz);
    __p = __get_short_pointer();
  } else {
    auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__sz) + 1);
    __p = __allocation.ptr;
    __begin_lifetime(__p, __allocation.count);
    __set_long_pointer(__p);
    __set_long_cap(__allocation.count);
    __set_long_size(__sz);
  }
  traits_type::copy(std::__to_address(__p), __s, __sz);
  traits_type::assign(__p[__sz], value_type());
  __annotate_new(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
                              __attribute__((__noinline__)) void
basic_string<_CharT, _Traits, _Allocator>::__init_copy_ctor_external(const value_type* __s, size_type __sz) {
  if (__libcpp_is_constant_evaluated())
    __r_.first() = __rep();

  pointer __p;
  if (__fits_in_sso(__sz)) {
    __p = __get_short_pointer();
    __set_short_size(__sz);
  } else {
    if (__sz > max_size())
      __throw_length_error();
    auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__sz) + 1);
    __p = __allocation.ptr;
    __begin_lifetime(__p, __allocation.count);
    __set_long_pointer(__p);
    __set_long_cap(__allocation.count);
    __set_long_size(__sz);
  }
  traits_type::copy(std::__to_address(__p), __s, __sz + 1);
  __annotate_new(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
                              void basic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c) {
  if (__libcpp_is_constant_evaluated())
    __r_.first() = __rep();

  if (__n > max_size())
    __throw_length_error();
  pointer __p;
  if (__fits_in_sso(__n)) {
    __set_short_size(__n);
    __p = __get_short_pointer();
  } else {
    auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__n) + 1);
    __p = __allocation.ptr;
    __begin_lifetime(__p, __allocation.count);
    __set_long_pointer(__p);
    __set_long_cap(__allocation.count);
    __set_long_size(__n);
  }
  traits_type::assign(std::__to_address(__p), __n, __c);
  traits_type::assign(__p[__n], value_type());
  __annotate_new(__n);
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> >
                              void
basic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last) {
  __init_with_sentinel(std::move(__first), std::move(__last));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
basic_string<_CharT, _Traits, _Allocator>::__init_with_sentinel(_InputIterator __first, _Sentinel __last) {
  __r_.first() = __rep();
  __annotate_new(0);


  try {

    for (; __first != __last; ++__first)
      push_back(*__first);

  } catch (...) {
    __annotate_delete();
    if (__is_long())
      __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
    throw;
  }

}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
                              void
basic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last) {
  size_type __sz = static_cast<size_type>(std::distance(__first, __last));
  __init_with_size(__first, __last, __sz);
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
basic_string<_CharT, _Traits, _Allocator>::__init_with_size(_InputIterator __first, _Sentinel __last, size_type __sz) {
  if (__libcpp_is_constant_evaluated())
    __r_.first() = __rep();

  if (__sz > max_size())
    __throw_length_error();

  pointer __p;
  if (__fits_in_sso(__sz)) {
    __set_short_size(__sz);
    __p = __get_short_pointer();

  } else {
    auto __allocation = std::__allocate_at_least(__alloc(), __recommend(__sz) + 1);
    __p = __allocation.ptr;
    __begin_lifetime(__p, __allocation.count);
    __set_long_pointer(__p);
    __set_long_cap(__allocation.count);
    __set_long_size(__sz);
  }


  try {

    for (; __first != __last; ++__first, (void)++__p)
      traits_type::assign(*__p, *__first);
    traits_type::assign(*__p, value_type());

  } catch (...) {
    if (__is_long())
      __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());
    throw;
  }

  __annotate_new(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
                              void basic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace(
    size_type __old_cap,
    size_type __delta_cap,
    size_type __old_sz,
    size_type __n_copy,
    size_type __n_del,
    size_type __n_add,
    const value_type* __p_new_stuff) {
  size_type __ms = max_size();
  if (__delta_cap > __ms - __old_cap - 1)
    __throw_length_error();
  pointer __old_p = __get_pointer();
  size_type __cap =
      __old_cap < __ms / 2 - __alignment ? __recommend(std::max(__old_cap + __delta_cap, 2 * __old_cap)) : __ms - 1;
  __annotate_delete();
  auto __allocation = std::__allocate_at_least(__alloc(), __cap + 1);
  pointer __p = __allocation.ptr;
  __begin_lifetime(__p, __allocation.count);
  if (__n_copy != 0)
    traits_type::copy(std::__to_address(__p), std::__to_address(__old_p), __n_copy);
  if (__n_add != 0)
    traits_type::copy(std::__to_address(__p) + __n_copy, __p_new_stuff, __n_add);
  size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
  if (__sec_cp_sz != 0)
    traits_type::copy(
        std::__to_address(__p) + __n_copy + __n_add, std::__to_address(__old_p) + __n_copy + __n_del, __sec_cp_sz);
  if (__old_cap + 1 != __min_cap)
    __alloc_traits::deallocate(__alloc(), __old_p, __old_cap + 1);
  __set_long_pointer(__p);
  __set_long_cap(__allocation.count);
  __old_sz = __n_copy + __n_add + __sec_cp_sz;
  __set_long_size(__old_sz);
  traits_type::assign(__p[__old_sz], value_type());
  __annotate_new(__old_cap + __delta_cap);
}




template <class _CharT, class _Traits, class _Allocator>
void



    __attribute__((__deprecated__("use __grow_by_without_replace"))) basic_string<_CharT, _Traits, _Allocator>::__grow_by(
        size_type __old_cap,
        size_type __delta_cap,
        size_type __old_sz,
        size_type __n_copy,
        size_type __n_del,
        size_type __n_add) {
  size_type __ms = max_size();
  if (__delta_cap > __ms - __old_cap)
    __throw_length_error();
  pointer __old_p = __get_pointer();
  size_type __cap =
      __old_cap < __ms / 2 - __alignment ? __recommend(std::max(__old_cap + __delta_cap, 2 * __old_cap)) : __ms - 1;
  __annotate_delete();
  auto __allocation = std::__allocate_at_least(__alloc(), __cap + 1);
  pointer __p = __allocation.ptr;
  __begin_lifetime(__p, __allocation.count);
  if (__n_copy != 0)
    traits_type::copy(std::__to_address(__p), std::__to_address(__old_p), __n_copy);
  size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
  if (__sec_cp_sz != 0)
    traits_type::copy(
        std::__to_address(__p) + __n_copy + __n_add, std::__to_address(__old_p) + __n_copy + __n_del, __sec_cp_sz);
  if (__old_cap + 1 != __min_cap)
    __alloc_traits::deallocate(__alloc(), __old_p, __old_cap + 1);
  __set_long_pointer(__p);
  __set_long_cap(__allocation.count);
}

template <class _CharT, class _Traits, class _Allocator>
void __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
basic_string<_CharT, _Traits, _Allocator>::__grow_by_without_replace(
    size_type __old_cap,
    size_type __delta_cap,
    size_type __old_sz,
    size_type __n_copy,
    size_type __n_del,
    size_type __n_add) {
#pragma GCC diagnostic push
# 2432 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 2432 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  __grow_by(__old_cap, __delta_cap, __old_sz, __n_copy, __n_del, __n_add);
#pragma GCC diagnostic pop
  __set_long_size(__old_sz - __n_del + __n_add);
  __annotate_new(__old_sz - __n_del + __n_add);
}



template <class _CharT, class _Traits, class _Allocator>
template <bool __is_short>
                              __attribute__((__noinline__)) basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__assign_no_alias(const value_type* __s, size_type __n) {
  size_type __cap = __is_short ? static_cast<size_type>(__min_cap) : __get_long_cap();
  if (__n < __cap) {
    size_type __old_size = __is_short ? __get_short_size() : __get_long_size();
    if (__n > __old_size)
      __annotate_increase(__n - __old_size);
    pointer __p = __is_short ? __get_short_pointer() : __get_long_pointer();
    __is_short ? __set_short_size(__n) : __set_long_size(__n);
    traits_type::copy(std::__to_address(__p), __s, __n);
    traits_type::assign(__p[__n], value_type());
    if (__old_size > __n)
      __annotate_shrink(__old_size);
  } else {
    size_type __sz = __is_short ? __get_short_size() : __get_long_size();
    __grow_by_and_replace(__cap - 1, __n - __cap + 1, __sz, 0, __sz, __n, __s);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
                              __attribute__((__noinline__)) basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__assign_external(const value_type* __s, size_type __n) {
  size_type __cap = capacity();
  if (__cap >= __n) {
    size_type __old_size = size();
    if (__n > __old_size)
      __annotate_increase(__n - __old_size);
    value_type* __p = std::__to_address(__get_pointer());
    traits_type::move(__p, __s, __n);
    return __null_terminate_at(__p, __n);
  } else {
    size_type __sz = size();
    __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);
    return *this;
  }
}

template <class _CharT, class _Traits, class _Allocator>
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n) {
  ((void)0);
  return (__builtin_constant_p(__n) && __fits_in_sso(__n)) ? __assign_short(__s, __n) : __assign_external(__s, __n);
}

template <class _CharT, class _Traits, class _Allocator>
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c) {
  size_type __cap = capacity();
  size_type __old_size = size();
  if (__cap < __n) {
    size_type __sz = size();
    __grow_by_without_replace(__cap, __n - __cap, __sz, 0, __sz);
    __annotate_increase(__n);
  } else if (__n > __old_size)
    __annotate_increase(__n - __old_size);
  value_type* __p = std::__to_address(__get_pointer());
  traits_type::assign(__p, __n, __c);
  return __null_terminate_at(__p, __n);
}

template <class _CharT, class _Traits, class _Allocator>
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c) {
  pointer __p;
  size_type __old_size = size();
  if (__old_size == 0)
    __annotate_increase(1);
  if (__is_long()) {
    __p = __get_long_pointer();
    __set_long_size(1);
  } else {
    __p = __get_short_pointer();
    __set_short_size(1);
  }
  traits_type::assign(*__p, __c);
  traits_type::assign(*++__p, value_type());
  if (__old_size > 1)
    __annotate_shrink(__old_size);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
                                                                    basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str) {
  if (this != std::addressof(__str)) {
    __copy_assign_alloc(__str);
    if (!__is_long()) {
      if (!__str.__is_long()) {
        size_type __old_size = __get_short_size();
        if (__get_short_size() < __str.__get_short_size())
          __annotate_increase(__str.__get_short_size() - __get_short_size());
        __r_.first() = __str.__r_.first();
        if (__old_size > __get_short_size())
          __annotate_shrink(__old_size);
      } else {
        return __assign_no_alias<true>(__str.data(), __str.size());
      }
    } else {
      return __assign_no_alias<false>(__str.data(), __str.size());
    }
  }
  return *this;
}
# 2609 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> >
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last) {
  __assign_with_sentinel(__first, __last);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
basic_string<_CharT, _Traits, _Allocator>::__assign_with_sentinel(_InputIterator __first, _Sentinel __last) {
  const basic_string __temp(__init_with_sentinel_tag(), std::move(__first), std::move(__last), __alloc());
  assign(__temp.data(), __temp.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last) {
  if (__string_is_trivial_iterator<_ForwardIterator>::value) {
    size_type __n = static_cast<size_type>(std::distance(__first, __last));
    __assign_trivial(__first, __last, __n);
  } else {
    __assign_with_sentinel(__first, __last);
  }

  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Iterator, class _Sentinel>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
basic_string<_CharT, _Traits, _Allocator>::__assign_trivial(_Iterator __first, _Sentinel __last, size_type __n) {
  ((void)0);


  size_type __old_size = size();
  size_type __cap = capacity();
  if (__cap < __n) {






    size_type __sz = size();
    __grow_by_without_replace(__cap, __n - __cap, __sz, 0, __sz);
    __annotate_increase(__n);
  } else if (__n > __old_size)
    __annotate_increase(__n - __old_size);
  pointer __p = __get_pointer();
  for (; __first != __last; ++__p, (void)++__first)
    traits_type::assign(*__p, *__first);
  traits_type::assign(*__p, value_type());
  __set_size(__n);
  if (__n < __old_size)
    __annotate_shrink(__old_size);
}

template <class _CharT, class _Traits, class _Allocator>
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n) {
  size_type __sz = __str.size();
  if (__pos > __sz)
    __throw_out_of_range();
  return assign(__str.data() + __pos, std::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp,
          __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                            !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
                        int> >
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const _Tp& __t, size_type __pos, size_type __n) {
  __self_view __sv = __t;
  size_type __sz = __sv.size();
  if (__pos > __sz)
    __throw_out_of_range();
  return assign(__sv.data() + __pos, std::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
                              __attribute__((__noinline__)) basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::__assign_external(const value_type* __s) {
  return __assign_external(__s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s) {
  ((void)0);
  return __builtin_constant_p(*__s)
           ? (__fits_in_sso(traits_type::length(__s)) ? __assign_short(__s, traits_type::length(__s))
                                                      : __assign_external(__s, traits_type::length(__s)))
           : __assign_external(__s);
}


template <class _CharT, class _Traits, class _Allocator>
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n) {
  ((void)0);
  size_type __cap = capacity();
  size_type __sz = size();
  if (__cap - __sz >= __n) {
    if (__n) {
      __annotate_increase(__n);
      value_type* __p = std::__to_address(__get_pointer());
      traits_type::copy(__p + __sz, __s, __n);
      __sz += __n;
      __set_size(__sz);
      traits_type::assign(__p[__sz], value_type());
    }
  } else
    __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c) {
  if (__n) {
    size_type __cap = capacity();
    size_type __sz = size();
    if (__cap - __sz < __n)
      __grow_by_without_replace(__cap, __sz + __n - __cap, __sz, __sz, 0);
    __annotate_increase(__n);
    pointer __p = __get_pointer();
    traits_type::assign(std::__to_address(__p) + __sz, __n, __c);
    __sz += __n;
    __set_size(__sz);
    traits_type::assign(__p[__sz], value_type());
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
                              inline void
basic_string<_CharT, _Traits, _Allocator>::__append_default_init(size_type __n) {
  if (__n) {
    size_type __cap = capacity();
    size_type __sz = size();
    if (__cap - __sz < __n)
      __grow_by_without_replace(__cap, __sz + __n - __cap, __sz, __sz, 0);
    __annotate_increase(__n);
    pointer __p = __get_pointer();
    __sz += __n;
    __set_size(__sz);
    traits_type::assign(__p[__sz], value_type());
  }
}

template <class _CharT, class _Traits, class _Allocator>
                              void basic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c) {
  bool __is_short = !__is_long();
  size_type __cap;
  size_type __sz;
  if (__is_short) {
    __cap = __min_cap - 1;
    __sz = __get_short_size();
  } else {
    __cap = __get_long_cap() - 1;
    __sz = __get_long_size();
  }
  if (__sz == __cap) {
    __grow_by_without_replace(__cap, 1, __sz, __sz, 0);
    __annotate_increase(1);
    __is_short = false;
  } else
    __annotate_increase(1);
  pointer __p = __get_pointer();
  if (__is_short) {
    __p = __get_short_pointer() + __sz;
    __set_short_size(__sz + 1);
  } else {
    __p = __get_long_pointer() + __sz;
    __set_long_size(__sz + 1);
  }
  traits_type::assign(*__p, __c);
  traits_type::assign(*++__p, value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(_ForwardIterator __first, _ForwardIterator __last) {
  size_type __sz = size();
  size_type __cap = capacity();
  size_type __n = static_cast<size_type>(std::distance(__first, __last));
  if (__n) {
    if (__string_is_trivial_iterator<_ForwardIterator>::value && !__addr_in_range(*__first)) {
      if (__cap - __sz < __n)
        __grow_by_without_replace(__cap, __sz + __n - __cap, __sz, __sz, 0);
      __annotate_increase(__n);
      pointer __p = __get_pointer() + __sz;
      for (; __first != __last; ++__p, (void)++__first)
        traits_type::assign(*__p, *__first);
      traits_type::assign(*__p, value_type());
      __set_size(__sz + __n);
    } else {
      const basic_string __temp(__first, __last, __alloc());
      append(__temp.data(), __temp.size());
    }
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n) {
  size_type __sz = __str.size();
  if (__pos > __sz)
    __throw_out_of_range();
  return append(__str.data() + __pos, std::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp,
          __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                            !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
                        int> >
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const _Tp& __t, size_type __pos, size_type __n) {
  __self_view __sv = __t;
  size_type __sz = __sv.size();
  if (__pos > __sz)
    __throw_out_of_range();
  return append(__sv.data() + __pos, std::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s) {
  ((void)0);
  return append(__s, traits_type::length(__s));
}



template <class _CharT, class _Traits, class _Allocator>
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n) {
  ((void)0);
  size_type __sz = size();
  if (__pos > __sz)
    __throw_out_of_range();
  size_type __cap = capacity();
  if (__cap - __sz >= __n) {
    if (__n) {
      __annotate_increase(__n);
      value_type* __p = std::__to_address(__get_pointer());
      size_type __n_move = __sz - __pos;
      if (__n_move != 0) {
        if (std::__is_pointer_in_range(__p + __pos, __p + __sz, __s))
          __s += __n;
        traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
      }
      traits_type::move(__p + __pos, __s, __n);
      __sz += __n;
      __set_size(__sz);
      traits_type::assign(__p[__sz], value_type());
    }
  } else
    __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c) {
  size_type __sz = size();
  if (__pos > __sz)
    __throw_out_of_range();
  if (__n) {
    size_type __cap = capacity();
    value_type* __p;
    if (__cap - __sz >= __n) {
      __annotate_increase(__n);
      __p = std::__to_address(__get_pointer());
      size_type __n_move = __sz - __pos;
      if (__n_move != 0)
        traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
    } else {
      __grow_by_without_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);
      __p = std::__to_address(__get_long_pointer());
    }
    traits_type::assign(__p + __pos, __n, __c);
    __sz += __n;
    __set_size(__sz);
    traits_type::assign(__p[__sz], value_type());
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> >
                              typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last) {
  const basic_string __temp(__first, __last, __alloc());
  return insert(__pos, __temp.data(), __temp.data() + __temp.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
                              typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(
    const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last) {
  auto __n = static_cast<size_type>(std::distance(__first, __last));
  return __insert_with_size(__pos, __first, __last, __n);
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Iterator, class _Sentinel>
                              typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::__insert_with_size(
    const_iterator __pos, _Iterator __first, _Sentinel __last, size_type __n) {
  size_type __ip = static_cast<size_type>(__pos - begin());
  if (__n == 0)
    return begin() + __ip;

  if (__string_is_trivial_iterator<_Iterator>::value && !__addr_in_range(*__first)) {
    return __insert_from_safe_copy(__n, __ip, __first, __last);
  } else {
    const basic_string __temp(__init_with_sentinel_tag(), __first, __last, __alloc());
    return __insert_from_safe_copy(__n, __ip, __temp.begin(), __temp.end());
  }
}

template <class _CharT, class _Traits, class _Allocator>
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(
    size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n) {
  size_type __str_sz = __str.size();
  if (__pos2 > __str_sz)
    __throw_out_of_range();
  return insert(__pos1, __str.data() + __pos2, std::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp,
          __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                            !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
                        int> >
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const _Tp& __t, size_type __pos2, size_type __n) {
  __self_view __sv = __t;
  size_type __str_sz = __sv.size();
  if (__pos2 > __str_sz)
    __throw_out_of_range();
  return insert(__pos1, __sv.data() + __pos2, std::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s) {
  ((void)0);
  return insert(__pos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
                              typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c) {
  size_type __ip = static_cast<size_type>(__pos - begin());
  size_type __sz = size();
  size_type __cap = capacity();
  value_type* __p;
  if (__cap == __sz) {
    __grow_by_without_replace(__cap, 1, __sz, __ip, 0, 1);
    __p = std::__to_address(__get_long_pointer());
  } else {
    __annotate_increase(1);
    __p = std::__to_address(__get_pointer());
    size_type __n_move = __sz - __ip;
    if (__n_move != 0)
      traits_type::move(__p + __ip + 1, __p + __ip, __n_move);
  }
  traits_type::assign(__p[__ip], __c);
  traits_type::assign(__p[++__sz], value_type());
  __set_size(__sz);
  return begin() + static_cast<difference_type>(__ip);
}



template <class _CharT, class _Traits, class _Allocator>
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(
    size_type __pos, size_type __n1, const value_type* __s, size_type __n2)
    __attribute__((__no_sanitize__("unsigned-integer-overflow"))) {
  ((void)0);
  size_type __sz = size();
  if (__pos > __sz)
    __throw_out_of_range();
  __n1 = std::min(__n1, __sz - __pos);
  size_type __cap = capacity();
  if (__cap - __sz + __n1 >= __n2) {
    value_type* __p = std::__to_address(__get_pointer());
    if (__n1 != __n2) {
      if (__n2 > __n1)
        __annotate_increase(__n2 - __n1);
      size_type __n_move = __sz - __pos - __n1;
      if (__n_move != 0) {
        if (__n1 > __n2) {
          traits_type::move(__p + __pos, __s, __n2);
          traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
          return __null_terminate_at(__p, __sz + (__n2 - __n1));
        }
        if (std::__is_pointer_in_range(__p + __pos + 1, __p + __sz, __s)) {
          if (__p + __pos + __n1 <= __s)
            __s += __n2 - __n1;
          else
          {
            traits_type::move(__p + __pos, __s, __n1);
            __pos += __n1;
            __s += __n2;
            __n2 -= __n1;
            __n1 = 0;
          }
        }
        traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
      }
    }
    traits_type::move(__p + __pos, __s, __n2);
    return __null_terminate_at(__p, __sz + (__n2 - __n1));
  } else
    __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c) {
  size_type __sz = size();
  if (__pos > __sz)
    __throw_out_of_range();
  __n1 = std::min(__n1, __sz - __pos);
  size_type __cap = capacity();
  value_type* __p;
  if (__cap - __sz + __n1 >= __n2) {
    __p = std::__to_address(__get_pointer());
    if (__n1 != __n2) {
      if (__n2 > __n1)
        __annotate_increase(__n2 - __n1);
      size_type __n_move = __sz - __pos - __n1;
      if (__n_move != 0)
        traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
    }
  } else {
    __grow_by_without_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);
    __p = std::__to_address(__get_long_pointer());
  }
  traits_type::assign(__p + __pos, __n2, __c);
  return __null_terminate_at(__p, __sz - (__n1 - __n2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, __enable_if_t<__has_input_iterator_category<_InputIterator>::value, int> >
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(
    const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2) {
  const basic_string __temp(__j1, __j2, __alloc());
  return replace(__i1, __i2, __temp);
}

template <class _CharT, class _Traits, class _Allocator>
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(
    size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2) {
  size_type __str_sz = __str.size();
  if (__pos2 > __str_sz)
    __throw_out_of_range();
  return replace(__pos1, __n1, __str.data() + __pos2, std::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp,
          __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                            !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
                        int> >
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(
    size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2) {
  __self_view __sv = __t;
  size_type __str_sz = __sv.size();
  if (__pos2 > __str_sz)
    __throw_out_of_range();
  return replace(__pos1, __n1, __sv.data() + __pos2, std::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s) {
  ((void)0);
  return replace(__pos, __n1, __s, traits_type::length(__s));
}





template <class _CharT, class _Traits, class _Allocator>
                              __attribute__((__noinline__)) void
basic_string<_CharT, _Traits, _Allocator>::__erase_external_with_move(size_type __pos, size_type __n) {
  if (__n) {
    size_type __sz = size();
    value_type* __p = std::__to_address(__get_pointer());
    __n = std::min(__n, __sz - __pos);
    size_type __n_move = __sz - __pos - __n;
    if (__n_move != 0)
      traits_type::move(__p + __pos, __p + __pos + __n, __n_move);
    __null_terminate_at(__p, __sz - __n);
  }
}

template <class _CharT, class _Traits, class _Allocator>
                              basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n) {
  if (__pos > size())
    __throw_out_of_range();
  if (__n == npos) {
    __erase_to_end(__pos);
  } else {
    __erase_external_with_move(__pos, __n);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos) {
  ((void)0);

  iterator __b = begin();
  size_type __r = static_cast<size_type>(__pos - __b);
  erase(__r, 1);
  return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last) {
  ((void)0);
  iterator __b = begin();
  size_type __r = static_cast<size_type>(__first - __b);
  erase(__r, static_cast<size_type>(__last - __first));
  return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline void basic_string<_CharT, _Traits, _Allocator>::pop_back() {
  ((void)0);
  __erase_to_end(size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
inline void basic_string<_CharT, _Traits, _Allocator>::clear() throw() {
  size_type __old_size = size();
  if (__is_long()) {
    traits_type::assign(*__get_long_pointer(), value_type());
    __set_long_size(0);
  } else {
    traits_type::assign(*__get_short_pointer(), value_type());
    __set_short_size(0);
  }
  __annotate_shrink(__old_size);
}

template <class _CharT, class _Traits, class _Allocator>
                              void basic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c) {
  size_type __sz = size();
  if (__n > __sz)
    append(__n - __sz, __c);
  else
    __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
                              inline void
basic_string<_CharT, _Traits, _Allocator>::__resize_default_init(size_type __n) {
  size_type __sz = size();
  if (__n > __sz) {
    __append_default_init(__n - __sz);
  } else
    __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
                              void basic_string<_CharT, _Traits, _Allocator>::reserve(size_type __requested_capacity) {
  if (__requested_capacity > max_size())
    __throw_length_error();




  if (__requested_capacity <= capacity())
    return;

  size_type __target_capacity = std::max(__requested_capacity, size());
  __target_capacity = __recommend(__target_capacity);
  if (__target_capacity == capacity())
    return;

  __shrink_or_extend(__target_capacity);
}

template <class _CharT, class _Traits, class _Allocator>
inline void basic_string<_CharT, _Traits, _Allocator>::shrink_to_fit() throw() {
  size_type __target_capacity = __recommend(size());
  if (__target_capacity == capacity())
    return;

  __shrink_or_extend(__target_capacity);
}

template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::__shrink_or_extend(size_type __target_capacity) {
  __annotate_delete();
  size_type __cap = capacity();
  size_type __sz = size();

  pointer __new_data, __p;
  bool __was_long, __now_long;
  if (__fits_in_sso(__target_capacity)) {
    __was_long = true;
    __now_long = false;
    __new_data = __get_short_pointer();
    __p = __get_long_pointer();
  } else {
    if (__target_capacity > __cap) {
      auto __allocation = std::__allocate_at_least(__alloc(), __target_capacity + 1);
      __new_data = __allocation.ptr;
      __target_capacity = __allocation.count - 1;
    } else {

      try {

        auto __allocation = std::__allocate_at_least(__alloc(), __target_capacity + 1);
        __new_data = __allocation.ptr;
        __target_capacity = __allocation.count - 1;

      } catch (...) {
        return;
      }




    }
    __begin_lifetime(__new_data, __target_capacity + 1);
    __now_long = true;
    __was_long = __is_long();
    __p = __get_pointer();
  }
  traits_type::copy(std::__to_address(__new_data), std::__to_address(__p), size() + 1);
  if (__was_long)
    __alloc_traits::deallocate(__alloc(), __p, __cap + 1);
  if (__now_long) {
    __set_long_cap(__target_capacity + 1);
    __set_long_size(__sz);
    __set_long_pointer(__new_data);
  } else
    __set_short_size(__sz);
  __annotate_new(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
                              typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const {
  if (__n >= size())
    __throw_out_of_range();
  return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
                              typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n) {
  if (__n >= size())
    __throw_out_of_range();
  return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
                              typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const {
  size_type __sz = size();
  if (__pos > __sz)
    __throw_out_of_range();
  size_type __rlen = std::min(__n, __sz - __pos);
  traits_type::copy(__s, data() + __pos, __rlen);
  return __rlen;
}

template <class _CharT, class _Traits, class _Allocator>
inline void basic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)





{
  ((void)0);



  if (!__is_long())
    __annotate_delete();
  if (this != &__str && !__str.__is_long())
    __str.__annotate_delete();
  std::swap(__r_.first(), __str.__r_.first());
  std::__swap_allocator(__alloc(), __str.__alloc());
  if (!__is_long())
    __annotate_new(__get_short_size());
  if (this != &__str && !__str.__is_long())
    __str.__annotate_new(__str.__get_short_size());
}



template <class _Traits>
struct __attribute__((__visibility__("hidden"))) __traits_eq {
  typedef typename _Traits::char_type char_type;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const char_type& __x, const char_type& __y) throw() {
    return _Traits::eq(__x, __y);
  }
};

template <class _CharT, class _Traits, class _Allocator>
                              typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s, size_type __pos, size_type __n) const throw() {
  ((void)0);
  return std::__str_find<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str, size_type __pos) const throw() {
  return std::__str_find<value_type, size_type, traits_type, npos>(data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
                              typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const _Tp& __t, size_type __pos) const throw() {
  __self_view __sv = __t;
  return std::__str_find<value_type, size_type, traits_type, npos>(data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s, size_type __pos) const throw() {
  ((void)0);
  return std::__str_find<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
                              typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(value_type __c, size_type __pos) const throw() {
  return std::__str_find<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
                              typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(
    const value_type* __s, size_type __pos, size_type __n) const throw() {
  ((void)0);
  return std::__str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str, size_type __pos) const throw() {
  return std::__str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
                              typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const _Tp& __t, size_type __pos) const throw() {
  __self_view __sv = __t;
  return std::__str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s, size_type __pos) const throw() {
  ((void)0);
  return std::__str_rfind<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
                              typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c, size_type __pos) const throw() {
  return std::__str_rfind<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
                              typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(
    const value_type* __s, size_type __pos, size_type __n) const throw() {
  ((void)0);
  return std::__str_find_first_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str, size_type __pos) const throw() {
  return std::__str_find_first_of<value_type, size_type, traits_type, npos>(
      data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
                              typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const _Tp& __t, size_type __pos) const throw() {
  __self_view __sv = __t;
  return std::__str_find_first_of<value_type, size_type, traits_type, npos>(
      data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s, size_type __pos) const throw() {
  ((void)0);
  return std::__str_find_first_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c, size_type __pos) const throw() {
  return find(__c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(
    const value_type* __s, size_type __pos, size_type __n) const throw() {
  ((void)0);
  return std::__str_find_last_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str, size_type __pos) const throw() {
  return std::__str_find_last_of<value_type, size_type, traits_type, npos>(
      data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
                              typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const _Tp& __t, size_type __pos) const throw() {
  __self_view __sv = __t;
  return std::__str_find_last_of<value_type, size_type, traits_type, npos>(
      data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s, size_type __pos) const throw() {
  ((void)0);
  return std::__str_find_last_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c, size_type __pos) const throw() {
  return rfind(__c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
                              typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(
    const value_type* __s, size_type __pos, size_type __n) const throw() {
  ((void)0);
  return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(
    const basic_string& __str, size_type __pos) const throw() {
  return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
                              typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const _Tp& __t, size_type __pos) const throw() {
  __self_view __sv = __t;
  return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s, size_type __pos) const throw() {
  ((void)0);
  return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c, size_type __pos) const throw() {
  return std::__str_find_first_not_of<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
                              typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(
    const value_type* __s, size_type __pos, size_type __n) const throw() {
  ((void)0);
  return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>(data(), size(), __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(
    const basic_string& __str, size_type __pos) const throw() {
  return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
                              typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const _Tp& __t, size_type __pos) const throw() {
  __self_view __sv = __t;
  return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s, size_type __pos) const throw() {
  ((void)0);
  return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c, size_type __pos) const throw() {
  return std::__str_find_last_not_of<value_type, size_type, traits_type, npos>(data(), size(), __c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
                              int basic_string<_CharT, _Traits, _Allocator>::compare(const _Tp& __t) const throw() {
  __self_view __sv = __t;
  size_t __lhs_sz = size();
  size_t __rhs_sz = __sv.size();
  int __result = traits_type::compare(data(), __sv.data(), std::min(__lhs_sz, __rhs_sz));
  if (__result != 0)
    return __result;
  if (__lhs_sz < __rhs_sz)
    return -1;
  if (__lhs_sz > __rhs_sz)
    return 1;
  return 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline int
basic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const throw() {
  return compare(__self_view(__str));
}

template <class _CharT, class _Traits, class _Allocator>
inline int basic_string<_CharT, _Traits, _Allocator>::compare(
    size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const {
  ((void)0);
  size_type __sz = size();
  if (__pos1 > __sz || __n2 == npos)
    __throw_out_of_range();
  size_type __rlen = std::min(__n1, __sz - __pos1);
  int __r = traits_type::compare(data() + __pos1, __s, std::min(__rlen, __n2));
  if (__r == 0) {
    if (__rlen < __n2)
      __r = -1;
    else if (__rlen > __n2)
      __r = 1;
  }
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int> >
                              int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1, size_type __n1, const _Tp& __t) const {
  __self_view __sv = __t;
  return compare(__pos1, __n1, __sv.data(), __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1, size_type __n1, const basic_string& __str) const {
  return compare(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp,
          __enable_if_t<__can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value &&
                            !__is_same_uncvref<_Tp, basic_string<_CharT, _Traits, _Allocator> >::value,
                        int> >
                              int basic_string<_CharT, _Traits, _Allocator>::compare(
    size_type __pos1, size_type __n1, const _Tp& __t, size_type __pos2, size_type __n2) const {
  __self_view __sv = __t;
  return __self_view(*this).substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
}

template <class _CharT, class _Traits, class _Allocator>
                              int basic_string<_CharT, _Traits, _Allocator>::compare(
    size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2) const {
  return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);
}

template <class _CharT, class _Traits, class _Allocator>
                              int
basic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const throw() {
  ((void)0);
  return compare(0, npos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
                              int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1, size_type __n1, const value_type* __s) const {
  ((void)0);
  return compare(__pos1, __n1, __s, traits_type::length(__s));
}



template <class _CharT, class _Traits, class _Allocator>
inline bool basic_string<_CharT, _Traits, _Allocator>::__invariants() const {
  if (size() > capacity())
    return false;
  if (capacity() < __min_cap - 1)
    return false;
  if (data() == __nullptr)
    return false;
  if (!_Traits::eq(data()[size()], value_type()))
    return false;
  return true;
}



template <class _CharT, class _Traits, class _Allocator>
inline void basic_string<_CharT, _Traits, _Allocator>::__clear_and_shrink() throw() {
  clear();
  if (__is_long()) {
    __annotate_delete();
    __alloc_traits::deallocate(__alloc(), __get_long_pointer(), capacity() + 1);
    __r_.first() = __rep();
  }
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw() {



  size_t __lhs_sz = __lhs.size();
  return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(), __rhs.data(), __lhs_sz) == 0;

}

template <class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,
           const basic_string<char, char_traits<char>, _Allocator>& __rhs) throw() {
  size_t __lhs_sz = __lhs.size();
  if (__lhs_sz != __rhs.size())
    return false;
  const char* __lp = __lhs.data();
  const char* __rp = __rhs.data();
  if (__lhs.__is_long())
    return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;
  for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)
    if (*__lp != *__rp)
      return false;
  return true;
}


template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator==(const _CharT* __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw() {
  typedef basic_string<_CharT, _Traits, _Allocator> _String;
  ((void)0);
  size_t __lhs_len = _Traits::length(__lhs);
  if (__lhs_len != __rhs.size())
    return false;
  return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;
}


template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs) throw() {



  typedef basic_string<_CharT, _Traits, _Allocator> _String;
  ((void)0);
  size_t __rhs_len = _Traits::length(__rhs);
  if (__rhs_len != __lhs.size())
    return false;
  return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;

}
# 3762 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
                                             const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw() {
  return !(__lhs == __rhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator!=(const _CharT* __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw() {
  return !(__lhs == __rhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs) throw() {
  return !(__lhs == __rhs);
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
                                            const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw() {
  return __lhs.compare(__rhs) < 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs) throw() {
  return __lhs.compare(__rhs) < 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<(const _CharT* __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw() {
  return __rhs.compare(__lhs) > 0;
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
                                            const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw() {
  return __rhs < __lhs;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs) throw() {
  return __rhs < __lhs;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>(const _CharT* __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw() {
  return __rhs < __lhs;
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
                                             const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw() {
  return !(__rhs < __lhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs) throw() {
  return !(__rhs < __lhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator<=(const _CharT* __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw() {
  return !(__rhs < __lhs);
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
                                             const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw() {
  return !(__lhs < __rhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs) throw() {
  return !(__lhs < __rhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator>=(const _CharT* __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs) throw() {
  return !(__lhs < __rhs);
}




template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,
          const basic_string<_CharT, _Traits, _Allocator>& __rhs) {
  using _String = basic_string<_CharT, _Traits, _Allocator>;
  auto __lhs_sz = __lhs.size();
  auto __rhs_sz = __rhs.size();
  _String __r(__uninitialized_size_tag(),
              __lhs_sz + __rhs_sz,
              _String::__alloc_traits::select_on_container_copy_construction(__lhs.get_allocator()));
  auto __ptr = std::__to_address(__r.__get_pointer());
  _Traits::copy(__ptr, __lhs.data(), __lhs_sz);
  _Traits::copy(__ptr + __lhs_sz, __rhs.data(), __rhs_sz);
  _Traits::assign(__ptr + __lhs_sz + __rhs_sz, 1, _CharT());
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT* __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs) {
  using _String = basic_string<_CharT, _Traits, _Allocator>;
  auto __lhs_sz = _Traits::length(__lhs);
  auto __rhs_sz = __rhs.size();
  _String __r(__uninitialized_size_tag(),
              __lhs_sz + __rhs_sz,
              _String::__alloc_traits::select_on_container_copy_construction(__rhs.get_allocator()));
  auto __ptr = std::__to_address(__r.__get_pointer());
  _Traits::copy(__ptr, __lhs, __lhs_sz);
  _Traits::copy(__ptr + __lhs_sz, __rhs.data(), __rhs_sz);
  _Traits::assign(__ptr + __lhs_sz + __rhs_sz, 1, _CharT());
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs) {
  using _String = basic_string<_CharT, _Traits, _Allocator>;
  typename _String::size_type __rhs_sz = __rhs.size();
  _String __r(__uninitialized_size_tag(),
              __rhs_sz + 1,
              _String::__alloc_traits::select_on_container_copy_construction(__rhs.get_allocator()));
  auto __ptr = std::__to_address(__r.__get_pointer());
  _Traits::assign(__ptr, 1, __lhs);
  _Traits::copy(__ptr + 1, __rhs.data(), __rhs_sz);
  _Traits::assign(__ptr + 1 + __rhs_sz, 1, _CharT());
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs) {
  using _String = basic_string<_CharT, _Traits, _Allocator>;
  typename _String::size_type __lhs_sz = __lhs.size();
  typename _String::size_type __rhs_sz = _Traits::length(__rhs);
  _String __r(__uninitialized_size_tag(),
              __lhs_sz + __rhs_sz,
              _String::__alloc_traits::select_on_container_copy_construction(__lhs.get_allocator()));
  auto __ptr = std::__to_address(__r.__get_pointer());
  _Traits::copy(__ptr, __lhs.data(), __lhs_sz);
  _Traits::copy(__ptr + __lhs_sz, __rhs, __rhs_sz);
  _Traits::assign(__ptr + __lhs_sz + __rhs_sz, 1, _CharT());
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs) {
  using _String = basic_string<_CharT, _Traits, _Allocator>;
  typename _String::size_type __lhs_sz = __lhs.size();
  _String __r(__uninitialized_size_tag(),
              __lhs_sz + 1,
              _String::__alloc_traits::select_on_container_copy_construction(__lhs.get_allocator()));
  auto __ptr = std::__to_address(__r.__get_pointer());
  _Traits::copy(__ptr, __lhs.data(), __lhs_sz);
  _Traits::assign(__ptr + __lhs_sz, 1, __rhs);
  _Traits::assign(__ptr + 1 + __lhs_sz, 1, _CharT());
  return __r;
}
# 3992 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
swap(basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>& __rhs)
                                              {
  __lhs.swap(__rhs);
}

__attribute__((__visibility__("default"))) int stoi(const string& __str, size_t* __idx = __nullptr, int __base = 10);
__attribute__((__visibility__("default"))) long stol(const string& __str, size_t* __idx = __nullptr, int __base = 10);
__attribute__((__visibility__("default"))) unsigned long stoul(const string& __str, size_t* __idx = __nullptr, int __base = 10);
__attribute__((__visibility__("default"))) long long stoll(const string& __str, size_t* __idx = __nullptr, int __base = 10);
__attribute__((__visibility__("default"))) unsigned long long stoull(const string& __str, size_t* __idx = __nullptr, int __base = 10);

__attribute__((__visibility__("default"))) float stof(const string& __str, size_t* __idx = __nullptr);
__attribute__((__visibility__("default"))) double stod(const string& __str, size_t* __idx = __nullptr);
__attribute__((__visibility__("default"))) long double stold(const string& __str, size_t* __idx = __nullptr);

__attribute__((__visibility__("default"))) string to_string(int __val);
__attribute__((__visibility__("default"))) string to_string(unsigned __val);
__attribute__((__visibility__("default"))) string to_string(long __val);
__attribute__((__visibility__("default"))) string to_string(unsigned long __val);
__attribute__((__visibility__("default"))) string to_string(long long __val);
__attribute__((__visibility__("default"))) string to_string(unsigned long long __val);
__attribute__((__visibility__("default"))) string to_string(float __val);
__attribute__((__visibility__("default"))) string to_string(double __val);
__attribute__((__visibility__("default"))) string to_string(long double __val);


__attribute__((__visibility__("default"))) int stoi(const wstring& __str, size_t* __idx = __nullptr, int __base = 10);
__attribute__((__visibility__("default"))) long stol(const wstring& __str, size_t* __idx = __nullptr, int __base = 10);
__attribute__((__visibility__("default"))) unsigned long stoul(const wstring& __str, size_t* __idx = __nullptr, int __base = 10);
__attribute__((__visibility__("default"))) long long stoll(const wstring& __str, size_t* __idx = __nullptr, int __base = 10);
__attribute__((__visibility__("default"))) unsigned long long stoull(const wstring& __str, size_t* __idx = __nullptr, int __base = 10);

__attribute__((__visibility__("default"))) float stof(const wstring& __str, size_t* __idx = __nullptr);
__attribute__((__visibility__("default"))) double stod(const wstring& __str, size_t* __idx = __nullptr);
__attribute__((__visibility__("default"))) long double stold(const wstring& __str, size_t* __idx = __nullptr);

__attribute__((__visibility__("default"))) wstring to_wstring(int __val);
__attribute__((__visibility__("default"))) wstring to_wstring(unsigned __val);
__attribute__((__visibility__("default"))) wstring to_wstring(long __val);
__attribute__((__visibility__("default"))) wstring to_wstring(unsigned long __val);
__attribute__((__visibility__("default"))) wstring to_wstring(long long __val);
__attribute__((__visibility__("default"))) wstring to_wstring(unsigned long long __val);
__attribute__((__visibility__("default"))) wstring to_wstring(float __val);
__attribute__((__visibility__("default"))) wstring to_wstring(double __val);
__attribute__((__visibility__("default"))) wstring to_wstring(long double __val);


template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("default"))) const typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::npos;

template <class _CharT, class _Allocator>
struct __string_hash : public __unary_function<basic_string<_CharT, char_traits<_CharT>, _Allocator>, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t
  operator()(const basic_string<_CharT, char_traits<_CharT>, _Allocator>& __val) const throw() {
    return std::__do_string_hash(__val.data(), __val.data() + __val.size());
  }
};

template <class _Allocator>
struct hash<basic_string<char, char_traits<char>, _Allocator> > : __string_hash<char, _Allocator> {};






template <class _Allocator>
struct hash<basic_string<char16_t, char_traits<char16_t>, _Allocator> > : __string_hash<char16_t, _Allocator> {};

template <class _Allocator>
struct hash<basic_string<char32_t, char_traits<char32_t>, _Allocator> > : __string_hash<char32_t, _Allocator> {};


template <class _Allocator>
struct hash<basic_string<wchar_t, char_traits<wchar_t>, _Allocator> > : __string_hash<wchar_t, _Allocator> {};


template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const basic_string<_CharT, _Traits, _Allocator>& __str);

template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, basic_string<_CharT, _Traits, _Allocator>& __str);

template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is, basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is, basic_string<_CharT, _Traits, _Allocator>& __str);

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is, basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is, basic_string<_CharT, _Traits, _Allocator>& __str);
# 4159 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/string" 3
}}
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/parser_std_format_spec.h" 2 3
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/parser_std_format_spec.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 48 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/parser_std_format_spec.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 1171 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/parser_std_format_spec.h" 3
}}
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_output.h" 2 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_output.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_output.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 329 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_output.h" 3
}}
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_integral.h" 2 3







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/array" 1 3
# 160 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/array" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 164 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/array" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, size_t _Size>
struct array {

  using __self = array;
  using value_type = _Tp;
  using reference = value_type&;
  using const_reference = const value_type&;
  using iterator = value_type*;
  using const_iterator = const value_type*;
  using pointer = value_type*;
  using const_pointer = const value_type*;
  using size_type = size_t;
  using difference_type = ptrdiff_t;
  using reverse_iterator = std::reverse_iterator<iterator>;
  using const_reverse_iterator = std::reverse_iterator<const_iterator>;

  _Tp __elems_[_Size];


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void fill(const value_type& __u) {
    std::fill_n(data(), _Size, __u);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(array& __a)
                                                     {
    std::swap_ranges(data(), data() + _Size, __a.data());
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator begin() throw() { return iterator(data()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator begin() const throw() {
    return const_iterator(data());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator end() throw() { return iterator(data() + _Size); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator end() const throw() {
    return const_iterator(data() + _Size);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator rbegin() throw() {
    return reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator rbegin() const throw() {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator rend() throw() {
    return reverse_iterator(begin());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator rend() const throw() {
    return const_reverse_iterator(begin());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator cbegin() const throw() { return begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator cend() const throw() { return end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator crbegin() const throw() {
    return rbegin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator crend() const throw() { return rend(); }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type size() const throw() { return _Size; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type max_size() const throw() { return _Size; }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool empty() const throw() {
    return _Size == 0;
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator[](size_type __n) throw() {
    ((void)0);
    return __elems_[__n];
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference operator[](size_type __n) const throw() {
    ((void)0);
    return __elems_[__n];
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference at(size_type __n) {
    if (__n >= _Size)
      __throw_out_of_range("array::at");
    return __elems_[__n];
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference at(size_type __n) const {
    if (__n >= _Size)
      __throw_out_of_range("array::at");
    return __elems_[__n];
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference front() throw() { return (*this)[0]; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference front() const throw() { return (*this)[0]; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference back() throw() { return (*this)[_Size - 1]; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference back() const throw() {
    return (*this)[_Size - 1];
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) value_type* data() throw() { return __elems_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const value_type* data() const throw() { return __elems_; }
};

template <class _Tp>
struct array<_Tp, 0> {

  typedef array __self;
  typedef _Tp value_type;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef value_type* iterator;
  typedef const value_type* const_iterator;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

  typedef __conditional_t<is_const<_Tp>::value, const __empty, __empty> _EmptyType;

  struct _ArrayInStructT {
    _Tp __data_[1];
  };
  __attribute__((__aligned__(_Alignof(_ArrayInStructT)))) _EmptyType __elems_[sizeof(_ArrayInStructT)];

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) value_type* data() throw() { return __nullptr; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const value_type* data() const throw() { return __nullptr; }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void fill(const value_type&) {
    _Static_assert(!is_const<_Tp>::value, "cannot fill zero-sized array of type 'const T'");
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(array&) throw() {
    _Static_assert(!is_const<_Tp>::value, "cannot swap zero-sized array of type 'const T'");
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator begin() throw() { return iterator(data()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator begin() const throw() {
    return const_iterator(data());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator end() throw() { return iterator(data()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator end() const throw() {
    return const_iterator(data());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator rbegin() throw() {
    return reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator rbegin() const throw() {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator rend() throw() {
    return reverse_iterator(begin());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator rend() const throw() {
    return const_reverse_iterator(begin());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator cbegin() const throw() { return begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator cend() const throw() { return end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator crbegin() const throw() {
    return rbegin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator crend() const throw() { return rend(); }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type size() const throw() { return 0; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type max_size() const throw() { return 0; }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool empty() const throw() { return true; }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator[](size_type) throw() {
    ((void)0);
    __libcpp_unreachable();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference operator[](size_type) const throw() {
    ((void)0);
    __libcpp_unreachable();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference at(size_type) {
    __throw_out_of_range("array<T, 0>::at");
    __libcpp_unreachable();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference at(size_type) const {
    __throw_out_of_range("array<T, 0>::at");
    __libcpp_unreachable();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference front() throw() {
    ((void)0);
    __libcpp_unreachable();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference front() const throw() {
    ((void)0);
    __libcpp_unreachable();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference back() throw() {
    ((void)0);
    __libcpp_unreachable();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference back() const throw() {
    ((void)0);
    __libcpp_unreachable();
  }
};






template <class _Tp, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator==(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y) {
  return std::equal(__x.begin(), __x.end(), __y.begin());
}



template <class _Tp, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y) {
  return !(__x == __y);
}

template <class _Tp, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y) {
  return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Tp, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y) {
  return __y < __x;
}

template <class _Tp, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y) {
  return !(__y < __x);
}

template <class _Tp, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>=(const array<_Tp, _Size>& __x, const array<_Tp, _Size>& __y) {
  return !(__x < __y);
}
# 426 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/array" 3
template <class _Tp, size_t _Size, __enable_if_t<_Size == 0 || __is_swappable<_Tp>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(array<_Tp, _Size>& __x, array<_Tp, _Size>& __y)
                                        {
  __x.swap(__y);
}

template <class _Tp, size_t _Size>
struct tuple_size<array<_Tp, _Size> > : public integral_constant<size_t, _Size> {};

template <size_t _Ip, class _Tp, size_t _Size>
struct tuple_element<_Ip, array<_Tp, _Size> > {
  _Static_assert(_Ip < _Size, "Index out of bounds in std::tuple_element<> (std::array)");
  typedef _Tp type;
};

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp& get(array<_Tp, _Size>& __a) throw() {
  _Static_assert(_Ip < _Size, "Index out of bounds in std::get<> (std::array)");
  return __a.__elems_[_Ip];
}

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _Tp& get(const array<_Tp, _Size>& __a) throw() {
  _Static_assert(_Ip < _Size, "Index out of bounds in std::get<> (const std::array)");
  return __a.__elems_[_Ip];
}

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp&& get(array<_Tp, _Size>&& __a) throw() {
  _Static_assert(_Ip < _Size, "Index out of bounds in std::get<> (std::array &&)");
  return std::move(__a.__elems_[_Ip]);
}

template <size_t _Ip, class _Tp, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _Tp&& get(const array<_Tp, _Size>&& __a) throw() {
  _Static_assert(_Ip < _Size, "Index out of bounds in std::get<> (const std::array &&)");
  return std::move(__a.__elems_[_Ip]);
}
# 497 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/array" 3
}}
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_integral.h" 2 3





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 1 3
# 202 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex/once_flag.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex/once_flag.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex/once_flag.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct once_flag;
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex/once_flag.h" 3
template <class _Callable>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void call_once(once_flag&, _Callable&);

template <class _Callable>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void call_once(once_flag&, const _Callable&);



struct once_flag {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) once_flag() throw() : __state_(_Unset) {}
  once_flag(const once_flag&) = delete;
  once_flag& operator=(const once_flag&) = delete;




  typedef unsigned long _State_type;


  static const _State_type _Unset = 0;
  static const _State_type _Pending = 1;
  static const _State_type _Complete = ~_State_type(0);

private:
  _State_type __state_;





  template <class _Callable>
  friend void call_once(once_flag&, _Callable&);

  template <class _Callable>
  friend void call_once(once_flag&, const _Callable&);

};
# 103 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex/once_flag.h" 3
template <class _Fp>
class __call_once_param {
  _Fp& __f_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __call_once_param(_Fp& __f) : __f_(__f) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator()() { __f_(); }
};



template <class _Fp>
void __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __call_once_proxy(void* __vp) {
  __call_once_param<_Fp>* __p = static_cast<__call_once_param<_Fp>*>(__vp);
  (*__p)();
}

__attribute__((__visibility__("default"))) void __call_once(volatile once_flag::_State_type&, void*, void (*)(void*));
# 137 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex/once_flag.h" 3
template <class _Callable>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void call_once(once_flag& __flag, _Callable& __func) {
  if (__libcpp_acquire_load(&__flag.__state_) != once_flag::_Complete) {
    __call_once_param<_Callable> __p(__func);
    std::__call_once(__flag.__state_, &__p, &__call_once_proxy<_Callable>);
  }
}

template <class _Callable>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void call_once(once_flag& __flag, const _Callable& __func) {
  if (__libcpp_acquire_load(&__flag.__state_) != once_flag::_Complete) {
    __call_once_param<const _Callable> __p(__func);
    std::__call_once(__flag.__state_, &__p, &__call_once_proxy<const _Callable>);
  }
}



}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/no_destroy.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__utility/no_destroy.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct __uninitialized_tag {};







template <class _Tp>
struct __no_destroy {
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __no_destroy(__uninitialized_tag) : __dummy_() {
    if (__libcpp_is_constant_evaluated()) {
      __dummy_ = char();
    }
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~__no_destroy() {

  }

  template <class... _Args>
                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __no_destroy(_Args&&... __args)
      : __obj_(std::forward<_Args>(__args)...) {}

  template <class... _Args>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp& __emplace(_Args&&... __args) {
    new (&__obj_) _Tp(std::forward<_Args>(__args)...);
    return __obj_;
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp& __get() { return __obj_; }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp const& __get() const { return __obj_; }

private:
  union {
    _Tp __obj_;
    char __dummy_;
  };
};

}}
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/clocale" 1 3
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/clocale" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale.h" 1 3
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/locale.h" 1 3 4
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/locale.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_locale.h" 1 3 4
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_locale.h" 3 4
struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;
 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
 char int_p_cs_precedes;
 char int_n_cs_precedes;
 char int_p_sep_by_space;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_null.h" 1 3 4
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_locale.h" 2 3 4

extern "C" {
struct lconv *localeconv(void);
}
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/locale.h" 2 3 4
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/locale.h" 3 4
extern "C" {
char *setlocale(int, const char *);
}
# 48 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale.h" 2 3
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/clocale" 2 3
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/clocale" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::lconv __attribute__((__using_if_exists__));
using ::setlocale __attribute__((__using_if_exists__));
using ::localeconv __attribute__((__using_if_exists__));

}}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 2 3
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 1 3 4
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_xlocale.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_xlocale.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/__xlocale.h" 1 3 4
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/__xlocale.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_mb_cur_max.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_mb_cur_max.h" 3 4
extern "C" {
int ___mb_cur_max(void);
}
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/__xlocale.h" 2 3 4

struct _xlocale;
typedef struct _xlocale * locale_t;

extern "C" {
int ___mb_cur_max_l(locale_t);
}
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_xlocale.h" 2 3 4
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_xlocale.h" 3 4
extern "C" {
extern const locale_t _c_locale;

locale_t duplocale(locale_t);
int freelocale(locale_t);
struct lconv * localeconv_l(locale_t);
locale_t newlocale(int, const char *, locale_t);
const char * querylocale(int, locale_t);
locale_t uselocale(locale_t);
}
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_ctype.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_ctype.h" 3 4
extern "C" {
unsigned long ___runetype_l(__darwin_ct_rune_t, locale_t);
__darwin_ct_rune_t ___tolower_l(__darwin_ct_rune_t, locale_t);
__darwin_ct_rune_t ___toupper_l(__darwin_ct_rune_t, locale_t);
}

extern "C" {
int __maskrune_l(__darwin_ct_rune_t, unsigned long, locale_t);
}

inline int
__istype_l(__darwin_ct_rune_t _c, unsigned long _f, locale_t _l)
{
 return !!(isascii(_c) ? (_DefaultRuneLocale.__runetype[_c] & _f)
  : __maskrune_l(_c, _f, _l));
}

inline __darwin_ct_rune_t
__toupper_l(__darwin_ct_rune_t _c, locale_t _l)
{
 return isascii(_c) ? _DefaultRuneLocale.__mapupper[_c]
  : ___toupper_l(_c, _l);
}

inline __darwin_ct_rune_t
__tolower_l(__darwin_ct_rune_t _c, locale_t _l)
{
 return isascii(_c) ? _DefaultRuneLocale.__maplower[_c]
  : ___tolower_l(_c, _l);
}

inline int
__wcwidth_l(__darwin_ct_rune_t _c, locale_t _l)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune_l(_c, 0xe0000000L|0x00040000L, _l);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}



inline int
digittoint_l(int c, locale_t l)
{
 return (__maskrune_l(c, 0x0F, l));
}

inline int
isalnum_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000100L|0x00000400L, l));
}

inline int
isalpha_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000100L, l));
}

inline int
isblank_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00020000L, l));
}

inline int
iscntrl_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000200L, l));
}

inline int
isdigit_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000400L, l));
}

inline int
isgraph_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000800L, l));
}

inline int
ishexnumber_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00010000L, l));
}

inline int
isideogram_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00080000L, l));
}

inline int
islower_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00001000L, l));
}

inline int
isnumber_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00000400L, l));
}

inline int
isphonogram_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00200000L, l));
}

inline int
isprint_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00040000L, l));
}

inline int
ispunct_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00002000L, l));
}

inline int
isrune_l(int c, locale_t l)
{
 return (__istype_l(c, 0xFFFFFFF0L, l));
}

inline int
isspace_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00004000L, l));
}

inline int
isspecial_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00100000L, l));
}

inline int
isupper_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00008000L, l));
}

inline int
isxdigit_l(int c, locale_t l)
{
 return (__istype_l(c, 0x00010000L, l));
}

inline int
tolower_l(int c, locale_t l)
{
        return (__tolower_l(c, l));
}

inline int
toupper_l(int c, locale_t l)
{
        return (__toupper_l(c, l));
}
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/___wctype.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/___wctype.h" 3 4
inline int
iswalnum_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000100L|0x00000400L, _l));
}

inline int
iswalpha_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000100L, _l));
}

inline int
iswcntrl_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000200L, _l));
}

inline int
iswctype_l(wint_t _wc, wctype_t _charclass, locale_t _l)
{
 return (__istype_l(_wc, _charclass, _l));
}

inline int
iswdigit_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000400L, _l));
}

inline int
iswgraph_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000800L, _l));
}

inline int
iswlower_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00001000L, _l));
}

inline int
iswprint_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00040000L, _l));
}

inline int
iswpunct_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00002000L, _l));
}

inline int
iswspace_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00004000L, _l));
}

inline int
iswupper_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00008000L, _l));
}

inline int
iswxdigit_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00010000L, _l));
}

inline wint_t
towlower_l(wint_t _wc, locale_t _l)
{
        return (__tolower_l(_wc, _l));
}

inline wint_t
towupper_l(wint_t _wc, locale_t _l)
{
        return (__toupper_l(_wc, _l));
}
# 138 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/___wctype.h" 3 4
extern "C" {
wctype_t
 wctype_l(const char *, locale_t);
}
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_stdio.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_stdio.h" 3 4
extern "C" {

int fprintf_l(FILE * , locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4)));
int fscanf_l(FILE * , locale_t , const char * , ...)
        __attribute__((__format__ (__scanf__, 3, 4)));
int printf_l(locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 2, 3)));
int scanf_l(locale_t , const char * , ...)
        __attribute__((__format__ (__scanf__, 2, 3)));
int sprintf_l(char * , locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4))) __attribute__((__availability__(swift, unavailable, message="Use snprintf_l instead.")));
int sscanf_l(const char * , locale_t , const char * , ...)
        __attribute__((__format__ (__scanf__, 3, 4)));
int vfprintf_l(FILE * , locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0)));
int vprintf_l(locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 2, 0)));
int vsprintf_l(char * , locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0))) __attribute__((__availability__(swift, unavailable, message="Use vsnprintf_l instead.")));


int snprintf_l(char * , size_t, locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 4, 5)));
int vfscanf_l(FILE * , locale_t , const char * , va_list)
        __attribute__((__format__ (__scanf__, 3, 0)));
int vscanf_l(locale_t , const char * , va_list)
        __attribute__((__format__ (__scanf__, 2, 0)));
int vsnprintf_l(char * , size_t, locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 4, 0)));
int vsscanf_l(const char * , locale_t , const char * , va_list)
        __attribute__((__format__ (__scanf__, 3, 0)));



int dprintf_l(int, locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4))) __attribute__((availability(macosx,introduced=10.7)));
int vdprintf_l(int, locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0))) __attribute__((availability(macosx,introduced=10.7)));




int asprintf_l(char ** , locale_t , const char * , ...)
        __attribute__((__format__ (__printf__, 3, 4)));
int vasprintf_l(char ** , locale_t , const char * , va_list)
        __attribute__((__format__ (__printf__, 3, 0)));


}
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_stdlib.h" 1 3 4
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_stdlib.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_stdlib.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_stdlib.h" 2 3 4


extern "C" {
double atof_l(const char *, locale_t);
int atoi_l(const char *, locale_t);
long atol_l(const char *, locale_t);

long long
  atoll_l(const char *, locale_t);

int mblen_l(const char *, size_t, locale_t);
size_t mbstowcs_l(wchar_t * , const char * , size_t,
     locale_t);
int mbtowc_l(wchar_t * , const char * , size_t,
     locale_t);
double strtod_l(const char *, char **, locale_t) __asm("_" "strtod_l" );
float strtof_l(const char *, char **, locale_t) __asm("_" "strtof_l" );
long strtol_l(const char *, char **, int, locale_t);
long double
  strtold_l(const char *, char **, locale_t);
long long
  strtoll_l(const char *, char **, int, locale_t);

long long
  strtoq_l(const char *, char **, int, locale_t);

unsigned long
  strtoul_l(const char *, char **, int, locale_t);
unsigned long long
  strtoull_l(const char *, char **, int, locale_t);

unsigned long long
  strtouq_l(const char *, char **, int, locale_t);

size_t wcstombs_l(char * , const wchar_t * , size_t,
     locale_t);
int wctomb_l(char *, wchar_t, locale_t);





}
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_string.h" 1 3 4
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_string.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_string.h" 2 3 4


extern "C" {
int strcoll_l(const char *, const char *, locale_t);
size_t strxfrm_l(char *, const char *, size_t, locale_t);
int strcasecmp_l(const char *, const char *, locale_t);
char *strcasestr_l(const char *, const char *, locale_t);
int strncasecmp_l(const char *, const char *, size_t, locale_t);
}
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_time.h" 1 3 4
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_time.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_time.h" 2 3 4



extern "C" {
size_t strftime_l(char * , size_t, const char * ,
  const struct tm * , locale_t)
  __asm("_" "strftime_l" ) __attribute__((__format__ (__strftime__, 3, 0)));
char *strptime_l(const char * , const char * ,
  struct tm * , locale_t)
  __asm("_" "strptime_l" ) __attribute__((__format__ (__strftime__, 2, 0)));
}
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_wchar.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_wchar.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 1 3 4
# 82 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_ptrdiff_t.h" 1 3 4
# 83 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3 4




# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_size_t.h" 1 3 4
# 88 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3 4




# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_rsize_t.h" 1 3 4
# 93 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3 4




# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_wchar_t.h" 1 3 4
# 98 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3 4
# 107 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_nullptr_t.h" 1 3 4
# 108 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3 4
# 122 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 3 4
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/__stddef_offsetof.h" 1 3 4
# 123 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stddef.h" 2 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 2 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_wchar.h" 2 3 4


extern "C" {
wint_t btowc_l(int, locale_t);
wint_t fgetwc_l(FILE *, locale_t);
wchar_t *fgetws_l(wchar_t * , int, FILE * , locale_t);
wint_t fputwc_l(wchar_t, FILE *, locale_t);
int fputws_l(const wchar_t * , FILE * , locale_t);
int fwprintf_l(FILE * , locale_t, const wchar_t * , ...);
int fwscanf_l(FILE * , locale_t, const wchar_t * , ...);
wint_t getwc_l(FILE *, locale_t);
wint_t getwchar_l(locale_t);
size_t mbrlen_l(const char * , size_t, mbstate_t * ,
     locale_t);
size_t mbrtowc_l(wchar_t * , const char * , size_t,
     mbstate_t * , locale_t);
int mbsinit_l(const mbstate_t *, locale_t);
size_t mbsrtowcs_l(wchar_t * , const char ** , size_t,
     mbstate_t * , locale_t);
wint_t putwc_l(wchar_t, FILE *, locale_t);
wint_t putwchar_l(wchar_t, locale_t);
int swprintf_l(wchar_t * , size_t n, locale_t,
  const wchar_t * , ...);
int swscanf_l(const wchar_t * , locale_t,
  const wchar_t * , ...);
wint_t ungetwc_l(wint_t, FILE *, locale_t);
int vfwprintf_l(FILE * , locale_t, const wchar_t * ,
  __darwin_va_list);
int vswprintf_l(wchar_t * , size_t n, locale_t,
  const wchar_t * , __darwin_va_list);
int vwprintf_l(locale_t, const wchar_t * , __darwin_va_list);
size_t wcrtomb_l(char * , wchar_t, mbstate_t * ,
     locale_t);
int wcscoll_l(const wchar_t *, const wchar_t *, locale_t);
size_t wcsftime_l(wchar_t * , size_t, const wchar_t * ,
  const struct tm * , locale_t)
  __asm("_" "wcsftime_l" );
size_t wcsrtombs_l(char * , const wchar_t ** , size_t,
     mbstate_t * , locale_t);
double wcstod_l(const wchar_t * , wchar_t ** , locale_t);
long wcstol_l(const wchar_t * , wchar_t ** , int,
     locale_t);
unsigned long
 wcstoul_l(const wchar_t * , wchar_t ** , int,
     locale_t);
int wcswidth_l(const wchar_t *, size_t, locale_t);
size_t wcsxfrm_l(wchar_t * , const wchar_t * , size_t,
     locale_t);
int wctob_l(wint_t, locale_t);
int wcwidth_l(wchar_t, locale_t);
int wprintf_l(locale_t, const wchar_t * , ...);
int wscanf_l(locale_t, const wchar_t * , ...);
}
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_wchar.h" 3 4
extern "C" {
int vfwscanf_l(FILE * , locale_t, const wchar_t * ,
  __darwin_va_list);
int vswscanf_l(const wchar_t * , locale_t,
  const wchar_t * , __darwin_va_list);
int vwscanf_l(locale_t, const wchar_t * , __darwin_va_list);
float wcstof_l(const wchar_t * , wchar_t ** , locale_t);
long double
 wcstold_l(const wchar_t * , wchar_t ** , locale_t);

long long
 wcstoll_l(const wchar_t * , wchar_t ** , int,
     locale_t);
unsigned long long
 wcstoull_l(const wchar_t * , wchar_t ** , int,
     locale_t);

}
# 120 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_wchar.h" 3 4
extern "C" {
size_t mbsnrtowcs_l(wchar_t * , const char ** , size_t,
     size_t, mbstate_t * , locale_t);
int wcscasecmp_l(const wchar_t *, const wchar_t *, locale_t) __attribute__((availability(macosx,introduced=10.7)));
int wcsncasecmp_l(const wchar_t *, const wchar_t *, size_t n, locale_t) __attribute__((availability(macosx,introduced=10.7)));
size_t wcsnrtombs_l(char * , const wchar_t ** , size_t,
     size_t, mbstate_t * , locale_t);
}







extern "C" {
wchar_t *fgetwln_l(FILE * , size_t *, locale_t) __attribute__((availability(macosx,introduced=10.7)));
}
# 58 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_wctype.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_wctype.h" 3 4
inline int
iswblank_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00020000L, _l));
}

inline int
iswhexnumber_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00010000L, _l));
}

inline int
iswideogram_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00080000L, _l));
}

inline int
iswnumber_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00000400L, _l));
}

inline int
iswphonogram_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00200000L, _l));
}

inline int
iswrune_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0xFFFFFFF0L, _l));
}

inline int
iswspecial_l(wint_t _wc, locale_t _l)
{
 return (__istype_l(_wc, 0x00100000L, _l));
}
# 90 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_wctype.h" 3 4
extern "C" {
wint_t nextwctype_l(wint_t, wctype_t, locale_t);
wint_t towctrans_l(wint_t, wctrans_t, locale_t);
wctrans_t
 wctrans_l(const char *, locale_t);
}
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale.h" 2 3 4
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 2 3
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

class __attribute__((__visibility__("default"))) locale;

template <class _Facet>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool has_facet(const locale&) throw();

template <class _Facet>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _Facet& use_facet(const locale&);

class __attribute__((__visibility__("default"))) locale {
public:

  class __attribute__((__visibility__("default"))) facet;
  class __attribute__((__visibility__("default"))) id;

  typedef int category;

  static const category
      none = 0,
      collate = (1 << 0), ctype = (1 << 1), monetary = (1 << 3), numeric = (1 << 4),
      time = (1 << 5), messages = (1 << 2), all = collate | ctype | monetary | numeric | time | messages;


  locale() throw();
  locale(const locale&) throw();
  explicit locale(const char*);
  explicit locale(const string&);
  locale(const locale&, const char*, category);
  locale(const locale&, const string&, category);
  template <class _Facet>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) locale(const locale&, _Facet*);
  locale(const locale&, const locale&, category);

  ~locale();

  const locale& operator=(const locale&) throw();

  template <class _Facet>
  inline __attribute__((__visibility__("hidden"))) locale combine(const locale&) const;


  string name() const;
  bool operator==(const locale&) const;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const locale& __y) const { return !(*this == __y); }

  template <class _CharT, class _Traits, class _Allocator>
  inline __attribute__((__visibility__("hidden"))) bool
  operator()(const basic_string<_CharT, _Traits, _Allocator>&, const basic_string<_CharT, _Traits, _Allocator>&) const;


  static locale global(const locale&);
  static const locale& classic();

private:
  class __imp;
  __imp* __locale_;

  template <class>
  friend struct __no_destroy;
  struct __private_tag {};
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit locale(__private_tag, __imp* __loc) : __locale_(__loc) {}

  void __install_ctor(const locale&, facet*, long);
  static locale& __global();
  bool has_facet(id&) const;
  const facet* use_facet(id&) const;

  template <class _Facet>
  friend bool has_facet(const locale&) throw();
  template <class _Facet>
  friend const _Facet& use_facet(const locale&);
};

class __attribute__((__visibility__("default"))) locale::facet : public __shared_count {
protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit facet(size_t __refs = 0) : __shared_count(static_cast<long>(__refs) - 1) {}

  ~facet() override;




private:
  void __on_zero_shared() throw() override;
};

class __attribute__((__visibility__("default"))) locale::id {
  once_flag __flag_;
  int32_t __id_;

  static int32_t __next_id;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) id() : __id_(0) {}
  void operator=(const id&) = delete;
  id(const id&) = delete;

public:
  long __get();

  friend class locale;
  friend class locale::__imp;
};

template <class _Facet>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) locale::locale(const locale& __other, _Facet* __f) {
  __install_ctor(__other, __f, __f ? __f->id.__get() : 0);
}

template <class _Facet>
locale locale::combine(const locale& __other) const {
  if (!std::has_facet<_Facet>(__other))
    __throw_runtime_error("locale::combine: locale missing facet");

  return locale(*this, &const_cast<_Facet&>(std::use_facet<_Facet>(__other)));
}

template <class _Facet>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool has_facet(const locale& __l) throw() {
  return __l.has_facet(_Facet::id);
}

template <class _Facet>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _Facet& use_facet(const locale& __l) {
  return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));
}



template <class _CharT>
class collate : public locale::facet {
public:
  typedef _CharT char_type;
  typedef basic_string<char_type> string_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit collate(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int
  compare(const char_type* __lo1, const char_type* __hi1, const char_type* __lo2, const char_type* __hi2) const {
    return do_compare(__lo1, __hi1, __lo2, __hi2);
  }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__always_inline__)) string_type
  transform(const char_type* __lo, const char_type* __hi) const {
    return do_transform(__lo, __hi);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long hash(const char_type* __lo, const char_type* __hi) const { return do_hash(__lo, __hi); }

  static locale::id id;

protected:
  ~collate() override;
  virtual int
  do_compare(const char_type* __lo1, const char_type* __hi1, const char_type* __lo2, const char_type* __hi2) const;
  virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const {
    return string_type(__lo, __hi);
  }
  virtual long do_hash(const char_type* __lo, const char_type* __hi) const;
};

template <class _CharT>
locale::id collate<_CharT>::id;

template <class _CharT>
collate<_CharT>::~collate() {}

template <class _CharT>
int collate<_CharT>::do_compare(
    const char_type* __lo1, const char_type* __hi1, const char_type* __lo2, const char_type* __hi2) const {
  for (; __lo2 != __hi2; ++__lo1, ++__lo2) {
    if (__lo1 == __hi1 || *__lo1 < *__lo2)
      return -1;
    if (*__lo2 < *__lo1)
      return 1;
  }
  return __lo1 != __hi1;
}

template <class _CharT>
long collate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const {
  size_t __h = 0;
  const size_t __sr = 8 * sizeof(size_t) - 8;
  const size_t __mask = size_t(0xF) << (__sr + 4);
  for (const char_type* __p = __lo; __p != __hi; ++__p) {
    __h = (__h << 4) + static_cast<size_t>(*__p);
    size_t __g = __h & __mask;
    __h ^= __g | (__g >> __sr);
  }
  return static_cast<long>(__h);
}

extern template class __attribute__((__visibility__("default"))) collate<char>;

extern template class __attribute__((__visibility__("default"))) collate<wchar_t>;




template <class _CharT>
class collate_byname;

template <>
class __attribute__((__visibility__("default"))) collate_byname<char> : public collate<char> {
  locale_t __l_;

public:
  typedef char char_type;
  typedef basic_string<char_type> string_type;

  explicit collate_byname(const char* __n, size_t __refs = 0);
  explicit collate_byname(const string& __n, size_t __refs = 0);

protected:
  ~collate_byname() override;
  int do_compare(
      const char_type* __lo1, const char_type* __hi1, const char_type* __lo2, const char_type* __hi2) const override;
  string_type do_transform(const char_type* __lo, const char_type* __hi) const override;
};


template <>
class __attribute__((__visibility__("default"))) collate_byname<wchar_t> : public collate<wchar_t> {
  locale_t __l_;

public:
  typedef wchar_t char_type;
  typedef basic_string<char_type> string_type;

  explicit collate_byname(const char* __n, size_t __refs = 0);
  explicit collate_byname(const string& __n, size_t __refs = 0);

protected:
  ~collate_byname() override;

  int do_compare(
      const char_type* __lo1, const char_type* __hi1, const char_type* __lo2, const char_type* __hi2) const override;
  string_type do_transform(const char_type* __lo, const char_type* __hi) const override;
};


template <class _CharT, class _Traits, class _Allocator>
bool locale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,
                        const basic_string<_CharT, _Traits, _Allocator>& __y) const {
  return std::use_facet<std::collate<_CharT> >(*this).compare(
             __x.data(), __x.data() + __x.size(), __y.data(), __y.data() + __y.size()) < 0;
}



class __attribute__((__visibility__("default"))) ctype_base {
public:
# 373 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
  typedef __uint32_t mask;





  static const mask space = 0x00004000L;
  static const mask print = 0x00040000L;
  static const mask cntrl = 0x00000200L;
  static const mask upper = 0x00008000L;
  static const mask lower = 0x00001000L;
  static const mask alpha = 0x00000100L;
  static const mask digit = 0x00000400L;
  static const mask punct = 0x00002000L;
  static const mask xdigit = 0x00010000L;







  static const mask blank = 0x00020000L;
  static const mask __regex_word = 0x80;
# 461 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
  static const mask alnum = alpha | digit;
  static const mask graph = alnum | punct;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ctype_base() {}

  _Static_assert((__regex_word & ~(std::make_unsigned<mask>::type)(space | print | cntrl | upper | lower | alpha | digit | punct | xdigit | blank)) == __regex_word, "__regex_word can't overlap other bits");


};

template <class _CharT>
class ctype;


template <>
class __attribute__((__visibility__("default"))) ctype<wchar_t> : public locale::facet, public ctype_base {
public:
  typedef wchar_t char_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit ctype(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool is(mask __m, char_type __c) const { return do_is(__m, __c); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const {
    return do_is(__low, __high, __vec);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const {
    return do_scan_is(__m, __low, __high);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const {
    return do_scan_not(__m, __low, __high);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type toupper(char_type __c) const { return do_toupper(__c); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const char_type* toupper(char_type* __low, const char_type* __high) const {
    return do_toupper(__low, __high);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type tolower(char_type __c) const { return do_tolower(__c); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const char_type* tolower(char_type* __low, const char_type* __high) const {
    return do_tolower(__low, __high);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type widen(char __c) const { return do_widen(__c); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const char* widen(const char* __low, const char* __high, char_type* __to) const {
    return do_widen(__low, __high, __to);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char narrow(char_type __c, char __dfault) const { return do_narrow(__c, __dfault); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const char_type*
  narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const {
    return do_narrow(__low, __high, __dfault, __to);
  }

  static locale::id id;

protected:
  ~ctype() override;
  virtual bool do_is(mask __m, char_type __c) const;
  virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;
  virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;
  virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;
  virtual char_type do_toupper(char_type) const;
  virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
  virtual char_type do_tolower(char_type) const;
  virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
  virtual char_type do_widen(char) const;
  virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;
  virtual char do_narrow(char_type, char __dfault) const;
  virtual const char_type*
  do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;
};


template <>
class __attribute__((__visibility__("default"))) ctype<char> : public locale::facet, public ctype_base {
  const mask* __tab_;
  bool __del_;

public:
  typedef char char_type;

  explicit ctype(const mask* __tab = __nullptr, bool __del = false, size_t __refs = 0);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool is(mask __m, char_type __c) const {
    return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) != 0 : false;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const {
    for (; __low != __high; ++__low, ++__vec)
      *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;
    return __low;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const {
    for (; __low != __high; ++__low)
      if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))
        break;
    return __low;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const {
    for (; __low != __high; ++__low)
      if (!isascii(*__low) || !(__tab_[static_cast<int>(*__low)] & __m))
        break;
    return __low;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type toupper(char_type __c) const { return do_toupper(__c); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const char_type* toupper(char_type* __low, const char_type* __high) const {
    return do_toupper(__low, __high);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type tolower(char_type __c) const { return do_tolower(__c); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const char_type* tolower(char_type* __low, const char_type* __high) const {
    return do_tolower(__low, __high);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type widen(char __c) const { return do_widen(__c); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const char* widen(const char* __low, const char* __high, char_type* __to) const {
    return do_widen(__low, __high, __to);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char narrow(char_type __c, char __dfault) const { return do_narrow(__c, __dfault); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const char*
  narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const {
    return do_narrow(__low, __high, __dfault, __to);
  }

  static locale::id id;


  static const size_t table_size = (1 <<8 );



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const mask* table() const throw() { return __tab_; }
  static const mask* classic_table() throw();
# 622 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
protected:
  ~ctype() override;
  virtual char_type do_toupper(char_type __c) const;
  virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;
  virtual char_type do_tolower(char_type __c) const;
  virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;
  virtual char_type do_widen(char __c) const;
  virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;
  virtual char do_narrow(char_type __c, char __dfault) const;
  virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;
};



template <class _CharT>
class ctype_byname;

template <>
class __attribute__((__visibility__("default"))) ctype_byname<char> : public ctype<char> {
  locale_t __l_;

public:
  explicit ctype_byname(const char*, size_t = 0);
  explicit ctype_byname(const string&, size_t = 0);

protected:
  ~ctype_byname() override;
  char_type do_toupper(char_type) const override;
  const char_type* do_toupper(char_type* __low, const char_type* __high) const override;
  char_type do_tolower(char_type) const override;
  const char_type* do_tolower(char_type* __low, const char_type* __high) const override;
};


template <>
class __attribute__((__visibility__("default"))) ctype_byname<wchar_t> : public ctype<wchar_t> {
  locale_t __l_;

public:
  explicit ctype_byname(const char*, size_t = 0);
  explicit ctype_byname(const string&, size_t = 0);

protected:
  ~ctype_byname() override;
  bool do_is(mask __m, char_type __c) const override;
  const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const override;
  const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const override;
  const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const override;
  char_type do_toupper(char_type) const override;
  const char_type* do_toupper(char_type* __low, const char_type* __high) const override;
  char_type do_tolower(char_type) const override;
  const char_type* do_tolower(char_type* __low, const char_type* __high) const override;
  char_type do_widen(char) const override;
  const char* do_widen(const char* __low, const char* __high, char_type* __dest) const override;
  char do_narrow(char_type, char __dfault) const override;
  const char_type*
  do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const override;
};


template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isspace(_CharT __c, const locale& __loc) {
  return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isprint(_CharT __c, const locale& __loc) {
  return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool iscntrl(_CharT __c, const locale& __loc) {
  return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isupper(_CharT __c, const locale& __loc) {
  return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool islower(_CharT __c, const locale& __loc) {
  return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isalpha(_CharT __c, const locale& __loc) {
  return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isdigit(_CharT __c, const locale& __loc) {
  return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool ispunct(_CharT __c, const locale& __loc) {
  return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isxdigit(_CharT __c, const locale& __loc) {
  return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isalnum(_CharT __c, const locale& __loc) {
  return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isgraph(_CharT __c, const locale& __loc) {
  return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);
}

template <class _CharT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool isblank(_CharT __c, const locale& __loc) {
  return std::use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _CharT toupper(_CharT __c, const locale& __loc) {
  return std::use_facet<ctype<_CharT> >(__loc).toupper(__c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _CharT tolower(_CharT __c, const locale& __loc) {
  return std::use_facet<ctype<_CharT> >(__loc).tolower(__c);
}



class __attribute__((__visibility__("default"))) codecvt_base {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) codecvt_base() {}
  enum result { ok, partial, error, noconv };
};



template <class _InternT, class _ExternT, class _StateT>
class codecvt;



template <>
class __attribute__((__visibility__("default"))) codecvt<char, char, mbstate_t> : public locale::facet, public codecvt_base {
public:
  typedef char intern_type;
  typedef char extern_type;
  typedef mbstate_t state_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit codecvt(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result
  out(state_type& __st,
      const intern_type* __frm,
      const intern_type* __frm_end,
      const intern_type*& __frm_nxt,
      extern_type* __to,
      extern_type* __to_end,
      extern_type*& __to_nxt) const {
    return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result
  unshift(state_type& __st, extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const {
    return do_unshift(__st, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result
  in(state_type& __st,
     const extern_type* __frm,
     const extern_type* __frm_end,
     const extern_type*& __frm_nxt,
     intern_type* __to,
     intern_type* __to_end,
     intern_type*& __to_nxt) const {
    return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int encoding() const throw() { return do_encoding(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool always_noconv() const throw() { return do_always_noconv(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int
  length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const {
    return do_length(__st, __frm, __end, __mx);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int max_length() const throw() { return do_max_length(); }

  static locale::id id;

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit codecvt(const char*, size_t __refs = 0) : locale::facet(__refs) {}

  ~codecvt() override;

  virtual result
  do_out(state_type& __st,
         const intern_type* __frm,
         const intern_type* __frm_end,
         const intern_type*& __frm_nxt,
         extern_type* __to,
         extern_type* __to_end,
         extern_type*& __to_nxt) const;
  virtual result
  do_in(state_type& __st,
        const extern_type* __frm,
        const extern_type* __frm_end,
        const extern_type*& __frm_nxt,
        intern_type* __to,
        intern_type* __to_end,
        intern_type*& __to_nxt) const;
  virtual result do_unshift(state_type& __st, extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
  virtual int do_encoding() const throw();
  virtual bool do_always_noconv() const throw();
  virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
  virtual int do_max_length() const throw();
};




template <>
class __attribute__((__visibility__("default"))) codecvt<wchar_t, char, mbstate_t> : public locale::facet, public codecvt_base {
  locale_t __l_;

public:
  typedef wchar_t intern_type;
  typedef char extern_type;
  typedef mbstate_t state_type;

  explicit codecvt(size_t __refs = 0);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result
  out(state_type& __st,
      const intern_type* __frm,
      const intern_type* __frm_end,
      const intern_type*& __frm_nxt,
      extern_type* __to,
      extern_type* __to_end,
      extern_type*& __to_nxt) const {
    return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result
  unshift(state_type& __st, extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const {
    return do_unshift(__st, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result
  in(state_type& __st,
     const extern_type* __frm,
     const extern_type* __frm_end,
     const extern_type*& __frm_nxt,
     intern_type* __to,
     intern_type* __to_end,
     intern_type*& __to_nxt) const {
    return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int encoding() const throw() { return do_encoding(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool always_noconv() const throw() { return do_always_noconv(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int
  length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const {
    return do_length(__st, __frm, __end, __mx);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int max_length() const throw() { return do_max_length(); }

  static locale::id id;

protected:
  explicit codecvt(const char*, size_t __refs = 0);

  ~codecvt() override;

  virtual result
  do_out(state_type& __st,
         const intern_type* __frm,
         const intern_type* __frm_end,
         const intern_type*& __frm_nxt,
         extern_type* __to,
         extern_type* __to_end,
         extern_type*& __to_nxt) const;
  virtual result
  do_in(state_type& __st,
        const extern_type* __frm,
        const extern_type* __frm_end,
        const extern_type*& __frm_nxt,
        intern_type* __to,
        intern_type* __to_end,
        intern_type*& __to_nxt) const;
  virtual result do_unshift(state_type& __st, extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
  virtual int do_encoding() const throw();
  virtual bool do_always_noconv() const throw();
  virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
  virtual int do_max_length() const throw();
};




template <>
class __attribute__((__visibility__("default"))) codecvt<char16_t, char, mbstate_t>
    : public locale::facet, public codecvt_base {
public:
  typedef char16_t intern_type;
  typedef char extern_type;
  typedef mbstate_t state_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit codecvt(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result
  out(state_type& __st,
      const intern_type* __frm,
      const intern_type* __frm_end,
      const intern_type*& __frm_nxt,
      extern_type* __to,
      extern_type* __to_end,
      extern_type*& __to_nxt) const {
    return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result
  unshift(state_type& __st, extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const {
    return do_unshift(__st, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result
  in(state_type& __st,
     const extern_type* __frm,
     const extern_type* __frm_end,
     const extern_type*& __frm_nxt,
     intern_type* __to,
     intern_type* __to_end,
     intern_type*& __to_nxt) const {
    return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int encoding() const throw() { return do_encoding(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool always_noconv() const throw() { return do_always_noconv(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int
  length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const {
    return do_length(__st, __frm, __end, __mx);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int max_length() const throw() { return do_max_length(); }

  static locale::id id;

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit codecvt(const char*, size_t __refs = 0) : locale::facet(__refs) {}

  ~codecvt() override;

  virtual result
  do_out(state_type& __st,
         const intern_type* __frm,
         const intern_type* __frm_end,
         const intern_type*& __frm_nxt,
         extern_type* __to,
         extern_type* __to_end,
         extern_type*& __to_nxt) const;
  virtual result
  do_in(state_type& __st,
        const extern_type* __frm,
        const extern_type* __frm_end,
        const extern_type*& __frm_nxt,
        intern_type* __to,
        intern_type* __to_end,
        intern_type*& __to_nxt) const;
  virtual result do_unshift(state_type& __st, extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
  virtual int do_encoding() const throw();
  virtual bool do_always_noconv() const throw();
  virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
  virtual int do_max_length() const throw();
};
# 1092 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
template <>
class __attribute__((__visibility__("default"))) codecvt<char32_t, char, mbstate_t>
    : public locale::facet, public codecvt_base {
public:
  typedef char32_t intern_type;
  typedef char extern_type;
  typedef mbstate_t state_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit codecvt(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result
  out(state_type& __st,
      const intern_type* __frm,
      const intern_type* __frm_end,
      const intern_type*& __frm_nxt,
      extern_type* __to,
      extern_type* __to_end,
      extern_type*& __to_nxt) const {
    return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result
  unshift(state_type& __st, extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const {
    return do_unshift(__st, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) result
  in(state_type& __st,
     const extern_type* __frm,
     const extern_type* __frm_end,
     const extern_type*& __frm_nxt,
     intern_type* __to,
     intern_type* __to_end,
     intern_type*& __to_nxt) const {
    return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int encoding() const throw() { return do_encoding(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool always_noconv() const throw() { return do_always_noconv(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int
  length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const {
    return do_length(__st, __frm, __end, __mx);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int max_length() const throw() { return do_max_length(); }

  static locale::id id;

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit codecvt(const char*, size_t __refs = 0) : locale::facet(__refs) {}

  ~codecvt() override;

  virtual result
  do_out(state_type& __st,
         const intern_type* __frm,
         const intern_type* __frm_end,
         const intern_type*& __frm_nxt,
         extern_type* __to,
         extern_type* __to_end,
         extern_type*& __to_nxt) const;
  virtual result
  do_in(state_type& __st,
        const extern_type* __frm,
        const extern_type* __frm_end,
        const extern_type*& __frm_nxt,
        intern_type* __to,
        intern_type* __to_end,
        intern_type*& __to_nxt) const;
  virtual result do_unshift(state_type& __st, extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;
  virtual int do_encoding() const throw();
  virtual bool do_always_noconv() const throw();
  virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;
  virtual int do_max_length() const throw();
};
# 1255 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
template <class _InternT, class _ExternT, class _StateT>
class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT> {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit codecvt_byname(const char* __nm, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit codecvt_byname(const string& __nm, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}

protected:
  ~codecvt_byname() override;
};

#pragma GCC diagnostic push
# 1267 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 1267 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _InternT, class _ExternT, class _StateT>
codecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname() {}
#pragma GCC diagnostic pop

extern template class __attribute__((__visibility__("default"))) codecvt_byname<char, char, mbstate_t>;

extern template class __attribute__((__visibility__("default"))) codecvt_byname<wchar_t, char, mbstate_t>;

extern template class __attribute__((__visibility__("default")))
    codecvt_byname<char16_t, char, mbstate_t>;
extern template class __attribute__((__visibility__("default")))
    codecvt_byname<char32_t, char, mbstate_t>;





template <size_t _Np>
struct __narrow_to_utf8 {
  template <class _OutputIterator, class _CharT>
  _OutputIterator operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;
};

template <>
struct __narrow_to_utf8<8> {
  template <class _OutputIterator, class _CharT>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const {
    for (; __wb < __we; ++__wb, ++__s)
      *__s = *__wb;
    return __s;
  }
};

#pragma GCC diagnostic push
# 1301 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 1301 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__((__visibility__("default"))) __narrow_to_utf8<16> : public codecvt<char16_t, char, mbstate_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop

  ~__narrow_to_utf8() override;

  template <class _OutputIterator, class _CharT>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const {
    result __r = ok;
    mbstate_t __mb;
    while (__wb < __we && __r != error) {
      const int __sz = 32;
      char __buf[__sz];
      char* __bn;
      const char16_t* __wn = (const char16_t*)__wb;
      __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn, __buf, __buf + __sz, __bn);
      if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)
        __throw_runtime_error("locale not supported");
      for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
        *__s = *__p;
      __wb = (const _CharT*)__wn;
    }
    return __s;
  }
};

#pragma GCC diagnostic push
# 1329 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 1329 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__((__visibility__("default"))) __narrow_to_utf8<32> : public codecvt<char32_t, char, mbstate_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop

  ~__narrow_to_utf8() override;

  template <class _OutputIterator, class _CharT>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const {
    result __r = ok;
    mbstate_t __mb;
    while (__wb < __we && __r != error) {
      const int __sz = 32;
      char __buf[__sz];
      char* __bn;
      const char32_t* __wn = (const char32_t*)__wb;
      __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn, __buf, __buf + __sz, __bn);
      if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)
        __throw_runtime_error("locale not supported");
      for (const char* __p = __buf; __p < __bn; ++__p, ++__s)
        *__s = *__p;
      __wb = (const _CharT*)__wn;
    }
    return __s;
  }
};

template <size_t _Np>
struct __widen_from_utf8 {
  template <class _OutputIterator>
  _OutputIterator operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;
};

template <>
struct __widen_from_utf8<8> {
  template <class _OutputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator operator()(_OutputIterator __s, const char* __nb, const char* __ne) const {
    for (; __nb < __ne; ++__nb, ++__s)
      *__s = *__nb;
    return __s;
  }
};

#pragma GCC diagnostic push
# 1373 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 1373 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__((__visibility__("default"))) __widen_from_utf8<16> : public codecvt<char16_t, char, mbstate_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop

  ~__widen_from_utf8() override;

  template <class _OutputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator operator()(_OutputIterator __s, const char* __nb, const char* __ne) const {
    result __r = ok;
    mbstate_t __mb;
    while (__nb < __ne && __r != error) {
      const int __sz = 32;
      char16_t __buf[__sz];
      char16_t* __bn;
      const char* __nn = __nb;
      __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb + __sz : __ne, __nn, __buf, __buf + __sz, __bn);
      if (__r == codecvt_base::error || __nn == __nb)
        __throw_runtime_error("locale not supported");
      for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)
        *__s = *__p;
      __nb = __nn;
    }
    return __s;
  }
};

#pragma GCC diagnostic push
# 1401 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 1401 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <>
struct __attribute__((__visibility__("default"))) __widen_from_utf8<32> : public codecvt<char32_t, char, mbstate_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}
#pragma GCC diagnostic pop

  ~__widen_from_utf8() override;

  template <class _OutputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator operator()(_OutputIterator __s, const char* __nb, const char* __ne) const {
    result __r = ok;
    mbstate_t __mb;
    while (__nb < __ne && __r != error) {
      const int __sz = 32;
      char32_t __buf[__sz];
      char32_t* __bn;
      const char* __nn = __nb;
      __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb + __sz : __ne, __nn, __buf, __buf + __sz, __bn);
      if (__r == codecvt_base::error || __nn == __nb)
        __throw_runtime_error("locale not supported");
      for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)
        *__s = *__p;
      __nb = __nn;
    }
    return __s;
  }
};



template <class _CharT>
class numpunct;

template <>
class __attribute__((__visibility__("default"))) numpunct<char> : public locale::facet {
public:
  typedef char char_type;
  typedef basic_string<char_type> string_type;

  explicit numpunct(size_t __refs = 0);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type decimal_point() const { return do_decimal_point(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type thousands_sep() const { return do_thousands_sep(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) string grouping() const { return do_grouping(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) string_type truename() const { return do_truename(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) string_type falsename() const { return do_falsename(); }

  static locale::id id;

protected:
  ~numpunct() override;
  virtual char_type do_decimal_point() const;
  virtual char_type do_thousands_sep() const;
  virtual string do_grouping() const;
  virtual string_type do_truename() const;
  virtual string_type do_falsename() const;

  char_type __decimal_point_;
  char_type __thousands_sep_;
  string __grouping_;
};


template <>
class __attribute__((__visibility__("default"))) numpunct<wchar_t> : public locale::facet {
public:
  typedef wchar_t char_type;
  typedef basic_string<char_type> string_type;

  explicit numpunct(size_t __refs = 0);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type decimal_point() const { return do_decimal_point(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type thousands_sep() const { return do_thousands_sep(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) string grouping() const { return do_grouping(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) string_type truename() const { return do_truename(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) string_type falsename() const { return do_falsename(); }

  static locale::id id;

protected:
  ~numpunct() override;
  virtual char_type do_decimal_point() const;
  virtual char_type do_thousands_sep() const;
  virtual string do_grouping() const;
  virtual string_type do_truename() const;
  virtual string_type do_falsename() const;

  char_type __decimal_point_;
  char_type __thousands_sep_;
  string __grouping_;
};




template <class _CharT>
class numpunct_byname;

template <>
class __attribute__((__visibility__("default"))) numpunct_byname<char> : public numpunct<char> {
public:
  typedef char char_type;
  typedef basic_string<char_type> string_type;

  explicit numpunct_byname(const char* __nm, size_t __refs = 0);
  explicit numpunct_byname(const string& __nm, size_t __refs = 0);

protected:
  ~numpunct_byname() override;

private:
  void __init(const char*);
};


template <>
class __attribute__((__visibility__("default"))) numpunct_byname<wchar_t> : public numpunct<wchar_t> {
public:
  typedef wchar_t char_type;
  typedef basic_string<char_type> string_type;

  explicit numpunct_byname(const char* __nm, size_t __refs = 0);
  explicit numpunct_byname(const string& __nm, size_t __refs = 0);

protected:
  ~numpunct_byname() override;

private:
  void __init(const char*);
};


}}
# 203 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 2 3






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ios" 1 3
# 224 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ios" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__system_error/error_category.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__system_error/error_category.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

class __attribute__((__visibility__("default"))) error_condition;
class __attribute__((__visibility__("default"))) error_code;

class __attribute__((__visibility__("hidden"))) __do_message;

class __attribute__((__visibility__("default"))) error_category {
public:
  virtual ~error_category() throw();




  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) error_category() throw() = default;

  error_category(const error_category&) = delete;
  error_category& operator=(const error_category&) = delete;

  virtual const char* name() const throw() = 0;
  virtual error_condition default_error_condition(int __ev) const throw();
  virtual bool equivalent(int __code, const error_condition& __condition) const throw();
  virtual bool equivalent(const error_code& __code, int __condition) const throw();
  virtual string message(int __ev) const = 0;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const error_category& __rhs) const throw() { return this == &__rhs; }
# 56 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__system_error/error_category.h" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const error_category& __rhs) const throw() { return !(*this == __rhs); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<(const error_category& __rhs) const throw() { return this < &__rhs; }



  friend class __attribute__((__visibility__("hidden"))) __do_message;
};

class __attribute__((__visibility__("hidden"))) __do_message : public error_category {
public:
  string message(int __ev) const override;
};

__attribute__((__visibility__("default"))) const error_category& generic_category() throw();
__attribute__((__visibility__("default"))) const error_category& system_category() throw();

}}
# 225 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ios" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__system_error/error_code.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__system_error/error_code.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__system_error/error_condition.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__system_error/error_condition.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_error_condition_enum : public false_type {};






template <>
struct is_error_condition_enum<errc> : true_type {};


template <>
struct is_error_condition_enum<errc::__lx> : true_type {};


namespace __adl_only {


void make_error_condition() = delete;
}

class __attribute__((__visibility__("default"))) error_condition {
  int __val_;
  const error_category* __cat_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) error_condition() throw() : __val_(0), __cat_(&generic_category()) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) error_condition(int __val, const error_category& __cat) throw()
      : __val_(__val),
        __cat_(&__cat) {}

  template <class _Ep, __enable_if_t<is_error_condition_enum<_Ep>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) error_condition(_Ep __e) throw() {
    using __adl_only::make_error_condition;
    *this = make_error_condition(__e);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void assign(int __val, const error_category& __cat) throw() {
    __val_ = __val;
    __cat_ = &__cat;
  }

  template <class _Ep, __enable_if_t<is_error_condition_enum<_Ep>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) error_condition& operator=(_Ep __e) throw() {
    using __adl_only::make_error_condition;
    *this = make_error_condition(__e);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void clear() throw() {
    __val_ = 0;
    __cat_ = &generic_category();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int value() const throw() { return __val_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const error_category& category() const throw() { return *__cat_; }
  string message() const;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit operator bool() const throw() { return __val_ != 0; }
};

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) error_condition make_error_condition(errc __e) throw() {
  return error_condition(static_cast<int>(__e), generic_category());
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const error_condition& __x, const error_condition& __y) throw() {
  return __x.category() == __y.category() && __x.value() == __y.value();
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const error_condition& __x, const error_condition& __y) throw() {
  return !(__x == __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<(const error_condition& __x, const error_condition& __y) throw() {
  return __x.category() < __y.category() || (__x.category() == __y.category() && __x.value() < __y.value());
}
# 121 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__system_error/error_condition.h" 3
template <>
struct hash<error_condition> : public __unary_function<error_condition, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(const error_condition& __ec) const throw() {
    return static_cast<size_t>(__ec.value());
  }
};

}}
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__system_error/error_code.h" 2 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__system_error/error_code.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_error_code_enum : public false_type {};






namespace __adl_only {


void make_error_code() = delete;
}

class __attribute__((__visibility__("default"))) error_code {
  int __val_;
  const error_category* __cat_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) error_code() throw() : __val_(0), __cat_(&system_category()) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) error_code(int __val, const error_category& __cat) throw() : __val_(__val), __cat_(&__cat) {}

  template <class _Ep, __enable_if_t<is_error_code_enum<_Ep>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) error_code(_Ep __e) throw() {
    using __adl_only::make_error_code;
    *this = make_error_code(__e);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void assign(int __val, const error_category& __cat) throw() {
    __val_ = __val;
    __cat_ = &__cat;
  }

  template <class _Ep, __enable_if_t<is_error_code_enum<_Ep>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) error_code& operator=(_Ep __e) throw() {
    using __adl_only::make_error_code;
    *this = make_error_code(__e);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void clear() throw() {
    __val_ = 0;
    __cat_ = &system_category();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int value() const throw() { return __val_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const error_category& category() const throw() { return *__cat_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) error_condition default_error_condition() const throw() {
    return __cat_->default_error_condition(__val_);
  }

  string message() const;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit operator bool() const throw() { return __val_ != 0; }
};

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) error_code make_error_code(errc __e) throw() {
  return error_code(static_cast<int>(__e), generic_category());
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const error_code& __x, const error_code& __y) throw() {
  return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const error_code& __x, const error_condition& __y) throw() {
  return __x.category().equivalent(__x.value(), __y) || __y.category().equivalent(__x, __y.value());
}


inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const error_condition& __x, const error_code& __y) throw() {
  return __y == __x;
}




inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const error_code& __x, const error_code& __y) throw() {
  return !(__x == __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const error_code& __x, const error_condition& __y) throw() {
  return !(__x == __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const error_condition& __x, const error_code& __y) throw() {
  return !(__x == __y);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<(const error_code& __x, const error_code& __y) throw() {
  return __x.category() < __y.category() || (__x.category() == __y.category() && __x.value() < __y.value());
}
# 134 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__system_error/error_code.h" 3
template <>
struct hash<error_code> : public __unary_function<error_code, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(const error_code& __ec) const throw() {
    return static_cast<size_t>(__ec.value());
  }
};

}}
# 226 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ios" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__system_error/system_error.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__system_error/system_error.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

class __attribute__((__visibility__("default"))) system_error : public runtime_error {
  error_code __ec_;

public:
  system_error(error_code __ec, const string& __what_arg);
  system_error(error_code __ec, const char* __what_arg);
  system_error(error_code __ec);
  system_error(int __ev, const error_category& __ecat, const string& __what_arg);
  system_error(int __ev, const error_category& __ecat, const char* __what_arg);
  system_error(int __ev, const error_category& __ecat);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) system_error(const system_error&) throw() = default;
  ~system_error() throw() override;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const error_code& code() const throw() { return __ec_; }
};

__attribute__((__noreturn__)) __attribute__((__visibility__("default"))) void __throw_system_error(int __ev, const char* __what_arg);
__attribute__((__noreturn__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline void __throw_system_error(error_code __ec, const char* __what_arg) {

  throw system_error(__ec, __what_arg);




}

}}
# 228 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ios" 2 3
# 243 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ios" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 247 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ios" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

typedef ptrdiff_t streamsize;

class __attribute__((__visibility__("default"))) ios_base {
public:
  class __attribute__((__visibility__("default"))) failure;

  typedef unsigned int fmtflags;
  static const fmtflags boolalpha = 0x0001;
  static const fmtflags dec = 0x0002;
  static const fmtflags fixed = 0x0004;
  static const fmtflags hex = 0x0008;
  static const fmtflags internal = 0x0010;
  static const fmtflags left = 0x0020;
  static const fmtflags oct = 0x0040;
  static const fmtflags right = 0x0080;
  static const fmtflags scientific = 0x0100;
  static const fmtflags showbase = 0x0200;
  static const fmtflags showpoint = 0x0400;
  static const fmtflags showpos = 0x0800;
  static const fmtflags skipws = 0x1000;
  static const fmtflags unitbuf = 0x2000;
  static const fmtflags uppercase = 0x4000;
  static const fmtflags adjustfield = left | right | internal;
  static const fmtflags basefield = dec | oct | hex;
  static const fmtflags floatfield = scientific | fixed;

  typedef unsigned int iostate;
  static const iostate badbit = 0x1;
  static const iostate eofbit = 0x2;
  static const iostate failbit = 0x4;
  static const iostate goodbit = 0x0;

  typedef unsigned int openmode;
  static const openmode app = 0x01;
  static const openmode ate = 0x02;
  static const openmode binary = 0x04;
  static const openmode in = 0x08;
  static const openmode out = 0x10;
  static const openmode trunc = 0x20;




  enum seekdir { beg, cur, end };


  typedef iostate io_state;
  typedef openmode open_mode;
  typedef seekdir seek_dir;

  typedef std::streamoff streamoff;
  typedef std::streampos streampos;


  class __attribute__((__visibility__("default"))) Init;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) fmtflags flags() const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) fmtflags flags(fmtflags __fmtfl);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) fmtflags setf(fmtflags __fmtfl);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) fmtflags setf(fmtflags __fmtfl, fmtflags __mask);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void unsetf(fmtflags __mask);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) streamsize precision() const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) streamsize precision(streamsize __prec);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) streamsize width() const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) streamsize width(streamsize __wide);


  locale imbue(const locale& __loc);
  locale getloc() const;


  static int xalloc();
  long& iword(int __index);
  void*& pword(int __index);


  virtual ~ios_base();


  enum event { erase_event, imbue_event, copyfmt_event };
  typedef void (*event_callback)(event, ios_base&, int __index);
  void register_callback(event_callback __fn, int __index);

  ios_base(const ios_base&) = delete;
  ios_base& operator=(const ios_base&) = delete;

  static bool sync_with_stdio(bool __sync = true);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iostate rdstate() const;
  void clear(iostate __state = goodbit);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void setstate(iostate __state);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool good() const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool eof() const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool fail() const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool bad() const;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iostate exceptions() const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void exceptions(iostate __iostate);

  void __set_badbit_and_consider_rethrow();
  void __set_failbit_and_consider_rethrow();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __setstate_nothrow(iostate __state) {
    if (__rdbuf_)
      __rdstate_ |= __state;
    else
      __rdstate_ |= __state | ios_base::badbit;
  }

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ios_base() {
  }

  void init(void* __sb);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void* rdbuf() const { return __rdbuf_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void rdbuf(void* __sb) {
    __rdbuf_ = __sb;
    clear();
  }

  void __call_callbacks(event);
  void copyfmt(const ios_base&);
  void move(ios_base&);
  void swap(ios_base&) throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void set_rdbuf(void* __sb) { __rdbuf_ = __sb; }

private:

  fmtflags __fmtflags_;
  streamsize __precision_;
  streamsize __width_;
  iostate __rdstate_;
  iostate __exceptions_;
  void* __rdbuf_;
  void* __loc_;
  event_callback* __fn_;
  int* __index_;
  size_t __event_size_;
  size_t __event_cap_;



  static atomic<int> __xindex_;



  long* __iarray_;
  size_t __iarray_size_;
  size_t __iarray_cap_;
  void** __parray_;
  size_t __parray_size_;
  size_t __parray_cap_;
};


struct __attribute__((__visibility__("default"))) io_errc { enum __lx{stream = 1};
__lx __v_; __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) io_errc(__lx __v) : __v_(__v) {} __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit io_errc(int __v) : __v_(static_cast<__lx>(__v)) {} __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) operator int() const { return __v_; } };

template <>
struct is_error_code_enum<io_errc> : public true_type {};


template <>
struct is_error_code_enum<io_errc::__lx> : public true_type {};


__attribute__((__visibility__("default"))) const error_category& iostream_category() throw();

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) error_code make_error_code(io_errc __e) throw() {
  return error_code(static_cast<int>(__e), iostream_category());
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) error_condition make_error_condition(io_errc __e) throw() {
  return error_condition(static_cast<int>(__e), iostream_category());
}

class __attribute__((__visibility__("default"))) ios_base::failure : public system_error {
public:
  explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);
  explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) failure(const failure&) throw() = default;
  ~failure() throw() override;
};

__attribute__((__noreturn__)) inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __throw_failure(char const* __msg) {

  throw ios_base::failure(__msg);



}

class __attribute__((__visibility__("default"))) ios_base::Init {
public:
  Init();
  ~Init();
};



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ios_base::fmtflags ios_base::flags() const { return __fmtflags_; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ios_base::fmtflags ios_base::flags(fmtflags __fmtfl) {
  fmtflags __r = __fmtflags_;
  __fmtflags_ = __fmtfl;
  return __r;
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ios_base::fmtflags ios_base::setf(fmtflags __fmtfl) {
  fmtflags __r = __fmtflags_;
  __fmtflags_ |= __fmtfl;
  return __r;
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void ios_base::unsetf(fmtflags __mask) { __fmtflags_ &= ~__mask; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ios_base::fmtflags ios_base::setf(fmtflags __fmtfl, fmtflags __mask) {
  fmtflags __r = __fmtflags_;
  unsetf(__mask);
  __fmtflags_ |= __fmtfl & __mask;
  return __r;
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) streamsize ios_base::precision() const { return __precision_; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) streamsize ios_base::precision(streamsize __prec) {
  streamsize __r = __precision_;
  __precision_ = __prec;
  return __r;
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) streamsize ios_base::width() const { return __width_; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) streamsize ios_base::width(streamsize __wide) {
  streamsize __r = __width_;
  __width_ = __wide;
  return __r;
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ios_base::iostate ios_base::rdstate() const { return __rdstate_; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void ios_base::setstate(iostate __state) { clear(__rdstate_ | __state); }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool ios_base::good() const { return __rdstate_ == 0; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool ios_base::eof() const { return (__rdstate_ & eofbit) != 0; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool ios_base::fail() const { return (__rdstate_ & (failbit | badbit)) != 0; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool ios_base::bad() const { return (__rdstate_ & badbit) != 0; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ios_base::iostate ios_base::exceptions() const { return __exceptions_; }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void ios_base::exceptions(iostate __iostate) {
  __exceptions_ = __iostate;
  clear(__rdstate_);
}

template <class _CharT, class _Traits>
class basic_ios : public ios_base {
public:

  typedef _CharT char_type;
  typedef _Traits traits_type;

  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::pos_type pos_type;
  typedef typename traits_type::off_type off_type;

  _Static_assert((is_same<_CharT, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT");





  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) operator void*() const { return fail() ? __nullptr : (void*)this; }




  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!() const { return fail(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iostate rdstate() const { return ios_base::rdstate(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void clear(iostate __state = goodbit) { ios_base::clear(__state); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void setstate(iostate __state) { ios_base::setstate(__state); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool good() const { return ios_base::good(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool eof() const { return ios_base::eof(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool fail() const { return ios_base::fail(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool bad() const { return ios_base::bad(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iostate exceptions() const { return ios_base::exceptions(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void exceptions(iostate __iostate) { ios_base::exceptions(__iostate); }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit basic_ios(basic_streambuf<char_type, traits_type>* __sb);
  ~basic_ios() override;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<char_type, traits_type>* tie() const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_streambuf<char_type, traits_type>* rdbuf() const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);

  basic_ios& copyfmt(const basic_ios& __rhs);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type fill() const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type fill(char_type __ch);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) locale imbue(const locale& __loc);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char narrow(char_type __c, char __dfault) const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type widen(char __c) const;

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ios() {
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void init(basic_streambuf<char_type, traits_type>* __sb);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void move(basic_ios& __rhs);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void move(basic_ios&& __rhs) { move(__rhs); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(basic_ios& __rhs) throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);

private:
  basic_ostream<char_type, traits_type>* __tie_;
  mutable int_type __fill_;
};

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type, traits_type>* __sb) {
  init(__sb);
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>::~basic_ios() {}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void basic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb) {
  ios_base::init(__sb);
  __tie_ = __nullptr;
  __fill_ = traits_type::eof();
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<_CharT, _Traits>* basic_ios<_CharT, _Traits>::tie() const {
  return __tie_;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr) {
  basic_ostream<char_type, traits_type>* __r = __tie_;
  __tie_ = __tiestr;
  return __r;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_streambuf<_CharT, _Traits>* basic_ios<_CharT, _Traits>::rdbuf() const {
  return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb) {
  basic_streambuf<char_type, traits_type>* __r = rdbuf();
  ios_base::rdbuf(__sb);
  return __r;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) locale basic_ios<_CharT, _Traits>::imbue(const locale& __loc) {
  locale __r = getloc();
  ios_base::imbue(__loc);
  if (rdbuf())
    rdbuf()->pubimbue(__loc);
  return __r;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const {
  return std::use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _CharT basic_ios<_CharT, _Traits>::widen(char __c) const {
  return std::use_facet<ctype<char_type> >(getloc()).widen(__c);
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _CharT basic_ios<_CharT, _Traits>::fill() const {
  if (traits_type::eq_int_type(traits_type::eof(), __fill_))
    __fill_ = widen(' ');
  return __fill_;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _CharT basic_ios<_CharT, _Traits>::fill(char_type __ch) {
  if (traits_type::eq_int_type(traits_type::eof(), __fill_))
    __fill_ = widen(' ');
  char_type __r = __fill_;
  __fill_ = __ch;
  return __r;
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>& basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs) {
  if (this != &__rhs) {
    __call_callbacks(erase_event);
    ios_base::copyfmt(__rhs);
    __tie_ = __rhs.__tie_;
    __fill_ = __rhs.__fill_;
    __call_callbacks(copyfmt_event);
    exceptions(__rhs.exceptions());
  }
  return *this;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void basic_ios<_CharT, _Traits>::move(basic_ios& __rhs) {
  ios_base::move(__rhs);
  __tie_ = __rhs.__tie_;
  __rhs.__tie_ = __nullptr;
  __fill_ = __rhs.__fill_;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void basic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) throw() {
  ios_base::swap(__rhs);
  std::swap(__tie_, __rhs.__tie_);
  std::swap(__fill_, __rhs.__fill_);
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void basic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb) {
  ios_base::set_rdbuf(__sb);
}

extern template class __attribute__((__visibility__("default"))) basic_ios<char>;


extern template class __attribute__((__visibility__("default"))) basic_ios<wchar_t>;


__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& boolalpha(ios_base& __str) {
  __str.setf(ios_base::boolalpha);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& noboolalpha(ios_base& __str) {
  __str.unsetf(ios_base::boolalpha);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& showbase(ios_base& __str) {
  __str.setf(ios_base::showbase);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& noshowbase(ios_base& __str) {
  __str.unsetf(ios_base::showbase);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& showpoint(ios_base& __str) {
  __str.setf(ios_base::showpoint);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& noshowpoint(ios_base& __str) {
  __str.unsetf(ios_base::showpoint);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& showpos(ios_base& __str) {
  __str.setf(ios_base::showpos);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& noshowpos(ios_base& __str) {
  __str.unsetf(ios_base::showpos);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& skipws(ios_base& __str) {
  __str.setf(ios_base::skipws);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& noskipws(ios_base& __str) {
  __str.unsetf(ios_base::skipws);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& uppercase(ios_base& __str) {
  __str.setf(ios_base::uppercase);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& nouppercase(ios_base& __str) {
  __str.unsetf(ios_base::uppercase);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& unitbuf(ios_base& __str) {
  __str.setf(ios_base::unitbuf);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& nounitbuf(ios_base& __str) {
  __str.unsetf(ios_base::unitbuf);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& internal(ios_base& __str) {
  __str.setf(ios_base::internal, ios_base::adjustfield);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& left(ios_base& __str) {
  __str.setf(ios_base::left, ios_base::adjustfield);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& right(ios_base& __str) {
  __str.setf(ios_base::right, ios_base::adjustfield);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& dec(ios_base& __str) {
  __str.setf(ios_base::dec, ios_base::basefield);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& hex(ios_base& __str) {
  __str.setf(ios_base::hex, ios_base::basefield);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& oct(ios_base& __str) {
  __str.setf(ios_base::oct, ios_base::basefield);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& fixed(ios_base& __str) {
  __str.setf(ios_base::fixed, ios_base::floatfield);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& scientific(ios_base& __str) {
  __str.setf(ios_base::scientific, ios_base::floatfield);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& hexfloat(ios_base& __str) {
  __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
  return __str;
}

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline ios_base& defaultfloat(ios_base& __str) {
  __str.unsetf(ios_base::floatfield);
  return __str;
}

}}
# 836 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ios" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 1 3
# 192 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__condition_variable/condition_variable.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__condition_variable/condition_variable.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex/mutex.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex/mutex.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

class __attribute__((__visibility__("default"))) mutex {
  __libcpp_mutex_t __m_ = {0x32AAABA7, {0}};

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) mutex() = default;

  mutex(const mutex&) = delete;
  mutex& operator=(const mutex&) = delete;




  ~mutex() throw();


  void lock() ;
  bool try_lock() throw() ;
  void unlock() throw() ;

  typedef __libcpp_mutex_t* native_handle_type;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) native_handle_type native_handle() { return &__m_; }
};

_Static_assert(is_nothrow_default_constructible<mutex>::value, "the default constructor for std::mutex must be nothrow");

}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__condition_variable/condition_variable.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex/unique_lock.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex/unique_lock.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex/tag_types.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex/tag_types.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

struct __attribute__((__visibility__("default"))) defer_lock_t {
  explicit defer_lock_t() = default;
};

struct __attribute__((__visibility__("default"))) try_to_lock_t {
  explicit try_to_lock_t() = default;
};

struct __attribute__((__visibility__("default"))) adopt_lock_t {
  explicit adopt_lock_t() = default;
};
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex/tag_types.h" 3
}}
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex/unique_lock.h" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex/unique_lock.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Mutex>
class unique_lock {
public:
  typedef _Mutex mutex_type;

private:
  mutex_type* __m_;
  bool __owns_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_lock() throw() : __m_(__nullptr), __owns_(false) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit unique_lock(mutex_type& __m) : __m_(std::addressof(__m)), __owns_(true) {
    __m_->lock();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_lock(mutex_type& __m, defer_lock_t) throw()
      : __m_(std::addressof(__m)),
        __owns_(false) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_lock(mutex_type& __m, try_to_lock_t)
      : __m_(std::addressof(__m)), __owns_(__m.try_lock()) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_lock(mutex_type& __m, adopt_lock_t) : __m_(std::addressof(__m)), __owns_(true) {}

  template <class _Clock, class _Duration>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_lock(mutex_type& __m, const chrono::time_point<_Clock, _Duration>& __t)
      : __m_(std::addressof(__m)), __owns_(__m.try_lock_until(__t)) {}

  template <class _Rep, class _Period>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_lock(mutex_type& __m, const chrono::duration<_Rep, _Period>& __d)
      : __m_(std::addressof(__m)), __owns_(__m.try_lock_for(__d)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~unique_lock() {
    if (__owns_)
      __m_->unlock();
  }

  unique_lock(unique_lock const&) = delete;
  unique_lock& operator=(unique_lock const&) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_lock(unique_lock&& __u) throw() : __m_(__u.__m_), __owns_(__u.__owns_) {
    __u.__m_ = __nullptr;
    __u.__owns_ = false;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unique_lock& operator=(unique_lock&& __u) throw() {
    if (__owns_)
      __m_->unlock();

    __m_ = __u.__m_;
    __owns_ = __u.__owns_;
    __u.__m_ = __nullptr;
    __u.__owns_ = false;
    return *this;
  }

  void lock();
  bool try_lock();

  template <class _Rep, class _Period>
  bool try_lock_for(const chrono::duration<_Rep, _Period>& __d);

  template <class _Clock, class _Duration>
  bool try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);

  void unlock();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(unique_lock& __u) throw() {
    std::swap(__m_, __u.__m_);
    std::swap(__owns_, __u.__owns_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) mutex_type* release() throw() {
    mutex_type* __m = __m_;
    __m_ = __nullptr;
    __owns_ = false;
    return __m;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool owns_lock() const throw() { return __owns_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit operator bool() const throw() { return __owns_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) mutex_type* mutex() const throw() { return __m_; }
};
_Static_assert(true, "");

template <class _Mutex>
void unique_lock<_Mutex>::lock() {
  if (__m_ == __nullptr)
    __throw_system_error(1, "unique_lock::lock: references null mutex");
  if (__owns_)
    __throw_system_error(11, "unique_lock::lock: already locked");
  __m_->lock();
  __owns_ = true;
}

template <class _Mutex>
bool unique_lock<_Mutex>::try_lock() {
  if (__m_ == __nullptr)
    __throw_system_error(1, "unique_lock::try_lock: references null mutex");
  if (__owns_)
    __throw_system_error(11, "unique_lock::try_lock: already locked");
  __owns_ = __m_->try_lock();
  return __owns_;
}

template <class _Mutex>
template <class _Rep, class _Period>
bool unique_lock<_Mutex>::try_lock_for(const chrono::duration<_Rep, _Period>& __d) {
  if (__m_ == __nullptr)
    __throw_system_error(1, "unique_lock::try_lock_for: references null mutex");
  if (__owns_)
    __throw_system_error(11, "unique_lock::try_lock_for: already locked");
  __owns_ = __m_->try_lock_for(__d);
  return __owns_;
}

template <class _Mutex>
template <class _Clock, class _Duration>
bool unique_lock<_Mutex>::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t) {
  if (__m_ == __nullptr)
    __throw_system_error(1, "unique_lock::try_lock_until: references null mutex");
  if (__owns_)
    __throw_system_error(11, "unique_lock::try_lock_until: already locked");
  __owns_ = __m_->try_lock_until(__t);
  return __owns_;
}

template <class _Mutex>
void unique_lock<_Mutex>::unlock() {
  if (!__owns_)
    __throw_system_error(1, "unique_lock::unlock: not locked");
  __m_->unlock();
  __owns_ = false;
}

template <class _Mutex>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(unique_lock<_Mutex>& __x, unique_lock<_Mutex>& __y) throw() {
  __x.swap(__y);
}

}}
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__condition_variable/condition_variable.h" 2 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__condition_variable/condition_variable.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__condition_variable/condition_variable.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {




struct __attribute__((__visibility__("default"))) cv_status { enum __lx{no_timeout, timeout};
__lx __v_; __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) cv_status(__lx __v) : __v_(__v) {} __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit cv_status(int __v) : __v_(static_cast<__lx>(__v)) {} __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) operator int() const { return __v_; } };

class __attribute__((__visibility__("default"))) condition_variable {
  __libcpp_condvar_t __cv_ = {0x3CB0B1BB, {0}};

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) condition_variable() throw() = default;




  ~condition_variable();


  condition_variable(const condition_variable&) = delete;
  condition_variable& operator=(const condition_variable&) = delete;

  void notify_one() throw();
  void notify_all() throw();

  void wait(unique_lock<mutex>& __lk) throw();
  template <class _Predicate>
  inline __attribute__((__visibility__("hidden"))) void wait(unique_lock<mutex>& __lk, _Predicate __pred);

  template <class _Clock, class _Duration>
  inline __attribute__((__visibility__("hidden"))) cv_status
  wait_until(unique_lock<mutex>& __lk, const chrono::time_point<_Clock, _Duration>& __t);

  template <class _Clock, class _Duration, class _Predicate>
  inline __attribute__((__visibility__("hidden"))) bool
  wait_until(unique_lock<mutex>& __lk, const chrono::time_point<_Clock, _Duration>& __t, _Predicate __pred);

  template <class _Rep, class _Period>
  inline __attribute__((__visibility__("hidden"))) cv_status
  wait_for(unique_lock<mutex>& __lk, const chrono::duration<_Rep, _Period>& __d);

  template <class _Rep, class _Period, class _Predicate>
  bool __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  wait_for(unique_lock<mutex>& __lk, const chrono::duration<_Rep, _Period>& __d, _Predicate __pred);

  typedef __libcpp_condvar_t* native_handle_type;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) native_handle_type native_handle() { return &__cv_; }

private:
  void
  __do_timed_wait(unique_lock<mutex>& __lk, chrono::time_point<chrono::system_clock, chrono::nanoseconds>) throw();




  template <class _Clock>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __do_timed_wait(unique_lock<mutex>& __lk, chrono::time_point<_Clock, chrono::nanoseconds>) throw();
};


template <class _Rep, class _Period, __enable_if_t<is_floating_point<_Rep>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) chrono::nanoseconds __safe_nanosecond_cast(chrono::duration<_Rep, _Period> __d) {
  using namespace chrono;
  using __ratio = ratio_divide<_Period, nano>;
  using __ns_rep = nanoseconds::rep;
  _Rep __result_float = __d.count() * __ratio::num / __ratio::den;

  _Rep __result_max = numeric_limits<__ns_rep>::max();
  if (__result_float >= __result_max) {
    return nanoseconds::max();
  }

  _Rep __result_min = numeric_limits<__ns_rep>::min();
  if (__result_float <= __result_min) {
    return nanoseconds::min();
  }

  return nanoseconds(static_cast<__ns_rep>(__result_float));
}

template <class _Rep, class _Period, __enable_if_t<!is_floating_point<_Rep>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) chrono::nanoseconds __safe_nanosecond_cast(chrono::duration<_Rep, _Period> __d) {
  using namespace chrono;
  if (__d.count() == 0) {
    return nanoseconds(0);
  }

  using __ratio = ratio_divide<_Period, nano>;
  using __ns_rep = nanoseconds::rep;
  __ns_rep __result_max = numeric_limits<__ns_rep>::max();
  if (__d.count() > 0 && __d.count() > __result_max / __ratio::num) {
    return nanoseconds::max();
  }

  __ns_rep __result_min = numeric_limits<__ns_rep>::min();
  if (__d.count() < 0 && __d.count() < __result_min / __ratio::num) {
    return nanoseconds::min();
  }

  __ns_rep __result = __d.count() * __ratio::num / __ratio::den;
  if (__result == 0) {
    return nanoseconds(1);
  }

  return nanoseconds(__result);
}


template <class _Predicate>
void condition_variable::wait(unique_lock<mutex>& __lk, _Predicate __pred) {
  while (!__pred())
    wait(__lk);
}

template <class _Clock, class _Duration>
cv_status condition_variable::wait_until(unique_lock<mutex>& __lk, const chrono::time_point<_Clock, _Duration>& __t) {
  using namespace chrono;
  using __clock_tp_ns = time_point<_Clock, nanoseconds>;

  typename _Clock::time_point __now = _Clock::now();
  if (__t <= __now)
    return cv_status::timeout;

  __clock_tp_ns __t_ns = __clock_tp_ns(std::__safe_nanosecond_cast(__t.time_since_epoch()));

  __do_timed_wait(__lk, __t_ns);
  return _Clock::now() < __t ? cv_status::no_timeout : cv_status::timeout;
}

template <class _Clock, class _Duration, class _Predicate>
bool condition_variable::wait_until(
    unique_lock<mutex>& __lk, const chrono::time_point<_Clock, _Duration>& __t, _Predicate __pred) {
  while (!__pred()) {
    if (wait_until(__lk, __t) == cv_status::timeout)
      return __pred();
  }
  return true;
}

template <class _Rep, class _Period>
cv_status condition_variable::wait_for(unique_lock<mutex>& __lk, const chrono::duration<_Rep, _Period>& __d) {
  using namespace chrono;
  if (__d <= __d.zero())
    return cv_status::timeout;
  using __ns_rep = nanoseconds::rep;
  steady_clock::time_point __c_now = steady_clock::now();





  using __clock_tp_ns = time_point<system_clock, nanoseconds>;
  __ns_rep __now_count_ns = std::__safe_nanosecond_cast(system_clock::now().time_since_epoch()).count();


  __ns_rep __d_ns_count = std::__safe_nanosecond_cast(__d).count();

  if (__now_count_ns > numeric_limits<__ns_rep>::max() - __d_ns_count) {
    __do_timed_wait(__lk, __clock_tp_ns::max());
  } else {
    __do_timed_wait(__lk, __clock_tp_ns(nanoseconds(__now_count_ns + __d_ns_count)));
  }

  return steady_clock::now() - __c_now < __d ? cv_status::no_timeout : cv_status::timeout;
}

template <class _Rep, class _Period, class _Predicate>
inline bool
condition_variable::wait_for(unique_lock<mutex>& __lk, const chrono::duration<_Rep, _Period>& __d, _Predicate __pred) {
  return wait_until(__lk, chrono::steady_clock::now() + __d, std::move(__pred));
}
# 231 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__condition_variable/condition_variable.h" 3
template <class _Clock>
inline void condition_variable::__do_timed_wait(unique_lock<mutex>& __lk,
                                                chrono::time_point<_Clock, chrono::nanoseconds> __tp) throw() {
  wait_for(__lk, __tp - _Clock::now());
}



}}
# 193 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex/lock_guard.h" 1 3
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__mutex/lock_guard.h" 3




namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Mutex>
class lock_guard {
public:
  typedef _Mutex mutex_type;

private:
  mutex_type& __m_;

public:
                        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit lock_guard(mutex_type& __m)

      : __m_(__m) {
    __m_.lock();
  }

                        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) lock_guard(mutex_type& __m, adopt_lock_t)

      : __m_(__m) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~lock_guard() { __m_.unlock(); }

private:
  lock_guard(lock_guard const&) = delete;
  lock_guard& operator=(lock_guard const&) = delete;
};
_Static_assert(true, "");

}}
# 196 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 2 3




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__thread/id.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__thread/id.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {


class __attribute__((__visibility__("default"))) __thread_id;

namespace this_thread {

__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __thread_id get_id() throw();

}

template <>
struct hash<__thread_id>;

class __thread_id {



  __libcpp_thread_id __id_;

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
  __lt_impl(__thread_id __x, __thread_id __y) throw() {
    if (__x.__id_ == 0)
      return __y.__id_ != 0;
    if (__y.__id_ == 0)
      return false;
    return __libcpp_thread_id_less(__x.__id_, __y.__id_);
  }

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __thread_id() throw() : __id_(0) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __reset() { __id_ = 0; }

  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(__thread_id __x, __thread_id __y) throw();

  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<(__thread_id __x, __thread_id __y) throw();




  template <class _CharT, class _Traits>
  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<_CharT, _Traits>&
  operator<<(basic_ostream<_CharT, _Traits>& __os, __thread_id __id);

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __thread_id(__libcpp_thread_id __id) : __id_(__id) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend __libcpp_thread_id __get_underlying_id(const __thread_id __id) { return __id.__id_; }

  friend __thread_id this_thread::get_id() throw();
  friend class __attribute__((__visibility__("default"))) thread;
  friend struct hash<__thread_id>;
};

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(__thread_id __x, __thread_id __y) throw() {

  if (__x.__id_ == 0)
    return __y.__id_ == 0;
  if (__y.__id_ == 0)
    return false;
  return __libcpp_thread_id_equal(__x.__id_, __y.__id_);
}



inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(__thread_id __x, __thread_id __y) throw() { return !(__x == __y); }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<(__thread_id __x, __thread_id __y) throw() {
  return __thread_id::__lt_impl(__x.__id_, __y.__id_);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<=(__thread_id __x, __thread_id __y) throw() { return !(__y < __x); }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>(__thread_id __x, __thread_id __y) throw() { return __y < __x; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>=(__thread_id __x, __thread_id __y) throw() { return !(__x < __y); }
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__thread/id.h" 3
namespace this_thread {

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __thread_id get_id() throw() { return __libcpp_thread_get_current_id(); }

}



}}
# 201 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 2 3
# 212 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 216 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



class __attribute__((__visibility__("default"))) recursive_mutex {
  __libcpp_recursive_mutex_t __m_;

public:
  recursive_mutex();
  ~recursive_mutex();

  recursive_mutex(const recursive_mutex&) = delete;
  recursive_mutex& operator=(const recursive_mutex&) = delete;

  void lock();
  bool try_lock() throw();
  void unlock() throw();

  typedef __libcpp_recursive_mutex_t* native_handle_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) native_handle_type native_handle() { return &__m_; }
};

class __attribute__((__visibility__("default"))) timed_mutex {
  mutex __m_;
  condition_variable __cv_;
  bool __locked_;

public:
  timed_mutex();
  ~timed_mutex();

  timed_mutex(const timed_mutex&) = delete;
  timed_mutex& operator=(const timed_mutex&) = delete;

public:
  void lock();
  bool try_lock() throw();
  template <class _Rep, class _Period>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool try_lock_for(const chrono::duration<_Rep, _Period>& __d) {
    return try_lock_until(chrono::steady_clock::now() + __d);
  }
  template <class _Clock, class _Duration>
  inline __attribute__((__visibility__("hidden"))) bool
  try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);
  void unlock() throw();
};

template <class _Clock, class _Duration>
bool timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t) {
  using namespace chrono;
  unique_lock<mutex> __lk(__m_);
  bool __no_timeout = _Clock::now() < __t;
  while (__no_timeout && __locked_)
    __no_timeout = __cv_.wait_until(__lk, __t) == cv_status::no_timeout;
  if (!__locked_) {
    __locked_ = true;
    return true;
  }
  return false;
}

class __attribute__((__visibility__("default"))) recursive_timed_mutex {
  mutex __m_;
  condition_variable __cv_;
  size_t __count_;
  __thread_id __id_;

public:
  recursive_timed_mutex();
  ~recursive_timed_mutex();

  recursive_timed_mutex(const recursive_timed_mutex&) = delete;
  recursive_timed_mutex& operator=(const recursive_timed_mutex&) = delete;

  void lock();
  bool try_lock() throw();
  template <class _Rep, class _Period>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool try_lock_for(const chrono::duration<_Rep, _Period>& __d) {
    return try_lock_until(chrono::steady_clock::now() + __d);
  }
  template <class _Clock, class _Duration>
  inline __attribute__((__visibility__("hidden"))) bool
  try_lock_until(const chrono::time_point<_Clock, _Duration>& __t);
  void unlock() throw();
};

template <class _Clock, class _Duration>
bool recursive_timed_mutex::try_lock_until(const chrono::time_point<_Clock, _Duration>& __t) {
  using namespace chrono;
  __thread_id __id = this_thread::get_id();
  unique_lock<mutex> __lk(__m_);
  if (__id == __id_) {
    if (__count_ == numeric_limits<size_t>::max())
      return false;
    ++__count_;
    return true;
  }
  bool __no_timeout = _Clock::now() < __t;
  while (__no_timeout && __count_ != 0)
    __no_timeout = __cv_.wait_until(__lk, __t) == cv_status::no_timeout;
  if (__count_ == 0) {
    __count_ = 1;
    __id_ = __id;
    return true;
  }
  return false;
}

template <class _L0, class _L1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int try_lock(_L0& __l0, _L1& __l1) {
  unique_lock<_L0> __u0(__l0, try_to_lock_t());
  if (__u0.owns_lock()) {
    if (__l1.try_lock()) {
      __u0.release();
      return -1;
    } else
      return 1;
  }
  return 0;
}
# 357 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 3
template <class _L0, class _L1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void lock(_L0& __l0, _L1& __l1) {
  while (true) {
    {
      unique_lock<_L0> __u0(__l0);
      if (__l1.try_lock()) {
        __u0.release();
        break;
      }
    }
    __libcpp_thread_yield();
    {
      unique_lock<_L1> __u1(__l1);
      if (__l0.try_lock()) {
        __u1.release();
        break;
      }
    }
    __libcpp_thread_yield();
  }
}
# 512 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 3
}}
# 526 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/system_error" 1 3
# 163 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/system_error" 3
# 527 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/mutex" 2 3
# 837 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ios" 2 3
# 210 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/streambuf" 1 3
# 120 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/streambuf" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 124 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/streambuf" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT, class _Traits>
class basic_streambuf {
public:

  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::pos_type pos_type;
  typedef typename traits_type::off_type off_type;

  _Static_assert((is_same<_CharT, typename traits_type::char_type>::value), "traits_type::char_type must be the same type as CharT");


  virtual ~basic_streambuf();


  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) locale pubimbue(const locale& __loc) {
    imbue(__loc);
    locale __r = __loc_;
    __loc_ = __loc;
    return __r;
  }

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) locale getloc() const { return __loc_; }


  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_streambuf* pubsetbuf(char_type* __s, streamsize __n) {
    return setbuf(__s, __n);
  }

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pos_type
  pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __which = ios_base::in | ios_base::out) {
    return seekoff(__off, __way, __which);
  }

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pos_type
  pubseekpos(pos_type __sp, ios_base::openmode __which = ios_base::in | ios_base::out) {
    return seekpos(__sp, __which);
  }

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int pubsync() { return sync(); }



  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) streamsize in_avail() {
    if (__ninp_ < __einp_)
      return static_cast<streamsize>(__einp_ - __ninp_);
    return showmanyc();
  }

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type snextc() {
    if (sbumpc() == traits_type::eof())
      return traits_type::eof();
    return sgetc();
  }

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type sbumpc() {
    if (__ninp_ == __einp_)
      return uflow();
    return traits_type::to_int_type(*__ninp_++);
  }

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type sgetc() {
    if (__ninp_ == __einp_)
      return underflow();
    return traits_type::to_int_type(*__ninp_);
  }

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) streamsize sgetn(char_type* __s, streamsize __n) { return xsgetn(__s, __n); }


  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type sputbackc(char_type __c) {
    if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))
      return pbackfail(traits_type::to_int_type(__c));
    return traits_type::to_int_type(*--__ninp_);
  }

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type sungetc() {
    if (__binp_ == __ninp_)
      return pbackfail();
    return traits_type::to_int_type(*--__ninp_);
  }


  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int_type sputc(char_type __c) {
    if (__nout_ == __eout_)
      return overflow(traits_type::to_int_type(__c));
    *__nout_++ = __c;
    return traits_type::to_int_type(__c);
  }

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) streamsize sputn(const char_type* __s, streamsize __n) {
    return xsputn(__s, __n);
  }

protected:
  basic_streambuf();
  basic_streambuf(const basic_streambuf& __rhs);
  basic_streambuf& operator=(const basic_streambuf& __rhs);
  void swap(basic_streambuf& __rhs);


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type* eback() const { return __binp_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type* gptr() const { return __ninp_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type* egptr() const { return __einp_; }

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void gbump(int __n) { __ninp_ += __n; }

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend) {
    __binp_ = __gbeg;
    __ninp_ = __gnext;
    __einp_ = __gend;
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type* pbase() const { return __bout_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type* pptr() const { return __nout_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type* epptr() const { return __eout_; }

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void pbump(int __n) { __nout_ += __n; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __pbump(streamsize __n) { __nout_ += __n; }

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void setp(char_type* __pbeg, char_type* __pend) {
    __bout_ = __nout_ = __pbeg;
    __eout_ = __pend;
  }



  virtual void imbue(const locale& __loc);


  virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);
  virtual pos_type
  seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __which = ios_base::in | ios_base::out);
  virtual pos_type seekpos(pos_type __sp, ios_base::openmode __which = ios_base::in | ios_base::out);
  virtual int sync();


  virtual streamsize showmanyc();
  virtual streamsize xsgetn(char_type* __s, streamsize __n);
  virtual int_type underflow();
  virtual int_type uflow();


  virtual int_type pbackfail(int_type __c = traits_type::eof());


  virtual streamsize xsputn(const char_type* __s, streamsize __n);
  virtual int_type overflow(int_type __c = traits_type::eof());

private:
  locale __loc_;
  char_type* __binp_;
  char_type* __ninp_;
  char_type* __einp_;
  char_type* __bout_;
  char_type* __nout_;
  char_type* __eout_;
};

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::~basic_streambuf() {}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf()
    : __binp_(__nullptr), __ninp_(__nullptr), __einp_(__nullptr), __bout_(__nullptr), __nout_(__nullptr), __eout_(__nullptr) {}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)
    : __loc_(__sb.__loc_),
      __binp_(__sb.__binp_),
      __ninp_(__sb.__ninp_),
      __einp_(__sb.__einp_),
      __bout_(__sb.__bout_),
      __nout_(__sb.__nout_),
      __eout_(__sb.__eout_) {}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>& basic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb) {
  __loc_ = __sb.__loc_;
  __binp_ = __sb.__binp_;
  __ninp_ = __sb.__ninp_;
  __einp_ = __sb.__einp_;
  __bout_ = __sb.__bout_;
  __nout_ = __sb.__nout_;
  __eout_ = __sb.__eout_;
  return *this;
}

template <class _CharT, class _Traits>
void basic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb) {
  std::swap(__loc_, __sb.__loc_);
  std::swap(__binp_, __sb.__binp_);
  std::swap(__ninp_, __sb.__ninp_);
  std::swap(__einp_, __sb.__einp_);
  std::swap(__bout_, __sb.__bout_);
  std::swap(__nout_, __sb.__nout_);
  std::swap(__eout_, __sb.__eout_);
}

template <class _CharT, class _Traits>
void basic_streambuf<_CharT, _Traits>::imbue(const locale&) {}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>* basic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize) {
  return this;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir, ios_base::openmode) {
  return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode) {
  return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
int basic_streambuf<_CharT, _Traits>::sync() {
  return 0;
}

template <class _CharT, class _Traits>
streamsize basic_streambuf<_CharT, _Traits>::showmanyc() {
  return 0;
}

template <class _CharT, class _Traits>
streamsize basic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n) {
  const int_type __eof = traits_type::eof();
  int_type __c;
  streamsize __i = 0;
  while (__i < __n) {
    if (__ninp_ < __einp_) {
      const streamsize __len = std::min(static_cast<streamsize>(2147483647), std::min(__einp_ - __ninp_, __n - __i));
      traits_type::copy(__s, __ninp_, __len);
      __s += __len;
      __i += __len;
      this->gbump(__len);
    } else if ((__c = uflow()) != __eof) {
      *__s = traits_type::to_char_type(__c);
      ++__s;
      ++__i;
    } else
      break;
  }
  return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type basic_streambuf<_CharT, _Traits>::underflow() {
  return traits_type::eof();
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type basic_streambuf<_CharT, _Traits>::uflow() {
  if (underflow() == traits_type::eof())
    return traits_type::eof();
  return traits_type::to_int_type(*__ninp_++);
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type basic_streambuf<_CharT, _Traits>::pbackfail(int_type) {
  return traits_type::eof();
}

template <class _CharT, class _Traits>
streamsize basic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n) {
  streamsize __i = 0;
  int_type __eof = traits_type::eof();
  while (__i < __n) {
    if (__nout_ >= __eout_) {
      if (overflow(traits_type::to_int_type(*__s)) == __eof)
        break;
      ++__s;
      ++__i;
    } else {
      streamsize __chunk_size = std::min(__eout_ - __nout_, __n - __i);
      traits_type::copy(__nout_, __s, __chunk_size);
      __nout_ += __chunk_size;
      __s += __chunk_size;
      __i += __chunk_size;
    }
  }
  return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type basic_streambuf<_CharT, _Traits>::overflow(int_type) {
  return traits_type::eof();
}

extern template class __attribute__((__visibility__("default"))) basic_streambuf<char>;


extern template class __attribute__((__visibility__("default"))) basic_streambuf<wchar_t>;


}}
# 213 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 2 3
# 222 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/nl_types.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/nl_types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 1 3 4
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_char.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_char.h" 3 4
typedef unsigned char u_char;
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_short.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_short.h" 3 4
typedef unsigned short u_short;
# 86 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int.h" 3 4
typedef unsigned int u_int;
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4

typedef unsigned long u_long;


typedef unsigned short ushort;

typedef unsigned int uint;




typedef u_int64_t u_quad_t;
typedef int64_t quad_t;
typedef quad_t * qaddr_t;

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_caddr_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_caddr_t.h" 3 4
typedef char * caddr_t;
# 103 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4

typedef int32_t daddr_t;



typedef u_int32_t fixpt_t;

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_blkcnt_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_blkcnt_t.h" 3 4
typedef __darwin_blkcnt_t blkcnt_t;
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_blksize_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_blksize_t.h" 3 4
typedef __darwin_blksize_t blksize_t;
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_gid_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_gid_t.h" 3 4
typedef __darwin_gid_t gid_t;
# 113 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_addr_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_addr_t.h" 3 4
typedef __uint32_t in_addr_t;
# 114 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_port_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_port_t.h" 3 4
typedef __uint16_t in_port_t;
# 115 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ino_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ino_t.h" 3 4
typedef __darwin_ino_t ino_t;
# 116 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ino64_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_ino64_t.h" 3 4
typedef __darwin_ino64_t ino64_t;
# 119 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_key_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_key_t.h" 3 4
typedef __int32_t key_t;
# 122 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_nlink_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_nlink_t.h" 3 4
typedef __uint16_t nlink_t;
# 124 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4




typedef int32_t segsz_t;
typedef int32_t swblk_t;
# 141 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 3 4
static inline __int32_t
major(__uint32_t _x)
{
 return (__int32_t)(((__uint32_t)_x >> 24) & 0xff);
}

static inline __int32_t
minor(__uint32_t _x)
{
 return (__int32_t)((_x) & 0xffffff);
}

static inline dev_t
makedev(__uint32_t _major, __uint32_t _minor)
{
 return (dev_t)(((_major) << 24) | (_minor));
}
# 169 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 170 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_useconds_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_useconds_t.h" 3 4
typedef __darwin_useconds_t useconds_t;
# 174 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_suseconds_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_suseconds_t.h" 3 4
typedef __darwin_suseconds_t suseconds_t;
# 175 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_rsize_t.h" 1 3 4
# 178 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 187 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_def.h" 1 3 4
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_def.h" 3 4
extern "C" {
typedef struct fd_set {
 __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;

int __darwin_check_fd_set_overflow(int, const void *, int) __attribute__((availability(macos,introduced=11.0))) __attribute__((availability(ios,introduced=14.0))) __attribute__((availability(tvos,introduced=14.0))) __attribute__((availability(watchos,introduced=7.0)));
}

inline __attribute__ ((__always_inline__)) int
__darwin_check_fd_set(int _a, const void *_b)
{

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunguarded-availability-new"

 if ((uintptr_t)&__darwin_check_fd_set_overflow != (uintptr_t) 0) {



  return __darwin_check_fd_set_overflow(_a, _b, 0);

 } else {
  return 1;
 }

#pragma clang diagnostic pop

}


inline __attribute__ ((__always_inline__)) int
__darwin_fd_isset(int _fd, const struct fd_set *_p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  return _p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] & ((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8))));
 }

 return 0;
}

inline __attribute__ ((__always_inline__)) void
__darwin_fd_set(int _fd, struct fd_set *const _p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  (_p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] |= ((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8)))));
 }
}

inline __attribute__ ((__always_inline__)) void
__darwin_fd_clr(int _fd, struct fd_set *const _p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  (_p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] &= ~((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8)))));
 }
}
# 188 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4




typedef __int32_t fd_mask;







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_setsize.h" 1 3 4
# 201 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_set.h" 1 3 4
# 202 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_clr.h" 1 3 4
# 203 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_zero.h" 1 3 4
# 204 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_isset.h" 1 3 4
# 205 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_copy.h" 1 3 4
# 208 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 235 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsblkcnt_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsblkcnt_t.h" 3 4
typedef __darwin_fsblkcnt_t fsblkcnt_t;
# 236 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsfilcnt_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsfilcnt_t.h" 3 4
typedef __darwin_fsfilcnt_t fsfilcnt_t;
# 237 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/nl_types.h" 2 3 4
# 89 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/nl_types.h" 3 4
typedef struct __nl_cat_d {
 void *__data;
 int __size;
} *nl_catd;

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_nl_item.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_types/_nl_item.h" 3 4
typedef __darwin_nl_item nl_item;
# 95 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/nl_types.h" 2 3 4

extern "C" {
nl_catd catopen(const char *, int);
char *catgets(nl_catd, int, int, const char *)
 __attribute__((__format_arg__(4)));
int catclose(nl_catd);
}
# 223 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 2 3




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale_dir/locale_base_api/bsd_locale_defaults.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__locale_dir/locale_base_api/bsd_locale_defaults.h" 3
# 228 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 2 3
# 234 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 238 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 270 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
template <class _InputIterator, class _ForwardIterator, class _Ctype>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ForwardIterator __scan_keyword(
    _InputIterator& __b,
    _InputIterator __e,
    _ForwardIterator __kb,
    _ForwardIterator __ke,
    const _Ctype& __ct,
    ios_base::iostate& __err,
    bool __case_sensitive = true) {
  typedef typename iterator_traits<_InputIterator>::value_type _CharT;
  size_t __nkw = static_cast<size_t>(std::distance(__kb, __ke));
  const unsigned char __doesnt_match = '\0';
  const unsigned char __might_match = '\1';
  const unsigned char __does_match = '\2';
  unsigned char __statbuf[100];
  unsigned char* __status = __statbuf;
  unique_ptr<unsigned char, void (*)(void*)> __stat_hold(__nullptr, free);
  if (__nkw > sizeof(__statbuf)) {
    __status = (unsigned char*)malloc(__nkw);
    if (__status == __nullptr)
      __throw_bad_alloc();
    __stat_hold.reset(__status);
  }
  size_t __n_might_match = __nkw;
  size_t __n_does_match = 0;

  unsigned char* __st = __status;
  for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void)++__st) {
    if (!__ky->empty())
      *__st = __might_match;
    else {
      *__st = __does_match;
      --__n_might_match;
      ++__n_does_match;
    }
  }

  for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx) {

    _CharT __c = *__b;
    if (!__case_sensitive)
      __c = __ct.toupper(__c);
    bool __consume = false;






    __st = __status;
    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void)++__st) {
      if (*__st == __might_match) {
        _CharT __kc = (*__ky)[__indx];
        if (!__case_sensitive)
          __kc = __ct.toupper(__kc);
        if (__c == __kc) {
          __consume = true;
          if (__ky->size() == __indx + 1) {
            *__st = __does_match;
            --__n_might_match;
            ++__n_does_match;
          }
        } else {
          *__st = __doesnt_match;
          --__n_might_match;
        }
      }
    }

    if (__consume) {
      ++__b;



      if (__n_might_match + __n_does_match > 1) {
        __st = __status;
        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void)++__st) {
          if (*__st == __does_match && __ky->size() != __indx + 1) {
            *__st = __doesnt_match;
            --__n_does_match;
          }
        }
      }
    }
  }

  if (__b == __e)
    __err |= ios_base::eofbit;

  for (__st = __status; __kb != __ke; ++__kb, (void)++__st)
    if (*__st == __does_match)
      break;
  if (__kb == __ke)
    __err |= ios_base::failbit;
  return __kb;
}

struct __attribute__((__visibility__("default"))) __num_get_base {
  static const int __num_get_buf_sz = 40;

  static int __get_base(ios_base&);
  static const char __src[33];
};

__attribute__((__visibility__("default"))) void
__check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end, ios_base::iostate& __err);

template <class _CharT>
struct __num_get : protected __num_get_base {
  static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point, _CharT& __thousands_sep);

  static int __stage2_float_loop(
      _CharT __ct,
      bool& __in_units,
      char& __exp,
      char* __a,
      char*& __a_end,
      _CharT __decimal_point,
      _CharT __thousands_sep,
      const string& __grouping,
      unsigned* __g,
      unsigned*& __g_end,
      unsigned& __dc,
      _CharT* __atoms);

  static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);
  static int __stage2_int_loop(
      _CharT __ct,
      int __base,
      char* __a,
      char*& __a_end,
      unsigned& __dc,
      _CharT __thousands_sep,
      const string& __grouping,
      unsigned* __g,
      unsigned*& __g_end,
      _CharT* __atoms);
# 444 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
};


template <class _CharT>
string __num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep) {
  locale __loc = __iob.getloc();
  std::use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);
  const numpunct<_CharT>& __np = std::use_facet<numpunct<_CharT> >(__loc);
  __thousands_sep = __np.thousands_sep();
  return __np.grouping();
}


template <class _CharT>
string __num_get<_CharT>::__stage2_float_prep(
    ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point, _CharT& __thousands_sep) {
  locale __loc = __iob.getloc();
  std::use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);
  const numpunct<_CharT>& __np = std::use_facet<numpunct<_CharT> >(__loc);
  __decimal_point = __np.decimal_point();
  __thousands_sep = __np.thousands_sep();
  return __np.grouping();
}

template <class _CharT>
int

__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,
                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,
                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)






{
  if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25])) {
    *__a_end++ = __ct == __atoms[24] ? '+' : '-';
    __dc = 0;
    return 0;
  }
  if (__grouping.size() != 0 && __ct == __thousands_sep) {
    if (__g_end - __g < __num_get_buf_sz) {
      *__g_end++ = __dc;
      __dc = 0;
    }
    return 0;
  }
  ptrdiff_t __f = std::find(__atoms, __atoms + 26, __ct) - __atoms;
  if (__f >= 24)
    return -1;
  switch (__base) {
  case 8:
  case 10:
    if (__f >= __base)
      return -1;
    break;
  case 16:
    if (__f < 22)
      break;
    if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0') {
      __dc = 0;
      *__a_end++ = __src[__f];
      return 0;
    }
    return -1;
  }
  *__a_end++ = __src[__f];
  ++__dc;
  return 0;
}

template <class _CharT>
int __num_get<_CharT>::__stage2_float_loop(
    _CharT __ct,
    bool& __in_units,
    char& __exp,
    char* __a,
    char*& __a_end,
    _CharT __decimal_point,
    _CharT __thousands_sep,
    const string& __grouping,
    unsigned* __g,
    unsigned*& __g_end,
    unsigned& __dc,
    _CharT* __atoms) {
  if (__ct == __decimal_point) {
    if (!__in_units)
      return -1;
    __in_units = false;
    *__a_end++ = '.';
    if (__grouping.size() != 0 && __g_end - __g < __num_get_buf_sz)
      *__g_end++ = __dc;
    return 0;
  }
  if (__ct == __thousands_sep && __grouping.size() != 0) {
    if (!__in_units)
      return -1;
    if (__g_end - __g < __num_get_buf_sz) {
      *__g_end++ = __dc;
      __dc = 0;
    }
    return 0;
  }
  ptrdiff_t __f = std::find(__atoms, __atoms + 32, __ct) - __atoms;
  if (__f >= 32)
    return -1;
  char __x = __src[__f];
  if (__x == '-' || __x == '+') {
    if (__a_end == __a || (std::toupper(__a_end[-1]) == std::toupper(__exp))) {
      *__a_end++ = __x;
      return 0;
    }
    return -1;
  }
  if (__x == 'x' || __x == 'X')
    __exp = 'P';
  else if (std::toupper(__x) == __exp) {
    __exp = std::tolower(__exp);
    if (__in_units) {
      __in_units = false;
      if (__grouping.size() != 0 && __g_end - __g < __num_get_buf_sz)
        *__g_end++ = __dc;
    }
  }
  *__a_end++ = __x;
  if (__f >= 22)
    return 0;
  ++__dc;
  return 0;
}

extern template struct __attribute__((__visibility__("default"))) __num_get<char>;

extern template struct __attribute__((__visibility__("default"))) __num_get<wchar_t>;


template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class num_get : public locale::facet, private __num_get<_CharT> {
public:
  typedef _CharT char_type;
  typedef _InputIterator iter_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit num_get(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, bool& __v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, long& __v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, long long& __v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, unsigned short& __v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, unsigned int& __v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, unsigned long& __v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, unsigned long long& __v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, float& __v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, double& __v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, long double& __v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, void*& __v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  static locale::id id;

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~num_get() override {}

  template <class _Fp>
  inline __attribute__((__visibility__("hidden"))) iter_type
  __do_get_floating_point(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, _Fp& __v) const;

  template <class _Signed>
  inline __attribute__((__visibility__("hidden"))) iter_type
  __do_get_signed(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, _Signed& __v) const;

  template <class _Unsigned>
  inline __attribute__((__visibility__("hidden"))) iter_type
  __do_get_unsigned(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, _Unsigned& __v) const;

  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, bool& __v) const;

  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, long& __v) const {
    return this->__do_get_signed(__b, __e, __iob, __err, __v);
  }

  virtual iter_type
  do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, long long& __v) const {
    return this->__do_get_signed(__b, __e, __iob, __err, __v);
  }

  virtual iter_type
  do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, unsigned short& __v) const {
    return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
  }

  virtual iter_type
  do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, unsigned int& __v) const {
    return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
  }

  virtual iter_type
  do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, unsigned long& __v) const {
    return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
  }

  virtual iter_type
  do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, unsigned long long& __v) const {
    return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
  }

  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, float& __v) const {
    return this->__do_get_floating_point(__b, __e, __iob, __err, __v);
  }

  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, double& __v) const {
    return this->__do_get_floating_point(__b, __e, __iob, __err, __v);
  }

  virtual iter_type
  do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, long double& __v) const {
    return this->__do_get_floating_point(__b, __e, __iob, __err, __v);
  }

  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, void*& __v) const;
};

template <class _CharT, class _InputIterator>
locale::id num_get<_CharT, _InputIterator>::id;

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
__num_get_signed_integral(const char* __a, const char* __a_end, ios_base::iostate& __err, int __base) {
  if (__a != __a_end) {
    __libcpp_remove_reference_t<__decltype((*__error()))> __save_errno = (*__error());
    (*__error()) = 0;
    char* __p2;
    long long __ll = strtoll_l(__a, &__p2, __base, 0);
    __libcpp_remove_reference_t<__decltype((*__error()))> __current_errno = (*__error());
    if (__current_errno == 0)
      (*__error()) = __save_errno;
    if (__p2 != __a_end) {
      __err = ios_base::failbit;
      return 0;
    } else if (__current_errno == 34 || __ll < numeric_limits<_Tp>::min() || numeric_limits<_Tp>::max() < __ll) {
      __err = ios_base::failbit;
      if (__ll > 0)
        return numeric_limits<_Tp>::max();
      else
        return numeric_limits<_Tp>::min();
    }
    return static_cast<_Tp>(__ll);
  }
  __err = ios_base::failbit;
  return 0;
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp
__num_get_unsigned_integral(const char* __a, const char* __a_end, ios_base::iostate& __err, int __base) {
  if (__a != __a_end) {
    const bool __negate = *__a == '-';
    if (__negate && ++__a == __a_end) {
      __err = ios_base::failbit;
      return 0;
    }
    __libcpp_remove_reference_t<__decltype((*__error()))> __save_errno = (*__error());
    (*__error()) = 0;
    char* __p2;
    unsigned long long __ll = strtoull_l(__a, &__p2, __base, 0);
    __libcpp_remove_reference_t<__decltype((*__error()))> __current_errno = (*__error());
    if (__current_errno == 0)
      (*__error()) = __save_errno;
    if (__p2 != __a_end) {
      __err = ios_base::failbit;
      return 0;
    } else if (__current_errno == 34 || numeric_limits<_Tp>::max() < __ll) {
      __err = ios_base::failbit;
      return numeric_limits<_Tp>::max();
    }
    _Tp __res = static_cast<_Tp>(__ll);
    if (__negate)
      __res = -__res;
    return __res;
  }
  __err = ios_base::failbit;
  return 0;
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp __do_strtod(const char* __a, char** __p2);

template <>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float __do_strtod<float>(const char* __a, char** __p2) {
  return strtof_l(__a, __p2, 0);
}

template <>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) double __do_strtod<double>(const char* __a, char** __p2) {
  return strtod_l(__a, __p2, 0);
}

template <>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) long double __do_strtod<long double>(const char* __a, char** __p2) {
  return strtold_l(__a, __p2, 0);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp __num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err) {
  if (__a != __a_end) {
    __libcpp_remove_reference_t<__decltype((*__error()))> __save_errno = (*__error());
    (*__error()) = 0;
    char* __p2;
    _Tp __ld = std::__do_strtod<_Tp>(__a, &__p2);
    __libcpp_remove_reference_t<__decltype((*__error()))> __current_errno = (*__error());
    if (__current_errno == 0)
      (*__error()) = __save_errno;
    if (__p2 != __a_end) {
      __err = ios_base::failbit;
      return 0;
    } else if (__current_errno == 34)
      __err = ios_base::failbit;
    return __ld;
  }
  __err = ios_base::failbit;
  return 0;
}

template <class _CharT, class _InputIterator>
_InputIterator num_get<_CharT, _InputIterator>::do_get(
    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, bool& __v) const {
  if ((__iob.flags() & ios_base::boolalpha) == 0) {
    long __lv = -1;
    __b = do_get(__b, __e, __iob, __err, __lv);
    switch (__lv) {
    case 0:
      __v = false;
      break;
    case 1:
      __v = true;
      break;
    default:
      __v = true;
      __err = ios_base::failbit;
      break;
    }
    return __b;
  }
  const ctype<_CharT>& __ct = std::use_facet<ctype<_CharT> >(__iob.getloc());
  const numpunct<_CharT>& __np = std::use_facet<numpunct<_CharT> >(__iob.getloc());
  typedef typename numpunct<_CharT>::string_type string_type;
  const string_type __names[2] = {__np.truename(), __np.falsename()};
  const string_type* __i = std::__scan_keyword(__b, __e, __names, __names + 2, __ct, __err);
  __v = __i == __names;
  return __b;
}



template <class _CharT, class _InputIterator>
template <class _Signed>
_InputIterator num_get<_CharT, _InputIterator>::__do_get_signed(
    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, _Signed& __v) const {

  int __base = this->__get_base(__iob);

  char_type __thousands_sep;
  const int __atoms_size = 26;





  char_type __atoms[__atoms_size];
  string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);

  string __buf;
  __buf.resize(__buf.capacity());
  char* __a = &__buf[0];
  char* __a_end = __a;
  unsigned __g[__num_get_base::__num_get_buf_sz];
  unsigned* __g_end = __g;
  unsigned __dc = 0;
  for (; __b != __e; ++__b) {
    if (__a_end == __a + __buf.size()) {
      size_t __tmp = __buf.size();
      __buf.resize(2 * __buf.size());
      __buf.resize(__buf.capacity());
      __a = &__buf[0];
      __a_end = __a + __tmp;
    }
    if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc, __thousands_sep, __grouping, __g, __g_end, __atoms))
      break;
  }
  if (__grouping.size() != 0 && __g_end - __g < __num_get_base::__num_get_buf_sz)
    *__g_end++ = __dc;

  __v = std::__num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);

  __check_grouping(__grouping, __g, __g_end, __err);

  if (__b == __e)
    __err |= ios_base::eofbit;
  return __b;
}



template <class _CharT, class _InputIterator>
template <class _Unsigned>
_InputIterator num_get<_CharT, _InputIterator>::__do_get_unsigned(
    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, _Unsigned& __v) const {

  int __base = this->__get_base(__iob);

  char_type __thousands_sep;
  const int __atoms_size = 26;





  char_type __atoms[__atoms_size];
  string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);

  string __buf;
  __buf.resize(__buf.capacity());
  char* __a = &__buf[0];
  char* __a_end = __a;
  unsigned __g[__num_get_base::__num_get_buf_sz];
  unsigned* __g_end = __g;
  unsigned __dc = 0;
  for (; __b != __e; ++__b) {
    if (__a_end == __a + __buf.size()) {
      size_t __tmp = __buf.size();
      __buf.resize(2 * __buf.size());
      __buf.resize(__buf.capacity());
      __a = &__buf[0];
      __a_end = __a + __tmp;
    }
    if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc, __thousands_sep, __grouping, __g, __g_end, __atoms))
      break;
  }
  if (__grouping.size() != 0 && __g_end - __g < __num_get_base::__num_get_buf_sz)
    *__g_end++ = __dc;

  __v = std::__num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);

  __check_grouping(__grouping, __g, __g_end, __err);

  if (__b == __e)
    __err |= ios_base::eofbit;
  return __b;
}



template <class _CharT, class _InputIterator>
template <class _Fp>
_InputIterator num_get<_CharT, _InputIterator>::__do_get_floating_point(
    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, _Fp& __v) const {


  char_type __atoms[32];
  char_type __decimal_point;
  char_type __thousands_sep;
  string __grouping = this->__stage2_float_prep(__iob, __atoms, __decimal_point, __thousands_sep);
  string __buf;
  __buf.resize(__buf.capacity());
  char* __a = &__buf[0];
  char* __a_end = __a;
  unsigned __g[__num_get_base::__num_get_buf_sz];
  unsigned* __g_end = __g;
  unsigned __dc = 0;
  bool __in_units = true;
  char __exp = 'E';
  for (; __b != __e; ++__b) {
    if (__a_end == __a + __buf.size()) {
      size_t __tmp = __buf.size();
      __buf.resize(2 * __buf.size());
      __buf.resize(__buf.capacity());
      __a = &__buf[0];
      __a_end = __a + __tmp;
    }
    if (this->__stage2_float_loop(
            *__b,
            __in_units,
            __exp,
            __a,
            __a_end,
            __decimal_point,
            __thousands_sep,
            __grouping,
            __g,
            __g_end,
            __dc,
            __atoms))
      break;
  }
  if (__grouping.size() != 0 && __in_units && __g_end - __g < __num_get_base::__num_get_buf_sz)
    *__g_end++ = __dc;

  __v = std::__num_get_float<_Fp>(__a, __a_end, __err);

  __check_grouping(__grouping, __g, __g_end, __err);

  if (__b == __e)
    __err |= ios_base::eofbit;
  return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator num_get<_CharT, _InputIterator>::do_get(
    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, void*& __v) const {

  int __base = 16;

  char_type __atoms[26];
  char_type __thousands_sep = char_type();
  string __grouping;
  std::use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src, __num_get_base::__src + 26, __atoms);
  string __buf;
  __buf.resize(__buf.capacity());
  char* __a = &__buf[0];
  char* __a_end = __a;
  unsigned __g[__num_get_base::__num_get_buf_sz];
  unsigned* __g_end = __g;
  unsigned __dc = 0;
  for (; __b != __e; ++__b) {
    if (__a_end == __a + __buf.size()) {
      size_t __tmp = __buf.size();
      __buf.resize(2 * __buf.size());
      __buf.resize(__buf.capacity());
      __a = &__buf[0];
      __a_end = __a + __tmp;
    }
    if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc, __thousands_sep, __grouping, __g, __g_end, __atoms))
      break;
  }

  __buf.resize(__a_end - __a);
  if (sscanf_l(__buf.c_str(), 0, "%p", &__v) != 1)
    __err = ios_base::failbit;

  if (__b == __e)
    __err |= ios_base::eofbit;
  return __b;
}

extern template class __attribute__((__visibility__("default"))) num_get<char>;

extern template class __attribute__((__visibility__("default"))) num_get<wchar_t>;


struct __attribute__((__visibility__("default"))) __num_put_base {
protected:
  static void __format_int(char* __fmt, const char* __len, bool __signd, ios_base::fmtflags __flags);
  static bool __format_float(char* __fmt, const char* __len, ios_base::fmtflags __flags);
  static char* __identify_padding(char* __nb, char* __ne, const ios_base& __iob);
};

template <class _CharT>
struct __num_put : protected __num_put_base {
  static void __widen_and_group_int(
      char* __nb, char* __np, char* __ne, _CharT* __ob, _CharT*& __op, _CharT*& __oe, const locale& __loc);
  static void __widen_and_group_float(
      char* __nb, char* __np, char* __ne, _CharT* __ob, _CharT*& __op, _CharT*& __oe, const locale& __loc);
};

template <class _CharT>
void __num_put<_CharT>::__widen_and_group_int(
    char* __nb, char* __np, char* __ne, _CharT* __ob, _CharT*& __op, _CharT*& __oe, const locale& __loc) {
  const ctype<_CharT>& __ct = std::use_facet<ctype<_CharT> >(__loc);
  const numpunct<_CharT>& __npt = std::use_facet<numpunct<_CharT> >(__loc);
  string __grouping = __npt.grouping();
  if (__grouping.empty()) {
    __ct.widen(__nb, __ne, __ob);
    __oe = __ob + (__ne - __nb);
  } else {
    __oe = __ob;
    char* __nf = __nb;
    if (*__nf == '-' || *__nf == '+')
      *__oe++ = __ct.widen(*__nf++);
    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' || __nf[1] == 'X')) {
      *__oe++ = __ct.widen(*__nf++);
      *__oe++ = __ct.widen(*__nf++);
    }
    std::reverse(__nf, __ne);
    _CharT __thousands_sep = __npt.thousands_sep();
    unsigned __dc = 0;
    unsigned __dg = 0;
    for (char* __p = __nf; __p < __ne; ++__p) {
      if (static_cast<unsigned>(__grouping[__dg]) > 0 && __dc == static_cast<unsigned>(__grouping[__dg])) {
        *__oe++ = __thousands_sep;
        __dc = 0;
        if (__dg < __grouping.size() - 1)
          ++__dg;
      }
      *__oe++ = __ct.widen(*__p);
      ++__dc;
    }
    std::reverse(__ob + (__nf - __nb), __oe);
  }
  if (__np == __ne)
    __op = __oe;
  else
    __op = __ob + (__np - __nb);
}

template <class _CharT>
void __num_put<_CharT>::__widen_and_group_float(
    char* __nb, char* __np, char* __ne, _CharT* __ob, _CharT*& __op, _CharT*& __oe, const locale& __loc) {
  const ctype<_CharT>& __ct = std::use_facet<ctype<_CharT> >(__loc);
  const numpunct<_CharT>& __npt = std::use_facet<numpunct<_CharT> >(__loc);
  string __grouping = __npt.grouping();
  __oe = __ob;
  char* __nf = __nb;
  if (*__nf == '-' || *__nf == '+')
    *__oe++ = __ct.widen(*__nf++);
  char* __ns;
  if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' || __nf[1] == 'X')) {
    *__oe++ = __ct.widen(*__nf++);
    *__oe++ = __ct.widen(*__nf++);
    for (__ns = __nf; __ns < __ne; ++__ns)
      if (!isxdigit_l(*__ns, 0))
        break;
  } else {
    for (__ns = __nf; __ns < __ne; ++__ns)
      if (!isdigit_l(*__ns, 0))
        break;
  }
  if (__grouping.empty()) {
    __ct.widen(__nf, __ns, __oe);
    __oe += __ns - __nf;
  } else {
    std::reverse(__nf, __ns);
    _CharT __thousands_sep = __npt.thousands_sep();
    unsigned __dc = 0;
    unsigned __dg = 0;
    for (char* __p = __nf; __p < __ns; ++__p) {
      if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg])) {
        *__oe++ = __thousands_sep;
        __dc = 0;
        if (__dg < __grouping.size() - 1)
          ++__dg;
      }
      *__oe++ = __ct.widen(*__p);
      ++__dc;
    }
    std::reverse(__ob + (__nf - __nb), __oe);
  }
  for (__nf = __ns; __nf < __ne; ++__nf) {
    if (*__nf == '.') {
      *__oe++ = __npt.decimal_point();
      ++__nf;
      break;
    } else
      *__oe++ = __ct.widen(*__nf);
  }
  __ct.widen(__nf, __ne, __oe);
  __oe += __ne - __nf;
  if (__np == __ne)
    __op = __oe;
  else
    __op = __ob + (__np - __nb);
}

extern template struct __attribute__((__visibility__("default"))) __num_put<char>;

extern template struct __attribute__((__visibility__("default"))) __num_put<wchar_t>;


template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class num_put : public locale::facet, private __num_put<_CharT> {
public:
  typedef _CharT char_type;
  typedef _OutputIterator iter_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit num_put(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type put(iter_type __s, ios_base& __iob, char_type __fl, bool __v) const {
    return do_put(__s, __iob, __fl, __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type put(iter_type __s, ios_base& __iob, char_type __fl, long __v) const {
    return do_put(__s, __iob, __fl, __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type put(iter_type __s, ios_base& __iob, char_type __fl, long long __v) const {
    return do_put(__s, __iob, __fl, __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type put(iter_type __s, ios_base& __iob, char_type __fl, unsigned long __v) const {
    return do_put(__s, __iob, __fl, __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type put(iter_type __s, ios_base& __iob, char_type __fl, unsigned long long __v) const {
    return do_put(__s, __iob, __fl, __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type put(iter_type __s, ios_base& __iob, char_type __fl, double __v) const {
    return do_put(__s, __iob, __fl, __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type put(iter_type __s, ios_base& __iob, char_type __fl, long double __v) const {
    return do_put(__s, __iob, __fl, __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const void* __v) const {
    return do_put(__s, __iob, __fl, __v);
  }

  static locale::id id;

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~num_put() override {}

  virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl, bool __v) const;
  virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl, long __v) const;
  virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl, long long __v) const;
  virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl, unsigned long) const;
  virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl, unsigned long long) const;
  virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl, double __v) const;
  virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl, long double __v) const;
  virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl, const void* __v) const;

  template <class _Integral>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline _OutputIterator
  __do_put_integral(iter_type __s, ios_base& __iob, char_type __fl, _Integral __v, char const* __len) const;

  template <class _Float>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline _OutputIterator
  __do_put_floating_point(iter_type __s, ios_base& __iob, char_type __fl, _Float __v, char const* __len) const;
};

template <class _CharT, class _OutputIterator>
locale::id num_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _OutputIterator __pad_and_output(
    _OutputIterator __s, const _CharT* __ob, const _CharT* __op, const _CharT* __oe, ios_base& __iob, _CharT __fl) {
  streamsize __sz = __oe - __ob;
  streamsize __ns = __iob.width();
  if (__ns > __sz)
    __ns -= __sz;
  else
    __ns = 0;
  for (; __ob < __op; ++__ob, ++__s)
    *__s = *__ob;
  for (; __ns; --__ns, ++__s)
    *__s = __fl;
  for (; __ob < __oe; ++__ob, ++__s)
    *__s = *__ob;
  __iob.width(0);
  return __s;
}

template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ostreambuf_iterator<_CharT, _Traits> __pad_and_output(
    ostreambuf_iterator<_CharT, _Traits> __s,
    const _CharT* __ob,
    const _CharT* __op,
    const _CharT* __oe,
    ios_base& __iob,
    _CharT __fl) {
  if (__s.__sbuf_ == __nullptr)
    return __s;
  streamsize __sz = __oe - __ob;
  streamsize __ns = __iob.width();
  if (__ns > __sz)
    __ns -= __sz;
  else
    __ns = 0;
  streamsize __np = __op - __ob;
  if (__np > 0) {
    if (__s.__sbuf_->sputn(__ob, __np) != __np) {
      __s.__sbuf_ = __nullptr;
      return __s;
    }
  }
  if (__ns > 0) {
    basic_string<_CharT, _Traits> __sp(__ns, __fl);
    if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns) {
      __s.__sbuf_ = __nullptr;
      return __s;
    }
  }
  __np = __oe - __op;
  if (__np > 0) {
    if (__s.__sbuf_->sputn(__op, __np) != __np) {
      __s.__sbuf_ = __nullptr;
      return __s;
    }
  }
  __iob.width(0);
  return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, bool __v) const {
  if ((__iob.flags() & ios_base::boolalpha) == 0)
    return do_put(__s, __iob, __fl, (unsigned long)__v);
  const numpunct<char_type>& __np = std::use_facet<numpunct<char_type> >(__iob.getloc());
  typedef typename numpunct<char_type>::string_type string_type;
  string_type __nm = __v ? __np.truename() : __np.falsename();
  for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)
    *__s = *__i;
  return __s;
}

template <class _CharT, class _OutputIterator>
template <class _Integral>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline _OutputIterator num_put<_CharT, _OutputIterator>::__do_put_integral(
    iter_type __s, ios_base& __iob, char_type __fl, _Integral __v, char const* __len) const {

  char __fmt[8] = {'%', 0};
  this->__format_int(__fmt + 1, __len, is_signed<_Integral>::value, __iob.flags());


  using _Unsigned = typename make_unsigned<_Integral>::type;
                    const unsigned __nbuf =
      (numeric_limits<_Unsigned>::digits / 3)
      + ((numeric_limits<_Unsigned>::digits % 3) != 0)
      + 2;
  char __nar[__nbuf];
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wformat-nonliteral"

  int __nc = snprintf_l(__nar, sizeof(__nar), 0, __fmt, __v);
#pragma clang diagnostic pop
  char* __ne = __nar + __nc;
  char* __np = this->__identify_padding(__nar, __ne, __iob);

  char_type __o[2 * (__nbuf - 1) - 1];
  char_type* __op;
  char_type* __oe;
  this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());


  return std::__pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, long __v) const {
  return this->__do_put_integral(__s, __iob, __fl, __v, "l");
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, long long __v) const {
  return this->__do_put_integral(__s, __iob, __fl, __v, "ll");
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, unsigned long __v) const {
  return this->__do_put_integral(__s, __iob, __fl, __v, "l");
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, unsigned long long __v) const {
  return this->__do_put_integral(__s, __iob, __fl, __v, "ll");
}

template <class _CharT, class _OutputIterator>
template <class _Float>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline _OutputIterator num_put<_CharT, _OutputIterator>::__do_put_floating_point(
    iter_type __s, ios_base& __iob, char_type __fl, _Float __v, char const* __len) const {

  char __fmt[8] = {'%', 0};
  bool __specify_precision = this->__format_float(__fmt + 1, __len, __iob.flags());
  const unsigned __nbuf = 30;
  char __nar[__nbuf];
  char* __nb = __nar;
  int __nc;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wformat-nonliteral"

  if (__specify_precision)
    __nc = snprintf_l(__nb, __nbuf, 0, __fmt, (int)__iob.precision(), __v);
  else
    __nc = snprintf_l(__nb, __nbuf, 0, __fmt, __v);
  unique_ptr<char, void (*)(void*)> __nbh(__nullptr, free);
  if (__nc > static_cast<int>(__nbuf - 1)) {
    if (__specify_precision)
      __nc = asprintf_l(&__nb, 0, __fmt, (int)__iob.precision(), __v);
    else
      __nc = asprintf_l(&__nb, 0, __fmt, __v);
    if (__nc == -1)
      __throw_bad_alloc();
    __nbh.reset(__nb);
  }
#pragma clang diagnostic pop
  char* __ne = __nb + __nc;
  char* __np = this->__identify_padding(__nb, __ne, __iob);

  char_type __o[2 * (__nbuf - 1) - 1];
  char_type* __ob = __o;
  unique_ptr<char_type, void (*)(void*)> __obh(0, free);
  if (__nb != __nar) {
    __ob = (char_type*)malloc(2 * static_cast<size_t>(__nc) * sizeof(char_type));
    if (__ob == 0)
      __throw_bad_alloc();
    __obh.reset(__ob);
  }
  char_type* __op;
  char_type* __oe;
  this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());


  __s = std::__pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
  return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, double __v) const {
  return this->__do_put_floating_point(__s, __iob, __fl, __v, "");
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, long double __v) const {
  return this->__do_put_floating_point(__s, __iob, __fl, __v, "L");
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, const void* __v) const {

  const unsigned __nbuf = 20;
  char __nar[__nbuf];
  int __nc = snprintf_l(__nar, sizeof(__nar), 0, "%p", __v);
  char* __ne = __nar + __nc;
  char* __np = this->__identify_padding(__nar, __ne, __iob);

  char_type __o[2 * (__nbuf - 1) - 1];
  char_type* __op;
  char_type* __oe;
  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
  __ct.widen(__nar, __ne, __o);
  __oe = __o + (__ne - __nar);
  if (__np == __ne)
    __op = __oe;
  else
    __op = __o + (__np - __nar);


  return std::__pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

extern template class __attribute__((__visibility__("default"))) num_put<char>;

extern template class __attribute__((__visibility__("default"))) num_put<wchar_t>;


template <class _CharT, class _InputIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int __get_up_to_n_digits(
    _InputIterator& __b, _InputIterator __e, ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n) {

  if (__b == __e) {
    __err |= ios_base::eofbit | ios_base::failbit;
    return 0;
  }

  _CharT __c = *__b;
  if (!__ct.is(ctype_base::digit, __c)) {
    __err |= ios_base::failbit;
    return 0;
  }
  int __r = __ct.narrow(__c, 0) - '0';
  for (++__b, (void)--__n; __b != __e && __n > 0; ++__b, (void)--__n) {

    __c = *__b;
    if (!__ct.is(ctype_base::digit, __c))
      return __r;
    __r = __r * 10 + __ct.narrow(__c, 0) - '0';
  }
  if (__b == __e)
    __err |= ios_base::eofbit;
  return __r;
}

class __attribute__((__visibility__("default"))) time_base {
public:
  enum dateorder { no_order, dmy, mdy, ymd, ydm };
};

template <class _CharT>
class __time_get_c_storage {
protected:
  typedef basic_string<_CharT> string_type;

  virtual const string_type* __weeks() const;
  virtual const string_type* __months() const;
  virtual const string_type* __am_pm() const;
  virtual const string_type& __c() const;
  virtual const string_type& __r() const;
  virtual const string_type& __x() const;
  virtual const string_type& __X() const;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~__time_get_c_storage() {}
};

template <>
__attribute__((__visibility__("default"))) const string* __time_get_c_storage<char>::__weeks() const;
template <>
__attribute__((__visibility__("default"))) const string* __time_get_c_storage<char>::__months() const;
template <>
__attribute__((__visibility__("default"))) const string* __time_get_c_storage<char>::__am_pm() const;
template <>
__attribute__((__visibility__("default"))) const string& __time_get_c_storage<char>::__c() const;
template <>
__attribute__((__visibility__("default"))) const string& __time_get_c_storage<char>::__r() const;
template <>
__attribute__((__visibility__("default"))) const string& __time_get_c_storage<char>::__x() const;
template <>
__attribute__((__visibility__("default"))) const string& __time_get_c_storage<char>::__X() const;


template <>
__attribute__((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__weeks() const;
template <>
__attribute__((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__months() const;
template <>
__attribute__((__visibility__("default"))) const wstring* __time_get_c_storage<wchar_t>::__am_pm() const;
template <>
__attribute__((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__c() const;
template <>
__attribute__((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__r() const;
template <>
__attribute__((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__x() const;
template <>
__attribute__((__visibility__("default"))) const wstring& __time_get_c_storage<wchar_t>::__X() const;


template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class time_get : public locale::facet, public time_base, private __time_get_c_storage<_CharT> {
public:
  typedef _CharT char_type;
  typedef _InputIterator iter_type;
  typedef time_base::dateorder dateorder;
  typedef basic_string<char_type> string_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit time_get(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) dateorder date_order() const { return this->do_date_order(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  get_time(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const {
    return do_get_time(__b, __e, __iob, __err, __tm);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  get_date(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const {
    return do_get_date(__b, __e, __iob, __err, __tm);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  get_weekday(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const {
    return do_get_weekday(__b, __e, __iob, __err, __tm);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  get_monthname(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const {
    return do_get_monthname(__b, __e, __iob, __err, __tm);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  get_year(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const {
    return do_get_year(__b, __e, __iob, __err, __tm);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  get(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm, char __fmt, char __mod = 0)
      const {
    return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);
  }

  iter_type
  get(iter_type __b,
      iter_type __e,
      ios_base& __iob,
      ios_base::iostate& __err,
      tm* __tm,
      const char_type* __fmtb,
      const char_type* __fmte) const;

  static locale::id id;

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~time_get() override {}

  virtual dateorder do_date_order() const;
  virtual iter_type
  do_get_time(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const;
  virtual iter_type
  do_get_date(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const;
  virtual iter_type
  do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const;
  virtual iter_type
  do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const;
  virtual iter_type
  do_get_year(iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const;
  virtual iter_type do_get(
      iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm, char __fmt, char __mod) const;

private:
  void __get_white_space(iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
  void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;

  void __get_weekdayname(
      int& __m, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
  void __get_monthname(
      int& __m, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
  void __get_day(int& __d, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
  void
  __get_month(int& __m, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
  void
  __get_year(int& __y, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
  void
  __get_year4(int& __y, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
  void
  __get_hour(int& __d, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
  void
  __get_12_hour(int& __h, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
  void
  __get_am_pm(int& __h, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
  void
  __get_minute(int& __m, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
  void
  __get_second(int& __s, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
  void
  __get_weekday(int& __w, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
  void __get_day_year_num(
      int& __w, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const;
};

template <class _CharT, class _InputIterator>
locale::id time_get<_CharT, _InputIterator>::id;



template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_weekdayname(
    int& __w, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {

  const string_type* __wk = this->__weeks();
  ptrdiff_t __i = std::__scan_keyword(__b, __e, __wk, __wk + 14, __ct, __err, false) - __wk;
  if (__i < 14)
    __w = __i % 7;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_monthname(
    int& __m, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {

  const string_type* __month = this->__months();
  ptrdiff_t __i = std::__scan_keyword(__b, __e, __month, __month + 24, __ct, __err, false) - __month;
  if (__i < 24)
    __m = __i % 12;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_day(
    int& __d, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
  int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 2);
  if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)
    __d = __t;
  else
    __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_month(
    int& __m, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
  int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;
  if (!(__err & ios_base::failbit) && 0 <= __t && __t <= 11)
    __m = __t;
  else
    __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_year(
    int& __y, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
  int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 4);
  if (!(__err & ios_base::failbit)) {
    if (__t < 69)
      __t += 2000;
    else if (69 <= __t && __t <= 99)
      __t += 1900;
    __y = __t - 1900;
  }
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_year4(
    int& __y, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
  int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 4);
  if (!(__err & ios_base::failbit))
    __y = __t - 1900;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_hour(
    int& __h, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
  int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 2);
  if (!(__err & ios_base::failbit) && __t <= 23)
    __h = __t;
  else
    __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_12_hour(
    int& __h, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
  int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 2);
  if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)
    __h = __t;
  else
    __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_minute(
    int& __m, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
  int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 2);
  if (!(__err & ios_base::failbit) && __t <= 59)
    __m = __t;
  else
    __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_second(
    int& __s, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
  int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 2);
  if (!(__err & ios_base::failbit) && __t <= 60)
    __s = __t;
  else
    __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_weekday(
    int& __w, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
  int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 1);
  if (!(__err & ios_base::failbit) && __t <= 6)
    __w = __t;
  else
    __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_day_year_num(
    int& __d, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
  int __t = std::__get_up_to_n_digits(__b, __e, __err, __ct, 3);
  if (!(__err & ios_base::failbit) && __t <= 365)
    __d = __t;
  else
    __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_white_space(
    iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
  for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
    ;
  if (__b == __e)
    __err |= ios_base::eofbit;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_am_pm(
    int& __h, iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
  const string_type* __ap = this->__am_pm();
  if (__ap[0].size() + __ap[1].size() == 0) {
    __err |= ios_base::failbit;
    return;
  }
  ptrdiff_t __i = std::__scan_keyword(__b, __e, __ap, __ap + 2, __ct, __err, false) - __ap;
  if (__i == 0 && __h == 12)
    __h = 0;
  else if (__i == 1 && __h < 12)
    __h += 12;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_percent(
    iter_type& __b, iter_type __e, ios_base::iostate& __err, const ctype<char_type>& __ct) const {
  if (__b == __e) {
    __err |= ios_base::eofbit | ios_base::failbit;
    return;
  }
  if (__ct.narrow(*__b, 0) != '%')
    __err |= ios_base::failbit;
  else if (++__b == __e)
    __err |= ios_base::eofbit;
}



template <class _CharT, class _InputIterator>
_InputIterator time_get<_CharT, _InputIterator>::get(
    iter_type __b,
    iter_type __e,
    ios_base& __iob,
    ios_base::iostate& __err,
    tm* __tm,
    const char_type* __fmtb,
    const char_type* __fmte) const {
  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
  __err = ios_base::goodbit;
  while (__fmtb != __fmte && __err == ios_base::goodbit) {
    if (__b == __e) {
      __err = ios_base::failbit;
      break;
    }
    if (__ct.narrow(*__fmtb, 0) == '%') {
      if (++__fmtb == __fmte) {
        __err = ios_base::failbit;
        break;
      }
      char __cmd = __ct.narrow(*__fmtb, 0);
      char __opt = '\0';
      if (__cmd == 'E' || __cmd == '0') {
        if (++__fmtb == __fmte) {
          __err = ios_base::failbit;
          break;
        }
        __opt = __cmd;
        __cmd = __ct.narrow(*__fmtb, 0);
      }
      __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);
      ++__fmtb;
    } else if (__ct.is(ctype_base::space, *__fmtb)) {
      for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)
        ;
      for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
        ;
    } else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb)) {
      ++__b;
      ++__fmtb;
    } else
      __err = ios_base::failbit;
  }
  if (__b == __e)
    __err |= ios_base::eofbit;
  return __b;
}

template <class _CharT, class _InputIterator>
typename time_get<_CharT, _InputIterator>::dateorder time_get<_CharT, _InputIterator>::do_date_order() const {
  return mdy;
}

template <class _CharT, class _InputIterator>
_InputIterator time_get<_CharT, _InputIterator>::do_get_time(
    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const {
  const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
  return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt) / sizeof(__fmt[0]));
}

template <class _CharT, class _InputIterator>
_InputIterator time_get<_CharT, _InputIterator>::do_get_date(
    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const {
  const string_type& __fmt = this->__x();
  return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());
}

template <class _CharT, class _InputIterator>
_InputIterator time_get<_CharT, _InputIterator>::do_get_weekday(
    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const {
  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
  __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
  return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator time_get<_CharT, _InputIterator>::do_get_monthname(
    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const {
  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
  __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
  return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator time_get<_CharT, _InputIterator>::do_get_year(
    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm) const {
  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
  __get_year(__tm->tm_year, __b, __e, __err, __ct);
  return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator time_get<_CharT, _InputIterator>::do_get(
    iter_type __b, iter_type __e, ios_base& __iob, ios_base::iostate& __err, tm* __tm, char __fmt, char) const {
  __err = ios_base::goodbit;
  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
  switch (__fmt) {
  case 'a':
  case 'A':
    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
    break;
  case 'b':
  case 'B':
  case 'h':
    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
    break;
  case 'c': {
    const string_type& __fm = this->__c();
    __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
  } break;
  case 'd':
  case 'e':
    __get_day(__tm->tm_mday, __b, __e, __err, __ct);
    break;
  case 'D': {
    const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};
    __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm) / sizeof(__fm[0]));
  } break;
  case 'F': {
    const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};
    __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm) / sizeof(__fm[0]));
  } break;
  case 'H':
    __get_hour(__tm->tm_hour, __b, __e, __err, __ct);
    break;
  case 'I':
    __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);
    break;
  case 'j':
    __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);
    break;
  case 'm':
    __get_month(__tm->tm_mon, __b, __e, __err, __ct);
    break;
  case 'M':
    __get_minute(__tm->tm_min, __b, __e, __err, __ct);
    break;
  case 'n':
  case 't':
    __get_white_space(__b, __e, __err, __ct);
    break;
  case 'p':
    __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);
    break;
  case 'r': {
    const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};
    __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm) / sizeof(__fm[0]));
  } break;
  case 'R': {
    const char_type __fm[] = {'%', 'H', ':', '%', 'M'};
    __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm) / sizeof(__fm[0]));
  } break;
  case 'S':
    __get_second(__tm->tm_sec, __b, __e, __err, __ct);
    break;
  case 'T': {
    const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
    __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm) / sizeof(__fm[0]));
  } break;
  case 'w':
    __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);
    break;
  case 'x':
    return do_get_date(__b, __e, __iob, __err, __tm);
  case 'X': {
    const string_type& __fm = this->__X();
    __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());
  } break;
  case 'y':
    __get_year(__tm->tm_year, __b, __e, __err, __ct);
    break;
  case 'Y':
    __get_year4(__tm->tm_year, __b, __e, __err, __ct);
    break;
  case '%':
    __get_percent(__b, __e, __err, __ct);
    break;
  default:
    __err |= ios_base::failbit;
  }
  return __b;
}

extern template class __attribute__((__visibility__("default"))) time_get<char>;

extern template class __attribute__((__visibility__("default"))) time_get<wchar_t>;


class __attribute__((__visibility__("default"))) __time_get {
protected:
  locale_t __loc_;

  __time_get(const char* __nm);
  __time_get(const string& __nm);
  ~__time_get();
};

template <class _CharT>
class __time_get_storage : public __time_get {
protected:
  typedef basic_string<_CharT> string_type;

  string_type __weeks_[14];
  string_type __months_[24];
  string_type __am_pm_[2];
  string_type __c_;
  string_type __r_;
  string_type __x_;
  string_type __X_;

  explicit __time_get_storage(const char* __nm);
  explicit __time_get_storage(const string& __nm);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~__time_get_storage() {}

  time_base::dateorder __do_date_order() const;

private:
  void init(const ctype<_CharT>&);
  string_type __analyze(char __fmt, const ctype<_CharT>&);
};
# 2031 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
template <> __attribute__((__visibility__("default"))) time_base::dateorder __time_get_storage<char>::__do_date_order() const; template <> __attribute__((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const char*); template <> __attribute__((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const string&); template <> __attribute__((__visibility__("default"))) void __time_get_storage<char>::init(const ctype<char>&); template <> __attribute__((__visibility__("default"))) __time_get_storage<char>::string_type __time_get_storage<char>::__analyze( char, const ctype<char>&); extern template __attribute__((__visibility__("default"))) time_base::dateorder __time_get_storage<char>::__do_date_order() const; extern template __attribute__((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const char*); extern template __attribute__((__visibility__("default"))) __time_get_storage<char>::__time_get_storage(const string&); extern template __attribute__((__visibility__("default"))) void __time_get_storage<char>::init(const ctype<char>&); extern template __attribute__((__visibility__("default"))) __time_get_storage<char>::string_type __time_get_storage<char>::__analyze(char, const ctype<char>&);

template <> __attribute__((__visibility__("default"))) time_base::dateorder __time_get_storage<wchar_t>::__do_date_order() const; template <> __attribute__((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const char*); template <> __attribute__((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const string&); template <> __attribute__((__visibility__("default"))) void __time_get_storage<wchar_t>::init(const ctype<wchar_t>&); template <> __attribute__((__visibility__("default"))) __time_get_storage<wchar_t>::string_type __time_get_storage<wchar_t>::__analyze( char, const ctype<wchar_t>&); extern template __attribute__((__visibility__("default"))) time_base::dateorder __time_get_storage<wchar_t>::__do_date_order() const; extern template __attribute__((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const char*); extern template __attribute__((__visibility__("default"))) __time_get_storage<wchar_t>::__time_get_storage(const string&); extern template __attribute__((__visibility__("default"))) void __time_get_storage<wchar_t>::init(const ctype<wchar_t>&); extern template __attribute__((__visibility__("default"))) __time_get_storage<wchar_t>::string_type __time_get_storage<wchar_t>::__analyze(char, const ctype<wchar_t>&);



template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class time_get_byname
    : public time_get<_CharT, _InputIterator>,
      private __time_get_storage<_CharT> {
public:
  typedef time_base::dateorder dateorder;
  typedef _InputIterator iter_type;
  typedef _CharT char_type;
  typedef basic_string<char_type> string_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit time_get_byname(const char* __nm, size_t __refs = 0)
      : time_get<_CharT, _InputIterator>(__refs), __time_get_storage<_CharT>(__nm) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit time_get_byname(const string& __nm, size_t __refs = 0)
      : time_get<_CharT, _InputIterator>(__refs), __time_get_storage<_CharT>(__nm) {}

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~time_get_byname() override {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) dateorder do_date_order() const override { return this->__do_date_order(); }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) const string_type* __weeks() const override { return this->__weeks_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) const string_type* __months() const override { return this->__months_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) const string_type* __am_pm() const override { return this->__am_pm_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) const string_type& __c() const override { return this->__c_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) const string_type& __r() const override { return this->__r_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) const string_type& __x() const override { return this->__x_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) const string_type& __X() const override { return this->__X_; }
};

extern template class __attribute__((__visibility__("default"))) time_get_byname<char>;

extern template class __attribute__((__visibility__("default"))) time_get_byname<wchar_t>;


class __attribute__((__visibility__("default"))) __time_put {
  locale_t __loc_;

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __time_put() : __loc_(0) {}
  __time_put(const char* __nm);
  __time_put(const string& __nm);
  ~__time_put();
  void __do_put(char* __nb, char*& __ne, const tm* __tm, char __fmt, char __mod) const;

  void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm, char __fmt, char __mod) const;

};

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class time_put : public locale::facet, private __time_put {
public:
  typedef _CharT char_type;
  typedef _OutputIterator iter_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit time_put(size_t __refs = 0) : locale::facet(__refs) {}

  iter_type
  put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm, const char_type* __pb, const char_type* __pe)
      const;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm, char __fmt, char __mod = 0) const {
    return do_put(__s, __iob, __fl, __tm, __fmt, __mod);
  }

  static locale::id id;

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~time_put() override {}
  virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm, char __fmt, char __mod) const;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit time_put(const char* __nm, size_t __refs) : locale::facet(__refs), __time_put(__nm) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit time_put(const string& __nm, size_t __refs)
      : locale::facet(__refs), __time_put(__nm) {}
};

template <class _CharT, class _OutputIterator>
locale::id time_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator time_put<_CharT, _OutputIterator>::put(
    iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm, const char_type* __pb, const char_type* __pe)
    const {
  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
  for (; __pb != __pe; ++__pb) {
    if (__ct.narrow(*__pb, 0) == '%') {
      if (++__pb == __pe) {
        *__s++ = __pb[-1];
        break;
      }
      char __mod = 0;
      char __fmt = __ct.narrow(*__pb, 0);
      if (__fmt == 'E' || __fmt == 'O') {
        if (++__pb == __pe) {
          *__s++ = __pb[-2];
          *__s++ = __pb[-1];
          break;
        }
        __mod = __fmt;
        __fmt = __ct.narrow(*__pb, 0);
      }
      __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);
    } else
      *__s++ = *__pb;
  }
  return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator time_put<_CharT, _OutputIterator>::do_put(
    iter_type __s, ios_base&, char_type, const tm* __tm, char __fmt, char __mod) const {
  char_type __nar[100];
  char_type* __nb = __nar;
  char_type* __ne = __nb + 100;
  __do_put(__nb, __ne, __tm, __fmt, __mod);
  return std::copy(__nb, __ne, __s);
}

extern template class __attribute__((__visibility__("default"))) time_put<char>;

extern template class __attribute__((__visibility__("default"))) time_put<wchar_t>;


template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class time_put_byname : public time_put<_CharT, _OutputIterator> {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit time_put_byname(const char* __nm, size_t __refs = 0)
      : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit time_put_byname(const string& __nm, size_t __refs = 0)
      : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~time_put_byname() override {}
};

extern template class __attribute__((__visibility__("default"))) time_put_byname<char>;

extern template class __attribute__((__visibility__("default"))) time_put_byname<wchar_t>;




class __attribute__((__visibility__("default"))) money_base {
public:
  enum part { none, space, symbol, sign, value };
  struct pattern {
    char field[4];
  };

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) money_base() {}
};



template <class _CharT, bool _International = false>
class moneypunct : public locale::facet, public money_base {
public:
  typedef _CharT char_type;
  typedef basic_string<char_type> string_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit moneypunct(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type decimal_point() const { return do_decimal_point(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) char_type thousands_sep() const { return do_thousands_sep(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) string grouping() const { return do_grouping(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) string_type curr_symbol() const { return do_curr_symbol(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) string_type positive_sign() const { return do_positive_sign(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) string_type negative_sign() const { return do_negative_sign(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) int frac_digits() const { return do_frac_digits(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pattern pos_format() const { return do_pos_format(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pattern neg_format() const { return do_neg_format(); }

  static locale::id id;
  static const bool intl = _International;

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~moneypunct() override {}

  virtual char_type do_decimal_point() const { return numeric_limits<char_type>::max(); }
  virtual char_type do_thousands_sep() const { return numeric_limits<char_type>::max(); }
  virtual string do_grouping() const { return string(); }
  virtual string_type do_curr_symbol() const { return string_type(); }
  virtual string_type do_positive_sign() const { return string_type(); }
  virtual string_type do_negative_sign() const { return string_type(1, '-'); }
  virtual int do_frac_digits() const { return 0; }
  virtual pattern do_pos_format() const {
    pattern __p = {{symbol, sign, none, value}};
    return __p;
  }
  virtual pattern do_neg_format() const {
    pattern __p = {{symbol, sign, none, value}};
    return __p;
  }
};

template <class _CharT, bool _International>
locale::id moneypunct<_CharT, _International>::id;

template <class _CharT, bool _International>
const bool moneypunct<_CharT, _International>::intl;

extern template class __attribute__((__visibility__("default"))) moneypunct<char, false>;
extern template class __attribute__((__visibility__("default"))) moneypunct<char, true>;

extern template class __attribute__((__visibility__("default"))) moneypunct<wchar_t, false>;
extern template class __attribute__((__visibility__("default"))) moneypunct<wchar_t, true>;




template <class _CharT, bool _International = false>
class moneypunct_byname : public moneypunct<_CharT, _International> {
public:
  typedef money_base::pattern pattern;
  typedef _CharT char_type;
  typedef basic_string<char_type> string_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit moneypunct_byname(const char* __nm, size_t __refs = 0)
      : moneypunct<_CharT, _International>(__refs) {
    init(__nm);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit moneypunct_byname(const string& __nm, size_t __refs = 0)
      : moneypunct<_CharT, _International>(__refs) {
    init(__nm.c_str());
  }

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~moneypunct_byname() override {}

  char_type do_decimal_point() const override { return __decimal_point_; }
  char_type do_thousands_sep() const override { return __thousands_sep_; }
  string do_grouping() const override { return __grouping_; }
  string_type do_curr_symbol() const override { return __curr_symbol_; }
  string_type do_positive_sign() const override { return __positive_sign_; }
  string_type do_negative_sign() const override { return __negative_sign_; }
  int do_frac_digits() const override { return __frac_digits_; }
  pattern do_pos_format() const override { return __pos_format_; }
  pattern do_neg_format() const override { return __neg_format_; }

private:
  char_type __decimal_point_;
  char_type __thousands_sep_;
  string __grouping_;
  string_type __curr_symbol_;
  string_type __positive_sign_;
  string_type __negative_sign_;
  int __frac_digits_;
  pattern __pos_format_;
  pattern __neg_format_;

  void init(const char*);
};

template <>
__attribute__((__visibility__("default"))) void moneypunct_byname<char, false>::init(const char*);
template <>
__attribute__((__visibility__("default"))) void moneypunct_byname<char, true>::init(const char*);
extern template class __attribute__((__visibility__("default"))) moneypunct_byname<char, false>;
extern template class __attribute__((__visibility__("default"))) moneypunct_byname<char, true>;


template <>
__attribute__((__visibility__("default"))) void moneypunct_byname<wchar_t, false>::init(const char*);
template <>
__attribute__((__visibility__("default"))) void moneypunct_byname<wchar_t, true>::init(const char*);
extern template class __attribute__((__visibility__("default"))) moneypunct_byname<wchar_t, false>;
extern template class __attribute__((__visibility__("default"))) moneypunct_byname<wchar_t, true>;




template <class _CharT>
class __money_get {
protected:
  typedef _CharT char_type;
  typedef basic_string<char_type> string_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __money_get() {}

  static void __gather_info(
      bool __intl,
      const locale& __loc,
      money_base::pattern& __pat,
      char_type& __dp,
      char_type& __ts,
      string& __grp,
      string_type& __sym,
      string_type& __psn,
      string_type& __nsn,
      int& __fd);
};

template <class _CharT>
void __money_get<_CharT>::__gather_info(
    bool __intl,
    const locale& __loc,
    money_base::pattern& __pat,
    char_type& __dp,
    char_type& __ts,
    string& __grp,
    string_type& __sym,
    string_type& __psn,
    string_type& __nsn,
    int& __fd) {
  if (__intl) {
    const moneypunct<char_type, true>& __mp = std::use_facet<moneypunct<char_type, true> >(__loc);
    __pat = __mp.neg_format();
    __nsn = __mp.negative_sign();
    __psn = __mp.positive_sign();
    __dp = __mp.decimal_point();
    __ts = __mp.thousands_sep();
    __grp = __mp.grouping();
    __sym = __mp.curr_symbol();
    __fd = __mp.frac_digits();
  } else {
    const moneypunct<char_type, false>& __mp = std::use_facet<moneypunct<char_type, false> >(__loc);
    __pat = __mp.neg_format();
    __nsn = __mp.negative_sign();
    __psn = __mp.positive_sign();
    __dp = __mp.decimal_point();
    __ts = __mp.thousands_sep();
    __grp = __mp.grouping();
    __sym = __mp.curr_symbol();
    __fd = __mp.frac_digits();
  }
}

extern template class __attribute__((__visibility__("default"))) __money_get<char>;

extern template class __attribute__((__visibility__("default"))) __money_get<wchar_t>;


template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >
class money_get : public locale::facet, private __money_get<_CharT> {
public:
  typedef _CharT char_type;
  typedef _InputIterator iter_type;
  typedef basic_string<char_type> string_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit money_get(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob, ios_base::iostate& __err, long double& __v) const {
    return do_get(__b, __e, __intl, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob, ios_base::iostate& __err, string_type& __v) const {
    return do_get(__b, __e, __intl, __iob, __err, __v);
  }

  static locale::id id;

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~money_get() override {}

  virtual iter_type
  do_get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob, ios_base::iostate& __err, long double& __v) const;
  virtual iter_type
  do_get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob, ios_base::iostate& __err, string_type& __v) const;

private:
  static bool __do_get(
      iter_type& __b,
      iter_type __e,
      bool __intl,
      const locale& __loc,
      ios_base::fmtflags __flags,
      ios_base::iostate& __err,
      bool& __neg,
      const ctype<char_type>& __ct,
      unique_ptr<char_type, void (*)(void*)>& __wb,
      char_type*& __wn,
      char_type* __we);
};

template <class _CharT, class _InputIterator>
locale::id money_get<_CharT, _InputIterator>::id;

__attribute__((__visibility__("default"))) void __do_nothing(void*);

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __double_or_nothing(unique_ptr<_Tp, void (*)(void*)>& __b, _Tp*& __n, _Tp*& __e) {
  bool __owns = __b.get_deleter() != __do_nothing;
  size_t __cur_cap = static_cast<size_t>(__e - __b.get()) * sizeof(_Tp);
  size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ? 2 * __cur_cap : numeric_limits<size_t>::max();
  if (__new_cap == 0)
    __new_cap = sizeof(_Tp);
  size_t __n_off = static_cast<size_t>(__n - __b.get());
  _Tp* __t = (_Tp*)std::realloc(__owns ? __b.get() : 0, __new_cap);
  if (__t == 0)
    __throw_bad_alloc();
  if (__owns)
    __b.release();
  __b = unique_ptr<_Tp, void (*)(void*)>(__t, free);
  __new_cap /= sizeof(_Tp);
  __n = __b.get() + __n_off;
  __e = __b.get() + __new_cap;
}


template <class _CharT, class _InputIterator>
bool money_get<_CharT, _InputIterator>::__do_get(
    iter_type& __b,
    iter_type __e,
    bool __intl,
    const locale& __loc,
    ios_base::fmtflags __flags,
    ios_base::iostate& __err,
    bool& __neg,
    const ctype<char_type>& __ct,
    unique_ptr<char_type, void (*)(void*)>& __wb,
    char_type*& __wn,
    char_type* __we) {
  if (__b == __e) {
    __err |= ios_base::failbit;
    return false;
  }
  const unsigned __bz = 100;
  unsigned __gbuf[__bz];
  unique_ptr<unsigned, void (*)(void*)> __gb(__gbuf, __do_nothing);
  unsigned* __gn = __gb.get();
  unsigned* __ge = __gn + __bz;
  money_base::pattern __pat;
  char_type __dp;
  char_type __ts;
  string __grp;
  string_type __sym;
  string_type __psn;
  string_type __nsn;


  string_type __spaces;
  int __fd;
  __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp, __sym, __psn, __nsn, __fd);
  const string_type* __trailing_sign = 0;
  __wn = __wb.get();
  for (unsigned __p = 0; __p < 4 && __b != __e; ++__p) {
    switch (__pat.field[__p]) {
    case money_base::space:
      if (__p != 3) {
        if (__ct.is(ctype_base::space, *__b))
          __spaces.push_back(*__b++);
        else {
          __err |= ios_base::failbit;
          return false;
        }
      }
      __attribute__((__fallthrough__));
    case money_base::none:
      if (__p != 3) {
        while (__b != __e && __ct.is(ctype_base::space, *__b))
          __spaces.push_back(*__b++);
      }
      break;
    case money_base::sign:
      if (__psn.size() > 0 && *__b == __psn[0]) {
        ++__b;
        __neg = false;
        if (__psn.size() > 1)
          __trailing_sign = &__psn;
        break;
      }
      if (__nsn.size() > 0 && *__b == __nsn[0]) {
        ++__b;
        __neg = true;
        if (__nsn.size() > 1)
          __trailing_sign = &__nsn;
        break;
      }
      if (__psn.size() > 0 && __nsn.size() > 0) {
        __err |= ios_base::failbit;
        return false;
      }
      if (__psn.size() == 0 && __nsn.size() == 0)

        break;
      __neg = (__nsn.size() == 0);
      break;
    case money_base::symbol: {
      bool __more_needed =
          __trailing_sign || (__p < 2) || (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));
      bool __sb = (__flags & ios_base::showbase) != 0;
      if (__sb || __more_needed) {
        typename string_type::const_iterator __sym_space_end = __sym.begin();
        if (__p > 0 && (__pat.field[__p - 1] == money_base::none || __pat.field[__p - 1] == money_base::space)) {


          while (__sym_space_end != __sym.end() && __ct.is(ctype_base::space, *__sym_space_end))
            ++__sym_space_end;
          const size_t __num_spaces = __sym_space_end - __sym.begin();
          if (__num_spaces > __spaces.size() ||
              !std::equal(__spaces.end() - __num_spaces, __spaces.end(), __sym.begin())) {



            __sym_space_end = __sym.begin();
          }
        }
        typename string_type::const_iterator __sym_curr_char = __sym_space_end;
        while (__sym_curr_char != __sym.end() && __b != __e && *__b == *__sym_curr_char) {
          ++__b;
          ++__sym_curr_char;
        }
        if (__sb && __sym_curr_char != __sym.end()) {
          __err |= ios_base::failbit;
          return false;
        }
      }
    } break;
    case money_base::value: {
      unsigned __ng = 0;
      for (; __b != __e; ++__b) {
        char_type __c = *__b;
        if (__ct.is(ctype_base::digit, __c)) {
          if (__wn == __we)
            std::__double_or_nothing(__wb, __wn, __we);
          *__wn++ = __c;
          ++__ng;
        } else if (__grp.size() > 0 && __ng > 0 && __c == __ts) {
          if (__gn == __ge)
            std::__double_or_nothing(__gb, __gn, __ge);
          *__gn++ = __ng;
          __ng = 0;
        } else
          break;
      }
      if (__gb.get() != __gn && __ng > 0) {
        if (__gn == __ge)
          std::__double_or_nothing(__gb, __gn, __ge);
        *__gn++ = __ng;
      }
      if (__fd > 0) {
        if (__b == __e || *__b != __dp) {
          __err |= ios_base::failbit;
          return false;
        }
        for (++__b; __fd > 0; --__fd, ++__b) {
          if (__b == __e || !__ct.is(ctype_base::digit, *__b)) {
            __err |= ios_base::failbit;
            return false;
          }
          if (__wn == __we)
            std::__double_or_nothing(__wb, __wn, __we);
          *__wn++ = *__b;
        }
      }
      if (__wn == __wb.get()) {
        __err |= ios_base::failbit;
        return false;
      }
    } break;
    }
  }
  if (__trailing_sign) {
    for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b) {
      if (__b == __e || *__b != (*__trailing_sign)[__i]) {
        __err |= ios_base::failbit;
        return false;
      }
    }
  }
  if (__gb.get() != __gn) {
    ios_base::iostate __et = ios_base::goodbit;
    __check_grouping(__grp, __gb.get(), __gn, __et);
    if (__et) {
      __err |= ios_base::failbit;
      return false;
    }
  }
  return true;
}

template <class _CharT, class _InputIterator>
_InputIterator money_get<_CharT, _InputIterator>::do_get(
    iter_type __b, iter_type __e, bool __intl, ios_base& __iob, ios_base::iostate& __err, long double& __v) const {
  const int __bz = 100;
  char_type __wbuf[__bz];
  unique_ptr<char_type, void (*)(void*)> __wb(__wbuf, __do_nothing);
  char_type* __wn;
  char_type* __we = __wbuf + __bz;
  locale __loc = __iob.getloc();
  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__loc);
  bool __neg = false;
  if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct, __wb, __wn, __we)) {
    const char __src[] = "0123456789";
    char_type __atoms[sizeof(__src) - 1];
    __ct.widen(__src, __src + (sizeof(__src) - 1), __atoms);
    char __nbuf[__bz];
    char* __nc = __nbuf;
    unique_ptr<char, void (*)(void*)> __h(__nullptr, free);
    if (__wn - __wb.get() > __bz - 2) {
      __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));
      if (__h.get() == __nullptr)
        __throw_bad_alloc();
      __nc = __h.get();
    }
    if (__neg)
      *__nc++ = '-';
    for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)
      *__nc = __src[std::find(__atoms, std::end(__atoms), *__w) - __atoms];
    *__nc = char();
    if (sscanf(__nbuf, "%Lf", &__v) != 1)
      __throw_runtime_error("money_get error");
  }
  if (__b == __e)
    __err |= ios_base::eofbit;
  return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator money_get<_CharT, _InputIterator>::do_get(
    iter_type __b, iter_type __e, bool __intl, ios_base& __iob, ios_base::iostate& __err, string_type& __v) const {
  const int __bz = 100;
  char_type __wbuf[__bz];
  unique_ptr<char_type, void (*)(void*)> __wb(__wbuf, __do_nothing);
  char_type* __wn;
  char_type* __we = __wbuf + __bz;
  locale __loc = __iob.getloc();
  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__loc);
  bool __neg = false;
  if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct, __wb, __wn, __we)) {
    __v.clear();
    if (__neg)
      __v.push_back(__ct.widen('-'));
    char_type __z = __ct.widen('0');
    char_type* __w;
    for (__w = __wb.get(); __w < __wn - 1; ++__w)
      if (*__w != __z)
        break;
    __v.append(__w, __wn);
  }
  if (__b == __e)
    __err |= ios_base::eofbit;
  return __b;
}

extern template class __attribute__((__visibility__("default"))) money_get<char>;

extern template class __attribute__((__visibility__("default"))) money_get<wchar_t>;




template <class _CharT>
class __money_put {
protected:
  typedef _CharT char_type;
  typedef basic_string<char_type> string_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __money_put() {}

  static void __gather_info(
      bool __intl,
      bool __neg,
      const locale& __loc,
      money_base::pattern& __pat,
      char_type& __dp,
      char_type& __ts,
      string& __grp,
      string_type& __sym,
      string_type& __sn,
      int& __fd);
  static void __format(
      char_type* __mb,
      char_type*& __mi,
      char_type*& __me,
      ios_base::fmtflags __flags,
      const char_type* __db,
      const char_type* __de,
      const ctype<char_type>& __ct,
      bool __neg,
      const money_base::pattern& __pat,
      char_type __dp,
      char_type __ts,
      const string& __grp,
      const string_type& __sym,
      const string_type& __sn,
      int __fd);
};

template <class _CharT>
void __money_put<_CharT>::__gather_info(
    bool __intl,
    bool __neg,
    const locale& __loc,
    money_base::pattern& __pat,
    char_type& __dp,
    char_type& __ts,
    string& __grp,
    string_type& __sym,
    string_type& __sn,
    int& __fd) {
  if (__intl) {
    const moneypunct<char_type, true>& __mp = std::use_facet<moneypunct<char_type, true> >(__loc);
    if (__neg) {
      __pat = __mp.neg_format();
      __sn = __mp.negative_sign();
    } else {
      __pat = __mp.pos_format();
      __sn = __mp.positive_sign();
    }
    __dp = __mp.decimal_point();
    __ts = __mp.thousands_sep();
    __grp = __mp.grouping();
    __sym = __mp.curr_symbol();
    __fd = __mp.frac_digits();
  } else {
    const moneypunct<char_type, false>& __mp = std::use_facet<moneypunct<char_type, false> >(__loc);
    if (__neg) {
      __pat = __mp.neg_format();
      __sn = __mp.negative_sign();
    } else {
      __pat = __mp.pos_format();
      __sn = __mp.positive_sign();
    }
    __dp = __mp.decimal_point();
    __ts = __mp.thousands_sep();
    __grp = __mp.grouping();
    __sym = __mp.curr_symbol();
    __fd = __mp.frac_digits();
  }
}

template <class _CharT>
void __money_put<_CharT>::__format(
    char_type* __mb,
    char_type*& __mi,
    char_type*& __me,
    ios_base::fmtflags __flags,
    const char_type* __db,
    const char_type* __de,
    const ctype<char_type>& __ct,
    bool __neg,
    const money_base::pattern& __pat,
    char_type __dp,
    char_type __ts,
    const string& __grp,
    const string_type& __sym,
    const string_type& __sn,
    int __fd) {
  __me = __mb;
  for (char __p : __pat.field) {
    switch (__p) {
    case money_base::none:
      __mi = __me;
      break;
    case money_base::space:
      __mi = __me;
      *__me++ = __ct.widen(' ');
      break;
    case money_base::sign:
      if (!__sn.empty())
        *__me++ = __sn[0];
      break;
    case money_base::symbol:
      if (!__sym.empty() && (__flags & ios_base::showbase))
        __me = std::copy(__sym.begin(), __sym.end(), __me);
      break;
    case money_base::value: {

      char_type* __t = __me;

      if (__neg)
        ++__db;

      const char_type* __d;
      for (__d = __db; __d < __de; ++__d)
        if (!__ct.is(ctype_base::digit, *__d))
          break;

      if (__fd > 0) {
        int __f;
        for (__f = __fd; __d > __db && __f > 0; --__f)
          *__me++ = *--__d;
        char_type __z = __f > 0 ? __ct.widen('0') : char_type();
        for (; __f > 0; --__f)
          *__me++ = __z;
        *__me++ = __dp;
      }

      if (__d == __db) {
        *__me++ = __ct.widen('0');
      } else {
        unsigned __ng = 0;
        unsigned __ig = 0;
        unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max() : static_cast<unsigned>(__grp[__ig]);
        while (__d != __db) {
          if (__ng == __gl) {
            *__me++ = __ts;
            __ng = 0;
            if (++__ig < __grp.size())
              __gl = __grp[__ig] == numeric_limits<char>::max()
                       ? numeric_limits<unsigned>::max()
                       : static_cast<unsigned>(__grp[__ig]);
          }
          *__me++ = *--__d;
          ++__ng;
        }
      }

      std::reverse(__t, __me);
    } break;
    }
  }

  if (__sn.size() > 1)
    __me = std::copy(__sn.begin() + 1, __sn.end(), __me);

  if ((__flags & ios_base::adjustfield) == ios_base::left)
    __mi = __me;
  else if ((__flags & ios_base::adjustfield) != ios_base::internal)
    __mi = __mb;
}

extern template class __attribute__((__visibility__("default"))) __money_put<char>;

extern template class __attribute__((__visibility__("default"))) __money_put<wchar_t>;


template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >
class money_put : public locale::facet, private __money_put<_CharT> {
public:
  typedef _CharT char_type;
  typedef _OutputIterator iter_type;
  typedef basic_string<char_type> string_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit money_put(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl, long double __units) const {
    return do_put(__s, __intl, __iob, __fl, __units);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iter_type
  put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl, const string_type& __digits) const {
    return do_put(__s, __intl, __iob, __fl, __digits);
  }

  static locale::id id;

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~money_put() override {}

  virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl, long double __units) const;
  virtual iter_type
  do_put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl, const string_type& __digits) const;
};

template <class _CharT, class _OutputIterator>
locale::id money_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator money_put<_CharT, _OutputIterator>::do_put(
    iter_type __s, bool __intl, ios_base& __iob, char_type __fl, long double __units) const {

  const size_t __bs = 100;
  char __buf[__bs];
  char* __bb = __buf;
  char_type __digits[__bs];
  char_type* __db = __digits;
  int __n = snprintf(__bb, __bs, "%.0Lf", __units);
  unique_ptr<char, void (*)(void*)> __hn(__nullptr, free);
  unique_ptr<char_type, void (*)(void*)> __hd(0, free);

  if (static_cast<size_t>(__n) > __bs - 1) {
    __n = asprintf_l(&__bb, 0, "%.0Lf", __units);
    if (__n == -1)
      __throw_bad_alloc();
    __hn.reset(__bb);
    __hd.reset((char_type*)malloc(static_cast<size_t>(__n) * sizeof(char_type)));
    if (__hd == __nullptr)
      __throw_bad_alloc();
    __db = __hd.get();
  }

  locale __loc = __iob.getloc();
  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__loc);
  __ct.widen(__bb, __bb + __n, __db);
  bool __neg = __n > 0 && __bb[0] == '-';
  money_base::pattern __pat;
  char_type __dp;
  char_type __ts;
  string __grp;
  string_type __sym;
  string_type __sn;
  int __fd;
  this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);

  char_type __mbuf[__bs];
  char_type* __mb = __mbuf;
  unique_ptr<char_type, void (*)(void*)> __hw(0, free);
  size_t __exn = __n > __fd ? (static_cast<size_t>(__n) - static_cast<size_t>(__fd)) * 2 + __sn.size() + __sym.size() +
                                  static_cast<size_t>(__fd) + 1
                            : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
  if (__exn > __bs) {
    __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));
    __mb = __hw.get();
    if (__mb == 0)
      __throw_bad_alloc();
  }

  char_type* __mi;
  char_type* __me;
  this->__format(
      __mb, __mi, __me, __iob.flags(), __db, __db + __n, __ct, __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);
  return std::__pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator money_put<_CharT, _OutputIterator>::do_put(
    iter_type __s, bool __intl, ios_base& __iob, char_type __fl, const string_type& __digits) const {

  locale __loc = __iob.getloc();
  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__loc);
  bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');
  money_base::pattern __pat;
  char_type __dp;
  char_type __ts;
  string __grp;
  string_type __sym;
  string_type __sn;
  int __fd;
  this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);

  char_type __mbuf[100];
  char_type* __mb = __mbuf;
  unique_ptr<char_type, void (*)(void*)> __h(0, free);
  size_t __exn =
      static_cast<int>(__digits.size()) > __fd
          ? (__digits.size() - static_cast<size_t>(__fd)) * 2 + __sn.size() + __sym.size() + static_cast<size_t>(__fd) +
                1
          : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
  if (__exn > 100) {
    __h.reset((char_type*)malloc(__exn * sizeof(char_type)));
    __mb = __h.get();
    if (__mb == 0)
      __throw_bad_alloc();
  }

  char_type* __mi;
  char_type* __me;
  this->__format(
      __mb,
      __mi,
      __me,
      __iob.flags(),
      __digits.data(),
      __digits.data() + __digits.size(),
      __ct,
      __neg,
      __pat,
      __dp,
      __ts,
      __grp,
      __sym,
      __sn,
      __fd);
  return std::__pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

extern template class __attribute__((__visibility__("default"))) money_put<char>;

extern template class __attribute__((__visibility__("default"))) money_put<wchar_t>;




class __attribute__((__visibility__("default"))) messages_base {
public:
  typedef intptr_t catalog;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) messages_base() {}
};

template <class _CharT>
class messages : public locale::facet, public messages_base {
public:
  typedef _CharT char_type;
  typedef basic_string<_CharT> string_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit messages(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) catalog open(const basic_string<char>& __nm, const locale& __loc) const {
    return do_open(__nm, __loc);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) string_type get(catalog __c, int __set, int __msgid, const string_type& __dflt) const {
    return do_get(__c, __set, __msgid, __dflt);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void close(catalog __c) const { do_close(__c); }

  static locale::id id;

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~messages() override {}

  virtual catalog do_open(const basic_string<char>&, const locale&) const;
  virtual string_type do_get(catalog, int __set, int __msgid, const string_type& __dflt) const;
  virtual void do_close(catalog) const;
};

template <class _CharT>
locale::id messages<_CharT>::id;

template <class _CharT>
typename messages<_CharT>::catalog messages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const {

  return (catalog)catopen(__nm.c_str(), 1);




}

template <class _CharT>
typename messages<_CharT>::string_type
messages<_CharT>::do_get(catalog __c, int __set, int __msgid, const string_type& __dflt) const {

  string __ndflt;
  __narrow_to_utf8<sizeof(char_type) * 8>()(
      std::back_inserter(__ndflt), __dflt.c_str(), __dflt.c_str() + __dflt.size());
  nl_catd __cat = (nl_catd)__c;
  _Static_assert(sizeof(catalog) >= sizeof(nl_catd), "Unexpected nl_catd type");
  char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());
  string_type __w;
  __widen_from_utf8<sizeof(char_type) * 8>()(std::back_inserter(__w), __n, __n + std::strlen(__n));
  return __w;






}

template <class _CharT>
void messages<_CharT>::do_close(catalog __c) const {

  catclose((nl_catd)__c);



}

extern template class __attribute__((__visibility__("default"))) messages<char>;

extern template class __attribute__((__visibility__("default"))) messages<wchar_t>;


template <class _CharT>
class messages_byname : public messages<_CharT> {
public:
  typedef messages_base::catalog catalog;
  typedef basic_string<_CharT> string_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit messages_byname(const char*, size_t __refs = 0) : messages<_CharT>(__refs) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit messages_byname(const string&, size_t __refs = 0) : messages<_CharT>(__refs) {}

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) ~messages_byname() override {}
};

extern template class __attribute__((__visibility__("default"))) messages_byname<char>;

extern template class __attribute__((__visibility__("default"))) messages_byname<wchar_t>;


template <class _Codecvt,
          class _Elem = wchar_t,
          class _WideAlloc = allocator<_Elem>,
          class _ByteAlloc = allocator<char> >
class wstring_convert {
public:
  typedef basic_string<char, char_traits<char>, _ByteAlloc> byte_string;
  typedef basic_string<_Elem, char_traits<_Elem>, _WideAlloc> wide_string;
  typedef typename _Codecvt::state_type state_type;
  typedef typename wide_string::traits_type::int_type int_type;

private:
  byte_string __byte_err_string_;
  wide_string __wide_err_string_;
  _Codecvt* __cvtptr_;
  state_type __cvtstate_;
  size_t __cvtcount_;

  wstring_convert(const wstring_convert& __wc);
  wstring_convert& operator=(const wstring_convert& __wc);

public:




  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) wstring_convert(_Codecvt* __pcvt = new _Codecvt);


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) wstring_convert(_Codecvt* __pcvt, state_type __state);
                               __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err = wide_string());



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~wstring_convert();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) wide_string from_bytes(char __byte) { return from_bytes(&__byte, &__byte + 1); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) wide_string from_bytes(const char* __ptr) {
    return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) wide_string from_bytes(const byte_string& __str) {
    return from_bytes(__str.data(), __str.data() + __str.size());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) wide_string from_bytes(const char* __first, const char* __last);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) byte_string to_bytes(_Elem __wchar) { return to_bytes(&__wchar, &__wchar + 1); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) byte_string to_bytes(const _Elem* __wptr) {
    return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) byte_string to_bytes(const wide_string& __wstr) {
    return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) byte_string to_bytes(const _Elem* __first, const _Elem* __last);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t converted() const throw() { return __cvtcount_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) state_type state() const { return __cvtstate_; }
};

#pragma GCC diagnostic push
# 3169 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 3169 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _WideAlloc, class _ByteAlloc>
inline wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::wstring_convert(_Codecvt* __pcvt)
    : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0) {}
#pragma GCC diagnostic pop

template <class _Codecvt, class _Elem, class _WideAlloc, class _ByteAlloc>
inline wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::wstring_convert(_Codecvt* __pcvt, state_type __state)
    : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0) {}

template <class _Codecvt, class _Elem, class _WideAlloc, class _ByteAlloc>
wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::wstring_convert(
    const byte_string& __byte_err, const wide_string& __wide_err)
    : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err), __cvtstate_(), __cvtcount_(0) {
  __cvtptr_ = new _Codecvt;
}
# 3200 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
#pragma GCC diagnostic push
# 3200 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 3200 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _WideAlloc, class _ByteAlloc>
wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::~wstring_convert() {
  delete __cvtptr_;
}

template <class _Codecvt, class _Elem, class _WideAlloc, class _ByteAlloc>
typename wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::wide_string
wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::from_bytes(const char* __frm, const char* __frm_end) {
#pragma GCC diagnostic pop
  __cvtcount_ = 0;
  if (__cvtptr_ != __nullptr) {
    wide_string __ws(2 * (__frm_end - __frm), _Elem());
    if (__frm != __frm_end)
      __ws.resize(__ws.capacity());
    codecvt_base::result __r = codecvt_base::ok;
    state_type __st = __cvtstate_;
    if (__frm != __frm_end) {
      _Elem* __to = &__ws[0];
      _Elem* __to_end = __to + __ws.size();
      const char* __frm_nxt;
      do {
        _Elem* __to_nxt;
        __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
        __cvtcount_ += __frm_nxt - __frm;
        if (__frm_nxt == __frm) {
          __r = codecvt_base::error;
        } else if (__r == codecvt_base::noconv) {
          __ws.resize(__to - &__ws[0]);

          __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);
          __frm = __frm_nxt;
          __r = codecvt_base::ok;
        } else if (__r == codecvt_base::ok) {
          __ws.resize(__to_nxt - &__ws[0]);
          __frm = __frm_nxt;
        } else if (__r == codecvt_base::partial) {
          ptrdiff_t __s = __to_nxt - &__ws[0];
          __ws.resize(2 * __s);
          __to = &__ws[0] + __s;
          __to_end = &__ws[0] + __ws.size();
          __frm = __frm_nxt;
        }
      } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
    }
    if (__r == codecvt_base::ok)
      return __ws;
  }

  if (__wide_err_string_.empty())
    __throw_range_error("wstring_convert: from_bytes error");

  return __wide_err_string_;
}

template <class _Codecvt, class _Elem, class _WideAlloc, class _ByteAlloc>
typename wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::byte_string
wstring_convert<_Codecvt, _Elem, _WideAlloc, _ByteAlloc>::to_bytes(const _Elem* __frm, const _Elem* __frm_end) {
  __cvtcount_ = 0;
  if (__cvtptr_ != __nullptr) {
    byte_string __bs(2 * (__frm_end - __frm), char());
    if (__frm != __frm_end)
      __bs.resize(__bs.capacity());
    codecvt_base::result __r = codecvt_base::ok;
    state_type __st = __cvtstate_;
    if (__frm != __frm_end) {
      char* __to = &__bs[0];
      char* __to_end = __to + __bs.size();
      const _Elem* __frm_nxt;
      do {
        char* __to_nxt;
        __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
        __cvtcount_ += __frm_nxt - __frm;
        if (__frm_nxt == __frm) {
          __r = codecvt_base::error;
        } else if (__r == codecvt_base::noconv) {
          __bs.resize(__to - &__bs[0]);

          __bs.append((const char*)__frm, (const char*)__frm_end);
          __frm = __frm_nxt;
          __r = codecvt_base::ok;
        } else if (__r == codecvt_base::ok) {
          __bs.resize(__to_nxt - &__bs[0]);
          __frm = __frm_nxt;
        } else if (__r == codecvt_base::partial) {
          ptrdiff_t __s = __to_nxt - &__bs[0];
          __bs.resize(2 * __s);
          __to = &__bs[0] + __s;
          __to_end = &__bs[0] + __bs.size();
          __frm = __frm_nxt;
        }
      } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
    }
    if (__r == codecvt_base::ok) {
      size_t __s = __bs.size();
      __bs.resize(__bs.capacity());
      char* __to = &__bs[0] + __s;
      char* __to_end = __to + __bs.size();
      do {
        char* __to_nxt;
        __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);
        if (__r == codecvt_base::noconv) {
          __bs.resize(__to - &__bs[0]);
          __r = codecvt_base::ok;
        } else if (__r == codecvt_base::ok) {
          __bs.resize(__to_nxt - &__bs[0]);
        } else if (__r == codecvt_base::partial) {
          ptrdiff_t __sp = __to_nxt - &__bs[0];
          __bs.resize(2 * __sp);
          __to = &__bs[0] + __sp;
          __to_end = &__bs[0] + __bs.size();
        }
      } while (__r == codecvt_base::partial);
      if (__r == codecvt_base::ok)
        return __bs;
    }
  }

  if (__byte_err_string_.empty())
    __throw_range_error("wstring_convert: to_bytes error");

  return __byte_err_string_;
}

template <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >
class wbuffer_convert : public basic_streambuf<_Elem, _Tr> {
public:

  typedef _Elem char_type;
  typedef _Tr traits_type;
  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::pos_type pos_type;
  typedef typename traits_type::off_type off_type;
  typedef typename _Codecvt::state_type state_type;

private:
  char* __extbuf_;
  const char* __extbufnext_;
  const char* __extbufend_;
  char __extbuf_min_[8];
  size_t __ebs_;
  char_type* __intbuf_;
  size_t __ibs_;
  streambuf* __bufptr_;
  _Codecvt* __cv_;
  state_type __st_;
  ios_base::openmode __cm_;
  bool __owns_eb_;
  bool __owns_ib_;
  bool __always_noconv_;

  wbuffer_convert(const wbuffer_convert&);
  wbuffer_convert& operator=(const wbuffer_convert&);

public:





                               __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  wbuffer_convert(streambuf* __bytebuf = __nullptr, _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~wbuffer_convert();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) streambuf* rdbuf() const { return __bufptr_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) streambuf* rdbuf(streambuf* __bytebuf) {
    streambuf* __r = __bufptr_;
    __bufptr_ = __bytebuf;
    return __r;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) state_type state() const { return __st_; }

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) virtual int_type underflow();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) virtual int_type pbackfail(int_type __c = traits_type::eof());
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) virtual int_type overflow(int_type __c = traits_type::eof());
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s, streamsize __n);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) virtual pos_type
  seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __wch = ios_base::in | ios_base::out);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) virtual pos_type
  seekpos(pos_type __sp, ios_base::openmode __wch = ios_base::in | ios_base::out);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) virtual int sync();

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) bool __read_mode();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) void __write_mode();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) wbuffer_convert* __close();
};

#pragma GCC diagnostic push
# 3392 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 3392 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)
    : __extbuf_(__nullptr),
      __extbufnext_(__nullptr),
      __extbufend_(__nullptr),
      __ebs_(0),
      __intbuf_(0),
      __ibs_(0),
      __bufptr_(__bytebuf),
      __cv_(__pcvt),
      __st_(__state),
      __cm_(0),
      __owns_eb_(false),
      __owns_ib_(false),
      __always_noconv_(__cv_ ? __cv_->always_noconv() : false) {
  setbuf(0, 4096);
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert() {
  __close();
  delete __cv_;
  if (__owns_eb_)
    delete[] __extbuf_;
  if (__owns_ib_)
    delete[] __intbuf_;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type wbuffer_convert<_Codecvt, _Elem, _Tr>::underflow() {
#pragma GCC diagnostic pop
  if (__cv_ == 0 || __bufptr_ == __nullptr)
    return traits_type::eof();
  bool __initial = __read_mode();
  char_type __1buf;
  if (this->gptr() == 0)
    this->setg(&__1buf, &__1buf + 1, &__1buf + 1);
  const size_t __unget_sz = __initial ? 0 : std::min<size_t>((this->egptr() - this->eback()) / 2, 4);
  int_type __c = traits_type::eof();
  if (this->gptr() == this->egptr()) {
    std::memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));
    if (__always_noconv_) {
      streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);
      __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);
      if (__nmemb != 0) {
        this->setg(this->eback(), this->eback() + __unget_sz, this->eback() + __unget_sz + __nmemb);
        __c = *this->gptr();
      }
    } else {
      if (__extbufend_ != __extbufnext_) {
        ((void)0);
        ((void)0);
        std::memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
      }
      __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
      __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
      streamsize __nmemb = std::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),
                                    static_cast<streamsize>(__extbufend_ - __extbufnext_));
      codecvt_base::result __r;


      streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);
      if (__nr != 0) {
        __extbufend_ = __extbufnext_ + __nr;
        char_type* __inext;
        __r = __cv_->in(
            __st_, __extbuf_, __extbufend_, __extbufnext_, this->eback() + __unget_sz, this->egptr(), __inext);
        if (__r == codecvt_base::noconv) {
          this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)const_cast<char*>(__extbufend_));
          __c = *this->gptr();
        } else if (__inext != this->eback() + __unget_sz) {
          this->setg(this->eback(), this->eback() + __unget_sz, __inext);
          __c = *this->gptr();
        }
      }
    }
  } else
    __c = *this->gptr();
  if (this->eback() == &__1buf)
    this->setg(0, 0, 0);
  return __c;
}

#pragma GCC diagnostic push
# 3476 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 3476 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c) {
#pragma GCC diagnostic pop
  if (__cv_ != 0 && __bufptr_ && this->eback() < this->gptr()) {
    if (traits_type::eq_int_type(__c, traits_type::eof())) {
      this->gbump(-1);
      return traits_type::not_eof(__c);
    }
    if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1])) {
      this->gbump(-1);
      *this->gptr() = traits_type::to_char_type(__c);
      return __c;
    }
  }
  return traits_type::eof();
}

#pragma GCC diagnostic push
# 3495 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 3495 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type wbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c) {
#pragma GCC diagnostic pop
  if (__cv_ == 0 || !__bufptr_)
    return traits_type::eof();
  __write_mode();
  char_type __1buf;
  char_type* __pb_save = this->pbase();
  char_type* __epb_save = this->epptr();
  if (!traits_type::eq_int_type(__c, traits_type::eof())) {
    if (this->pptr() == 0)
      this->setp(&__1buf, &__1buf + 1);
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }
  if (this->pptr() != this->pbase()) {
    if (__always_noconv_) {
      streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());
      if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
        return traits_type::eof();
    } else {
      char* __extbe = __extbuf_;
      codecvt_base::result __r;
      do {
        const char_type* __e;
        __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e, __extbuf_, __extbuf_ + __ebs_, __extbe);
        if (__e == this->pbase())
          return traits_type::eof();
        if (__r == codecvt_base::noconv) {
          streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
          if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)
            return traits_type::eof();
        } else if (__r == codecvt_base::ok || __r == codecvt_base::partial) {
          streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);
          if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
            return traits_type::eof();
          if (__r == codecvt_base::partial) {
            this->setp(const_cast<char_type*>(__e), this->pptr());
            this->__pbump(this->epptr() - this->pbase());
          }
        } else
          return traits_type::eof();
      } while (__r == codecvt_base::partial);
    }
    this->setp(__pb_save, __epb_save);
  }
  return traits_type::not_eof(__c);
}

#pragma GCC diagnostic push
# 3545 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 3545 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _Tr>
basic_streambuf<_Elem, _Tr>* wbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n) {
#pragma GCC diagnostic pop
  this->setg(0, 0, 0);
  this->setp(0, 0);
  if (__owns_eb_)
    delete[] __extbuf_;
  if (__owns_ib_)
    delete[] __intbuf_;
  __ebs_ = __n;
  if (__ebs_ > sizeof(__extbuf_min_)) {
    if (__always_noconv_ && __s) {
      __extbuf_ = (char*)__s;
      __owns_eb_ = false;
    } else {
      __extbuf_ = new char[__ebs_];
      __owns_eb_ = true;
    }
  } else {
    __extbuf_ = __extbuf_min_;
    __ebs_ = sizeof(__extbuf_min_);
    __owns_eb_ = false;
  }
  if (!__always_noconv_) {
    __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));
    if (__s && __ibs_ >= sizeof(__extbuf_min_)) {
      __intbuf_ = __s;
      __owns_ib_ = false;
    } else {
      __intbuf_ = new char_type[__ibs_];
      __owns_ib_ = true;
    }
  } else {
    __ibs_ = 0;
    __intbuf_ = 0;
    __owns_ib_ = false;
  }
  return this;
}

#pragma GCC diagnostic push
# 3586 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 3586 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __om) {
  int __width = __cv_->encoding();
  if (__cv_ == 0 || !__bufptr_ || (__width <= 0 && __off != 0) || sync())
    return pos_type(off_type(-1));

  if (__way != ios_base::beg && __way != ios_base::cur && __way != ios_base::end)
    return pos_type(off_type(-1));
  pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);
  __r.state(__st_);
  return __r;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch) {
  if (__cv_ == 0 || !__bufptr_ || sync())
    return pos_type(off_type(-1));
  if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))
    return pos_type(off_type(-1));
  return __sp;
}

template <class _Codecvt, class _Elem, class _Tr>
int wbuffer_convert<_Codecvt, _Elem, _Tr>::sync() {
#pragma GCC diagnostic pop
  if (__cv_ == 0 || !__bufptr_)
    return 0;
  if (__cm_ & ios_base::out) {
    if (this->pptr() != this->pbase())
      if (overflow() == traits_type::eof())
        return -1;
    codecvt_base::result __r;
    do {
      char* __extbe;
      __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
      streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);
      if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
        return -1;
    } while (__r == codecvt_base::partial);
    if (__r == codecvt_base::error)
      return -1;
    if (__bufptr_->pubsync())
      return -1;
  } else if (__cm_ & ios_base::in) {
    off_type __c;
    if (__always_noconv_)
      __c = this->egptr() - this->gptr();
    else {
      int __width = __cv_->encoding();
      __c = __extbufend_ - __extbufnext_;
      if (__width > 0)
        __c += __width * (this->egptr() - this->gptr());
      else {
        if (this->gptr() != this->egptr()) {
          std::reverse(this->gptr(), this->egptr());
          codecvt_base::result __r;
          const char_type* __e = this->gptr();
          char* __extbe;
          do {
            __r = __cv_->out(__st_, __e, this->egptr(), __e, __extbuf_, __extbuf_ + __ebs_, __extbe);
            switch (__r) {
            case codecvt_base::noconv:
              __c += this->egptr() - this->gptr();
              break;
            case codecvt_base::ok:
            case codecvt_base::partial:
              __c += __extbe - __extbuf_;
              break;
            default:
              return -1;
            }
          } while (__r == codecvt_base::partial);
        }
      }
    }
    if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))
      return -1;
    this->setg(0, 0, 0);
    __cm_ = 0;
  }
  return 0;
}

#pragma GCC diagnostic push
# 3672 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 3672 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Codecvt, class _Elem, class _Tr>
bool wbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode() {
  if (!(__cm_ & ios_base::in)) {
    this->setp(0, 0);
    if (__always_noconv_)
      this->setg((char_type*)__extbuf_, (char_type*)__extbuf_ + __ebs_, (char_type*)__extbuf_ + __ebs_);
    else
      this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
    __cm_ = ios_base::in;
    return true;
  }
  return false;
}

template <class _Codecvt, class _Elem, class _Tr>
void wbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode() {
  if (!(__cm_ & ios_base::out)) {
    this->setg(0, 0, 0);
    if (__ebs_ > sizeof(__extbuf_min_)) {
      if (__always_noconv_)
        this->setp((char_type*)__extbuf_, (char_type*)__extbuf_ + (__ebs_ - 1));
      else
        this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
    } else
      this->setp(0, 0);
    __cm_ = ios_base::out;
  }
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>* wbuffer_convert<_Codecvt, _Elem, _Tr>::__close() {
  wbuffer_convert* __rt = __nullptr;
  if (__cv_ != __nullptr && __bufptr_ != __nullptr) {
    __rt = this;
    if ((__cm_ & ios_base::out) && sync())
      __rt = __nullptr;
  }
  return __rt;
}

#pragma GCC diagnostic pop

}}
# 3724 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdarg" 1 3
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdarg" 3
# 1 "/Library/Developer/CommandLineTools/usr/lib/clang/16/include/stdarg.h" 1 3
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdarg" 2 3
# 47 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cstdarg" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::va_list __attribute__((__using_if_exists__));

}}
# 3725 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/locale" 2 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_integral.h" 2 3
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_integral.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_integral.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 441 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_integral.h" 3
}}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_bool.h" 2 3
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_bool.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_bool.h" 3
}}
# 326 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3
# 338 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/temp_value.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/temp_value.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Alloc>
struct __temp_value {
  typedef allocator_traits<_Alloc> _Traits;


  typename aligned_storage<sizeof(_Tp), _Alignof(_Tp)>::type __v;





  _Alloc& __a;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp* __addr() {

    return reinterpret_cast<_Tp*>(std::addressof(__v));



  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp& get() { return *__addr(); }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __attribute__((__no_sanitize__("cfi"))) __temp_value(_Alloc& __alloc, _Args&&... __args)
      : __a(__alloc) {
    _Traits::construct(__a, __addr(), std::forward<_Args>(__args)...);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~__temp_value() { _Traits::destroy(__a, __addr()); }
};

}}
# 339 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__split_buffer" 1 3
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__split_buffer" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__split_buffer" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





template <class _Tp, class _Allocator = allocator<_Tp> >
struct __split_buffer {
public:
  using value_type = _Tp;
  using allocator_type = _Allocator;
  using __alloc_rr = __libcpp_remove_reference_t<allocator_type>;
  using __alloc_traits = allocator_traits<__alloc_rr>;
  using reference = value_type&;
  using const_reference = const value_type&;
  using size_type = typename __alloc_traits::size_type;
  using difference_type = typename __alloc_traits::difference_type;
  using pointer = typename __alloc_traits::pointer;
  using const_pointer = typename __alloc_traits::const_pointer;
  using iterator = pointer;
  using const_iterator = const_pointer;

  pointer __first_;
  pointer __begin_;
  pointer __end_;
  __compressed_pair<pointer, allocator_type> __end_cap_;

  using __alloc_ref = __add_lvalue_reference_t<allocator_type>;
  using __alloc_const_ref = __add_lvalue_reference_t<allocator_type>;

  __split_buffer(const __split_buffer&) = delete;
  __split_buffer& operator=(const __split_buffer&) = delete;

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __split_buffer()

      : __first_(__nullptr), __begin_(__nullptr), __end_(__nullptr), __end_cap_(__nullptr, __default_init_tag()) {}

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __split_buffer(__alloc_rr& __a)
      : __first_(__nullptr), __begin_(__nullptr), __end_(__nullptr), __end_cap_(__nullptr, __a) {}

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __split_buffer(const __alloc_rr& __a)
      : __first_(__nullptr), __begin_(__nullptr), __end_(__nullptr), __end_cap_(__nullptr, __a) {}

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __split_buffer(__split_buffer&& __c)
                                                                      ;

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __split_buffer& operator=(__split_buffer&& __c)


                                                                                ;

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~__split_buffer();

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __alloc_rr& __alloc() throw() { return __end_cap_.second(); }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const __alloc_rr& __alloc() const throw() {
    return __end_cap_.second();
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer& __end_cap() throw() { return __end_cap_.first(); }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const pointer& __end_cap() const throw() {
    return __end_cap_.first();
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator begin() throw() { return __begin_; }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator begin() const throw() { return __begin_; }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator end() throw() { return __end_; }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator end() const throw() { return __end_; }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void clear() throw() { __destruct_at_end(__begin_); }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type size() const {
    return static_cast<size_type>(__end_ - __begin_);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool empty() const { return __end_ == __begin_; }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type capacity() const {
    return static_cast<size_type>(__end_cap() - __first_);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type __front_spare() const {
    return static_cast<size_type>(__begin_ - __first_);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type __back_spare() const {
    return static_cast<size_type>(__end_cap() - __end_);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference front() { return *__begin_; }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference front() const { return *__begin_; }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference back() { return *(__end_ - 1); }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference back() const { return *(__end_ - 1); }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void reserve(size_type __n);
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void shrink_to_fit() throw();
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void push_front(const_reference __x);
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void push_back(const_reference __x);
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void push_front(value_type&& __x);
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void push_back(value_type&& __x);

  template <class... _Args>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void emplace_back(_Args&&... __args);

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void pop_front() { __destruct_at_begin(__begin_ + 1); }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void pop_back() { __destruct_at_end(__end_ - 1); }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __construct_at_end(size_type __n);
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __construct_at_end(size_type __n, const_reference __x);

  template <class _InputIter, __enable_if_t<__has_exactly_input_iterator_category<_InputIter>::value, int> = 0>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __construct_at_end(_InputIter __first, _InputIter __last);

  template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);

  template <class _Iterator, class _Sentinel>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __construct_at_end_with_sentinel(_Iterator __first, _Sentinel __last);

  template <class _Iterator>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __construct_at_end_with_size(_Iterator __first, size_type __n);

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __destruct_at_begin(pointer __new_begin) {
    __destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __destruct_at_begin(pointer __new_begin, false_type);
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __destruct_at_begin(pointer __new_begin, true_type);

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __destruct_at_end(pointer __new_last) throw() {
    __destruct_at_end(__new_last, false_type());
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __destruct_at_end(pointer __new_last, false_type) throw();
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __destruct_at_end(pointer __new_last, true_type) throw();

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(__split_buffer& __x)
                                                                                                                  ;

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __invariants() const;

private:
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign_alloc(__split_buffer& __c, true_type)
                                                                    {
    __alloc() = std::move(__c.__alloc());
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign_alloc(__split_buffer&, false_type) throw() {}

  struct _ConstructTransaction {
                                  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit _ConstructTransaction(
        pointer* __p, size_type __n) throw()
        : __pos_(*__p),
          __end_(*__p + __n),
          __dest_(__p) {}

                                  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~_ConstructTransaction() { *__dest_ = __pos_; }

    pointer __pos_;
    const pointer __end_;

  private:
    pointer* __dest_;
  };
};

template <class _Tp, class _Allocator>
                              bool __split_buffer<_Tp, _Allocator>::__invariants() const {
  if (__first_ == __nullptr) {
    if (__begin_ != __nullptr)
      return false;
    if (__end_ != __nullptr)
      return false;
    if (__end_cap() != __nullptr)
      return false;
  } else {
    if (__begin_ < __first_)
      return false;
    if (__end_ < __begin_)
      return false;
    if (__end_cap() < __end_)
      return false;
  }
  return true;
}






template <class _Tp, class _Allocator>
                              void __split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n) {
  _ConstructTransaction __tx(&this->__end_, __n);
  for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
    __alloc_traits::construct(this->__alloc(), std::__to_address(__tx.__pos_));
  }
}







template <class _Tp, class _Allocator>
                              void
__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x) {
  _ConstructTransaction __tx(&this->__end_, __n);
  for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
    __alloc_traits::construct(this->__alloc(), std::__to_address(__tx.__pos_), __x);
  }
}

template <class _Tp, class _Allocator>
template <class _InputIter, __enable_if_t<__has_exactly_input_iterator_category<_InputIter>::value, int> >
                              void
__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last) {
  __construct_at_end_with_sentinel(__first, __last);
}

template <class _Tp, class _Allocator>
template <class _Iterator, class _Sentinel>
                              void
__split_buffer<_Tp, _Allocator>::__construct_at_end_with_sentinel(_Iterator __first, _Sentinel __last) {
  __alloc_rr& __a = this->__alloc();
  for (; __first != __last; ++__first) {
    if (__end_ == __end_cap()) {
      size_type __old_cap = __end_cap() - __first_;
      size_type __new_cap = std::max<size_type>(2 * __old_cap, 8);
      __split_buffer __buf(__new_cap, 0, __a);
      for (pointer __p = __begin_; __p != __end_; ++__p, (void)++__buf.__end_)
        __alloc_traits::construct(__buf.__alloc(), std::__to_address(__buf.__end_), std::move(*__p));
      swap(__buf);
    }
    __alloc_traits::construct(__a, std::__to_address(this->__end_), *__first);
    ++this->__end_;
  }
}
template <class _Tp, class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
                              void
__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last) {
  __construct_at_end_with_size(__first, std::distance(__first, __last));
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
                              void
__split_buffer<_Tp, _Allocator>::__construct_at_end_with_size(_ForwardIterator __first, size_type __n) {
  _ConstructTransaction __tx(&this->__end_, __n);
  for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_, (void)++__first) {
    __alloc_traits::construct(this->__alloc(), std::__to_address(__tx.__pos_), *__first);
  }
}

template <class _Tp, class _Allocator>
                              inline void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type) {
  while (__begin_ != __new_begin)
    __alloc_traits::destroy(__alloc(), std::__to_address(__begin_++));
}

template <class _Tp, class _Allocator>
                              inline void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type) {
  __begin_ = __new_begin;
}

template <class _Tp, class _Allocator>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) throw() {
  while (__new_last != __end_)
    __alloc_traits::destroy(__alloc(), std::__to_address(--__end_));
}

template <class _Tp, class _Allocator>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) throw() {
  __end_ = __new_last;
}

template <class _Tp, class _Allocator>

__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)
    : __end_cap_(__nullptr, __a) {
  if (__cap == 0) {
    __first_ = __nullptr;
  } else {
    auto __allocation = std::__allocate_at_least(__alloc(), __cap);
    __first_ = __allocation.ptr;
    __cap = __allocation.count;
  }
  __begin_ = __end_ = __first_ + __start;
  __end_cap() = __first_ + __cap;
}

template <class _Tp, class _Allocator>
                              __split_buffer<_Tp, _Allocator>::~__split_buffer() {
  clear();
  if (__first_)
    __alloc_traits::deallocate(__alloc(), __first_, capacity());
}

template <class _Tp, class _Allocator>
                              __split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)

    : __first_(std::move(__c.__first_)),
      __begin_(std::move(__c.__begin_)),
      __end_(std::move(__c.__end_)),
      __end_cap_(std::move(__c.__end_cap_)) {
  __c.__first_ = __nullptr;
  __c.__begin_ = __nullptr;
  __c.__end_ = __nullptr;
  __c.__end_cap() = __nullptr;
}

template <class _Tp, class _Allocator>

__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)
    : __end_cap_(__nullptr, __a) {
  if (__a == __c.__alloc()) {
    __first_ = __c.__first_;
    __begin_ = __c.__begin_;
    __end_ = __c.__end_;
    __end_cap() = __c.__end_cap();
    __c.__first_ = __nullptr;
    __c.__begin_ = __nullptr;
    __c.__end_ = __nullptr;
    __c.__end_cap() = __nullptr;
  } else {
    auto __allocation = std::__allocate_at_least(__alloc(), __c.size());
    __first_ = __allocation.ptr;
    __begin_ = __end_ = __first_;
    __end_cap() = __first_ + __allocation.count;
    typedef move_iterator<iterator> _Ip;
    __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));
  }
}

template <class _Tp, class _Allocator>
                              __split_buffer<_Tp, _Allocator>&
__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)


                                                                               {
  clear();
  shrink_to_fit();
  __first_ = __c.__first_;
  __begin_ = __c.__begin_;
  __end_ = __c.__end_;
  __end_cap() = __c.__end_cap();
  __move_assign_alloc(__c, integral_constant<bool, __alloc_traits::propagate_on_container_move_assignment::value>());
  __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = __nullptr;
  return *this;
}

template <class _Tp, class _Allocator>
                              void __split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)
                                                                                                                 {
  std::swap(__first_, __x.__first_);
  std::swap(__begin_, __x.__begin_);
  std::swap(__end_, __x.__end_);
  std::swap(__end_cap(), __x.__end_cap());
  std::__swap_allocator(__alloc(), __x.__alloc());
}

template <class _Tp, class _Allocator>
                              void __split_buffer<_Tp, _Allocator>::reserve(size_type __n) {
  if (__n < capacity()) {
    __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());
    __t.__construct_at_end(move_iterator<pointer>(__begin_), move_iterator<pointer>(__end_));
    std::swap(__first_, __t.__first_);
    std::swap(__begin_, __t.__begin_);
    std::swap(__end_, __t.__end_);
    std::swap(__end_cap(), __t.__end_cap());
  }
}

template <class _Tp, class _Allocator>
                              void __split_buffer<_Tp, _Allocator>::shrink_to_fit() throw() {
  if (capacity() > size()) {

    try {

      __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());
      __t.__construct_at_end(move_iterator<pointer>(__begin_), move_iterator<pointer>(__end_));
      __t.__end_ = __t.__begin_ + (__end_ - __begin_);
      std::swap(__first_, __t.__first_);
      std::swap(__begin_, __t.__begin_);
      std::swap(__end_, __t.__end_);
      std::swap(__end_cap(), __t.__end_cap());

    } catch (...) {
    }

  }
}

template <class _Tp, class _Allocator>
                              void __split_buffer<_Tp, _Allocator>::push_front(const_reference __x) {
  if (__begin_ == __first_) {
    if (__end_ < __end_cap()) {
      difference_type __d = __end_cap() - __end_;
      __d = (__d + 1) / 2;
      __begin_ = std::move_backward(__begin_, __end_, __end_ + __d);
      __end_ += __d;
    } else {
      size_type __c = std::max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
      __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());
      __t.__construct_at_end(move_iterator<pointer>(__begin_), move_iterator<pointer>(__end_));
      std::swap(__first_, __t.__first_);
      std::swap(__begin_, __t.__begin_);
      std::swap(__end_, __t.__end_);
      std::swap(__end_cap(), __t.__end_cap());
    }
  }
  __alloc_traits::construct(__alloc(), std::__to_address(__begin_ - 1), __x);
  --__begin_;
}

template <class _Tp, class _Allocator>
                              void __split_buffer<_Tp, _Allocator>::push_front(value_type&& __x) {
  if (__begin_ == __first_) {
    if (__end_ < __end_cap()) {
      difference_type __d = __end_cap() - __end_;
      __d = (__d + 1) / 2;
      __begin_ = std::move_backward(__begin_, __end_, __end_ + __d);
      __end_ += __d;
    } else {
      size_type __c = std::max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
      __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());
      __t.__construct_at_end(move_iterator<pointer>(__begin_), move_iterator<pointer>(__end_));
      std::swap(__first_, __t.__first_);
      std::swap(__begin_, __t.__begin_);
      std::swap(__end_, __t.__end_);
      std::swap(__end_cap(), __t.__end_cap());
    }
  }
  __alloc_traits::construct(__alloc(), std::__to_address(__begin_ - 1), std::move(__x));
  --__begin_;
}

template <class _Tp, class _Allocator>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__split_buffer<_Tp, _Allocator>::push_back(const_reference __x) {
  if (__end_ == __end_cap()) {
    if (__begin_ > __first_) {
      difference_type __d = __begin_ - __first_;
      __d = (__d + 1) / 2;
      __end_ = std::move(__begin_, __end_, __begin_ - __d);
      __begin_ -= __d;
    } else {
      size_type __c = std::max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
      __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
      __t.__construct_at_end(move_iterator<pointer>(__begin_), move_iterator<pointer>(__end_));
      std::swap(__first_, __t.__first_);
      std::swap(__begin_, __t.__begin_);
      std::swap(__end_, __t.__end_);
      std::swap(__end_cap(), __t.__end_cap());
    }
  }
  __alloc_traits::construct(__alloc(), std::__to_address(__end_), __x);
  ++__end_;
}

template <class _Tp, class _Allocator>
                              void __split_buffer<_Tp, _Allocator>::push_back(value_type&& __x) {
  if (__end_ == __end_cap()) {
    if (__begin_ > __first_) {
      difference_type __d = __begin_ - __first_;
      __d = (__d + 1) / 2;
      __end_ = std::move(__begin_, __end_, __begin_ - __d);
      __begin_ -= __d;
    } else {
      size_type __c = std::max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
      __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
      __t.__construct_at_end(move_iterator<pointer>(__begin_), move_iterator<pointer>(__end_));
      std::swap(__first_, __t.__first_);
      std::swap(__begin_, __t.__begin_);
      std::swap(__end_, __t.__end_);
      std::swap(__end_cap(), __t.__end_cap());
    }
  }
  __alloc_traits::construct(__alloc(), std::__to_address(__end_), std::move(__x));
  ++__end_;
}

template <class _Tp, class _Allocator>
template <class... _Args>
                              void __split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args) {
  if (__end_ == __end_cap()) {
    if (__begin_ > __first_) {
      difference_type __d = __begin_ - __first_;
      __d = (__d + 1) / 2;
      __end_ = std::move(__begin_, __end_, __begin_ - __d);
      __begin_ -= __d;
    } else {
      size_type __c = std::max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
      __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
      __t.__construct_at_end(move_iterator<pointer>(__begin_), move_iterator<pointer>(__end_));
      std::swap(__first_, __t.__first_);
      std::swap(__begin_, __t.__begin_);
      std::swap(__end_, __t.__end_);
      std::swap(__end_cap(), __t.__end_cap());
    }
  }
  __alloc_traits::construct(__alloc(), std::__to_address(__end_), std::forward<_Args>(__args)...);
  ++__end_;
}

template <class _Tp, class _Allocator>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
swap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y) {
  __x.swap(__y);
}

}}
# 347 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3
# 379 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 383 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Allocator >
class vector {
private:
  typedef allocator<_Tp> __default_allocator_type;

public:
  typedef vector __self;
  typedef _Tp value_type;
  typedef _Allocator allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;

  typedef __wrap_iter<pointer> iterator;
  typedef __wrap_iter<const_pointer> const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

  _Static_assert((is_same<typename allocator_type::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");


  _Static_assert(is_same<allocator_type, __rebind_alloc<__alloc_traits, value_type> >::value, "[allocator.requirements] states that rebinding an allocator to the same type should result in the " "original allocator");



                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector()
                                                                          {}
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit vector(const allocator_type& __a)





      : __end_cap_(__nullptr, __a) {
  }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit vector(size_type __n);



                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector(size_type __n, const value_type& __x);

  template <class = __enable_if_t<__is_allocator<_Allocator>::value> >
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  vector(size_type __n, const value_type& __x, const allocator_type& __a)
      : __end_cap_(__nullptr, __a) {
    if (__n > 0) {
      __vallocate(__n);
      __construct_at_end(__n, __x);
    }
  }

  template <class _InputIterator,
            __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value &&
                              is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value,
                          int> = 0>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector(_InputIterator __first, _InputIterator __last);
  template <class _InputIterator,
            __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value &&
                              is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value,
                          int> = 0>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a);

  template <
      class _ForwardIterator,
      __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value &&
                        is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value,
                    int> = 0>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector(_ForwardIterator __first, _ForwardIterator __last);

  template <
      class _ForwardIterator,
      __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value &&
                        is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value,
                    int> = 0>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a);
# 483 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
private:
  class __destroy_vector {
  public:
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __destroy_vector(vector& __vec) : __vec_(__vec) {}

                                  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator()() {
      if (__vec_.__begin_ != __nullptr) {
        __vec_.__clear();
        __vec_.__annotate_delete();
        __alloc_traits::deallocate(__vec_.__alloc(), __vec_.__begin_, __vec_.capacity());
      }
    }

  private:
    vector& __vec_;
  };

public:
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~vector() { __destroy_vector (*this)(); }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector(const vector& __x);
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  vector(const vector& __x, const __type_identity_t<allocator_type>& __a);
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector& operator=(const vector& __x);
# 520 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector(vector&& __x)



                                                                      ;


                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  vector(vector&& __x, const __type_identity_t<allocator_type>& __a);
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector& operator=(vector&& __x)
                                                                                       ;

  template <class _InputIterator,
            __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value &&
                              is_constructible<value_type, typename iterator_traits<_InputIterator>::reference>::value,
                          int> = 0>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void assign(_InputIterator __first, _InputIterator __last);
  template <
      class _ForwardIterator,
      __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value &&
                        is_constructible<value_type, typename iterator_traits<_ForwardIterator>::reference>::value,
                    int> = 0>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void assign(_ForwardIterator __first, _ForwardIterator __last);
# 557 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void assign(size_type __n, const_reference __u);







                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) allocator_type get_allocator() const throw() {
    return this->__alloc();
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator begin() throw();
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator begin() const throw();
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator end() throw();
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator end() const throw();

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator rbegin() throw() {
    return reverse_iterator(end());
  }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator rbegin() const throw() {
    return const_reverse_iterator(end());
  }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator rend() throw() {
    return reverse_iterator(begin());
  }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator rend() const throw() {
    return const_reverse_iterator(begin());
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator cbegin() const throw() { return begin(); }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator cend() const throw() { return end(); }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator crbegin() const throw() {
    return rbegin();
  }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator crend() const throw() { return rend(); }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type size() const throw() {
    return static_cast<size_type>(this->__end_ - this->__begin_);
  }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type capacity() const throw() {
    return static_cast<size_type>(__end_cap() - this->__begin_);
  }
                                                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool empty() const throw() {
    return this->__begin_ == this->__end_;
  }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type max_size() const throw();
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void reserve(size_type __n);
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void shrink_to_fit() throw();

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator[](size_type __n) throw();
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference operator[](size_type __n) const throw();
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference at(size_type __n);
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference at(size_type __n) const;

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference front() throw() {
    ((void)0);
    return *this->__begin_;
  }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference front() const throw() {
    ((void)0);
    return *this->__begin_;
  }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference back() throw() {
    ((void)0);
    return *(this->__end_ - 1);
  }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference back() const throw() {
    ((void)0);
    return *(this->__end_ - 1);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) value_type* data() throw() {
    return std::__to_address(this->__begin_);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const value_type* data() const throw() {
    return std::__to_address(this->__begin_);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void push_back(const_reference __x);

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void push_back(value_type&& __x);

  template <class... _Args>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))




      void
      emplace_back(_Args&&... __args);
# 658 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void pop_back();

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator insert(const_iterator __position, const_reference __x);

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator insert(const_iterator __position, value_type&& __x);
  template <class... _Args>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator emplace(const_iterator __position, _Args&&... __args);

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator
  insert(const_iterator __position, size_type __n, const_reference __x);

  template <class _InputIterator,
            __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value &&
                              is_constructible< value_type, typename iterator_traits<_InputIterator>::reference>::value,
                          int> = 0>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator
  insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
# 689 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
  template <
      class _ForwardIterator,
      __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value &&
                        is_constructible< value_type, typename iterator_traits<_ForwardIterator>::reference>::value,
                    int> = 0>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator
  insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);
# 704 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator erase(const_iterator __position);
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator erase(const_iterator __first, const_iterator __last);

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void clear() throw() {
    size_type __old_size = size();
    __clear();
    __annotate_shrink(__old_size);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void resize(size_type __sz);
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void resize(size_type __sz, const_reference __x);

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(vector&)



                                                                                                                      ;


                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __invariants() const;

private:
  pointer __begin_ = __nullptr;
  pointer __end_ = __nullptr;
  __compressed_pair<pointer, allocator_type> __end_cap_ =
      __compressed_pair<pointer, allocator_type>(__nullptr, __default_init_tag());
# 738 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __vallocate(size_type __n) {
    if (__n > max_size())
      __throw_length_error();
    auto __allocation = std::__allocate_at_least(__alloc(), __n);
    __begin_ = __allocation.ptr;
    __end_ = __allocation.ptr;
    __end_cap() = __begin_ + __allocation.count;
    __annotate_new(0);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __vdeallocate() throw();
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type __recommend(size_type __new_size) const;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __construct_at_end(size_type __n);
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __construct_at_end(size_type __n, const_reference __x);

  template <class _InputIterator, class _Sentinel>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __init_with_size(_InputIterator __first, _Sentinel __last, size_type __n) {
    auto __guard = std::__make_exception_guard(__destroy_vector(*this));

    if (__n > 0) {
      __vallocate(__n);
      __construct_at_end(__first, __last, __n);
    }

    __guard.__complete();
  }

  template <class _InputIterator, class _Sentinel>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __init_with_sentinel(_InputIterator __first, _Sentinel __last) {
    auto __guard = std::__make_exception_guard(__destroy_vector(*this));

    for (; __first != __last; ++__first)
      emplace_back(*__first);

    __guard.__complete();
  }

  template <class _Iterator, class _Sentinel>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __assign_with_sentinel(_Iterator __first, _Sentinel __last);

  template <class _ForwardIterator, class _Sentinel>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __assign_with_size(_ForwardIterator __first, _Sentinel __last, difference_type __n);

  template <class _InputIterator, class _Sentinel>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator
  __insert_with_sentinel(const_iterator __position, _InputIterator __first, _Sentinel __last);

  template <class _Iterator, class _Sentinel>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator
  __insert_with_size(const_iterator __position, _Iterator __first, _Sentinel __last, difference_type __n);

  template <class _InputIterator, class _Sentinel>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __construct_at_end(_InputIterator __first, _Sentinel __last, size_type __n);

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __append(size_type __n);
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __append(size_type __n, const_reference __x);
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator __make_iter(pointer __p) throw() {
    return iterator(__p);
  }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator __make_iter(const_pointer __p) const throw() {
    return const_iterator(__p);
  }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer
  __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __move_range(pointer __from_s, pointer __from_e, pointer __to);
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign(vector& __c, true_type)
                                                                   ;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign(vector& __c, false_type)
                                                        ;
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __destruct_at_end(pointer __new_last) throw() {
    size_type __old_size = size();
    __base_destruct_at_end(__new_last);
    __annotate_shrink(__old_size);
  }

  template <class _Up>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline pointer __push_back_slow_path(_Up&& __x);

  template <class... _Args>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline pointer __emplace_back_slow_path(_Args&&... __args);
# 834 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __annotate_contiguous_container(
      const void* __old_mid, const void* __new_mid) const {
    (void)__old_mid;
    (void)__new_mid;







  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __annotate_new(size_type __current_size) const throw() {
    (void)__current_size;



  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __annotate_delete() const throw() {



  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __annotate_increase(size_type __n) const throw() {
    (void)__n;



  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __annotate_shrink(size_type __old_size) const throw() {
    (void)__old_size;



  }

  struct _ConstructTransaction {
                                  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit _ConstructTransaction(vector& __v, size_type __n)
        : __v_(__v), __pos_(__v.__end_), __new_end_(__v.__end_ + __n) {



    }
                                  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~_ConstructTransaction() {
      __v_.__end_ = __pos_;





    }

    vector& __v_;
    pointer __pos_;
    const_pointer const __new_end_;

  private:
    _ConstructTransaction(_ConstructTransaction const&) = delete;
    _ConstructTransaction& operator=(_ConstructTransaction const&) = delete;
  };

  template <class... _Args>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __construct_one_at_end(_Args&&... __args) {
    _ConstructTransaction __tx(*this, 1);
    __alloc_traits::construct(this->__alloc(), std::__to_address(__tx.__pos_), std::forward<_Args>(__args)...);
    ++__tx.__pos_;
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) allocator_type& __alloc() throw() {
    return this->__end_cap_.second();
  }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const allocator_type& __alloc() const throw() {
    return this->__end_cap_.second();
  }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer& __end_cap() throw() {
    return this->__end_cap_.first();
  }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const pointer& __end_cap() const throw() {
    return this->__end_cap_.first();
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __clear() throw() {
    __base_destruct_at_end(this->__begin_);
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __base_destruct_at_end(pointer __new_last) throw() {
    pointer __soon_to_be_end = this->__end_;
    while (__new_last != __soon_to_be_end)
      __alloc_traits::destroy(__alloc(), std::__to_address(--__soon_to_be_end));
    this->__end_ = __new_last;
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __copy_assign_alloc(const vector& __c) {
    __copy_assign_alloc(__c, integral_constant<bool, __alloc_traits::propagate_on_container_copy_assignment::value>());
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign_alloc(vector& __c)

                                                                    {
    __move_assign_alloc(__c, integral_constant<bool, __alloc_traits::propagate_on_container_move_assignment::value>());
  }

  __attribute__((__noreturn__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __throw_length_error() const { std::__throw_length_error("vector"); }

  __attribute__((__noreturn__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __throw_out_of_range() const { std::__throw_out_of_range("vector"); }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __copy_assign_alloc(const vector& __c, true_type) {
    if (__alloc() != __c.__alloc()) {
      __clear();
      __annotate_delete();
      __alloc_traits::deallocate(__alloc(), this->__begin_, capacity());
      this->__begin_ = this->__end_ = __end_cap() = __nullptr;
    }
    __alloc() = __c.__alloc();
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __copy_assign_alloc(const vector&, false_type) {}

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign_alloc(vector& __c, true_type)
                                                                    {
    __alloc() = std::move(__c.__alloc());
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign_alloc(vector&, false_type) throw() {}
};
# 985 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
template <class _Tp, class _Allocator>
                              void
vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v) {
  __annotate_delete();
  using _RevIter = std::reverse_iterator<pointer>;
  __v.__begin_ = std::__uninitialized_allocator_move_if_noexcept(
                     __alloc(), _RevIter(__end_), _RevIter(__begin_), _RevIter(__v.__begin_))
                     .base();
  std::swap(this->__begin_, __v.__begin_);
  std::swap(this->__end_, __v.__end_);
  std::swap(this->__end_cap(), __v.__end_cap());
  __v.__first_ = __v.__begin_;
  __annotate_new(size());
}

template <class _Tp, class _Allocator>
                              typename vector<_Tp, _Allocator>::pointer
vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p) {
  __annotate_delete();
  pointer __r = __v.__begin_;
  using _RevIter = std::reverse_iterator<pointer>;
  __v.__begin_ = std::__uninitialized_allocator_move_if_noexcept(
                     __alloc(), _RevIter(__p), _RevIter(__begin_), _RevIter(__v.__begin_))
                     .base();
  __v.__end_ = std::__uninitialized_allocator_move_if_noexcept(__alloc(), __p, __end_, __v.__end_);
  std::swap(this->__begin_, __v.__begin_);
  std::swap(this->__end_, __v.__end_);
  std::swap(this->__end_cap(), __v.__end_cap());
  __v.__first_ = __v.__begin_;
  __annotate_new(size());
  return __r;
}

template <class _Tp, class _Allocator>
                              void vector<_Tp, _Allocator>::__vdeallocate() throw() {
  if (this->__begin_ != __nullptr) {
    clear();
    __annotate_delete();
    __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());
    this->__begin_ = this->__end_ = this->__end_cap() = __nullptr;
  }
}

template <class _Tp, class _Allocator>
                              typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::max_size() const throw() {
  return std::min<size_type>(__alloc_traits::max_size(this->__alloc()), numeric_limits<difference_type>::max());
}


template <class _Tp, class _Allocator>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::__recommend(size_type __new_size) const {
  const size_type __ms = max_size();
  if (__new_size > __ms)
    this->__throw_length_error();
  const size_type __cap = capacity();
  if (__cap >= __ms / 2)
    return __ms;
  return std::max<size_type>(2 * __cap, __new_size);
}






template <class _Tp, class _Allocator>
                              void vector<_Tp, _Allocator>::__construct_at_end(size_type __n) {
  _ConstructTransaction __tx(*this, __n);
  const_pointer __new_end = __tx.__new_end_;
  for (pointer __pos = __tx.__pos_; __pos != __new_end; __tx.__pos_ = ++__pos) {
    __alloc_traits::construct(this->__alloc(), std::__to_address(__pos));
  }
}







template <class _Tp, class _Allocator>
                              inline void
vector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x) {
  _ConstructTransaction __tx(*this, __n);
  const_pointer __new_end = __tx.__new_end_;
  for (pointer __pos = __tx.__pos_; __pos != __new_end; __tx.__pos_ = ++__pos) {
    __alloc_traits::construct(this->__alloc(), std::__to_address(__pos), __x);
  }
}

template <class _Tp, class _Allocator>
template <class _InputIterator, class _Sentinel>
                              void
vector<_Tp, _Allocator>::__construct_at_end(_InputIterator __first, _Sentinel __last, size_type __n) {
  _ConstructTransaction __tx(*this, __n);
  __tx.__pos_ = std::__uninitialized_allocator_copy(__alloc(), __first, __last, __tx.__pos_);
}





template <class _Tp, class _Allocator>
                              void vector<_Tp, _Allocator>::__append(size_type __n) {
  if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
    this->__construct_at_end(__n);
  else {
    allocator_type& __a = this->__alloc();
    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);
    __v.__construct_at_end(__n);
    __swap_out_circular_buffer(__v);
  }
}





template <class _Tp, class _Allocator>
                              void vector<_Tp, _Allocator>::__append(size_type __n, const_reference __x) {
  if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
    this->__construct_at_end(__n, __x);
  else {
    allocator_type& __a = this->__alloc();
    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);
    __v.__construct_at_end(__n, __x);
    __swap_out_circular_buffer(__v);
  }
}

template <class _Tp, class _Allocator>
                              vector<_Tp, _Allocator>::vector(size_type __n) {
  auto __guard = std::__make_exception_guard(__destroy_vector(*this));
  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__n);
  }
  __guard.__complete();
}
# 1140 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
template <class _Tp, class _Allocator>
                              vector<_Tp, _Allocator>::vector(size_type __n, const value_type& __x) {
  auto __guard = std::__make_exception_guard(__destroy_vector(*this));
  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__n, __x);
  }
  __guard.__complete();
}

template <class _Tp, class _Allocator>
template <class _InputIterator,
          __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value &&
                            is_constructible<_Tp, typename iterator_traits<_InputIterator>::reference>::value,
                        int> >
                              vector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last) {
  __init_with_sentinel(__first, __last);
}

template <class _Tp, class _Allocator>
template <class _InputIterator,
          __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value &&
                            is_constructible<_Tp, typename iterator_traits<_InputIterator>::reference>::value,
                        int> >

vector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a)
    : __end_cap_(__nullptr, __a) {
  __init_with_sentinel(__first, __last);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator,
          __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value &&
                            is_constructible<_Tp, typename iterator_traits<_ForwardIterator>::reference>::value,
                        int> >
                              vector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last) {
  size_type __n = static_cast<size_type>(std::distance(__first, __last));
  __init_with_size(__first, __last, __n);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator,
          __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value &&
                            is_constructible<_Tp, typename iterator_traits<_ForwardIterator>::reference>::value,
                        int> >

vector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a)
    : __end_cap_(__nullptr, __a) {
  size_type __n = static_cast<size_type>(std::distance(__first, __last));
  __init_with_size(__first, __last, __n);
}

template <class _Tp, class _Allocator>
                              vector<_Tp, _Allocator>::vector(const vector& __x)
    : __end_cap_(__nullptr, __alloc_traits::select_on_container_copy_construction(__x.__alloc())) {
  __init_with_size(__x.__begin_, __x.__end_, __x.size());
}

template <class _Tp, class _Allocator>

vector<_Tp, _Allocator>::vector(const vector& __x, const __type_identity_t<allocator_type>& __a)
    : __end_cap_(__nullptr, __a) {
  __init_with_size(__x.__begin_, __x.__end_, __x.size());
}

template <class _Tp, class _Allocator>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector<_Tp, _Allocator>::vector(vector&& __x)





    : __end_cap_(__nullptr, std::move(__x.__alloc())) {
  this->__begin_ = __x.__begin_;
  this->__end_ = __x.__end_;
  this->__end_cap() = __x.__end_cap();
  __x.__begin_ = __x.__end_ = __x.__end_cap() = __nullptr;
}

template <class _Tp, class _Allocator>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
vector<_Tp, _Allocator>::vector(vector&& __x, const __type_identity_t<allocator_type>& __a)
    : __end_cap_(__nullptr, __a) {
  if (__a == __x.__alloc()) {
    this->__begin_ = __x.__begin_;
    this->__end_ = __x.__end_;
    this->__end_cap() = __x.__end_cap();
    __x.__begin_ = __x.__end_ = __x.__end_cap() = __nullptr;
  } else {
    typedef move_iterator<iterator> _Ip;
    auto __guard = std::__make_exception_guard(__destroy_vector(*this));
    assign(_Ip(__x.begin()), _Ip(__x.end()));
    __guard.__complete();
  }
}
# 1263 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
template <class _Tp, class _Allocator>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector<_Tp, _Allocator>&
vector<_Tp, _Allocator>::operator=(vector&& __x)
                                                                                      {
  __move_assign(__x, integral_constant<bool, __alloc_traits::propagate_on_container_move_assignment::value>());
  return *this;
}

template <class _Tp, class _Allocator>
                              void vector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)
                                                       {
  if (__alloc() != __c.__alloc()) {
    typedef move_iterator<iterator> _Ip;
    assign(_Ip(__c.begin()), _Ip(__c.end()));
  } else
    __move_assign(__c, true_type());
}

template <class _Tp, class _Allocator>
                              void vector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)
                                                                  {
  __vdeallocate();
  __move_assign_alloc(__c);
  this->__begin_ = __c.__begin_;
  this->__end_ = __c.__end_;
  this->__end_cap() = __c.__end_cap();
  __c.__begin_ = __c.__end_ = __c.__end_cap() = __nullptr;
}

template <class _Tp, class _Allocator>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector<_Tp, _Allocator>&
vector<_Tp, _Allocator>::operator=(const vector& __x) {
  if (this != std::addressof(__x)) {
    __copy_assign_alloc(__x);
    assign(__x.__begin_, __x.__end_);
  }
  return *this;
}

template <class _Tp, class _Allocator>
template <class _InputIterator,
          __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value &&
                            is_constructible<_Tp, typename iterator_traits<_InputIterator>::reference>::value,
                        int> >
                              void vector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last) {
  __assign_with_sentinel(__first, __last);
}

template <class _Tp, class _Allocator>
template <class _Iterator, class _Sentinel>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
vector<_Tp, _Allocator>::__assign_with_sentinel(_Iterator __first, _Sentinel __last) {
  clear();
  for (; __first != __last; ++__first)
    emplace_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator,
          __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value &&
                            is_constructible<_Tp, typename iterator_traits<_ForwardIterator>::reference>::value,
                        int> >
                              void vector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last) {
  __assign_with_size(__first, __last, std::distance(__first, __last));
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator, class _Sentinel>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
vector<_Tp, _Allocator>::__assign_with_size(_ForwardIterator __first, _Sentinel __last, difference_type __n) {
  size_type __new_size = static_cast<size_type>(__n);
  if (__new_size <= capacity()) {
    if (__new_size > size()) {
      _ForwardIterator __mid = std::next(__first, size());
      std::copy(__first, __mid, this->__begin_);
      __construct_at_end(__mid, __last, __new_size - size());
    } else {
      pointer __m = std::__copy<_ClassicAlgPolicy>(__first, __last, this->__begin_).second;
      this->__destruct_at_end(__m);
    }
  } else {
    __vdeallocate();
    __vallocate(__recommend(__new_size));
    __construct_at_end(__first, __last, __new_size);
  }
}

template <class _Tp, class _Allocator>
                              void vector<_Tp, _Allocator>::assign(size_type __n, const_reference __u) {
  if (__n <= capacity()) {
    size_type __s = size();
    std::fill_n(this->__begin_, std::min(__n, __s), __u);
    if (__n > __s)
      __construct_at_end(__n - __s, __u);
    else
      this->__destruct_at_end(this->__begin_ + __n);
  } else {
    __vdeallocate();
    __vallocate(__recommend(static_cast<size_type>(__n)));
    __construct_at_end(__n, __u);
  }
}

template <class _Tp, class _Allocator>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::begin() throw() {
  return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::begin() const throw() {
  return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::end() throw() {
  return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::end() const throw() {
  return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::operator[](size_type __n) throw() {
  ((void)0);
  return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::operator[](size_type __n) const throw() {
  ((void)0);
  return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
                              typename vector<_Tp, _Allocator>::reference vector<_Tp, _Allocator>::at(size_type __n) {
  if (__n >= size())
    this->__throw_out_of_range();
  return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
                              typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::at(size_type __n) const {
  if (__n >= size())
    this->__throw_out_of_range();
  return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
                              void vector<_Tp, _Allocator>::reserve(size_type __n) {
  if (__n > capacity()) {
    if (__n > max_size())
      this->__throw_length_error();
    allocator_type& __a = this->__alloc();
    __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);
    __swap_out_circular_buffer(__v);
  }
}

template <class _Tp, class _Allocator>
                              void vector<_Tp, _Allocator>::shrink_to_fit() throw() {
  if (capacity() > size()) {

    try {

      allocator_type& __a = this->__alloc();
      __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);
      __swap_out_circular_buffer(__v);

    } catch (...) {
    }

  }
}

template <class _Tp, class _Allocator>
template <class _Up>
                              typename vector<_Tp, _Allocator>::pointer
vector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x) {
  allocator_type& __a = this->__alloc();
  __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);

  __alloc_traits::construct(__a, std::__to_address(__v.__end_), std::forward<_Up>(__x));
  __v.__end_++;
  __swap_out_circular_buffer(__v);
  return this->__end_;
}

template <class _Tp, class _Allocator>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
vector<_Tp, _Allocator>::push_back(const_reference __x) {
  pointer __end = this->__end_;
  if (__end < this->__end_cap()) {
    __construct_one_at_end(__x);
    ++__end;
  } else {
    __end = __push_back_slow_path(__x);
  }
  this->__end_ = __end;
}

template <class _Tp, class _Allocator>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void vector<_Tp, _Allocator>::push_back(value_type&& __x) {
  pointer __end = this->__end_;
  if (__end < this->__end_cap()) {
    __construct_one_at_end(std::move(__x));
    ++__end;
  } else {
    __end = __push_back_slow_path(std::move(__x));
  }
  this->__end_ = __end;
}

template <class _Tp, class _Allocator>
template <class... _Args>
                              typename vector<_Tp, _Allocator>::pointer
vector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args) {
  allocator_type& __a = this->__alloc();
  __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);

  __alloc_traits::construct(__a, std::__to_address(__v.__end_), std::forward<_Args>(__args)...);
  __v.__end_++;
  __swap_out_circular_buffer(__v);
  return this->__end_;
}

template <class _Tp, class _Allocator>
template <class... _Args>
                              inline



    void

    vector<_Tp, _Allocator>::emplace_back(_Args&&... __args) {
  pointer __end = this->__end_;
  if (__end < this->__end_cap()) {
    __construct_one_at_end(std::forward<_Args>(__args)...);
    ++__end;
  } else {
    __end = __emplace_back_slow_path(std::forward<_Args>(__args)...);
  }
  this->__end_ = __end;



}

template <class _Tp, class _Allocator>
                              inline void vector<_Tp, _Allocator>::pop_back() {
  ((void)0);
  this->__destruct_at_end(this->__end_ - 1);
}

template <class _Tp, class _Allocator>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __position) {
  ((void)0);

  difference_type __ps = __position - cbegin();
  pointer __p = this->__begin_ + __ps;
  this->__destruct_at_end(std::move(__p + 1, this->__end_, __p));
  return __make_iter(__p);
}

template <class _Tp, class _Allocator>
                              typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last) {
  ((void)0);
  pointer __p = this->__begin_ + (__first - begin());
  if (__first != __last) {
    this->__destruct_at_end(std::move(__p + (__last - __first), this->__end_, __p));
  }
  return __make_iter(__p);
}

template <class _Tp, class _Allocator>
                              void
vector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to) {
  pointer __old_last = this->__end_;
  difference_type __n = __old_last - __to;
  {
    pointer __i = __from_s + __n;
    _ConstructTransaction __tx(*this, __from_e - __i);
    for (pointer __pos = __tx.__pos_; __i < __from_e; ++__i, (void)++__pos, __tx.__pos_ = __pos) {
      __alloc_traits::construct(this->__alloc(), std::__to_address(__pos), std::move(*__i));
    }
  }
  std::move_backward(__from_s, __from_s + __n, __old_last);
}

template <class _Tp, class _Allocator>
                              typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x) {
  pointer __p = this->__begin_ + (__position - begin());

  if (!__libcpp_is_constant_evaluated() && this->__end_ < this->__end_cap()) {
    if (__p == this->__end_) {
      __construct_one_at_end(__x);
    } else {
      __move_range(__p, this->__end_, __p + 1);
      const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
      if (__p <= __xr && __xr < this->__end_)
        ++__xr;
      *__p = *__xr;
    }
  } else {
    allocator_type& __a = this->__alloc();
    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
    __v.push_back(__x);
    __p = __swap_out_circular_buffer(__v, __p);
  }
  return __make_iter(__p);
}

template <class _Tp, class _Allocator>
                              typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x) {
  pointer __p = this->__begin_ + (__position - begin());
  if (this->__end_ < this->__end_cap()) {
    if (__p == this->__end_) {
      __construct_one_at_end(std::move(__x));
    } else {
      __move_range(__p, this->__end_, __p + 1);
      *__p = std::move(__x);
    }
  } else {
    allocator_type& __a = this->__alloc();
    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
    __v.push_back(std::move(__x));
    __p = __swap_out_circular_buffer(__v, __p);
  }
  return __make_iter(__p);
}

template <class _Tp, class _Allocator>
template <class... _Args>
                              typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args) {
  pointer __p = this->__begin_ + (__position - begin());
  if (this->__end_ < this->__end_cap()) {
    if (__p == this->__end_) {
      __construct_one_at_end(std::forward<_Args>(__args)...);
    } else {
      __temp_value<value_type, _Allocator> __tmp(this->__alloc(), std::forward<_Args>(__args)...);
      __move_range(__p, this->__end_, __p + 1);
      *__p = std::move(__tmp.get());
    }
  } else {
    allocator_type& __a = this->__alloc();
    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
    __v.emplace_back(std::forward<_Args>(__args)...);
    __p = __swap_out_circular_buffer(__v, __p);
  }
  return __make_iter(__p);
}

template <class _Tp, class _Allocator>
                              typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x) {
  pointer __p = this->__begin_ + (__position - begin());
  if (__n > 0) {

    if (!__libcpp_is_constant_evaluated() && __n <= static_cast<size_type>(this->__end_cap() - this->__end_)) {
      size_type __old_n = __n;
      pointer __old_last = this->__end_;
      if (__n > static_cast<size_type>(this->__end_ - __p)) {
        size_type __cx = __n - (this->__end_ - __p);
        __construct_at_end(__cx, __x);
        __n -= __cx;
      }
      if (__n > 0) {
        __move_range(__p, __old_last, __p + __old_n);
        const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
        if (__p <= __xr && __xr < this->__end_)
          __xr += __old_n;
        std::fill_n(__p, __n, *__xr);
      }
    } else {
      allocator_type& __a = this->__alloc();
      __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);
      __v.__construct_at_end(__n, __x);
      __p = __swap_out_circular_buffer(__v, __p);
    }
  }
  return __make_iter(__p);
}
template <class _Tp, class _Allocator>
template <class _InputIterator,
          __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value &&
                            is_constructible<_Tp, typename iterator_traits<_InputIterator>::reference>::value,
                        int> >
                              typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last) {
  return __insert_with_sentinel(__position, __first, __last);
}

template <class _Tp, class _Allocator>
template <class _InputIterator, class _Sentinel>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::__insert_with_sentinel(const_iterator __position, _InputIterator __first, _Sentinel __last) {
  difference_type __off = __position - begin();
  pointer __p = this->__begin_ + __off;
  allocator_type& __a = this->__alloc();
  pointer __old_last = this->__end_;
  for (; this->__end_ != this->__end_cap() && __first != __last; ++__first) {
    __construct_one_at_end(*__first);
  }
  __split_buffer<value_type, allocator_type&> __v(__a);
  if (__first != __last) {

    try {

      __v.__construct_at_end_with_sentinel(std::move(__first), std::move(__last));
      difference_type __old_size = __old_last - this->__begin_;
      difference_type __old_p = __p - this->__begin_;
      reserve(__recommend(size() + __v.size()));
      __p = this->__begin_ + __old_p;
      __old_last = this->__begin_ + __old_size;

    } catch (...) {
      erase(__make_iter(__old_last), end());
      throw;
    }

  }
  __p = std::rotate(__p, __old_last, this->__end_);
  insert(__make_iter(__p), std::make_move_iterator(__v.begin()), std::make_move_iterator(__v.end()));
  return begin() + __off;
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator,
          __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value &&
                            is_constructible<_Tp, typename iterator_traits<_ForwardIterator>::reference>::value,
                        int> >
                              typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last) {
  return __insert_with_size(__position, __first, __last, std::distance(__first, __last));
}

template <class _Tp, class _Allocator>
template <class _Iterator, class _Sentinel>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::__insert_with_size(
    const_iterator __position, _Iterator __first, _Sentinel __last, difference_type __n) {
  auto __insertion_size = __n;
  pointer __p = this->__begin_ + (__position - begin());
  if (__n > 0) {
    if (__n <= this->__end_cap() - this->__end_) {
      size_type __old_n = __n;
      pointer __old_last = this->__end_;
      _Iterator __m = std::next(__first, __n);
      difference_type __dx = this->__end_ - __p;
      if (__n > __dx) {
        __m = __first;
        difference_type __diff = this->__end_ - __p;
        std::advance(__m, __diff);
        __construct_at_end(__m, __last, __n - __diff);
        __n = __dx;
      }
      if (__n > 0) {
        __move_range(__p, __old_last, __p + __old_n);
        std::copy(__first, __m, __p);
      }
    } else {
      allocator_type& __a = this->__alloc();
      __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);
      __v.__construct_at_end_with_size(__first, __insertion_size);
      __p = __swap_out_circular_buffer(__v, __p);
    }
  }
  return __make_iter(__p);
}

template <class _Tp, class _Allocator>
                              void vector<_Tp, _Allocator>::resize(size_type __sz) {
  size_type __cs = size();
  if (__cs < __sz)
    this->__append(__sz - __cs);
  else if (__cs > __sz)
    this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
                              void vector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x) {
  size_type __cs = size();
  if (__cs < __sz)
    this->__append(__sz - __cs, __x);
  else if (__cs > __sz)
    this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
                              void vector<_Tp, _Allocator>::swap(vector& __x)





{
  ((void)0);



  std::swap(this->__begin_, __x.__begin_);
  std::swap(this->__end_, __x.__end_);
  std::swap(this->__end_cap(), __x.__end_cap());
  std::__swap_allocator(
      this->__alloc(), __x.__alloc(), integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());
}

template <class _Tp, class _Allocator>
                              bool vector<_Tp, _Allocator>::__invariants() const {
  if (this->__begin_ == __nullptr) {
    if (this->__end_ != __nullptr || this->__end_cap() != __nullptr)
      return false;
  } else {
    if (this->__begin_ > this->__end_)
      return false;
    if (this->__begin_ == this->__end_cap())
      return false;
    if (this->__end_ > this->__end_cap())
      return false;
  }
  return true;
}



template <class _Allocator>
class vector<bool, _Allocator>;

template <class _Allocator>
struct hash<vector<bool, _Allocator> >;

template <class _Allocator>
struct __has_storage_type<vector<bool, _Allocator> > {
  static const bool value = true;
};

template <class _Allocator>
class vector<bool, _Allocator> {
public:
  typedef vector __self;
  typedef bool value_type;
  typedef _Allocator allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;
  typedef size_type __storage_type;
  typedef __bit_iterator<vector, false> pointer;
  typedef __bit_iterator<vector, true> const_pointer;
  typedef pointer iterator;
  typedef const_pointer const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

private:
  typedef __rebind_alloc<__alloc_traits, __storage_type> __storage_allocator;
  typedef allocator_traits<__storage_allocator> __storage_traits;
  typedef typename __storage_traits::pointer __storage_pointer;
  typedef typename __storage_traits::const_pointer __const_storage_pointer;

  __storage_pointer __begin_;
  size_type __size_;
  __compressed_pair<size_type, __storage_allocator> __cap_alloc_;

public:
  typedef __bit_reference<vector> reference;



  typedef __bit_const_reference<vector> const_reference;


private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type& __cap() throw() { return __cap_alloc_.first(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const size_type& __cap() const throw() {
    return __cap_alloc_.first();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __storage_allocator& __alloc() throw() {
    return __cap_alloc_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const __storage_allocator& __alloc() const throw() {
    return __cap_alloc_.second();
  }

  static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static size_type
  __internal_cap_to_external(size_type __n) throw() {
    return __n * __bits_per_word;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static size_type
  __external_cap_to_internal(size_type __n) throw() {
    return (__n - 1) / __bits_per_word + 1;
  }

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector()
                                                                         ;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit vector(const allocator_type& __a)

                                                                      ;




private:
  class __destroy_vector {
  public:
                      __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __destroy_vector(vector& __vec) : __vec_(__vec) {}

                                  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator()() {
      if (__vec_.__begin_ != __nullptr)
        __storage_traits::deallocate(__vec_.__alloc(), __vec_.__begin_, __vec_.__cap());
    }

  private:
    vector& __vec_;
  };

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~vector() { __destroy_vector (*this)(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit vector(size_type __n);



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector(size_type __n, const value_type& __v);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  vector(size_type __n, const value_type& __v, const allocator_type& __a);
  template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector(_InputIterator __first, _InputIterator __last);
  template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a);
  template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector(_ForwardIterator __first, _ForwardIterator __last);
  template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a);
# 1930 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector(const vector& __v);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector(const vector& __v, const allocator_type& __a);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector& operator=(const vector& __v);
# 1946 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector(vector&& __v)



                                                                      ;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  vector(vector&& __v, const __type_identity_t<allocator_type>& __a);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector& operator=(vector&& __v)
                                                                                       ;

  template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> = 0>
  void __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) assign(_InputIterator __first, _InputIterator __last);
  template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
  void __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) assign(_ForwardIterator __first, _ForwardIterator __last);
# 1975 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void assign(size_type __n, const value_type& __x);







  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) allocator_type get_allocator() const throw() {
    return allocator_type(this->__alloc());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type max_size() const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type capacity() const throw() {
    return __internal_cap_to_external(__cap());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type size() const throw() { return __size_; }
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool empty() const throw() {
    return __size_ == 0;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void reserve(size_type __n);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void shrink_to_fit() throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator begin() throw() { return __make_iter(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator begin() const throw() { return __make_iter(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator end() throw() { return __make_iter(__size_); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator end() const throw() {
    return __make_iter(__size_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator rbegin() throw() {
    return reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator rbegin() const throw() {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator rend() throw() {
    return reverse_iterator(begin());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator rend() const throw() {
    return const_reverse_iterator(begin());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator cbegin() const throw() { return __make_iter(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator cend() const throw() {
    return __make_iter(__size_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator crbegin() const throw() {
    return rbegin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator crend() const throw() { return rend(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator[](size_type __n) { return __make_ref(__n); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference operator[](size_type __n) const {
    return __make_ref(__n);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference at(size_type __n);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference at(size_type __n) const;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference front() { return __make_ref(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference front() const { return __make_ref(0); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference back() { return __make_ref(__size_ - 1); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference back() const { return __make_ref(__size_ - 1); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void push_back(const value_type& __x);
# 2062 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void pop_back() { --__size_; }
# 2071 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator insert(const_iterator __position, const value_type& __x);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator
  insert(const_iterator __position, size_type __n, const value_type& __x);
  template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> = 0>
  iterator __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
  template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> = 0>
  iterator __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);
# 2101 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator erase(const_iterator __position);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator erase(const_iterator __first, const_iterator __last);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void clear() throw() { __size_ = 0; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(vector&)



                                                                                                                      ;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static void swap(reference __x, reference __y) throw() {
    std::swap(__x, __y);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void resize(size_type __sz, value_type __x = false);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void flip() throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __invariants() const;

private:
  __attribute__((__noreturn__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __throw_length_error() const { std::__throw_length_error("vector"); }

  __attribute__((__noreturn__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __throw_out_of_range() const { std::__throw_out_of_range("vector"); }

  template <class _InputIterator, class _Sentinel>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __init_with_size(_InputIterator __first, _Sentinel __last, size_type __n) {
    auto __guard = std::__make_exception_guard(__destroy_vector(*this));

    if (__n > 0) {
      __vallocate(__n);
      __construct_at_end(std::move(__first), std::move(__last), __n);
    }

    __guard.__complete();
  }

  template <class _InputIterator, class _Sentinel>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __init_with_sentinel(_InputIterator __first, _Sentinel __last) {

    try {

      for (; __first != __last; ++__first)
        push_back(*__first);

    } catch (...) {
      if (__begin_ != __nullptr)
        __storage_traits::deallocate(__alloc(), __begin_, __cap());
      throw;
    }

  }

  template <class _Iterator, class _Sentinel>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __assign_with_sentinel(_Iterator __first, _Sentinel __last);

  template <class _ForwardIterator, class _Sentinel>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __assign_with_size(_ForwardIterator __first, _Sentinel __last, difference_type __ns);

  template <class _InputIterator, class _Sentinel>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator
  __insert_with_sentinel(const_iterator __position, _InputIterator __first, _Sentinel __last);

  template <class _Iterator, class _Sentinel>
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator
  __insert_with_size(const_iterator __position, _Iterator __first, _Sentinel __last, difference_type __n);
# 2178 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __vallocate(size_type __n) {
    if (__n > max_size())
      __throw_length_error();
    auto __allocation = std::__allocate_at_least(__alloc(), __external_cap_to_internal(__n));
    __begin_ = __allocation.ptr;
    __size_ = 0;
    __cap() = __allocation.count;
    if (__libcpp_is_constant_evaluated()) {
      for (size_type __i = 0; __i != __cap(); ++__i)
        std::__construct_at(std::__to_address(__begin_) + __i);
    }
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __vdeallocate() throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static size_type __align_it(size_type __new_size) throw() {
    return (__new_size + (__bits_per_word - 1)) & ~((size_type)__bits_per_word - 1);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type __recommend(size_type __new_size) const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __construct_at_end(size_type __n, bool __x);
  template <class _InputIterator, class _Sentinel>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __construct_at_end(_InputIterator __first, _Sentinel __last, size_type __n);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __append(size_type __n, const_reference __x);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference __make_ref(size_type __pos) throw() {
    return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference __make_ref(size_type __pos) const throw() {
    return __bit_const_reference<vector>(
        __begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator __make_iter(size_type __pos) throw() {
    return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator __make_iter(size_type __pos) const throw() {
    return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator __const_iterator_cast(const_iterator __p) throw() {
    return begin() + (__p - cbegin());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __copy_assign_alloc(const vector& __v) {
    __copy_assign_alloc(
        __v, integral_constant<bool, __storage_traits::propagate_on_container_copy_assignment::value>());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __copy_assign_alloc(const vector& __c, true_type) {
    if (__alloc() != __c.__alloc())
      __vdeallocate();
    __alloc() = __c.__alloc();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __copy_assign_alloc(const vector&, false_type) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign(vector& __c, false_type);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign(vector& __c, true_type)
                                                                   ;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign_alloc(vector& __c)

                                                                    {
    __move_assign_alloc(
        __c, integral_constant<bool, __storage_traits::propagate_on_container_move_assignment::value>());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign_alloc(vector& __c, true_type)
                                                                    {
    __alloc() = std::move(__c.__alloc());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign_alloc(vector&, false_type) throw() {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t __hash_code() const throw();

  friend class __bit_reference<vector>;
  friend class __bit_const_reference<vector>;
  friend class __bit_iterator<vector, false>;
  friend class __bit_iterator<vector, true>;
  friend struct __bit_array<vector>;
  friend struct hash<vector>;
};

template <class _Allocator>
                              void vector<bool, _Allocator>::__vdeallocate() throw() {
  if (this->__begin_ != __nullptr) {
    __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());
    this->__begin_ = __nullptr;
    this->__size_ = this->__cap() = 0;
  }
}

template <class _Allocator>
                              typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::max_size() const throw() {
  size_type __amax = __storage_traits::max_size(__alloc());
  size_type __nmax = numeric_limits<size_type>::max() / 2;
  if (__nmax / __bits_per_word <= __amax)
    return __nmax;
  return __internal_cap_to_external(__amax);
}


template <class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::__recommend(size_type __new_size) const {
  const size_type __ms = max_size();
  if (__new_size > __ms)
    this->__throw_length_error();
  const size_type __cap = capacity();
  if (__cap >= __ms / 2)
    return __ms;
  return std::max(2 * __cap, __align_it(__new_size));
}





template <class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
vector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x) {
  size_type __old_size = this->__size_;
  this->__size_ += __n;
  if (__old_size == 0 || ((__old_size - 1) / __bits_per_word) != ((this->__size_ - 1) / __bits_per_word)) {
    if (this->__size_ <= __bits_per_word)
      this->__begin_[0] = __storage_type(0);
    else
      this->__begin_[(this->__size_ - 1) / __bits_per_word] = __storage_type(0);
  }
  std::fill_n(__make_iter(__old_size), __n, __x);
}

template <class _Allocator>
template <class _InputIterator, class _Sentinel>
                              void
vector<bool, _Allocator>::__construct_at_end(_InputIterator __first, _Sentinel __last, size_type __n) {
  size_type __old_size = this->__size_;
  this->__size_ += __n;
  if (__old_size == 0 || ((__old_size - 1) / __bits_per_word) != ((this->__size_ - 1) / __bits_per_word)) {
    if (this->__size_ <= __bits_per_word)
      this->__begin_[0] = __storage_type(0);
    else
      this->__begin_[(this->__size_ - 1) / __bits_per_word] = __storage_type(0);
  }
  std::__copy<_ClassicAlgPolicy>(__first, __last, __make_iter(__old_size));
}

template <class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector<bool, _Allocator>::vector()

    : __begin_(__nullptr), __size_(0), __cap_alloc_(0, __default_init_tag()) {}

template <class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector<bool, _Allocator>::vector(const allocator_type& __a)





    : __begin_(__nullptr), __size_(0), __cap_alloc_(0, static_cast<__storage_allocator>(__a)) {
}

template <class _Allocator>
                              vector<bool, _Allocator>::vector(size_type __n)
    : __begin_(__nullptr), __size_(0), __cap_alloc_(0, __default_init_tag()) {
  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__n, false);
  }
}
# 2356 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
template <class _Allocator>
                              vector<bool, _Allocator>::vector(size_type __n, const value_type& __x)
    : __begin_(__nullptr), __size_(0), __cap_alloc_(0, __default_init_tag()) {
  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__n, __x);
  }
}

template <class _Allocator>

vector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)
    : __begin_(__nullptr), __size_(0), __cap_alloc_(0, static_cast<__storage_allocator>(__a)) {
  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__n, __x);
  }
}

template <class _Allocator>
template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> >
                              vector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last)
    : __begin_(__nullptr), __size_(0), __cap_alloc_(0, __default_init_tag()) {
  __init_with_sentinel(__first, __last);
}

template <class _Allocator>
template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> >

vector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a)
    : __begin_(__nullptr), __size_(0), __cap_alloc_(0, static_cast<__storage_allocator>(__a)) {
  __init_with_sentinel(__first, __last);
}

template <class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
                              vector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last)
    : __begin_(__nullptr), __size_(0), __cap_alloc_(0, __default_init_tag()) {
  auto __n = static_cast<size_type>(std::distance(__first, __last));
  __init_with_size(__first, __last, __n);
}

template <class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >

vector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a)
    : __begin_(__nullptr), __size_(0), __cap_alloc_(0, static_cast<__storage_allocator>(__a)) {
  auto __n = static_cast<size_type>(std::distance(__first, __last));
  __init_with_size(__first, __last, __n);
}
# 2432 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
template <class _Allocator>
                              vector<bool, _Allocator>::vector(const vector& __v)
    : __begin_(__nullptr),
      __size_(0),
      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc())) {
  if (__v.size() > 0) {
    __vallocate(__v.size());
    __construct_at_end(__v.begin(), __v.end(), __v.size());
  }
}

template <class _Allocator>
                              vector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)
    : __begin_(__nullptr), __size_(0), __cap_alloc_(0, __a) {
  if (__v.size() > 0) {
    __vallocate(__v.size());
    __construct_at_end(__v.begin(), __v.end(), __v.size());
  }
}

template <class _Allocator>
                              vector<bool, _Allocator>& vector<bool, _Allocator>::operator=(const vector& __v) {
  if (this != std::addressof(__v)) {
    __copy_assign_alloc(__v);
    if (__v.__size_) {
      if (__v.__size_ > capacity()) {
        __vdeallocate();
        __vallocate(__v.__size_);
      }
      std::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);
    }
    __size_ = __v.__size_;
  }
  return *this;
}

template <class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector<bool, _Allocator>::vector(vector&& __v)





    : __begin_(__v.__begin_),
      __size_(__v.__size_),
      __cap_alloc_(std::move(__v.__cap_alloc_)) {
  __v.__begin_ = __nullptr;
  __v.__size_ = 0;
  __v.__cap() = 0;
}

template <class _Allocator>

vector<bool, _Allocator>::vector(vector&& __v, const __type_identity_t<allocator_type>& __a)
    : __begin_(__nullptr), __size_(0), __cap_alloc_(0, __a) {
  if (__a == allocator_type(__v.__alloc())) {
    this->__begin_ = __v.__begin_;
    this->__size_ = __v.__size_;
    this->__cap() = __v.__cap();
    __v.__begin_ = __nullptr;
    __v.__cap() = __v.__size_ = 0;
  } else if (__v.size() > 0) {
    __vallocate(__v.size());
    __construct_at_end(__v.begin(), __v.end(), __v.size());
  }
}

template <class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) vector<bool, _Allocator>&
vector<bool, _Allocator>::operator=(vector&& __v)
                                                                                      {
  __move_assign(__v, integral_constant<bool, __storage_traits::propagate_on_container_move_assignment::value>());
  return *this;
}

template <class _Allocator>
                              void vector<bool, _Allocator>::__move_assign(vector& __c, false_type) {
  if (__alloc() != __c.__alloc())
    assign(__c.begin(), __c.end());
  else
    __move_assign(__c, true_type());
}

template <class _Allocator>
                              void vector<bool, _Allocator>::__move_assign(vector& __c, true_type)
                                                                  {
  __vdeallocate();
  __move_assign_alloc(__c);
  this->__begin_ = __c.__begin_;
  this->__size_ = __c.__size_;
  this->__cap() = __c.__cap();
  __c.__begin_ = __nullptr;
  __c.__cap() = __c.__size_ = 0;
}

template <class _Allocator>
                              void vector<bool, _Allocator>::assign(size_type __n, const value_type& __x) {
  __size_ = 0;
  if (__n > 0) {
    size_type __c = capacity();
    if (__n <= __c)
      __size_ = __n;
    else {
      vector __v(get_allocator());
      __v.reserve(__recommend(__n));
      __v.__size_ = __n;
      swap(__v);
    }
    std::fill_n(begin(), __n, __x);
  }
}

template <class _Allocator>
template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> >
                              void vector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last) {
  __assign_with_sentinel(__first, __last);
}

template <class _Allocator>
template <class _Iterator, class _Sentinel>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
vector<bool, _Allocator>::__assign_with_sentinel(_Iterator __first, _Sentinel __last) {
  clear();
  for (; __first != __last; ++__first)
    push_back(*__first);
}

template <class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
                              void vector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last) {
  __assign_with_size(__first, __last, std::distance(__first, __last));
}

template <class _Allocator>
template <class _ForwardIterator, class _Sentinel>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
vector<bool, _Allocator>::__assign_with_size(_ForwardIterator __first, _Sentinel __last, difference_type __ns) {
  ((void)0);

  clear();

  const size_t __n = static_cast<size_type>(__ns);
  if (__n) {
    if (__n > capacity()) {
      __vdeallocate();
      __vallocate(__n);
    }
    __construct_at_end(__first, __last, __n);
  }
}

template <class _Allocator>
                              void vector<bool, _Allocator>::reserve(size_type __n) {
  if (__n > capacity()) {
    if (__n > max_size())
      this->__throw_length_error();
    vector __v(this->get_allocator());
    __v.__vallocate(__n);
    __v.__construct_at_end(this->begin(), this->end(), this->size());
    swap(__v);
  }
}

template <class _Allocator>
                              void vector<bool, _Allocator>::shrink_to_fit() throw() {
  if (__external_cap_to_internal(size()) > __cap()) {

    try {

      vector(*this, allocator_type(__alloc())).swap(*this);

    } catch (...) {
    }

  }
}

template <class _Allocator>
typename vector<bool, _Allocator>::reference vector<bool, _Allocator>::at(size_type __n) {
  if (__n >= size())
    this->__throw_out_of_range();
  return (*this)[__n];
}

template <class _Allocator>
typename vector<bool, _Allocator>::const_reference vector<bool, _Allocator>::at(size_type __n) const {
  if (__n >= size())
    this->__throw_out_of_range();
  return (*this)[__n];
}

template <class _Allocator>
                              void vector<bool, _Allocator>::push_back(const value_type& __x) {
  if (this->__size_ == this->capacity())
    reserve(__recommend(this->__size_ + 1));
  ++this->__size_;
  back() = __x;
}

template <class _Allocator>
                              typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x) {
  iterator __r;
  if (size() < capacity()) {
    const_iterator __old_end = end();
    ++__size_;
    std::copy_backward(__position, __old_end, end());
    __r = __const_iterator_cast(__position);
  } else {
    vector __v(get_allocator());
    __v.reserve(__recommend(__size_ + 1));
    __v.__size_ = __size_ + 1;
    __r = std::copy(cbegin(), __position, __v.begin());
    std::copy_backward(__position, cend(), __v.end());
    swap(__v);
  }
  *__r = __x;
  return __r;
}

template <class _Allocator>
                              typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x) {
  iterator __r;
  size_type __c = capacity();
  if (__n <= __c && size() <= __c - __n) {
    const_iterator __old_end = end();
    __size_ += __n;
    std::copy_backward(__position, __old_end, end());
    __r = __const_iterator_cast(__position);
  } else {
    vector __v(get_allocator());
    __v.reserve(__recommend(__size_ + __n));
    __v.__size_ = __size_ + __n;
    __r = std::copy(cbegin(), __position, __v.begin());
    std::copy_backward(__position, cend(), __v.end());
    swap(__v);
  }
  std::fill_n(__r, __n, __x);
  return __r;
}

template <class _Allocator>
template <class _InputIterator, __enable_if_t<__has_exactly_input_iterator_category<_InputIterator>::value, int> >
                              typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last) {
  return __insert_with_sentinel(__position, __first, __last);
}

template <class _Allocator>
template <class _InputIterator, class _Sentinel>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::__insert_with_sentinel(const_iterator __position, _InputIterator __first, _Sentinel __last) {
  difference_type __off = __position - begin();
  iterator __p = __const_iterator_cast(__position);
  iterator __old_end = end();
  for (; size() != capacity() && __first != __last; ++__first) {
    ++this->__size_;
    back() = *__first;
  }
  vector __v(get_allocator());
  if (__first != __last) {

    try {

      __v.__assign_with_sentinel(std::move(__first), std::move(__last));
      difference_type __old_size = static_cast<difference_type>(__old_end - begin());
      difference_type __old_p = __p - begin();
      reserve(__recommend(size() + __v.size()));
      __p = begin() + __old_p;
      __old_end = begin() + __old_size;

    } catch (...) {
      erase(__old_end, end());
      throw;
    }

  }
  __p = std::rotate(__p, __old_end, end());
  insert(__p, __v.begin(), __v.end());
  return begin() + __off;
}

template <class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_forward_iterator_category<_ForwardIterator>::value, int> >
                              typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last) {
  return __insert_with_size(__position, __first, __last, std::distance(__first, __last));
}

template <class _Allocator>
template <class _ForwardIterator, class _Sentinel>
                              __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::__insert_with_size(
    const_iterator __position, _ForwardIterator __first, _Sentinel __last, difference_type __n_signed) {
  ((void)0);
  const size_type __n = static_cast<size_type>(__n_signed);
  iterator __r;
  size_type __c = capacity();
  if (__n <= __c && size() <= __c - __n) {
    const_iterator __old_end = end();
    __size_ += __n;
    std::copy_backward(__position, __old_end, end());
    __r = __const_iterator_cast(__position);
  } else {
    vector __v(get_allocator());
    __v.reserve(__recommend(__size_ + __n));
    __v.__size_ = __size_ + __n;
    __r = std::copy(cbegin(), __position, __v.begin());
    std::copy_backward(__position, cend(), __v.end());
    swap(__v);
  }
  std::__copy<_ClassicAlgPolicy>(__first, __last, __r);
  return __r;
}

template <class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __position) {
  iterator __r = __const_iterator_cast(__position);
  std::copy(__position + 1, this->cend(), __r);
  --__size_;
  return __r;
}

template <class _Allocator>
                              typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last) {
  iterator __r = __const_iterator_cast(__first);
  difference_type __d = __last - __first;
  std::copy(__last, this->cend(), __r);
  __size_ -= __d;
  return __r;
}

template <class _Allocator>
                              void vector<bool, _Allocator>::swap(vector& __x)





{
  std::swap(this->__begin_, __x.__begin_);
  std::swap(this->__size_, __x.__size_);
  std::swap(this->__cap(), __x.__cap());
  std::__swap_allocator(
      this->__alloc(), __x.__alloc(), integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());
}

template <class _Allocator>
                              void vector<bool, _Allocator>::resize(size_type __sz, value_type __x) {
  size_type __cs = size();
  if (__cs < __sz) {
    iterator __r;
    size_type __c = capacity();
    size_type __n = __sz - __cs;
    if (__n <= __c && __cs <= __c - __n) {
      __r = end();
      __size_ += __n;
    } else {
      vector __v(get_allocator());
      __v.reserve(__recommend(__size_ + __n));
      __v.__size_ = __size_ + __n;
      __r = std::copy(cbegin(), cend(), __v.begin());
      swap(__v);
    }
    std::fill_n(__r, __n, __x);
  } else
    __size_ = __sz;
}

template <class _Allocator>
                              void vector<bool, _Allocator>::flip() throw() {

  size_type __n = __size_;
  __storage_pointer __p = __begin_;
  for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
    *__p = ~*__p;

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __storage_type __b = *__p & __m;
    *__p &= ~__m;
    *__p |= ~__b & __m;
  }
}

template <class _Allocator>
                              bool vector<bool, _Allocator>::__invariants() const {
  if (this->__begin_ == __nullptr) {
    if (this->__size_ != 0 || this->__cap() != 0)
      return false;
  } else {
    if (this->__cap() == 0)
      return false;
    if (this->__size_ > this->capacity())
      return false;
  }
  return true;
}

template <class _Allocator>
                              size_t vector<bool, _Allocator>::__hash_code() const throw() {
  size_t __h = 0;

  size_type __n = __size_;
  __storage_pointer __p = __begin_;
  for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
    __h ^= *__p;

  if (__n > 0) {
    const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __h ^= *__p & __m;
  }
  return __h;
}

template <class _Allocator>
struct hash<vector<bool, _Allocator> >
    : public __unary_function<vector<bool, _Allocator>, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t
  operator()(const vector<bool, _Allocator>& __vec) const throw() {
    return __vec.__hash_code();
  }
};

template <class _Tp, class _Allocator>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
operator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y) {
  const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();
  return __sz == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
}



template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y) {
  return !(__x == __y);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y) {
  return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y) {
  return __y < __x;
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y) {
  return !(__x < __y);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y) {
  return !(__y < __x);
}
# 2904 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
template <class _Tp, class _Allocator>
                              inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
swap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y) {
  __x.swap(__y);
}
# 2957 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
}}
# 6 "src/core/Renderer.h" 2

# 1 "src/core/Shader.h" 1







class Shader {
public:
    unsigned int ID;
    Shader(const char* vertexSource, const char* fragmentSource);
    void use();
    ~Shader();
};
# 8 "src/core/Renderer.h" 2


class Renderer {
public:
    void initialize();
    void render();

private:
    unsigned int VAO, VBO, EBO;
    std::vector<unsigned int> terrainIndices;
};
# 7 "src/core/Application.h" 2



class Application {
public:
    Application();
    ~Application();
    void run();
private:
    GLFWwindow* window;
    Camera camera;
    Renderer renderer;
    Player player;
};
# 2 "src/core/Application.cpp" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iostream" 1 3
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iostream" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/istream" 1 3
# 170 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/istream" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ostream" 1 3
# 187 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ostream" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 1 3
# 152 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 156 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <size_t _N_words, size_t _Size>
class __bitset;

template <size_t _N_words, size_t _Size>
struct __has_storage_type<__bitset<_N_words, _Size> > {
  static const bool value = true;
};

template <size_t _N_words, size_t _Size>
class __bitset {
public:
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;
  typedef size_type __storage_type;

protected:
  typedef __bitset __self;
  typedef __storage_type* __storage_pointer;
  typedef const __storage_type* __const_storage_pointer;
  static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

  friend class __bit_reference<__bitset>;
  friend class __bit_const_reference<__bitset>;
  friend class __bit_iterator<__bitset, false>;
  friend class __bit_iterator<__bitset, true>;
  friend struct __bit_array<__bitset>;

  __storage_type __first_[_N_words];

  typedef __bit_reference<__bitset> reference;
  typedef __bit_const_reference<__bitset> const_reference;
  typedef __bit_iterator<__bitset, false> iterator;
  typedef __bit_iterator<__bitset, true> const_iterator;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bitset() throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __bitset(unsigned long long __v) throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference __make_ref(size_t __pos) throw() {
    return reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference __make_ref(size_t __pos) const throw() {
    return const_reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator __make_iter(size_t __pos) throw() {
    return iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator __make_iter(size_t __pos) const throw() {
    return const_iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator&=(const __bitset& __v) throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator|=(const __bitset& __v) throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator^=(const __bitset& __v) throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void flip() throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long to_ulong() const {
    return to_ulong(integral_constant < bool, _Size< sizeof(unsigned long) * 8>());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long long to_ullong() const {
    return to_ullong(integral_constant < bool, _Size< sizeof(unsigned long long) * 8>());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool all() const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool any() const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t __hash_code() const throw();

private:

  void __init(unsigned long long __v, false_type) throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __init(unsigned long long __v, true_type) throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long to_ulong(false_type) const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long to_ulong(true_type) const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long long to_ullong(false_type) const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long long to_ullong(true_type) const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long long to_ullong(true_type, false_type) const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long long to_ullong(true_type, true_type) const;
};

template <size_t _N_words, size_t _Size>
inline __bitset<_N_words, _Size>::__bitset() throw()



{

  std::fill_n(__first_, _N_words, __storage_type(0));

}



template <size_t _N_words, size_t _Size>
void __bitset<_N_words, _Size>::__init(unsigned long long __v, false_type) throw() {
  __storage_type __t[sizeof(unsigned long long) / sizeof(__storage_type)];
  size_t __sz = _Size;
  for (size_t __i = 0; __i < sizeof(__t) / sizeof(__t[0]); ++__i, __v >>= __bits_per_word, __sz -= __bits_per_word)
    if (__sz < __bits_per_word)
      __t[__i] = static_cast<__storage_type>(__v) & (1ULL << __sz) - 1;
    else
      __t[__i] = static_cast<__storage_type>(__v);

  std::copy(__t, __t + sizeof(__t) / sizeof(__t[0]), __first_);
  std::fill(
      __first_ + sizeof(__t) / sizeof(__t[0]), __first_ + sizeof(__first_) / sizeof(__first_[0]), __storage_type(0));
}

template <size_t _N_words, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __bitset<_N_words, _Size>::__init(unsigned long long __v, true_type) throw() {
  __first_[0] = __v;
  if (_Size < __bits_per_word)
    __first_[0] &= (1ULL << _Size) - 1;

  std::fill(__first_ + 1, __first_ + sizeof(__first_) / sizeof(__first_[0]), __storage_type(0));
}



template <size_t _N_words, size_t _Size>
inline __bitset<_N_words, _Size>::__bitset(unsigned long long __v) throw()
# 292 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3
{

  __init(__v, integral_constant<bool, sizeof(unsigned long long) == sizeof(__storage_type)>());

}

template <size_t _N_words, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__bitset<_N_words, _Size>::operator&=(const __bitset& __v) throw() {
  for (size_type __i = 0; __i < _N_words; ++__i)
    __first_[__i] &= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__bitset<_N_words, _Size>::operator|=(const __bitset& __v) throw() {
  for (size_type __i = 0; __i < _N_words; ++__i)
    __first_[__i] |= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__bitset<_N_words, _Size>::operator^=(const __bitset& __v) throw() {
  for (size_type __i = 0; __i < _N_words; ++__i)
    __first_[__i] ^= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __bitset<_N_words, _Size>::flip() throw() {

  size_type __n = _Size;
  __storage_pointer __p = __first_;
  for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
    *__p = ~*__p;

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __storage_type __b = *__p & __m;
    *__p &= ~__m;
    *__p |= ~__b & __m;
  }
}

template <size_t _N_words, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long
__bitset<_N_words, _Size>::to_ulong(false_type) const {
  const_iterator __e = __make_iter(_Size);
  const_iterator __i = std::find(__make_iter(sizeof(unsigned long) * 8), __e, true);
  if (__i != __e)
    __throw_overflow_error("bitset to_ulong overflow error");

  return __first_[0];
}

template <size_t _N_words, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long
__bitset<_N_words, _Size>::to_ulong(true_type) const {
  return __first_[0];
}

template <size_t _N_words, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long long
__bitset<_N_words, _Size>::to_ullong(false_type) const {
  const_iterator __e = __make_iter(_Size);
  const_iterator __i = std::find(__make_iter(sizeof(unsigned long long) * 8), __e, true);
  if (__i != __e)
    __throw_overflow_error("bitset to_ullong overflow error");

  return to_ullong(true_type());
}

template <size_t _N_words, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type) const {
  return to_ullong(true_type(), integral_constant<bool, sizeof(__storage_type) < sizeof(unsigned long long)>());
}

template <size_t _N_words, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, false_type) const {
  return __first_[0];
}

template <size_t _N_words, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, true_type) const {
  unsigned long long __r = __first_[0];
  for (size_t __i = 1; __i < sizeof(unsigned long long) / sizeof(__storage_type); ++__i)
    __r |= static_cast<unsigned long long>(__first_[__i]) << (sizeof(__storage_type) * 8);
  return __r;
}

template <size_t _N_words, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __bitset<_N_words, _Size>::all() const throw() {

  size_type __n = _Size;
  __const_storage_pointer __p = __first_;
  for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
    if (~*__p)
      return false;

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    if (~*__p & __m)
      return false;
  }
  return true;
}

template <size_t _N_words, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __bitset<_N_words, _Size>::any() const throw() {

  size_type __n = _Size;
  __const_storage_pointer __p = __first_;
  for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
    if (*__p)
      return true;

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    if (*__p & __m)
      return true;
  }
  return false;
}

template <size_t _N_words, size_t _Size>
inline size_t __bitset<_N_words, _Size>::__hash_code() const throw() {
  size_t __h = 0;
  for (size_type __i = 0; __i < _N_words; ++__i)
    __h ^= __first_[__i];
  return __h;
}

template <size_t _Size>
class __bitset<1, _Size> {
public:
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;
  typedef size_type __storage_type;

protected:
  typedef __bitset __self;
  typedef __storage_type* __storage_pointer;
  typedef const __storage_type* __const_storage_pointer;
  static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

  friend class __bit_reference<__bitset>;
  friend class __bit_const_reference<__bitset>;
  friend class __bit_iterator<__bitset, false>;
  friend class __bit_iterator<__bitset, true>;
  friend struct __bit_array<__bitset>;

  __storage_type __first_;

  typedef __bit_reference<__bitset> reference;
  typedef __bit_const_reference<__bitset> const_reference;
  typedef __bit_iterator<__bitset, false> iterator;
  typedef __bit_iterator<__bitset, true> const_iterator;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bitset() throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __bitset(unsigned long long __v) throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference __make_ref(size_t __pos) throw() {
    return reference(&__first_, __storage_type(1) << __pos);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference __make_ref(size_t __pos) const throw() {
    return const_reference(&__first_, __storage_type(1) << __pos);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator __make_iter(size_t __pos) throw() {
    return iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator __make_iter(size_t __pos) const throw() {
    return const_iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator&=(const __bitset& __v) throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator|=(const __bitset& __v) throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator^=(const __bitset& __v) throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void flip() throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long to_ulong() const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long long to_ullong() const;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool all() const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool any() const throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t __hash_code() const throw();
};

template <size_t _Size>
inline __bitset<1, _Size>::__bitset() throw() : __first_(0) {}

template <size_t _Size>
inline __bitset<1, _Size>::__bitset(unsigned long long __v) throw()
    : __first_(_Size == __bits_per_word ? static_cast<__storage_type>(__v)
                                        : static_cast<__storage_type>(__v) & ((__storage_type(1) << _Size) - 1)) {}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__bitset<1, _Size>::operator&=(const __bitset& __v) throw() {
  __first_ &= __v.__first_;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__bitset<1, _Size>::operator|=(const __bitset& __v) throw() {
  __first_ |= __v.__first_;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__bitset<1, _Size>::operator^=(const __bitset& __v) throw() {
  __first_ ^= __v.__first_;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __bitset<1, _Size>::flip() throw() {
  __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
  __first_ = ~__first_;
  __first_ &= __m;
}

template <size_t _Size>
inline unsigned long __bitset<1, _Size>::to_ulong() const {
  return __first_;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long long __bitset<1, _Size>::to_ullong() const {
  return __first_;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __bitset<1, _Size>::all() const throw() {
  __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
  return !(~__first_ & __m);
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __bitset<1, _Size>::any() const throw() {
  __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
  return __first_ & __m;
}

template <size_t _Size>
inline size_t __bitset<1, _Size>::__hash_code() const throw() {
  return __first_;
}

template <>
class __bitset<0, 0> {
public:
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;
  typedef size_type __storage_type;

protected:
  typedef __bitset __self;
  typedef __storage_type* __storage_pointer;
  typedef const __storage_type* __const_storage_pointer;
  static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

  friend class __bit_reference<__bitset>;
  friend class __bit_const_reference<__bitset>;
  friend class __bit_iterator<__bitset, false>;
  friend class __bit_iterator<__bitset, true>;
  friend struct __bit_array<__bitset>;

  typedef __bit_reference<__bitset> reference;
  typedef __bit_const_reference<__bitset> const_reference;
  typedef __bit_iterator<__bitset, false> iterator;
  typedef __bit_iterator<__bitset, true> const_iterator;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bitset() throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __bitset(unsigned long long) throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference __make_ref(size_t) throw() {
    return reference(__nullptr, 1);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference __make_ref(size_t) const throw() {
    return const_reference(__nullptr, 1);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator __make_iter(size_t) throw() {
    return iterator(__nullptr, 0);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator __make_iter(size_t) const throw() {
    return const_iterator(__nullptr, 0);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator&=(const __bitset&) throw() {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator|=(const __bitset&) throw() {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator^=(const __bitset&) throw() {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void flip() throw() {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long to_ulong() const { return 0; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long long to_ullong() const { return 0; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool all() const throw() { return true; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool any() const throw() { return false; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t __hash_code() const throw() { return 0; }
};

inline __bitset<0, 0>::__bitset() throw() {}

inline __bitset<0, 0>::__bitset(unsigned long long) throw() {}

template <size_t _Size>
class bitset;
template <size_t _Size>
struct hash<bitset<_Size> >;

template <size_t _Size>
class bitset
    : private __bitset<_Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1, _Size> {
public:
  static const unsigned __n_words = _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1;
  typedef __bitset<__n_words, _Size> base;

public:
  typedef typename base::reference reference;
  typedef typename base::const_reference const_reference;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset() throw() {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset(unsigned long long __v) throw() : base(__v) {}
  template <class _CharT, class = __enable_if_t<_IsCharLikeType<_CharT>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit bitset(
      const _CharT* __str,



      typename basic_string<_CharT>::size_type __n = basic_string<_CharT>::npos,

      _CharT __zero = _CharT('0'),
      _CharT __one = _CharT('1')) {

    size_t __rlen = std::min(__n, char_traits<_CharT>::length(__str));
    __init_from_string_view(basic_string_view<_CharT>(__str, __rlen), __zero, __one);
  }
# 650 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3
  template <class _CharT, class _Traits, class _Allocator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit bitset(
      const basic_string<_CharT, _Traits, _Allocator>& __str,
      typename basic_string<_CharT, _Traits, _Allocator>::size_type __pos = 0,
      typename basic_string<_CharT, _Traits, _Allocator>::size_type __n =
          basic_string<_CharT, _Traits, _Allocator>::npos,
      _CharT __zero = _CharT('0'),
      _CharT __one = _CharT('1')) {
    if (__pos > __str.size())
      std::__throw_out_of_range("bitset string pos out of range");

    size_t __rlen = std::min(__n, __str.size() - __pos);
    __init_from_string_view(basic_string_view<_CharT, _Traits>(__str.data() + __pos, __rlen), __zero, __one);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset& operator&=(const bitset& __rhs) throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset& operator|=(const bitset& __rhs) throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset& operator^=(const bitset& __rhs) throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset& operator<<=(size_t __pos) throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset& operator>>=(size_t __pos) throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset& set() throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset& set(size_t __pos, bool __val = true);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset& reset() throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset& reset(size_t __pos);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset operator~() const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset& flip() throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset& flip(size_t __pos);





  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference operator[](size_t __p) const { return base::__make_ref(__p); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator[](size_t __p) { return base::__make_ref(__p); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long to_ulong() const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long long to_ullong() const;
  template <class _CharT, class _Traits, class _Allocator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string<_CharT, _Traits, _Allocator>
  to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const;
  template <class _CharT, class _Traits>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string<_CharT, _Traits, allocator<_CharT> >
  to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const;
  template <class _CharT>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >
  to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string<char, char_traits<char>, allocator<char> >
  to_string(char __zero = '0', char __one = '1') const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t count() const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t size() const throw() { return _Size; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const bitset& __rhs) const throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const bitset& __rhs) const throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool test(size_t __pos) const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool all() const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool any() const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool none() const throw() { return !any(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset operator<<(size_t __pos) const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset operator>>(size_t __pos) const throw();

private:
  template <class _CharT, class _Traits>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __init_from_string_view(basic_string_view<_CharT, _Traits> __str, _CharT __zero, _CharT __one) {
    for (size_t __i = 0; __i < __str.size(); ++__i)
      if (!_Traits::eq(__str[__i], __zero) && !_Traits::eq(__str[__i], __one))
        std::__throw_invalid_argument("bitset string ctor has invalid argument");

    size_t __mp = std::min(__str.size(), _Size);
    size_t __i = 0;
    for (; __i < __mp; ++__i) {
      _CharT __c = __str[__mp - 1 - __i];
      (*this)[__i] = _Traits::eq(__c, __one);
    }
    std::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t __hash_code() const throw() { return base::__hash_code(); }

  friend struct hash<bitset>;
};

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset<_Size>&
bitset<_Size>::operator&=(const bitset& __rhs) throw() {
  base::operator&=(__rhs);
  return *this;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset<_Size>&
bitset<_Size>::operator|=(const bitset& __rhs) throw() {
  base::operator|=(__rhs);
  return *this;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset<_Size>&
bitset<_Size>::operator^=(const bitset& __rhs) throw() {
  base::operator^=(__rhs);
  return *this;
}

template <size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset<_Size>& bitset<_Size>::operator<<=(size_t __pos) throw() {
  __pos = std::min(__pos, _Size);
  std::copy_backward(base::__make_iter(0), base::__make_iter(_Size - __pos), base::__make_iter(_Size));
  std::fill_n(base::__make_iter(0), __pos, false);
  return *this;
}

template <size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset<_Size>& bitset<_Size>::operator>>=(size_t __pos) throw() {
  __pos = std::min(__pos, _Size);
  std::copy(base::__make_iter(__pos), base::__make_iter(_Size), base::__make_iter(0));
  std::fill_n(base::__make_iter(_Size - __pos), __pos, false);
  return *this;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset<_Size>& bitset<_Size>::set() throw() {
  std::fill_n(base::__make_iter(0), _Size, true);
  return *this;
}

template <size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset<_Size>& bitset<_Size>::set(size_t __pos, bool __val) {
  if (__pos >= _Size)
    __throw_out_of_range("bitset set argument out of range");

  (*this)[__pos] = __val;
  return *this;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset<_Size>& bitset<_Size>::reset() throw() {
  std::fill_n(base::__make_iter(0), _Size, false);
  return *this;
}

template <size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset<_Size>& bitset<_Size>::reset(size_t __pos) {
  if (__pos >= _Size)
    __throw_out_of_range("bitset reset argument out of range");

  (*this)[__pos] = false;
  return *this;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset<_Size> bitset<_Size>::operator~() const throw() {
  bitset __x(*this);
  __x.flip();
  return __x;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset<_Size>& bitset<_Size>::flip() throw() {
  base::flip();
  return *this;
}

template <size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset<_Size>& bitset<_Size>::flip(size_t __pos) {
  if (__pos >= _Size)
    __throw_out_of_range("bitset flip argument out of range");

  reference __r = base::__make_ref(__pos);
  __r = ~__r;
  return *this;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long bitset<_Size>::to_ulong() const {
  return base::to_ulong();
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unsigned long long bitset<_Size>::to_ullong() const {
  return base::to_ullong();
}

template <size_t _Size>
template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string<_CharT, _Traits, _Allocator>
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const {
  basic_string<_CharT, _Traits, _Allocator> __r(_Size, __zero);
  for (size_t __i = 0; __i != _Size; ++__i) {
    if ((*this)[__i])
      __r[_Size - 1 - __i] = __one;
  }
  return __r;
}

template <size_t _Size>
template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string<_CharT, _Traits, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const {
  return to_string<_CharT, _Traits, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const {
  return to_string<_CharT, char_traits<_CharT>, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_string<char, char_traits<char>, allocator<char> >
bitset<_Size>::to_string(char __zero, char __one) const {
  return to_string<char, char_traits<char>, allocator<char> >(__zero, __one);
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t bitset<_Size>::count() const throw() {
  return static_cast<size_t>(std::count(base::__make_iter(0), base::__make_iter(_Size), true));
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
bitset<_Size>::operator==(const bitset& __rhs) const throw() {
  return std::equal(base::__make_iter(0), base::__make_iter(_Size), __rhs.__make_iter(0));
}



template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool bitset<_Size>::operator!=(const bitset& __rhs) const throw() {
  return !(*this == __rhs);
}



template <size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool bitset<_Size>::test(size_t __pos) const {
  if (__pos >= _Size)
    __throw_out_of_range("bitset test argument out of range");

  return (*this)[__pos];
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool bitset<_Size>::all() const throw() {
  return base::all();
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool bitset<_Size>::any() const throw() {
  return base::any();
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset<_Size>
bitset<_Size>::operator<<(size_t __pos) const throw() {
  bitset __r = *this;
  __r <<= __pos;
  return __r;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset<_Size>
bitset<_Size>::operator>>(size_t __pos) const throw() {
  bitset __r = *this;
  __r >>= __pos;
  return __r;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset<_Size>
operator&(const bitset<_Size>& __x, const bitset<_Size>& __y) throw() {
  bitset<_Size> __r = __x;
  __r &= __y;
  return __r;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset<_Size>
operator|(const bitset<_Size>& __x, const bitset<_Size>& __y) throw() {
  bitset<_Size> __r = __x;
  __r |= __y;
  return __r;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bitset<_Size>
operator^(const bitset<_Size>& __x, const bitset<_Size>& __y) throw() {
  bitset<_Size> __r = __x;
  __r ^= __y;
  return __r;
}

template <size_t _Size>
struct hash<bitset<_Size> > : public __unary_function<bitset<_Size>, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(const bitset<_Size>& __bs) const throw() { return __bs.__hash_code(); }
};

template <class _CharT, class _Traits, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x);

template <class _CharT, class _Traits, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x);

}}
# 188 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ostream" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/format" 1 3
# 195 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/format" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/container_adaptor.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/container_adaptor.h" 3





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/range_default_formatter.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/range_default_formatter.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/statically_widen.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/statically_widen.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__chrono/statically_widen.h" 3
}}
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/range_default_formatter.h" 2 3




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/range_formatter.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/range_formatter.h" 3








# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_context.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_context.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_arg_store.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_arg_store.h" 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_arg_store.h" 3
namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 265 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_arg_store.h" 3
}}
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_context.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_args.h" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_args.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_args.h" 3
}}
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_context.h" 2 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_context.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_context.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 209 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_context.h" 3
}}
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/range_formatter.h" 2 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/range_formatter.h" 3
namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 262 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/range_formatter.h" 3
}}
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/range_default_formatter.h" 2 3
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/range_default_formatter.h" 3
namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 212 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/range_default_formatter.h" 3
}}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/container_adaptor.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/ref_view.h" 1 3
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/ref_view.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__ranges/ref_view.h" 3
}}
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/container_adaptor.h" 2 3


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 1 3
# 272 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 1 3
# 240 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 244 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Allocator = allocator<_Tp> >
class deque;

template <class _ValueType, class _DiffType>
struct __deque_block_size {
  static const _DiffType value = sizeof(_ValueType) < 256 ? 4096 / sizeof(_ValueType) : 16;
};

template <class _ValueType,
          class _Pointer,
          class _Reference,
          class _MapPointer,
          class _DiffType,
          _DiffType _BS =





              __deque_block_size<_ValueType, _DiffType>::value

          >
class __deque_iterator {
  typedef _MapPointer __map_iterator;

public:
  typedef _Pointer pointer;
  typedef _DiffType difference_type;

private:
  __map_iterator __m_iter_;
  pointer __ptr_;

  static const difference_type __block_size;

public:
  typedef _ValueType value_type;
  typedef random_access_iterator_tag iterator_category;
  typedef _Reference reference;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __deque_iterator() throw()




  {
  }

  template <class _Pp, class _Rp, class _MP, __enable_if_t<is_convertible<_Pp, pointer>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  __deque_iterator(const __deque_iterator<value_type, _Pp, _Rp, _MP, difference_type, _BS>& __it) throw()
      : __m_iter_(__it.__m_iter_),
        __ptr_(__it.__ptr_) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator*() const { return *__ptr_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer operator->() const { return __ptr_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __deque_iterator& operator++() {
    if (++__ptr_ - *__m_iter_ == __block_size) {
      ++__m_iter_;
      __ptr_ = *__m_iter_;
    }
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __deque_iterator operator++(int) {
    __deque_iterator __tmp = *this;
    ++(*this);
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __deque_iterator& operator--() {
    if (__ptr_ == *__m_iter_) {
      --__m_iter_;
      __ptr_ = *__m_iter_ + __block_size;
    }
    --__ptr_;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __deque_iterator operator--(int) {
    __deque_iterator __tmp = *this;
    --(*this);
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __deque_iterator& operator+=(difference_type __n) {
    if (__n != 0) {
      __n += __ptr_ - *__m_iter_;
      if (__n > 0) {
        __m_iter_ += __n / __block_size;
        __ptr_ = *__m_iter_ + __n % __block_size;
      } else
      {
        difference_type __z = __block_size - 1 - __n;
        __m_iter_ -= __z / __block_size;
        __ptr_ = *__m_iter_ + (__block_size - 1 - __z % __block_size);
      }
    }
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __deque_iterator& operator-=(difference_type __n) { return *this += -__n; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __deque_iterator operator+(difference_type __n) const {
    __deque_iterator __t(*this);
    __t += __n;
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __deque_iterator operator-(difference_type __n) const {
    __deque_iterator __t(*this);
    __t -= __n;
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend __deque_iterator operator+(difference_type __n, const __deque_iterator& __it) {
    return __it + __n;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend difference_type operator-(const __deque_iterator& __x, const __deque_iterator& __y) {
    if (__x != __y)
      return (__x.__m_iter_ - __y.__m_iter_) * __block_size + (__x.__ptr_ - *__x.__m_iter_) -
             (__y.__ptr_ - *__y.__m_iter_);
    return 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator[](difference_type __n) const { return *(*this + __n); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool operator==(const __deque_iterator& __x, const __deque_iterator& __y) {
    return __x.__ptr_ == __y.__ptr_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool operator!=(const __deque_iterator& __x, const __deque_iterator& __y) {
    return !(__x == __y);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool operator<(const __deque_iterator& __x, const __deque_iterator& __y) {
    return __x.__m_iter_ < __y.__m_iter_ || (__x.__m_iter_ == __y.__m_iter_ && __x.__ptr_ < __y.__ptr_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool operator>(const __deque_iterator& __x, const __deque_iterator& __y) {
    return __y < __x;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool operator<=(const __deque_iterator& __x, const __deque_iterator& __y) {
    return !(__y < __x);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool operator>=(const __deque_iterator& __x, const __deque_iterator& __y) {
    return !(__x < __y);
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __deque_iterator(__map_iterator __m, pointer __p) throw()
      : __m_iter_(__m),
        __ptr_(__p) {}

  template <class _Tp, class _Ap>
  friend class deque;
  template <class _Vp, class _Pp, class _Rp, class _MP, class _Dp, _Dp>
  friend class __deque_iterator;

  template <class>
  friend struct __segmented_iterator_traits;
};

template <class _ValueType, class _Pointer, class _Reference, class _MapPointer, class _DiffType, _DiffType _BlockSize>
struct __segmented_iterator_traits<
    __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize> > {
private:
  using _Iterator = __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize>;

public:
  using __is_segmented_iterator = true_type;
  using __segment_iterator = _MapPointer;
  using __local_iterator = _Pointer;

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __segment_iterator __segment(_Iterator __iter) { return __iter.__m_iter_; }
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __local_iterator __local(_Iterator __iter) { return __iter.__ptr_; }
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __local_iterator __begin(__segment_iterator __iter) { return *__iter; }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __local_iterator __end(__segment_iterator __iter) {
    return *__iter + _Iterator::__block_size;
  }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Iterator __compose(__segment_iterator __segment, __local_iterator __local) {
    if (__segment && __local == __end(__segment)) {
      ++__segment;
      return _Iterator(__segment, *__segment);
    }
    return _Iterator(__segment, __local);
  }
};

template <class _ValueType, class _Pointer, class _Reference, class _MapPointer, class _DiffType, _DiffType _BlockSize>
const _DiffType __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer, _DiffType, _BlockSize>::__block_size =
    __deque_block_size<_ValueType, _DiffType>::value;

template <class _Tp, class _Allocator >
class deque {
public:


  using value_type = _Tp;

  _Static_assert((is_same<typename _Allocator::value_type, value_type>::value), "Allocator::value_type must be same type as value_type");


  using allocator_type = _Allocator;
  using __alloc_traits = allocator_traits<allocator_type>;

  using size_type = typename __alloc_traits::size_type;
  using difference_type = typename __alloc_traits::difference_type;

  using pointer = typename __alloc_traits::pointer;
  using const_pointer = typename __alloc_traits::const_pointer;

  using __pointer_allocator = __rebind_alloc<__alloc_traits, pointer>;
  using __const_pointer_allocator = __rebind_alloc<__alloc_traits, const_pointer>;
  using __map = __split_buffer<pointer, __pointer_allocator>;
  using __map_alloc_traits = allocator_traits<__pointer_allocator>;
  using __map_pointer = typename __map_alloc_traits::pointer;
  using __map_const_pointer = typename allocator_traits<__const_pointer_allocator>::const_pointer;
  using __map_const_iterator = typename __map::const_iterator;

  using reference = value_type&;
  using const_reference = const value_type&;

  using iterator = __deque_iterator<value_type, pointer, reference, __map_pointer, difference_type>;
  using const_iterator =
      __deque_iterator<value_type, const_pointer, const_reference, __map_const_pointer, difference_type>;
  using reverse_iterator = std::reverse_iterator<iterator>;
  using const_reverse_iterator = std::reverse_iterator<const_iterator>;

  _Static_assert(is_same<allocator_type, __rebind_alloc<__alloc_traits, value_type> >::value, "[allocator.requirements] states that rebinding an allocator to the same type should result in the " "original allocator");


  _Static_assert(is_nothrow_default_constructible<allocator_type>::value == is_nothrow_default_constructible<__pointer_allocator>::value, "rebinding an allocator should not change excpetion guarantees");


  _Static_assert(is_nothrow_move_constructible<allocator_type>::value == is_nothrow_move_constructible<typename __map::allocator_type>::value, "rebinding an allocator should not change excpetion guarantees");



private:
  struct __deque_block_range {
    explicit __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __deque_block_range(pointer __b, pointer __e) throw()
        : __begin_(__b),
          __end_(__e) {}
    const pointer __begin_;
    const pointer __end_;
  };

  struct __deque_range {
    iterator __pos_;
    const iterator __end_;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __deque_range(iterator __pos, iterator __e) throw() : __pos_(__pos), __end_(__e) {}

    explicit __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) operator bool() const throw() { return __pos_ != __end_; }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __deque_range begin() const { return *this; }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __deque_range end() const { return __deque_range(__end_, __end_); }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __deque_block_range operator*() const throw() {
      if (__pos_.__m_iter_ == __end_.__m_iter_) {
        return __deque_block_range(__pos_.__ptr_, __end_.__ptr_);
      }
      return __deque_block_range(__pos_.__ptr_, *__pos_.__m_iter_ + __block_size);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __deque_range& operator++() throw() {
      if (__pos_.__m_iter_ == __end_.__m_iter_) {
        __pos_ = __end_;
      } else {
        ++__pos_.__m_iter_;
        __pos_.__ptr_ = *__pos_.__m_iter_;
      }
      return *this;
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool operator==(__deque_range const& __lhs, __deque_range const& __rhs) {
      return __lhs.__pos_ == __rhs.__pos_;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) friend bool operator!=(__deque_range const& __lhs, __deque_range const& __rhs) {
      return !(__lhs == __rhs);
    }
  };

  struct _ConstructTransaction {
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _ConstructTransaction(deque* __db, __deque_block_range& __r)
        : __pos_(__r.__begin_), __end_(__r.__end_), __begin_(__r.__begin_), __base_(__db) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~_ConstructTransaction() { __base_->__size() += (__pos_ - __begin_); }

    pointer __pos_;
    const pointer __end_;

  private:
    const pointer __begin_;
    deque* const __base_;
  };

  static const difference_type __block_size;

  __map __map_;
  size_type __start_;
  __compressed_pair<size_type, allocator_type> __size_;

public:

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) deque()
      : __start_(0), __size_(0, __default_init_tag()) {
    __annotate_new(0);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~deque() {
    clear();
    __annotate_delete();
    typename __map::iterator __i = __map_.begin();
    typename __map::iterator __e = __map_.end();
    for (; __i != __e; ++__i)
      __alloc_traits::deallocate(__alloc(), *__i, __block_size);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit deque(const allocator_type& __a)
      : __map_(__pointer_allocator(__a)), __start_(0), __size_(0, __a) {
    __annotate_new(0);
  }

  explicit __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) deque(size_type __n);



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) deque(size_type __n, const value_type& __v);

  template <class = __enable_if_t<__is_allocator<_Allocator>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) deque(size_type __n, const value_type& __v, const allocator_type& __a)
      : __map_(__pointer_allocator(__a)), __start_(0), __size_(0, __a) {
    __annotate_new(0);
    if (__n > 0)
      __append(__n, __v);
  }

  template <class _InputIter, __enable_if_t<__has_input_iterator_category<_InputIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) deque(_InputIter __f, _InputIter __l);
  template <class _InputIter, __enable_if_t<__has_input_iterator_category<_InputIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) deque(_InputIter __f, _InputIter __l, const allocator_type& __a);
# 612 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) deque(const deque& __c);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) deque(const deque& __c, const __type_identity_t<allocator_type>& __a);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) deque& operator=(const deque& __c);
# 635 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3
  template <class _InputIter,
            __enable_if_t<__has_input_iterator_category<_InputIter>::value &&
                              !__has_random_access_iterator_category<_InputIter>::value,
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void assign(_InputIter __f, _InputIter __l);
  template <class _RAIter, __enable_if_t<__has_random_access_iterator_category<_RAIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void assign(_RAIter __f, _RAIter __l);
# 660 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void assign(size_type __n, const value_type& __v);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) allocator_type get_allocator() const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) allocator_type& __alloc() throw() { return __size_.second(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const allocator_type& __alloc() const throw() { return __size_.second(); }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator begin() throw() {
    __map_pointer __mp = __map_.begin() + __start_ / __block_size;
    return iterator(__mp, __map_.empty() ? 0 : *__mp + __start_ % __block_size);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator begin() const throw() {
    __map_const_pointer __mp = static_cast<__map_const_pointer>(__map_.begin() + __start_ / __block_size);
    return const_iterator(__mp, __map_.empty() ? 0 : *__mp + __start_ % __block_size);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator end() throw() {
    size_type __p = size() + __start_;
    __map_pointer __mp = __map_.begin() + __p / __block_size;
    return iterator(__mp, __map_.empty() ? 0 : *__mp + __p % __block_size);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator end() const throw() {
    size_type __p = size() + __start_;
    __map_const_pointer __mp = static_cast<__map_const_pointer>(__map_.begin() + __p / __block_size);
    return const_iterator(__mp, __map_.empty() ? 0 : *__mp + __p % __block_size);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator rbegin() throw() { return reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator rbegin() const throw() { return const_reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reverse_iterator rend() throw() { return reverse_iterator(begin()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator rend() const throw() { return const_reverse_iterator(begin()); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator cbegin() const throw() { return begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator cend() const throw() { return end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator crbegin() const throw() { return const_reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reverse_iterator crend() const throw() { return const_reverse_iterator(begin()); }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type size() const throw() { return __size(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type& __size() throw() { return __size_.first(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const size_type& __size() const throw() { return __size_.first(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type max_size() const throw() {
    return std::min<size_type>(__alloc_traits::max_size(__alloc()), numeric_limits<difference_type>::max());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void resize(size_type __n);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void resize(size_type __n, const value_type& __v);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void shrink_to_fit() throw();
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool empty() const throw() { return size() == 0; }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator[](size_type __i) throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference operator[](size_type __i) const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference at(size_type __i);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference at(size_type __i) const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference front() throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference front() const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference back() throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference back() const throw();


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void push_front(const value_type& __v);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void push_back(const value_type& __v);
# 763 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator insert(const_iterator __p, const value_type& __v);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator insert(const_iterator __p, size_type __n, const value_type& __v);
  template <class _InputIter, __enable_if_t<__has_exactly_input_iterator_category<_InputIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator insert(const_iterator __p, _InputIter __f, _InputIter __l);
  template <class _ForwardIterator,
            __enable_if_t<__has_exactly_forward_iterator_category<_ForwardIterator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator insert(const_iterator __p, _ForwardIterator __f, _ForwardIterator __l);
  template <class _BiIter, __enable_if_t<__has_bidirectional_iterator_category<_BiIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator insert(const_iterator __p, _BiIter __f, _BiIter __l);
# 790 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void pop_front();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void pop_back();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator erase(const_iterator __p);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator erase(const_iterator __f, const_iterator __l);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(deque& __c)



                                                                                                                      ;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void clear() throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __invariants() const {
    if (!__map_.__invariants())
      return false;
    if (__map_.size() >= size_type(-1) / __block_size)
      return false;
    for (__map_const_iterator __i = __map_.begin(), __e = __map_.end(); __i != __e; ++__i)
      if (*__i == __nullptr)
        return false;
    if (__map_.size() != 0) {
      if (size() >= __map_.size() * __block_size)
        return false;
      if (__start_ >= __map_.size() * __block_size - size())
        return false;
    } else {
      if (size() != 0)
        return false;
      if (__start_ != 0)
        return false;
    }
    return true;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign_alloc(deque& __c)

                                                                    {
    __move_assign_alloc(__c, integral_constant<bool, __alloc_traits::propagate_on_container_move_assignment::value>());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign_alloc(deque& __c, true_type)
                                                                    {
    __alloc() = std::move(__c.__alloc());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign_alloc(deque&, false_type) throw() {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign(deque& __c)

                                                                        {
    __map_ = std::move(__c.__map_);
    __start_ = __c.__start_;
    __size() = __c.size();
    __move_assign_alloc(__c);
    __c.__start_ = __c.__size() = 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static size_type __recommend_blocks(size_type __n) {
    return __n / __block_size + (__n % __block_size != 0);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type __capacity() const {
    return __map_.size() == 0 ? 0 : __map_.size() * __block_size - 1;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type __block_count() const { return __map_.size(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type __front_spare() const { return __start_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type __front_spare_blocks() const { return __front_spare() / __block_size; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type __back_spare() const { return __capacity() - (__start_ + size()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type __back_spare_blocks() const { return __back_spare() / __block_size; }

private:
  enum __asan_annotation_type { __asan_unposion, __asan_poison };

  enum __asan_annotation_place {
    __asan_front_moved,
    __asan_back_moved,
  };
# 876 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __annotate_double_ended_contiguous_container(
      const void* __beg,
      const void* __end,
      const void* __old_con_beg,
      const void* __old_con_end,
      const void* __new_con_beg,
      const void* __new_con_end) const {
    (void)__beg;
    (void)__end;
    (void)__old_con_beg;
    (void)__old_con_end;
    (void)__new_con_beg;
    (void)__new_con_end;





  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __annotate_from_to(
      size_type __beg,
      size_type __end,
      __asan_annotation_type __annotation_type,
      __asan_annotation_place __place) const throw() {
    (void)__beg;
    (void)__end;
    (void)__annotation_type;
    (void)__place;
# 998 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __annotate_new(size_type __current_size) const throw() {
    (void)__current_size;
# 1010 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __annotate_delete() const throw() {
# 1023 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __annotate_increase_front(size_type __n) const throw() {
    (void)__n;



  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __annotate_increase_back(size_type __n) const throw() {
    (void)__n;



  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __annotate_shrink_front(size_type __old_size, size_type __old_start) const throw() {
    (void)__old_size;
    (void)__old_start;



  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __annotate_shrink_back(size_type __old_size, size_type __old_start) const throw() {
    (void)__old_size;
    (void)__old_start;



  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __annotate_poison_block(const void* __beginning, const void* __end) const throw() {
    (void)__beginning;
    (void)__end;



  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __annotate_whole_block(size_t __block_index, __asan_annotation_type __annotation_type) const throw() {
    (void)__block_index;
    (void)__annotation_type;
# 1079 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3
  }
# 1143 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __maybe_remove_front_spare(bool __keep_one = true) {
    if (__front_spare_blocks() >= 2 || (!__keep_one && __front_spare_blocks())) {
      __annotate_whole_block(0, __asan_unposion);
      __alloc_traits::deallocate(__alloc(), __map_.front(), __block_size);
      __map_.pop_front();
      __start_ -= __block_size;
      return true;
    }
    return false;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __maybe_remove_back_spare(bool __keep_one = true) {
    if (__back_spare_blocks() >= 2 || (!__keep_one && __back_spare_blocks())) {
      __annotate_whole_block(__map_.size() - 1, __asan_unposion);
      __alloc_traits::deallocate(__alloc(), __map_.back(), __block_size);
      __map_.pop_back();
      return true;
    }
    return false;
  }

  template <class _Iterator, class _Sentinel>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __assign_with_sentinel(_Iterator __f, _Sentinel __l);

  template <class _RandomAccessIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __assign_with_size_random_access(_RandomAccessIterator __f, difference_type __n);
  template <class _Iterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __assign_with_size(_Iterator __f, difference_type __n);

  template <class _Iterator, class _Sentinel>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator __insert_with_sentinel(const_iterator __p, _Iterator __f, _Sentinel __l);

  template <class _Iterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator __insert_with_size(const_iterator __p, _Iterator __f, size_type __n);

  template <class _BiIter, class _Sentinel>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator
  __insert_bidirectional(const_iterator __p, _BiIter __f, _Sentinel __sent, size_type __n);
  template <class _BiIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator __insert_bidirectional(const_iterator __p, _BiIter __f, _BiIter __l, size_type __n);

  template <class _InpIter, __enable_if_t<__has_exactly_input_iterator_category<_InpIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __append(_InpIter __f, _InpIter __l);
  template <class _ForIter, __enable_if_t<__has_forward_iterator_category<_ForIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __append(_ForIter __f, _ForIter __l);

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __append_with_size(_InputIterator __from, size_type __n);
  template <class _InputIterator, class _Sentinel>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __append_with_sentinel(_InputIterator __f, _Sentinel __l);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __append(size_type __n);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __append(size_type __n, const value_type& __v);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __erase_to_end(const_iterator __f);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __add_front_capacity();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __add_front_capacity(size_type __n);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __add_back_capacity();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __add_back_capacity(size_type __n);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator __move_and_check(iterator __f, iterator __l, iterator __r, const_pointer& __vt);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator
  __move_backward_and_check(iterator __f, iterator __l, iterator __r, const_pointer& __vt);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_construct_and_check(iterator __f, iterator __l, iterator __r, const_pointer& __vt);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
  __move_construct_backward_and_check(iterator __f, iterator __l, iterator __r, const_pointer& __vt);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __copy_assign_alloc(const deque& __c) {
    __copy_assign_alloc(__c, integral_constant<bool, __alloc_traits::propagate_on_container_copy_assignment::value>());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __copy_assign_alloc(const deque& __c, true_type) {
    if (__alloc() != __c.__alloc()) {
      clear();
      shrink_to_fit();
    }
    __alloc() = __c.__alloc();
    __map_.__alloc() = __c.__map_.__alloc();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __copy_assign_alloc(const deque&, false_type) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign(deque& __c, true_type)
                                                                   ;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign(deque& __c, false_type);
};

template <class _Tp, class _Alloc>
                  const typename allocator_traits<_Alloc>::difference_type deque<_Tp, _Alloc>::__block_size =
    __deque_block_size<value_type, difference_type>::value;
# 1253 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3
template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(size_type __n) : __start_(0), __size_(0, __default_init_tag()) {
  __annotate_new(0);
  if (__n > 0)
    __append(__n);
}
# 1270 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3
template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(size_type __n, const value_type& __v) : __start_(0), __size_(0, __default_init_tag()) {
  __annotate_new(0);
  if (__n > 0)
    __append(__n, __v);
}

template <class _Tp, class _Allocator>
template <class _InputIter, __enable_if_t<__has_input_iterator_category<_InputIter>::value, int> >
deque<_Tp, _Allocator>::deque(_InputIter __f, _InputIter __l) : __start_(0), __size_(0, __default_init_tag()) {
  __annotate_new(0);
  __append(__f, __l);
}

template <class _Tp, class _Allocator>
template <class _InputIter, __enable_if_t<__has_input_iterator_category<_InputIter>::value, int> >
deque<_Tp, _Allocator>::deque(_InputIter __f, _InputIter __l, const allocator_type& __a)
    : __map_(__pointer_allocator(__a)), __start_(0), __size_(0, __a) {
  __annotate_new(0);
  __append(__f, __l);
}

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(const deque& __c)
    : __map_(__pointer_allocator(__alloc_traits::select_on_container_copy_construction(__c.__alloc()))),
      __start_(0),
      __size_(0, __map_.__alloc()) {
  __annotate_new(0);
  __append(__c.begin(), __c.end());
}

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(const deque& __c, const __type_identity_t<allocator_type>& __a)
    : __map_(__pointer_allocator(__a)), __start_(0), __size_(0, __a) {
  __annotate_new(0);
  __append(__c.begin(), __c.end());
}

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>& deque<_Tp, _Allocator>::operator=(const deque& __c) {
  if (this != std::addressof(__c)) {
    __copy_assign_alloc(__c);
    assign(__c.begin(), __c.end());
  }
  return *this;
}
# 1382 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3
template <class _Tp, class _Allocator>
template <class _InputIter,
          __enable_if_t<__has_input_iterator_category<_InputIter>::value &&
                            !__has_random_access_iterator_category<_InputIter>::value,
                        int> >
void deque<_Tp, _Allocator>::assign(_InputIter __f, _InputIter __l) {
  __assign_with_sentinel(__f, __l);
}

template <class _Tp, class _Allocator>
template <class _Iterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void deque<_Tp, _Allocator>::__assign_with_sentinel(_Iterator __f, _Sentinel __l) {
  iterator __i = begin();
  iterator __e = end();
  for (; __f != __l && __i != __e; ++__f, (void)++__i)
    *__i = *__f;
  if (__f != __l)
    __append_with_sentinel(std::move(__f), std::move(__l));
  else
    __erase_to_end(__i);
}

template <class _Tp, class _Allocator>
template <class _RAIter, __enable_if_t<__has_random_access_iterator_category<_RAIter>::value, int> >
void deque<_Tp, _Allocator>::assign(_RAIter __f, _RAIter __l) {
  __assign_with_size_random_access(__f, __l - __f);
}

template <class _Tp, class _Allocator>
template <class _RandomAccessIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
deque<_Tp, _Allocator>::__assign_with_size_random_access(_RandomAccessIterator __f, difference_type __n) {
  if (static_cast<size_type>(__n) > size()) {
    auto __l = __f + size();
    std::copy(__f, __l, begin());
    __append_with_size(__l, __n - size());
  } else
    __erase_to_end(std::copy_n(__f, __n, begin()));
}

template <class _Tp, class _Allocator>
template <class _Iterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void deque<_Tp, _Allocator>::__assign_with_size(_Iterator __f, difference_type __n) {
  if (static_cast<size_type>(__n) > size()) {
    auto __added_size = __n - size();

    auto __i = begin();
    for (auto __count = size(); __count != 0; --__count) {
      *__i++ = *__f++;
    }

    __append_with_size(__f, __added_size);

  } else {
    __erase_to_end(std::copy_n(__f, __n, begin()));
  }
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::assign(size_type __n, const value_type& __v) {
  if (__n > size()) {
    std::fill_n(begin(), size(), __v);
    __n -= size();
    __append(__n, __v);
  } else
    __erase_to_end(std::fill_n(begin(), __n, __v));
}

template <class _Tp, class _Allocator>
inline _Allocator deque<_Tp, _Allocator>::get_allocator() const throw() {
  return __alloc();
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::resize(size_type __n) {
  if (__n > size())
    __append(__n - size());
  else if (__n < size())
    __erase_to_end(begin() + __n);
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::resize(size_type __n, const value_type& __v) {
  if (__n > size())
    __append(__n - size(), __v);
  else if (__n < size())
    __erase_to_end(begin() + __n);
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::shrink_to_fit() throw() {
  allocator_type& __a = __alloc();
  if (empty()) {
    __annotate_delete();
    while (__map_.size() > 0) {
      __alloc_traits::deallocate(__a, __map_.back(), __block_size);
      __map_.pop_back();
    }
    __start_ = 0;
  } else {
    __maybe_remove_front_spare( false);
    __maybe_remove_back_spare( false);
  }
  __map_.shrink_to_fit();
}

template <class _Tp, class _Allocator>
inline typename deque<_Tp, _Allocator>::reference deque<_Tp, _Allocator>::operator[](size_type __i) throw() {
  size_type __p = __start_ + __i;
  return *(*(__map_.begin() + __p / __block_size) + __p % __block_size);
}

template <class _Tp, class _Allocator>
inline typename deque<_Tp, _Allocator>::const_reference
deque<_Tp, _Allocator>::operator[](size_type __i) const throw() {
  size_type __p = __start_ + __i;
  return *(*(__map_.begin() + __p / __block_size) + __p % __block_size);
}

template <class _Tp, class _Allocator>
inline typename deque<_Tp, _Allocator>::reference deque<_Tp, _Allocator>::at(size_type __i) {
  if (__i >= size())
    std::__throw_out_of_range("deque");
  size_type __p = __start_ + __i;
  return *(*(__map_.begin() + __p / __block_size) + __p % __block_size);
}

template <class _Tp, class _Allocator>
inline typename deque<_Tp, _Allocator>::const_reference deque<_Tp, _Allocator>::at(size_type __i) const {
  if (__i >= size())
    std::__throw_out_of_range("deque");
  size_type __p = __start_ + __i;
  return *(*(__map_.begin() + __p / __block_size) + __p % __block_size);
}

template <class _Tp, class _Allocator>
inline typename deque<_Tp, _Allocator>::reference deque<_Tp, _Allocator>::front() throw() {
  return *(*(__map_.begin() + __start_ / __block_size) + __start_ % __block_size);
}

template <class _Tp, class _Allocator>
inline typename deque<_Tp, _Allocator>::const_reference deque<_Tp, _Allocator>::front() const throw() {
  return *(*(__map_.begin() + __start_ / __block_size) + __start_ % __block_size);
}

template <class _Tp, class _Allocator>
inline typename deque<_Tp, _Allocator>::reference deque<_Tp, _Allocator>::back() throw() {
  size_type __p = size() + __start_ - 1;
  return *(*(__map_.begin() + __p / __block_size) + __p % __block_size);
}

template <class _Tp, class _Allocator>
inline typename deque<_Tp, _Allocator>::const_reference deque<_Tp, _Allocator>::back() const throw() {
  size_type __p = size() + __start_ - 1;
  return *(*(__map_.begin() + __p / __block_size) + __p % __block_size);
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::push_back(const value_type& __v) {
  allocator_type& __a = __alloc();
  if (__back_spare() == 0)
    __add_back_capacity();

  __annotate_increase_back(1);
  __alloc_traits::construct(__a, std::addressof(*end()), __v);
  ++__size();
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::push_front(const value_type& __v) {
  allocator_type& __a = __alloc();
  if (__front_spare() == 0)
    __add_front_capacity();

  __annotate_increase_front(1);
  __alloc_traits::construct(__a, std::addressof(*--begin()), __v);
  --__start_;
  ++__size();
}
# 1724 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3
template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::insert(const_iterator __p, const value_type& __v) {
  size_type __pos = __p - begin();
  size_type __to_end = size() - __pos;
  allocator_type& __a = __alloc();
  if (__pos < __to_end) {
    if (__front_spare() == 0)
      __add_front_capacity();

    __annotate_increase_front(1);
    if (__pos == 0) {
      __alloc_traits::construct(__a, std::addressof(*--begin()), __v);
      --__start_;
      ++__size();
    } else {
      const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
      iterator __b = begin();
      iterator __bm1 = std::prev(__b);
      if (__vt == pointer_traits<const_pointer>::pointer_to(*__b))
        __vt = pointer_traits<const_pointer>::pointer_to(*__bm1);
      __alloc_traits::construct(__a, std::addressof(*__bm1), std::move(*__b));
      --__start_;
      ++__size();
      if (__pos > 1)
        __b = __move_and_check(std::next(__b), __b + __pos, __b, __vt);
      *__b = *__vt;
    }
  } else {
    if (__back_spare() == 0)
      __add_back_capacity();

    __annotate_increase_back(1);
    size_type __de = size() - __pos;
    if (__de == 0) {
      __alloc_traits::construct(__a, std::addressof(*end()), __v);
      ++__size();
    } else {
      const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
      iterator __e = end();
      iterator __em1 = std::prev(__e);
      if (__vt == pointer_traits<const_pointer>::pointer_to(*__em1))
        __vt = pointer_traits<const_pointer>::pointer_to(*__e);
      __alloc_traits::construct(__a, std::addressof(*__e), std::move(*__em1));
      ++__size();
      if (__de > 1)
        __e = __move_backward_and_check(__e - __de, __em1, __e, __vt);
      *--__e = *__vt;
    }
  }
  return begin() + __pos;
}

template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, size_type __n, const value_type& __v) {
  size_type __pos = __p - begin();
  size_type __to_end = __size() - __pos;
  allocator_type& __a = __alloc();
  if (__pos < __to_end) {
    if (__n > __front_spare())
      __add_front_capacity(__n - __front_spare());

    __annotate_increase_front(__n);
    iterator __old_begin = begin();
    iterator __i = __old_begin;
    if (__n > __pos) {
      for (size_type __m = __n - __pos; __m; --__m, --__start_, ++__size())
        __alloc_traits::construct(__a, std::addressof(*--__i), __v);
      __n = __pos;
    }
    if (__n > 0) {
      const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
      iterator __obn = __old_begin + __n;
      __move_construct_backward_and_check(__old_begin, __obn, __i, __vt);
      if (__n < __pos)
        __old_begin = __move_and_check(__obn, __old_begin + __pos, __old_begin, __vt);
      std::fill_n(__old_begin, __n, *__vt);
    }
  } else {
    size_type __back_capacity = __back_spare();
    if (__n > __back_capacity)
      __add_back_capacity(__n - __back_capacity);

    __annotate_increase_back(__n);
    iterator __old_end = end();
    iterator __i = __old_end;
    size_type __de = size() - __pos;
    if (__n > __de) {
      for (size_type __m = __n - __de; __m; --__m, (void)++__i, ++__size())
        __alloc_traits::construct(__a, std::addressof(*__i), __v);
      __n = __de;
    }
    if (__n > 0) {
      const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
      iterator __oen = __old_end - __n;
      __move_construct_and_check(__oen, __old_end, __i, __vt);
      if (__n < __de)
        __old_end = __move_backward_and_check(__old_end - __de, __oen, __old_end, __vt);
      std::fill_n(__old_end - __n, __n, *__vt);
    }
  }
  return begin() + __pos;
}

template <class _Tp, class _Allocator>
template <class _InputIter, __enable_if_t<__has_exactly_input_iterator_category<_InputIter>::value, int> >
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, _InputIter __f, _InputIter __l) {
  return __insert_with_sentinel(__p, __f, __l);
}

template <class _Tp, class _Allocator>
template <class _Iterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::__insert_with_sentinel(const_iterator __p, _Iterator __f, _Sentinel __l) {
  __split_buffer<value_type, allocator_type&> __buf(__alloc());
  __buf.__construct_at_end_with_sentinel(std::move(__f), std::move(__l));
  typedef typename __split_buffer<value_type, allocator_type&>::iterator __bi;
  return insert(__p, move_iterator<__bi>(__buf.begin()), move_iterator<__bi>(__buf.end()));
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator, __enable_if_t<__has_exactly_forward_iterator_category<_ForwardIterator>::value, int> >
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, _ForwardIterator __f, _ForwardIterator __l) {
  return __insert_with_size(__p, __f, std::distance(__f, __l));
}

template <class _Tp, class _Allocator>
template <class _Iterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::__insert_with_size(const_iterator __p, _Iterator __f, size_type __n) {
  __split_buffer<value_type, allocator_type&> __buf(__n, 0, __alloc());
  __buf.__construct_at_end_with_size(__f, __n);
  typedef typename __split_buffer<value_type, allocator_type&>::iterator __fwd;
  return insert(__p, move_iterator<__fwd>(__buf.begin()), move_iterator<__fwd>(__buf.end()));
}

template <class _Tp, class _Allocator>
template <class _BiIter, __enable_if_t<__has_bidirectional_iterator_category<_BiIter>::value, int> >
typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::insert(const_iterator __p, _BiIter __f, _BiIter __l) {
  return __insert_bidirectional(__p, __f, __l, std::distance(__f, __l));
}

template <class _Tp, class _Allocator>
template <class _BiIter, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::__insert_bidirectional(const_iterator __p, _BiIter __f, _Sentinel, size_type __n) {
  return __insert_bidirectional(__p, __f, std::next(__f, __n), __n);
}

template <class _Tp, class _Allocator>
template <class _BiIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::__insert_bidirectional(const_iterator __p, _BiIter __f, _BiIter __l, size_type __n) {
  size_type __pos = __p - begin();
  size_type __to_end = size() - __pos;
  allocator_type& __a = __alloc();
  if (__pos < __to_end) {
    if (__n > __front_spare())
      __add_front_capacity(__n - __front_spare());

    __annotate_increase_front(__n);
    iterator __old_begin = begin();
    iterator __i = __old_begin;
    _BiIter __m = __f;
    if (__n > __pos) {
      __m = __pos < __n / 2 ? std::prev(__l, __pos) : std::next(__f, __n - __pos);
      for (_BiIter __j = __m; __j != __f; --__start_, ++__size())
        __alloc_traits::construct(__a, std::addressof(*--__i), *--__j);
      __n = __pos;
    }
    if (__n > 0) {
      iterator __obn = __old_begin + __n;
      for (iterator __j = __obn; __j != __old_begin;) {
        __alloc_traits::construct(__a, std::addressof(*--__i), std::move(*--__j));
        --__start_;
        ++__size();
      }
      if (__n < __pos)
        __old_begin = std::move(__obn, __old_begin + __pos, __old_begin);
      std::copy(__m, __l, __old_begin);
    }
  } else {
    size_type __back_capacity = __back_spare();
    if (__n > __back_capacity)
      __add_back_capacity(__n - __back_capacity);

    __annotate_increase_back(__n);
    iterator __old_end = end();
    iterator __i = __old_end;
    _BiIter __m = __l;
    size_type __de = size() - __pos;
    if (__n > __de) {
      __m = __de < __n / 2 ? std::next(__f, __de) : std::prev(__l, __n - __de);
      for (_BiIter __j = __m; __j != __l; ++__i, (void)++__j, ++__size())
        __alloc_traits::construct(__a, std::addressof(*__i), *__j);
      __n = __de;
    }
    if (__n > 0) {
      iterator __oen = __old_end - __n;
      for (iterator __j = __oen; __j != __old_end; ++__i, (void)++__j, ++__size())
        __alloc_traits::construct(__a, std::addressof(*__i), std::move(*__j));
      if (__n < __de)
        __old_end = std::move_backward(__old_end - __de, __oen, __old_end);
      std::copy_backward(__f, __m, __old_end);
    }
  }
  return begin() + __pos;
}

template <class _Tp, class _Allocator>
template <class _InpIter, __enable_if_t<__has_exactly_input_iterator_category<_InpIter>::value, int> >
void deque<_Tp, _Allocator>::__append(_InpIter __f, _InpIter __l) {
  __append_with_sentinel(__f, __l);
}

template <class _Tp, class _Allocator>
template <class _InputIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void deque<_Tp, _Allocator>::__append_with_sentinel(_InputIterator __f, _Sentinel __l) {
  for (; __f != __l; ++__f)

    push_back(*__f);



}

template <class _Tp, class _Allocator>
template <class _ForIter, __enable_if_t<__has_forward_iterator_category<_ForIter>::value, int> >
void deque<_Tp, _Allocator>::__append(_ForIter __f, _ForIter __l) {
  __append_with_size(__f, std::distance(__f, __l));
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void deque<_Tp, _Allocator>::__append_with_size(_InputIterator __f, size_type __n) {
  allocator_type& __a = __alloc();
  size_type __back_capacity = __back_spare();
  if (__n > __back_capacity)
    __add_back_capacity(__n - __back_capacity);


  __annotate_increase_back(__n);
  for (__deque_block_range __br : __deque_range(end(), end() + __n)) {
    _ConstructTransaction __tx(this, __br);
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_, (void)++__f) {
      __alloc_traits::construct(__a, std::__to_address(__tx.__pos_), *__f);
    }
  }
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__append(size_type __n) {
  allocator_type& __a = __alloc();
  size_type __back_capacity = __back_spare();
  if (__n > __back_capacity)
    __add_back_capacity(__n - __back_capacity);

  __annotate_increase_back(__n);
  for (__deque_block_range __br : __deque_range(end(), end() + __n)) {
    _ConstructTransaction __tx(this, __br);
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
      __alloc_traits::construct(__a, std::__to_address(__tx.__pos_));
    }
  }
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__append(size_type __n, const value_type& __v) {
  allocator_type& __a = __alloc();
  size_type __back_capacity = __back_spare();
  if (__n > __back_capacity)
    __add_back_capacity(__n - __back_capacity);

  __annotate_increase_back(__n);
  for (__deque_block_range __br : __deque_range(end(), end() + __n)) {
    _ConstructTransaction __tx(this, __br);
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
      __alloc_traits::construct(__a, std::__to_address(__tx.__pos_), __v);
    }
  }
}



template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__add_front_capacity() {
  allocator_type& __a = __alloc();
  if (__back_spare() >= __block_size) {
    __start_ += __block_size;
    pointer __pt = __map_.back();
    __map_.pop_back();
    __map_.push_front(__pt);
  }

  else if (__map_.size() < __map_.capacity()) {


    if (__map_.__front_spare() > 0)
      __map_.push_front(__alloc_traits::allocate(__a, __block_size));
    else {
      __map_.push_back(__alloc_traits::allocate(__a, __block_size));

      pointer __pt = __map_.back();
      __map_.pop_back();
      __map_.push_front(__pt);
    }
    __start_ = __map_.size() == 1 ? __block_size / 2 : __start_ + __block_size;
  }

  else {
    __split_buffer<pointer, __pointer_allocator&> __buf(
        std::max<size_type>(2 * __map_.capacity(), 1), 0, __map_.__alloc());

    typedef __allocator_destructor<_Allocator> _Dp;
    unique_ptr<pointer, _Dp> __hold(__alloc_traits::allocate(__a, __block_size), _Dp(__a, __block_size));
    __buf.push_back(__hold.get());
    __hold.release();

    for (__map_pointer __i = __map_.begin(); __i != __map_.end(); ++__i)
      __buf.push_back(*__i);
    std::swap(__map_.__first_, __buf.__first_);
    std::swap(__map_.__begin_, __buf.__begin_);
    std::swap(__map_.__end_, __buf.__end_);
    std::swap(__map_.__end_cap(), __buf.__end_cap());
    __start_ = __map_.size() == 1 ? __block_size / 2 : __start_ + __block_size;
  }
  __annotate_whole_block(0, __asan_poison);
}



template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__add_front_capacity(size_type __n) {
  allocator_type& __a = __alloc();
  size_type __nb = __recommend_blocks(__n + __map_.empty());

  size_type __back_capacity = __back_spare() / __block_size;
  __back_capacity = std::min(__back_capacity, __nb);
  __nb -= __back_capacity;

  if (__nb == 0) {
    __start_ += __block_size * __back_capacity;
    for (; __back_capacity > 0; --__back_capacity) {
      pointer __pt = __map_.back();
      __map_.pop_back();
      __map_.push_front(__pt);
    }
  }

  else if (__nb <= __map_.capacity() -
                       __map_.size()) {


    for (; __nb > 0; --__nb, __start_ += __block_size - (__map_.size() == 1)) {
      if (__map_.__front_spare() == 0)
        break;
      __map_.push_front(__alloc_traits::allocate(__a, __block_size));
      __annotate_whole_block(0, __asan_poison);
    }
    for (; __nb > 0; --__nb, ++__back_capacity)
      __map_.push_back(__alloc_traits::allocate(__a, __block_size));

    __start_ += __back_capacity * __block_size;
    for (; __back_capacity > 0; --__back_capacity) {
      pointer __pt = __map_.back();
      __map_.pop_back();
      __map_.push_front(__pt);
      __annotate_whole_block(0, __asan_poison);
    }
  }

  else {
    size_type __ds = (__nb + __back_capacity) * __block_size - __map_.empty();
    __split_buffer<pointer, __pointer_allocator&> __buf(
        std::max<size_type>(2 * __map_.capacity(), __nb + __map_.size()), 0, __map_.__alloc());

    try {

      for (; __nb > 0; --__nb) {
        __buf.push_back(__alloc_traits::allocate(__a, __block_size));

        __annotate_poison_block(std::__to_address(__buf.back()), std::__to_address(__buf.back() + __block_size));
      }

    } catch (...) {
      __annotate_delete();
      for (__map_pointer __i = __buf.begin(); __i != __buf.end(); ++__i)
        __alloc_traits::deallocate(__a, *__i, __block_size);
      throw;
    }

    for (; __back_capacity > 0; --__back_capacity) {
      __buf.push_back(__map_.back());
      __map_.pop_back();
    }
    for (__map_pointer __i = __map_.begin(); __i != __map_.end(); ++__i)
      __buf.push_back(*__i);
    std::swap(__map_.__first_, __buf.__first_);
    std::swap(__map_.__begin_, __buf.__begin_);
    std::swap(__map_.__end_, __buf.__end_);
    std::swap(__map_.__end_cap(), __buf.__end_cap());
    __start_ += __ds;
  }
}



template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__add_back_capacity() {
  allocator_type& __a = __alloc();
  if (__front_spare() >= __block_size) {
    __start_ -= __block_size;
    pointer __pt = __map_.front();
    __map_.pop_front();
    __map_.push_back(__pt);
  }

  else if (__map_.size() < __map_.capacity()) {


    if (__map_.__back_spare() != 0)
      __map_.push_back(__alloc_traits::allocate(__a, __block_size));
    else {
      __map_.push_front(__alloc_traits::allocate(__a, __block_size));

      pointer __pt = __map_.front();
      __map_.pop_front();
      __map_.push_back(__pt);
    }
    __annotate_whole_block(__map_.size() - 1, __asan_poison);
  }

  else {
    __split_buffer<pointer, __pointer_allocator&> __buf(
        std::max<size_type>(2 * __map_.capacity(), 1), __map_.size(), __map_.__alloc());

    typedef __allocator_destructor<_Allocator> _Dp;
    unique_ptr<pointer, _Dp> __hold(__alloc_traits::allocate(__a, __block_size), _Dp(__a, __block_size));
    __buf.push_back(__hold.get());
    __hold.release();

    for (__map_pointer __i = __map_.end(); __i != __map_.begin();)
      __buf.push_front(*--__i);
    std::swap(__map_.__first_, __buf.__first_);
    std::swap(__map_.__begin_, __buf.__begin_);
    std::swap(__map_.__end_, __buf.__end_);
    std::swap(__map_.__end_cap(), __buf.__end_cap());
    __annotate_whole_block(__map_.size() - 1, __asan_poison);
  }
}



template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__add_back_capacity(size_type __n) {
  allocator_type& __a = __alloc();
  size_type __nb = __recommend_blocks(__n + __map_.empty());

  size_type __front_capacity = __front_spare() / __block_size;
  __front_capacity = std::min(__front_capacity, __nb);
  __nb -= __front_capacity;

  if (__nb == 0) {
    __start_ -= __block_size * __front_capacity;
    for (; __front_capacity > 0; --__front_capacity) {
      pointer __pt = __map_.front();
      __map_.pop_front();
      __map_.push_back(__pt);
    }
  }

  else if (__nb <= __map_.capacity() -
                       __map_.size()) {


    for (; __nb > 0; --__nb) {
      if (__map_.__back_spare() == 0)
        break;
      __map_.push_back(__alloc_traits::allocate(__a, __block_size));
      __annotate_whole_block(__map_.size() - 1, __asan_poison);
    }
    for (; __nb > 0; --__nb, ++__front_capacity, __start_ += __block_size - (__map_.size() == 1)) {
      __map_.push_front(__alloc_traits::allocate(__a, __block_size));
      __annotate_whole_block(0, __asan_poison);
    }

    __start_ -= __block_size * __front_capacity;
    for (; __front_capacity > 0; --__front_capacity) {
      pointer __pt = __map_.front();
      __map_.pop_front();
      __map_.push_back(__pt);
    }
  }

  else {
    size_type __ds = __front_capacity * __block_size;
    __split_buffer<pointer, __pointer_allocator&> __buf(
        std::max<size_type>(2 * __map_.capacity(), __nb + __map_.size()),
        __map_.size() - __front_capacity,
        __map_.__alloc());

    try {

      for (; __nb > 0; --__nb) {
        __buf.push_back(__alloc_traits::allocate(__a, __block_size));

        __annotate_poison_block(std::__to_address(__buf.back()), std::__to_address(__buf.back() + __block_size));
      }

    } catch (...) {
      __annotate_delete();
      for (__map_pointer __i = __buf.begin(); __i != __buf.end(); ++__i)
        __alloc_traits::deallocate(__a, *__i, __block_size);
      throw;
    }

    for (; __front_capacity > 0; --__front_capacity) {
      __buf.push_back(__map_.front());
      __map_.pop_front();
    }
    for (__map_pointer __i = __map_.end(); __i != __map_.begin();)
      __buf.push_front(*--__i);
    std::swap(__map_.__first_, __buf.__first_);
    std::swap(__map_.__begin_, __buf.__begin_);
    std::swap(__map_.__end_, __buf.__end_);
    std::swap(__map_.__end_cap(), __buf.__end_cap());
    __start_ -= __ds;
  }
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::pop_front() {
  size_type __old_sz = size();
  size_type __old_start = __start_;
  allocator_type& __a = __alloc();
  __alloc_traits::destroy(
      __a, std::__to_address(*(__map_.begin() + __start_ / __block_size) + __start_ % __block_size));
  --__size();
  ++__start_;
  __annotate_shrink_front(__old_sz, __old_start);
  __maybe_remove_front_spare();
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::pop_back() {
  ((void)0);
  size_type __old_sz = size();
  size_type __old_start = __start_;
  allocator_type& __a = __alloc();
  size_type __p = size() + __start_ - 1;
  __alloc_traits::destroy(__a, std::__to_address(*(__map_.begin() + __p / __block_size) + __p % __block_size));
  --__size();
  __annotate_shrink_back(__old_sz, __old_start);
  __maybe_remove_back_spare();
}



template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::__move_and_check(iterator __f, iterator __l, iterator __r, const_pointer& __vt) {



  difference_type __n = __l - __f;
  while (__n > 0) {
    pointer __fb = __f.__ptr_;
    pointer __fe = *__f.__m_iter_ + __block_size;
    difference_type __bs = __fe - __fb;
    if (__bs > __n) {
      __bs = __n;
      __fe = __fb + __bs;
    }
    if (__fb <= __vt && __vt < __fe)
      __vt = (const_iterator(static_cast<__map_const_pointer>(__f.__m_iter_), __vt) -= __f - __r).__ptr_;
    __r = std::move(__fb, __fe, __r);
    __n -= __bs;
    __f += __bs;
  }
  return __r;
}



template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::__move_backward_and_check(iterator __f, iterator __l, iterator __r, const_pointer& __vt) {



  difference_type __n = __l - __f;
  while (__n > 0) {
    --__l;
    pointer __lb = *__l.__m_iter_;
    pointer __le = __l.__ptr_ + 1;
    difference_type __bs = __le - __lb;
    if (__bs > __n) {
      __bs = __n;
      __lb = __le - __bs;
    }
    if (__lb <= __vt && __vt < __le)
      __vt = (const_iterator(static_cast<__map_const_pointer>(__l.__m_iter_), __vt) += __r - __l - 1).__ptr_;
    __r = std::move_backward(__lb, __le, __r);
    __n -= __bs;
    __l -= __bs - 1;
  }
  return __r;
}



template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__move_construct_and_check(iterator __f, iterator __l, iterator __r, const_pointer& __vt) {
  allocator_type& __a = __alloc();



  difference_type __n = __l - __f;
  while (__n > 0) {
    pointer __fb = __f.__ptr_;
    pointer __fe = *__f.__m_iter_ + __block_size;
    difference_type __bs = __fe - __fb;
    if (__bs > __n) {
      __bs = __n;
      __fe = __fb + __bs;
    }
    if (__fb <= __vt && __vt < __fe)
      __vt = (const_iterator(static_cast<__map_const_pointer>(__f.__m_iter_), __vt) += __r - __f).__ptr_;
    for (; __fb != __fe; ++__fb, ++__r, ++__size())
      __alloc_traits::construct(__a, std::addressof(*__r), std::move(*__fb));
    __n -= __bs;
    __f += __bs;
  }
}



template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__move_construct_backward_and_check(
    iterator __f, iterator __l, iterator __r, const_pointer& __vt) {
  allocator_type& __a = __alloc();







  difference_type __n = __l - __f;
  while (__n > 0) {
    --__l;
    pointer __lb = *__l.__m_iter_;
    pointer __le = __l.__ptr_ + 1;
    difference_type __bs = __le - __lb;
    if (__bs > __n) {
      __bs = __n;
      __lb = __le - __bs;
    }
    if (__lb <= __vt && __vt < __le)
      __vt = (const_iterator(static_cast<__map_const_pointer>(__l.__m_iter_), __vt) -= __l - __r + 1).__ptr_;
    while (__le != __lb) {
      __alloc_traits::construct(__a, std::addressof(*--__r), std::move(*--__le));
      --__start_;
      ++__size();
    }
    __n -= __bs;
    __l -= __bs - 1;
  }
}

template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::erase(const_iterator __f) {
  size_type __old_sz = size();
  size_type __old_start = __start_;
  iterator __b = begin();
  difference_type __pos = __f - __b;
  iterator __p = __b + __pos;
  allocator_type& __a = __alloc();
  if (static_cast<size_t>(__pos) <= (size() - 1) / 2) {
    std::move_backward(__b, __p, std::next(__p));
    __alloc_traits::destroy(__a, std::addressof(*__b));
    --__size();
    ++__start_;
    __annotate_shrink_front(__old_sz, __old_start);
    __maybe_remove_front_spare();
  } else {
    iterator __i = std::move(std::next(__p), end(), __p);
    __alloc_traits::destroy(__a, std::addressof(*__i));
    --__size();
    __annotate_shrink_back(__old_sz, __old_start);
    __maybe_remove_back_spare();
  }
  return begin() + __pos;
}

template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::erase(const_iterator __f, const_iterator __l) {
  size_type __old_sz = size();
  size_type __old_start = __start_;
  difference_type __n = __l - __f;
  iterator __b = begin();
  difference_type __pos = __f - __b;
  iterator __p = __b + __pos;
  if (__n > 0) {
    allocator_type& __a = __alloc();
    if (static_cast<size_t>(__pos) <= (size() - __n) / 2) {
      iterator __i = std::move_backward(__b, __p, __p + __n);
      for (; __b != __i; ++__b)
        __alloc_traits::destroy(__a, std::addressof(*__b));
      __size() -= __n;
      __start_ += __n;
      __annotate_shrink_front(__old_sz, __old_start);
      while (__maybe_remove_front_spare()) {
      }
    } else {
      iterator __i = std::move(__p + __n, end(), __p);
      for (iterator __e = end(); __i != __e; ++__i)
        __alloc_traits::destroy(__a, std::addressof(*__i));
      __size() -= __n;
      __annotate_shrink_back(__old_sz, __old_start);
      while (__maybe_remove_back_spare()) {
      }
    }
  }
  return begin() + __pos;
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__erase_to_end(const_iterator __f) {
  size_type __old_sz = size();
  size_type __old_start = __start_;
  iterator __e = end();
  difference_type __n = __e - __f;
  if (__n > 0) {
    allocator_type& __a = __alloc();
    iterator __b = begin();
    difference_type __pos = __f - __b;
    for (iterator __p = __b + __pos; __p != __e; ++__p)
      __alloc_traits::destroy(__a, std::addressof(*__p));
    __size() -= __n;
    __annotate_shrink_back(__old_sz, __old_start);
    while (__maybe_remove_back_spare()) {
    }
  }
}

template <class _Tp, class _Allocator>
inline void deque<_Tp, _Allocator>::swap(deque& __c)





{
  __map_.swap(__c.__map_);
  std::swap(__start_, __c.__start_);
  std::swap(__size(), __c.__size());
  std::__swap_allocator(__alloc(), __c.__alloc());
}

template <class _Tp, class _Allocator>
inline void deque<_Tp, _Allocator>::clear() throw() {
  __annotate_delete();
  allocator_type& __a = __alloc();
  for (iterator __i = begin(), __e = end(); __i != __e; ++__i)
    __alloc_traits::destroy(__a, std::addressof(*__i));
  __size() = 0;
  while (__map_.size() > 2) {
    __alloc_traits::deallocate(__a, __map_.front(), __block_size);
    __map_.pop_front();
  }
  switch (__map_.size()) {
  case 1:
    __start_ = __block_size / 2;
    break;
  case 2:
    __start_ = __block_size;
    break;
  }
  __annotate_new(0);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y) {
  const typename deque<_Tp, _Allocator>::size_type __sz = __x.size();
  return __sz == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
}



template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y) {
  return !(__x == __y);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y) {
  return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y) {
  return __y < __x;
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>=(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y) {
  return !(__x < __y);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<=(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y) {
  return !(__y < __x);
}
# 2552 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3
template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(deque<_Tp, _Allocator>& __x, deque<_Tp, _Allocator>& __y)
                                          {
  __x.swap(__y);
}
# 2584 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3
}}
# 2602 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 1 3
# 520 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/binary_negate.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/binary_negate.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Predicate>
class binary_negate
    : public __binary_function<typename _Predicate::first_argument_type,
                               typename _Predicate::second_argument_type,
                               bool> {
  _Predicate __pred_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit binary_negate(const _Predicate& __pred)
      : __pred_(__pred) {}

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(
      const typename _Predicate::first_argument_type& __x, const typename _Predicate::second_argument_type& __y) const {
    return !__pred_(__x, __y);
  }
};

template <class _Predicate>
                            inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) binary_negate<_Predicate>
not2(const _Predicate& __pred) {
  return binary_negate<_Predicate>(__pred);
}



}}
# 521 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
struct is_bind_expression
    : _If< _IsSame<_Tp, __remove_cvref_t<_Tp> >::value, false_type, is_bind_expression<__remove_cvref_t<_Tp> > > {};






template <class _Tp>
struct is_placeholder
    : _If< _IsSame<_Tp, __remove_cvref_t<_Tp> >::value,
           integral_constant<int, 0>,
           is_placeholder<__remove_cvref_t<_Tp> > > {};






namespace placeholders {

template <int _Np>
struct __ph {};
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind.h" 3
__attribute__((__visibility__("default"))) extern const __ph<1> _1;
__attribute__((__visibility__("default"))) extern const __ph<2> _2;
__attribute__((__visibility__("default"))) extern const __ph<3> _3;
__attribute__((__visibility__("default"))) extern const __ph<4> _4;
__attribute__((__visibility__("default"))) extern const __ph<5> _5;
__attribute__((__visibility__("default"))) extern const __ph<6> _6;
__attribute__((__visibility__("default"))) extern const __ph<7> _7;
__attribute__((__visibility__("default"))) extern const __ph<8> _8;
__attribute__((__visibility__("default"))) extern const __ph<9> _9;
__attribute__((__visibility__("default"))) extern const __ph<10> _10;

}

template <int _Np>
struct is_placeholder<placeholders::__ph<_Np> > : public integral_constant<int, _Np> {};
# 293 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind.h" 3
}}
# 522 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind_back.h" 1 3
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind_back.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/perfect_forward.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/perfect_forward.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/perfect_forward.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 100 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/perfect_forward.h" 3
}}
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind_back.h" 2 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind_back.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind_back.h" 3
}}
# 523 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind_front.h" 1 3
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind_front.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 54 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/bind_front.h" 3
}}
# 524 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/binder1st.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/binder1st.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Operation>
class binder1st
    : public __unary_function<typename _Operation::second_argument_type, typename _Operation::result_type> {
protected:
  _Operation op;
  typename _Operation::first_argument_type value;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) binder1st(const _Operation& __x, const typename _Operation::first_argument_type __y)
      : op(__x), value(__y) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename _Operation::result_type
  operator()(typename _Operation::second_argument_type& __x) const {
    return op(value, __x);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename _Operation::result_type
  operator()(const typename _Operation::second_argument_type& __x) const {
    return op(value, __x);
  }
};

template <class _Operation, class _Tp>
                            inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) binder1st<_Operation>
bind1st(const _Operation& __op, const _Tp& __x) {
  return binder1st<_Operation>(__op, __x);
}



}}
# 525 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/binder2nd.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/binder2nd.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Operation>
class binder2nd
    : public __unary_function<typename _Operation::first_argument_type, typename _Operation::result_type> {
protected:
  _Operation op;
  typename _Operation::second_argument_type value;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) binder2nd(const _Operation& __x, const typename _Operation::second_argument_type __y)
      : op(__x), value(__y) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename _Operation::result_type
  operator()(typename _Operation::first_argument_type& __x) const {
    return op(__x, value);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename _Operation::result_type
  operator()(const typename _Operation::first_argument_type& __x) const {
    return op(__x, value);
  }
};

template <class _Operation, class _Tp>
                            inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) binder2nd<_Operation>
bind2nd(const _Operation& __op, const _Tp& __x) {
  return binder2nd<_Operation>(__op, __x);
}



}}
# 526 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/boyer_moore_searcher.h" 1 3
# 14 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/boyer_moore_searcher.h" 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/boyer_moore_searcher.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 1 3
# 590 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/is_transparent.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/is_transparent.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/is_transparent.h" 3
}}
# 591 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 1 3
# 53 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Key, class _Tp>
struct __hash_value_type;

template <class _Tp>
struct __is_hash_value_type_imp : false_type {};

template <class _Key, class _Value>
struct __is_hash_value_type_imp<__hash_value_type<_Key, _Value> > : true_type {};

template <class... _Args>
struct __is_hash_value_type : false_type {};

template <class _One>
struct __is_hash_value_type<_One> : __is_hash_value_type_imp<__remove_cvref_t<_One> > {};

__attribute__((__visibility__("default"))) size_t __next_prime(size_t __n);

template <class _NodePtr>
struct __hash_node_base {
  typedef typename pointer_traits<_NodePtr>::element_type __node_type;
  typedef __hash_node_base __first_node;
  typedef __rebind_pointer_t<_NodePtr, __first_node> __node_base_pointer;
  typedef _NodePtr __node_pointer;




  typedef __conditional_t<is_pointer<__node_pointer>::value, __node_base_pointer, __node_pointer> __next_pointer;


  __next_pointer __next_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __next_pointer __ptr() throw() {
    return static_cast<__next_pointer>(pointer_traits<__node_base_pointer>::pointer_to(*this));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __node_pointer __upcast() throw() {
    return static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(*this));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t __hash() const throw() { return static_cast<__node_type const&>(*this).__hash_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_node_base() throw() : __next_(__nullptr) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __hash_node_base(__next_pointer __next) throw() : __next_(__next) {}
};

template <class _Tp, class _VoidPtr>
struct __hash_node : public __hash_node_base< __rebind_pointer_t<_VoidPtr, __hash_node<_Tp, _VoidPtr> > > {
  typedef _Tp __node_value_type;
  using _Base = __hash_node_base<__rebind_pointer_t<_VoidPtr, __hash_node<_Tp, _VoidPtr> > >;
  using __next_pointer = typename _Base::__next_pointer;

  size_t __hash_;
# 127 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
private:
  __attribute__((__aligned__(_Alignof(_Tp)))) char __buffer_[sizeof(_Tp)];

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Tp& __get_value() { return *std::__launder(reinterpret_cast<_Tp*>(&__buffer_)); }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __hash_node(__next_pointer __next, size_t __hash) : _Base(__next), __hash_(__hash) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~__hash_node() {}
};

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool __is_hash_power2(size_t __bc) { return __bc > 2 && !(__bc & (__bc - 1)); }

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t __constrain_hash(size_t __h, size_t __bc) {
  return !(__bc & (__bc - 1)) ? __h & (__bc - 1) : (__h < __bc ? __h : __h % __bc);
}

inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t __next_hash_pow2(size_t __n) {
  return __n < 2 ? __n : (size_t(1) << (numeric_limits<size_t>::digits - __libcpp_clz(__n - 1)));
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
class __hash_table;

template <class _NodePtr>
class __hash_iterator;
template <class _ConstNodePtr>
class __hash_const_iterator;
template <class _NodePtr>
class __hash_local_iterator;
template <class _ConstNodePtr>
class __hash_const_local_iterator;
template <class _HashIterator>
class __hash_map_iterator;
template <class _HashIterator>
class __hash_map_const_iterator;

template <class _Tp>
struct __hash_key_value_types {
  _Static_assert(!is_reference<_Tp>::value && !is_const<_Tp>::value, "");
  typedef _Tp key_type;
  typedef _Tp __node_value_type;
  typedef _Tp __container_value_type;
  static const bool __is_map = false;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static key_type const& __get_key(_Tp const& __v) { return __v; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static __container_value_type const& __get_value(__node_value_type const& __v) { return __v; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static __container_value_type* __get_ptr(__node_value_type& __n) { return std::addressof(__n); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static __container_value_type&& __move(__node_value_type& __v) { return std::move(__v); }
};

template <class _Key, class _Tp>
struct __hash_key_value_types<__hash_value_type<_Key, _Tp> > {
  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef __hash_value_type<_Key, _Tp> __node_value_type;
  typedef pair<const _Key, _Tp> __container_value_type;
  typedef __container_value_type __map_value_type;
  static const bool __is_map = true;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static key_type const& __get_key(__container_value_type const& __v) { return __v.first; }

  template <class _Up, __enable_if_t<__is_same_uncvref<_Up, __node_value_type>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static __container_value_type const& __get_value(_Up& __t) {
    return __t.__get_value();
  }

  template <class _Up, __enable_if_t<__is_same_uncvref<_Up, __container_value_type>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static __container_value_type const& __get_value(_Up& __t) {
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static __container_value_type* __get_ptr(__node_value_type& __n) {
    return std::addressof(__n.__get_value());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static pair<key_type&&, mapped_type&&> __move(__node_value_type& __v) { return __v.__move(); }
};

template <class _Tp, class _AllocPtr, class _KVTypes = __hash_key_value_types<_Tp>, bool = _KVTypes::__is_map>
struct __hash_map_pointer_types {};

template <class _Tp, class _AllocPtr, class _KVTypes>
struct __hash_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {
  typedef typename _KVTypes::__map_value_type _Mv;
  typedef __rebind_pointer_t<_AllocPtr, _Mv> __map_value_type_pointer;
  typedef __rebind_pointer_t<_AllocPtr, const _Mv> __const_map_value_type_pointer;
};

template <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>
struct __hash_node_types;

template <class _NodePtr, class _Tp, class _VoidPtr>
struct __hash_node_types<_NodePtr, __hash_node<_Tp, _VoidPtr> >
    : public __hash_key_value_types<_Tp>,
      __hash_map_pointer_types<_Tp, _VoidPtr>

{
  typedef __hash_key_value_types<_Tp> __base;

public:
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;

  typedef __rebind_pointer_t<_NodePtr, void> __void_pointer;

  typedef typename pointer_traits<_NodePtr>::element_type __node_type;
  typedef _NodePtr __node_pointer;

  typedef __hash_node_base<__node_pointer> __node_base_type;
  typedef __rebind_pointer_t<_NodePtr, __node_base_type> __node_base_pointer;

  typedef typename __node_base_type::__next_pointer __next_pointer;

  typedef _Tp __node_value_type;
  typedef __rebind_pointer_t<_VoidPtr, __node_value_type> __node_value_type_pointer;
  typedef __rebind_pointer_t<_VoidPtr, const __node_value_type> __const_node_value_type_pointer;

private:
  _Static_assert(!is_const<__node_type>::value, "_NodePtr should never be a pointer to const");
  _Static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value), "_VoidPtr does not point to unqualified void type");

  _Static_assert((is_same<__rebind_pointer_t<_VoidPtr, __node_type>, _NodePtr>::value), "_VoidPtr does not rebind to _NodePtr.");

};

template <class _HashIterator>
struct __hash_node_types_from_iterator;
template <class _NodePtr>
struct __hash_node_types_from_iterator<__hash_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};
template <class _NodePtr>
struct __hash_node_types_from_iterator<__hash_const_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};
template <class _NodePtr>
struct __hash_node_types_from_iterator<__hash_local_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};
template <class _NodePtr>
struct __hash_node_types_from_iterator<__hash_const_local_iterator<_NodePtr> > : __hash_node_types<_NodePtr> {};

template <class _NodeValueTp, class _VoidPtr>
struct __make_hash_node_types {
  typedef __hash_node<_NodeValueTp, _VoidPtr> _NodeTp;
  typedef __rebind_pointer_t<_VoidPtr, _NodeTp> _NodePtr;
  typedef __hash_node_types<_NodePtr> type;
};

template <class _NodePtr>
class __hash_iterator {
  typedef __hash_node_types<_NodePtr> _NodeTypes;
  typedef _NodePtr __node_pointer;
  typedef typename _NodeTypes::__next_pointer __next_pointer;

  __next_pointer __node_;

public:
  typedef forward_iterator_tag iterator_category;
  typedef typename _NodeTypes::__node_value_type value_type;
  typedef typename _NodeTypes::difference_type difference_type;
  typedef value_type& reference;
  typedef typename _NodeTypes::__node_value_type_pointer pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_iterator() throw() : __node_(__nullptr) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator*() const { return __node_->__upcast()->__get_value(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer operator->() const {
    return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__get_value());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_iterator& operator++() {
    __node_ = __node_->__next_;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_iterator operator++(int) {
    __hash_iterator __t(*this);
    ++(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const __hash_iterator& __x, const __hash_iterator& __y) {
    return __x.__node_ == __y.__node_;
  }
  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const __hash_iterator& __x, const __hash_iterator& __y) {
    return !(__x == __y);
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __hash_iterator(__next_pointer __node) throw() : __node_(__node) {}

  template <class, class, class, class>
  friend class __hash_table;
  template <class>
  friend class __hash_const_iterator;
  template <class>
  friend class __hash_map_iterator;
  template <class, class, class, class, class>
  friend class unordered_map;
  template <class, class, class, class, class>
  friend class unordered_multimap;
};

template <class _NodePtr>
class __hash_const_iterator {
  _Static_assert(!is_const<typename pointer_traits<_NodePtr>::element_type>::value, "");
  typedef __hash_node_types<_NodePtr> _NodeTypes;
  typedef _NodePtr __node_pointer;
  typedef typename _NodeTypes::__next_pointer __next_pointer;

  __next_pointer __node_;

public:
  typedef __hash_iterator<_NodePtr> __non_const_iterator;

  typedef forward_iterator_tag iterator_category;
  typedef typename _NodeTypes::__node_value_type value_type;
  typedef typename _NodeTypes::difference_type difference_type;
  typedef const value_type& reference;
  typedef typename _NodeTypes::__const_node_value_type_pointer pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_const_iterator() throw() : __node_(__nullptr) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_const_iterator(const __non_const_iterator& __x) throw() : __node_(__x.__node_) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator*() const { return __node_->__upcast()->__get_value(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer operator->() const {
    return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__get_value());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_const_iterator& operator++() {
    __node_ = __node_->__next_;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_const_iterator operator++(int) {
    __hash_const_iterator __t(*this);
    ++(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const __hash_const_iterator& __x, const __hash_const_iterator& __y) {
    return __x.__node_ == __y.__node_;
  }
  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const __hash_const_iterator& __x, const __hash_const_iterator& __y) {
    return !(__x == __y);
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __hash_const_iterator(__next_pointer __node) throw() : __node_(__node) {}

  template <class, class, class, class>
  friend class __hash_table;
  template <class>
  friend class __hash_map_const_iterator;
  template <class, class, class, class, class>
  friend class unordered_map;
  template <class, class, class, class, class>
  friend class unordered_multimap;
};

template <class _NodePtr>
class __hash_local_iterator {
  typedef __hash_node_types<_NodePtr> _NodeTypes;
  typedef _NodePtr __node_pointer;
  typedef typename _NodeTypes::__next_pointer __next_pointer;

  __next_pointer __node_;
  size_t __bucket_;
  size_t __bucket_count_;

public:
  typedef forward_iterator_tag iterator_category;
  typedef typename _NodeTypes::__node_value_type value_type;
  typedef typename _NodeTypes::difference_type difference_type;
  typedef value_type& reference;
  typedef typename _NodeTypes::__node_value_type_pointer pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_local_iterator() throw() : __node_(__nullptr) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator*() const { return __node_->__upcast()->__get_value(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer operator->() const {
    return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__get_value());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_local_iterator& operator++() {
    __node_ = __node_->__next_;
    if (__node_ != __nullptr && std::__constrain_hash(__node_->__hash(), __bucket_count_) != __bucket_)
      __node_ = __nullptr;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_local_iterator operator++(int) {
    __hash_local_iterator __t(*this);
    ++(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const __hash_local_iterator& __x, const __hash_local_iterator& __y) {
    return __x.__node_ == __y.__node_;
  }
  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const __hash_local_iterator& __x, const __hash_local_iterator& __y) {
    return !(__x == __y);
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __hash_local_iterator(
      __next_pointer __node, size_t __bucket, size_t __bucket_count) throw()
      : __node_(__node),
        __bucket_(__bucket),
        __bucket_count_(__bucket_count) {
    if (__node_ != __nullptr)
      __node_ = __node_->__next_;
  }

  template <class, class, class, class>
  friend class __hash_table;
  template <class>
  friend class __hash_const_local_iterator;
  template <class>
  friend class __hash_map_iterator;
};

template <class _ConstNodePtr>
class __hash_const_local_iterator {
  typedef __hash_node_types<_ConstNodePtr> _NodeTypes;
  typedef _ConstNodePtr __node_pointer;
  typedef typename _NodeTypes::__next_pointer __next_pointer;

  __next_pointer __node_;
  size_t __bucket_;
  size_t __bucket_count_;

  typedef pointer_traits<__node_pointer> __pointer_traits;
  typedef typename __pointer_traits::element_type __node;
  typedef __remove_const_t<__node> __non_const_node;
  typedef __rebind_pointer_t<__node_pointer, __non_const_node> __non_const_node_pointer;

public:
  typedef __hash_local_iterator<__non_const_node_pointer> __non_const_iterator;

  typedef forward_iterator_tag iterator_category;
  typedef typename _NodeTypes::__node_value_type value_type;
  typedef typename _NodeTypes::difference_type difference_type;
  typedef const value_type& reference;
  typedef typename _NodeTypes::__const_node_value_type_pointer pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_const_local_iterator() throw() : __node_(__nullptr) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_const_local_iterator(const __non_const_iterator& __x) throw()
      : __node_(__x.__node_),
        __bucket_(__x.__bucket_),
        __bucket_count_(__x.__bucket_count_) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator*() const { return __node_->__upcast()->__get_value(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer operator->() const {
    return pointer_traits<pointer>::pointer_to(__node_->__upcast()->__get_value());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_const_local_iterator& operator++() {
    __node_ = __node_->__next_;
    if (__node_ != __nullptr && std::__constrain_hash(__node_->__hash(), __bucket_count_) != __bucket_)
      __node_ = __nullptr;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_const_local_iterator operator++(int) {
    __hash_const_local_iterator __t(*this);
    ++(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
  operator==(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y) {
    return __x.__node_ == __y.__node_;
  }
  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
  operator!=(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y) {
    return !(__x == __y);
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __hash_const_local_iterator(
      __next_pointer __node_ptr, size_t __bucket, size_t __bucket_count) throw()
      : __node_(__node_ptr),
        __bucket_(__bucket),
        __bucket_count_(__bucket_count) {
    if (__node_ != __nullptr)
      __node_ = __node_->__next_;
  }

  template <class, class, class, class>
  friend class __hash_table;
  template <class>
  friend class __hash_map_const_iterator;
};

template <class _Alloc>
class __bucket_list_deallocator {
  typedef _Alloc allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;
  typedef typename __alloc_traits::size_type size_type;

  __compressed_pair<size_type, allocator_type> __data_;

public:
  typedef typename __alloc_traits::pointer pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bucket_list_deallocator()
      : __data_(0, __default_init_tag()) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bucket_list_deallocator(const allocator_type& __a, size_type __size)

      : __data_(__size, __a) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __bucket_list_deallocator(__bucket_list_deallocator&& __x)

      : __data_(std::move(__x.__data_)) {
    __x.size() = 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type& size() throw() { return __data_.first(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type size() const throw() { return __data_.first(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) allocator_type& __alloc() throw() { return __data_.second(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const allocator_type& __alloc() const throw() { return __data_.second(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator()(pointer __p) throw() { __alloc_traits::deallocate(__alloc(), __p, size()); }
};

template <class _Alloc>
class __hash_map_node_destructor;

template <class _Alloc>
class __hash_node_destructor {
  typedef _Alloc allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;

public:
  typedef typename __alloc_traits::pointer pointer;

private:
  typedef __hash_node_types<pointer> _NodeTypes;

  allocator_type& __na_;

public:
  bool __value_constructed;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_node_destructor(__hash_node_destructor const&) = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_node_destructor& operator=(const __hash_node_destructor&) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __hash_node_destructor(allocator_type& __na, bool __constructed = false) throw()
      : __na_(__na),
        __value_constructed(__constructed) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator()(pointer __p) throw() {
    if (__value_constructed) {
      __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__get_value()));
      std::__destroy_at(std::addressof(*__p));
    }
    if (__p)
      __alloc_traits::deallocate(__na_, __p, 1);
  }

  template <class>
  friend class __hash_map_node_destructor;
};
# 604 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
template <class _Key, class _Hash, class _Equal>
struct __enforce_unordered_container_requirements {





  typedef int type;
};

template <class _Key, class _Hash, class _Equal>






    typename __enforce_unordered_container_requirements<_Key, _Hash, _Equal>::type
    __diagnose_unordered_container_requirements(int);




template <class _Key, class _Hash, class _Equal>
int __diagnose_unordered_container_requirements(void*);

template <class _Tp, class _Hash, class _Equal, class _Alloc>
class __hash_table {
public:
  typedef _Tp value_type;
  typedef _Hash hasher;
  typedef _Equal key_equal;
  typedef _Alloc allocator_type;

private:
  typedef allocator_traits<allocator_type> __alloc_traits;
  typedef typename __make_hash_node_types<value_type, typename __alloc_traits::void_pointer>::type _NodeTypes;

public:
  typedef typename _NodeTypes::__node_value_type __node_value_type;
  typedef typename _NodeTypes::__container_value_type __container_value_type;
  typedef typename _NodeTypes::key_type key_type;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;

  typedef typename __alloc_traits::size_type size_type;



  typedef typename _NodeTypes::difference_type difference_type;

public:


  typedef typename _NodeTypes::__node_type __node;
  typedef __rebind_alloc<__alloc_traits, __node> __node_allocator;
  typedef allocator_traits<__node_allocator> __node_traits;
  typedef typename _NodeTypes::__void_pointer __void_pointer;
  typedef typename _NodeTypes::__node_pointer __node_pointer;
  typedef typename _NodeTypes::__node_pointer __node_const_pointer;
  typedef typename _NodeTypes::__node_base_type __first_node;
  typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
  typedef typename _NodeTypes::__next_pointer __next_pointer;

private:



  _Static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value), "Allocator does not rebind pointers in a sane manner.");

  typedef __rebind_alloc<__node_traits, __first_node> __node_base_allocator;
  typedef allocator_traits<__node_base_allocator> __node_base_traits;
  _Static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value), "Allocator does not rebind pointers in a sane manner.");


private:
  typedef __rebind_alloc<__node_traits, __next_pointer> __pointer_allocator;
  typedef __bucket_list_deallocator<__pointer_allocator> __bucket_list_deleter;
  typedef unique_ptr<__next_pointer[], __bucket_list_deleter> __bucket_list;
  typedef allocator_traits<__pointer_allocator> __pointer_alloc_traits;
  typedef typename __bucket_list_deleter::pointer __node_pointer_pointer;


  __bucket_list __bucket_list_;
  __compressed_pair<__first_node, __node_allocator> __p1_;
  __compressed_pair<size_type, hasher> __p2_;
  __compressed_pair<float, key_equal> __p3_;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type& size() throw() { return __p2_.first(); }

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type size() const throw() { return __p2_.first(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) hasher& hash_function() throw() { return __p2_.second(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const hasher& hash_function() const throw() { return __p2_.second(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float& max_load_factor() throw() { return __p3_.first(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float max_load_factor() const throw() { return __p3_.first(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) key_equal& key_eq() throw() { return __p3_.second(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const key_equal& key_eq() const throw() { return __p3_.second(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __node_allocator& __node_alloc() throw() { return __p1_.second(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const __node_allocator& __node_alloc() const throw() { return __p1_.second(); }

public:
  typedef __hash_iterator<__node_pointer> iterator;
  typedef __hash_const_iterator<__node_pointer> const_iterator;
  typedef __hash_local_iterator<__node_pointer> local_iterator;
  typedef __hash_const_local_iterator<__node_pointer> const_local_iterator;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_table() ;



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_table(const hasher& __hf, const key_equal& __eql);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_table(const hasher& __hf, const key_equal& __eql, const allocator_type& __a);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __hash_table(const allocator_type& __a);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_table(const __hash_table& __u);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_table(const __hash_table& __u, const allocator_type& __a);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_table(__hash_table&& __u) ;



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_table(__hash_table&& __u, const allocator_type& __a);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~__hash_table();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_table& operator=(const __hash_table& __u);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_table& operator=(__hash_table&& __u)


                                                                      ;
  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __assign_unique(_InputIterator __first, _InputIterator __last);
  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __assign_multi(_InputIterator __first, _InputIterator __last);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type max_size() const throw() {
    return std::min<size_type>(__node_traits::max_size(__node_alloc()), numeric_limits<difference_type >::max());
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __next_pointer __node_insert_multi_prepare(size_t __cp_hash, value_type& __cp_val);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __node_insert_multi_perform(__node_pointer __cp, __next_pointer __pn) throw();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __next_pointer __node_insert_unique_prepare(size_t __nd_hash, value_type& __nd_val);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __node_insert_unique_perform(__node_pointer __ptr) throw();

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<iterator, bool> __node_insert_unique(__node_pointer __nd);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator __node_insert_multi(__node_pointer __nd);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);

  template <class _Key, class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<iterator, bool> __emplace_unique_key_args(_Key const& __k, _Args&&... __args);

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<iterator, bool> __emplace_unique(_Pp&& __x) {
    return __emplace_unique_extract_key(std::forward<_Pp>(__x), __can_extract_key<_Pp, key_type>());
  }

  template <class _First,
            class _Second,
            __enable_if_t<__can_extract_map_key<_First, key_type, __container_value_type>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<iterator, bool> __emplace_unique(_First&& __f, _Second&& __s) {
    return __emplace_unique_key_args(__f, std::forward<_First>(__f), std::forward<_Second>(__s));
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<iterator, bool> __emplace_unique(_Args&&... __args) {
    return __emplace_unique_impl(std::forward<_Args>(__args)...);
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<iterator, bool> __emplace_unique_extract_key(_Pp&& __x, __extract_key_fail_tag) {
    return __emplace_unique_impl(std::forward<_Pp>(__x));
  }
  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<iterator, bool> __emplace_unique_extract_key(_Pp&& __x, __extract_key_self_tag) {
    return __emplace_unique_key_args(__x, std::forward<_Pp>(__x));
  }
  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<iterator, bool> __emplace_unique_extract_key(_Pp&& __x, __extract_key_first_tag) {
    return __emplace_unique_key_args(__x.first, std::forward<_Pp>(__x));
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator __emplace_multi(_Args&&... __args);
  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<iterator, bool> __insert_unique(__container_value_type&& __x) {
    return __emplace_unique_key_args(_NodeTypes::__get_key(__x), std::move(__x));
  }

  template <class _Pp, class = __enable_if_t<!__is_same_uncvref<_Pp, __container_value_type>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<iterator, bool> __insert_unique(_Pp&& __x) {
    return __emplace_unique(std::forward<_Pp>(__x));
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator __insert_multi(_Pp&& __x) {
    return __emplace_multi(std::forward<_Pp>(__x));
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator __insert_multi(const_iterator __p, _Pp&& __x) {
    return __emplace_hint_multi(__p, std::forward<_Pp>(__x));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<iterator, bool> __insert_unique(const __container_value_type& __x) {
    return __emplace_unique_key_args(_NodeTypes::__get_key(__x), __x);
  }
# 845 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void clear() throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __rehash_unique(size_type __n) { __rehash<true>(__n); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __rehash_multi(size_type __n) { __rehash<false>(__n); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __reserve_unique(size_type __n) {
    __rehash_unique(static_cast<size_type>(std::ceil(__n / max_load_factor())));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __reserve_multi(size_type __n) {
    __rehash_multi(static_cast<size_type>(std::ceil(__n / max_load_factor())));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type bucket_count() const throw() { return __bucket_list_.get_deleter().size(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator begin() throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator end() throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator begin() const throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator end() const throw();

  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type bucket(const _Key& __k) const {
    ((void)0);

    return std::__constrain_hash(hash_function()(__k), bucket_count());
  }

  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator find(const _Key& __x);
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator find(const _Key& __x) const;

  typedef __hash_node_destructor<__node_allocator> _Dp;
  typedef unique_ptr<__node, _Dp> __node_holder;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator erase(const_iterator __p);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator erase(const_iterator __first, const_iterator __last);
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type __erase_unique(const _Key& __k);
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type __erase_multi(const _Key& __k);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __node_holder remove(const_iterator __p) throw();

  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type __count_unique(const _Key& __k) const;
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type __count_multi(const _Key& __k) const;

  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<iterator, iterator> __equal_range_unique(const _Key& __k);
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<const_iterator, const_iterator> __equal_range_unique(const _Key& __k) const;

  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<iterator, iterator> __equal_range_multi(const _Key& __k);
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<const_iterator, const_iterator> __equal_range_multi(const _Key& __k) const;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(__hash_table& __u)





                                                                   ;




  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type max_bucket_count() const throw() { return max_size(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type bucket_size(size_type __n) const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float load_factor() const throw() {
    size_type __bc = bucket_count();
    return __bc != 0 ? (float)size() / __bc : 0.f;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void max_load_factor(float __mlf) throw() {



    ((void)0);
    max_load_factor() = std::max(__mlf, load_factor());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) local_iterator begin(size_type __n) {
    ((void)0);

    return local_iterator(__bucket_list_[__n], __n, bucket_count());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) local_iterator end(size_type __n) {
    ((void)0);

    return local_iterator(__nullptr, __n, bucket_count());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_local_iterator cbegin(size_type __n) const {
    ((void)0);

    return const_local_iterator(__bucket_list_[__n], __n, bucket_count());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_local_iterator cend(size_type __n) const {
    ((void)0);

    return const_local_iterator(__nullptr, __n, bucket_count());
  }

private:
  template <bool _UniqueKeys>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __rehash(size_type __n);
  template <bool _UniqueKeys>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __do_rehash(size_type __n);

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __node_holder __construct_node(_Args&&... __args);

  template <class _First, class... _Rest>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __node_holder __construct_node_hash(size_t __hash, _First&& __f, _Rest&&... __rest);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __copy_assign_alloc(const __hash_table& __u) {
    __copy_assign_alloc(__u, integral_constant<bool, __node_traits::propagate_on_container_copy_assignment::value>());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __copy_assign_alloc(const __hash_table& __u, true_type);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __copy_assign_alloc(const __hash_table&, false_type) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign(__hash_table& __u, false_type);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign(__hash_table& __u, true_type)

                                                                  ;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign_alloc(__hash_table& __u) {


    __move_assign_alloc(__u, integral_constant<bool, __node_traits::propagate_on_container_move_assignment::value>());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign_alloc(__hash_table& __u, true_type) {

    __bucket_list_.get_deleter().__alloc() = std::move(__u.__bucket_list_.get_deleter().__alloc());
    __node_alloc() = std::move(__u.__node_alloc());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __move_assign_alloc(__hash_table&, false_type) throw() {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __deallocate_node(__next_pointer __np) throw();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __next_pointer __detach() throw();

  template <class, class, class, class, class>
  friend class unordered_map;
  template <class, class, class, class, class>
  friend class unordered_multimap;
};

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline __hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table()



    : __p2_(0, __default_init_tag()), __p3_(1.0f, __default_init_tag()) {}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline __hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf, const key_equal& __eql)
    : __bucket_list_(__nullptr, __bucket_list_deleter()), __p1_(), __p2_(0, __hf), __p3_(1.0f, __eql) {}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(
    const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __bucket_list_(__nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__default_init_tag(), __node_allocator(__a)),
      __p2_(0, __hf),
      __p3_(1.0f, __eql) {}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const allocator_type& __a)
    : __bucket_list_(__nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__default_init_tag(), __node_allocator(__a)),
      __p2_(0, __default_init_tag()),
      __p3_(1.0f, __default_init_tag()) {}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u)
    : __bucket_list_(__nullptr,
                     __bucket_list_deleter(allocator_traits<__pointer_allocator>::select_on_container_copy_construction(
                                               __u.__bucket_list_.get_deleter().__alloc()),
                                           0)),
      __p1_(__default_init_tag(),
            allocator_traits<__node_allocator>::select_on_container_copy_construction(__u.__node_alloc())),
      __p2_(0, __u.hash_function()),
      __p3_(__u.__p3_) {}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u, const allocator_type& __a)
    : __bucket_list_(__nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__default_init_tag(), __node_allocator(__a)),
      __p2_(0, __u.hash_function()),
      __p3_(__u.__p3_) {}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u)



    : __bucket_list_(std::move(__u.__bucket_list_)),
      __p1_(std::move(__u.__p1_)),
      __p2_(std::move(__u.__p2_)),
      __p3_(std::move(__u.__p3_)) {
  if (size() > 0) {
    __bucket_list_[std::__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] = __p1_.first().__ptr();
    __u.__p1_.first().__next_ = __nullptr;
    __u.size() = 0;
  }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u, const allocator_type& __a)
    : __bucket_list_(__nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),
      __p1_(__default_init_tag(), __node_allocator(__a)),
      __p2_(0, std::move(__u.hash_function())),
      __p3_(std::move(__u.__p3_)) {
  if (__a == allocator_type(__u.__node_alloc())) {
    __bucket_list_.reset(__u.__bucket_list_.release());
    __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();
    __u.__bucket_list_.get_deleter().size() = 0;
    if (__u.size() > 0) {
      __p1_.first().__next_ = __u.__p1_.first().__next_;
      __u.__p1_.first().__next_ = __nullptr;
      __bucket_list_[std::__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] = __p1_.first().__ptr();
      size() = __u.size();
      __u.size() = 0;
    }
  }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::~__hash_table() {

  _Static_assert((is_copy_constructible<key_equal>::value), "Predicate must be copy-constructible.");
  _Static_assert((is_copy_constructible<hasher>::value), "Hasher must be copy-constructible.");


  __deallocate_node(__p1_.first().__next_);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__copy_assign_alloc(const __hash_table& __u, true_type) {
  if (__node_alloc() != __u.__node_alloc()) {
    clear();
    __bucket_list_.reset();
    __bucket_list_.get_deleter().size() = 0;
  }
  __bucket_list_.get_deleter().__alloc() = __u.__bucket_list_.get_deleter().__alloc();
  __node_alloc() = __u.__node_alloc();
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
__hash_table<_Tp, _Hash, _Equal, _Alloc>& __hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(const __hash_table& __u) {
  if (this != std::addressof(__u)) {
    __copy_assign_alloc(__u);
    hash_function() = __u.hash_function();
    key_eq() = __u.key_eq();
    max_load_factor() = __u.max_load_factor();
    __assign_multi(__u.begin(), __u.end());
  }
  return *this;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__deallocate_node(__next_pointer __np) throw() {
  __node_allocator& __na = __node_alloc();
  while (__np != __nullptr) {
    __next_pointer __next = __np->__next_;
    __node_pointer __real_np = __np->__upcast();
    __node_traits::destroy(__na, _NodeTypes::__get_ptr(__real_np->__get_value()));
    std::__destroy_at(std::addressof(*__real_np));
    __node_traits::deallocate(__na, __real_np, 1);
    __np = __next;
  }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__next_pointer
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__detach() throw() {
  size_type __bc = bucket_count();
  for (size_type __i = 0; __i < __bc; ++__i)
    __bucket_list_[__i] = __nullptr;
  size() = 0;
  __next_pointer __cache = __p1_.first().__next_;
  __p1_.first().__next_ = __nullptr;
  return __cache;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(__hash_table& __u, true_type)

                                                                 {
  clear();
  __bucket_list_.reset(__u.__bucket_list_.release());
  __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();
  __u.__bucket_list_.get_deleter().size() = 0;
  __move_assign_alloc(__u);
  size() = __u.size();
  hash_function() = std::move(__u.hash_function());
  max_load_factor() = __u.max_load_factor();
  key_eq() = std::move(__u.key_eq());
  __p1_.first().__next_ = __u.__p1_.first().__next_;
  if (size() > 0) {
    __bucket_list_[std::__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] = __p1_.first().__ptr();
    __u.__p1_.first().__next_ = __nullptr;
    __u.size() = 0;
  }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(__hash_table& __u, false_type) {
  if (__node_alloc() == __u.__node_alloc())
    __move_assign(__u, true_type());
  else {
    hash_function() = std::move(__u.hash_function());
    key_eq() = std::move(__u.key_eq());
    max_load_factor() = __u.max_load_factor();
    if (bucket_count() != 0) {
      __next_pointer __cache = __detach();

      try {

        const_iterator __i = __u.begin();
        while (__cache != __nullptr && __u.size() != 0) {
          __cache->__upcast()->__get_value() = std::move(__u.remove(__i++)->__get_value());
          __next_pointer __next = __cache->__next_;
          __node_insert_multi(__cache->__upcast());
          __cache = __next;
        }

      } catch (...) {
        __deallocate_node(__cache);
        throw;
      }

      __deallocate_node(__cache);
    }
    const_iterator __i = __u.begin();
    while (__u.size() != 0) {
      __node_holder __h = __construct_node(_NodeTypes::__move(__u.remove(__i++)->__get_value()));
      __node_insert_multi(__h.get());
      __h.release();
    }
  }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline __hash_table<_Tp, _Hash, _Equal, _Alloc>&
__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(__hash_table&& __u) {


  __move_assign(__u, integral_constant<bool, __node_traits::propagate_on_container_move_assignment::value>());
  return *this;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _InputIterator>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_unique(_InputIterator __first, _InputIterator __last) {
  typedef iterator_traits<_InputIterator> _ITraits;
  typedef typename _ITraits::value_type _ItValueType;
  _Static_assert((is_same<_ItValueType, __container_value_type>::value), "__assign_unique may only be called with the containers value type");


  if (bucket_count() != 0) {
    __next_pointer __cache = __detach();

    try {

      for (; __cache != __nullptr && __first != __last; ++__first) {
        __cache->__upcast()->__get_value() = *__first;
        __next_pointer __next = __cache->__next_;
        __node_insert_unique(__cache->__upcast());
        __cache = __next;
      }

    } catch (...) {
      __deallocate_node(__cache);
      throw;
    }

    __deallocate_node(__cache);
  }
  for (; __first != __last; ++__first)
    __insert_unique(*__first);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _InputIterator>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_multi(_InputIterator __first, _InputIterator __last) {
  typedef iterator_traits<_InputIterator> _ITraits;
  typedef typename _ITraits::value_type _ItValueType;
  _Static_assert((is_same<_ItValueType, __container_value_type>::value || is_same<_ItValueType, __node_value_type>::value), "__assign_multi may only be called with the containers value type" " or the nodes value type");



  if (bucket_count() != 0) {
    __next_pointer __cache = __detach();

    try {

      for (; __cache != __nullptr && __first != __last; ++__first) {
        __cache->__upcast()->__get_value() = *__first;
        __next_pointer __next = __cache->__next_;
        __node_insert_multi(__cache->__upcast());
        __cache = __next;
      }

    } catch (...) {
      __deallocate_node(__cache);
      throw;
    }

    __deallocate_node(__cache);
  }
  for (; __first != __last; ++__first)
    __insert_multi(_NodeTypes::__get_value(*__first));
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() throw() {
  return iterator(__p1_.first().__next_);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::end() throw() {
  return iterator(__nullptr);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() const throw() {
  return const_iterator(__p1_.first().__next_);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::end() const throw() {
  return const_iterator(__nullptr);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::clear() throw() {
  if (size() > 0) {
    __deallocate_node(__p1_.first().__next_);
    __p1_.first().__next_ = __nullptr;
    size_type __bc = bucket_count();
    for (size_type __i = 0; __i < __bc; ++__i)
      __bucket_list_[__i] = __nullptr;
    size() = 0;
  }
}
# 1303 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
template <class _Tp, class _Hash, class _Equal, class _Alloc>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__next_pointer
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique_prepare(size_t __hash, value_type& __value) {
  size_type __bc = bucket_count();

  if (__bc != 0) {
    size_t __chash = std::__constrain_hash(__hash, __bc);
    __next_pointer __ndptr = __bucket_list_[__chash];
    if (__ndptr != __nullptr) {
      for (__ndptr = __ndptr->__next_;
           __ndptr != __nullptr &&
           (__ndptr->__hash() == __hash || std::__constrain_hash(__ndptr->__hash(), __bc) == __chash);
           __ndptr = __ndptr->__next_) {
        if ((__ndptr->__hash() == __hash) && key_eq()(__ndptr->__upcast()->__get_value(), __value))
          return __ndptr;
      }
    }
  }
  if (size() + 1 > __bc * max_load_factor() || __bc == 0) {
    __rehash_unique(std::max<size_type>(
        2 * __bc + !std::__is_hash_power2(__bc), size_type(std::ceil(float(size() + 1) / max_load_factor()))));
  }
  return __nullptr;
}





template <class _Tp, class _Hash, class _Equal, class _Alloc>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique_perform(__node_pointer __nd) throw() {
  size_type __bc = bucket_count();
  size_t __chash = std::__constrain_hash(__nd->__hash(), __bc);

  __next_pointer __pn = __bucket_list_[__chash];
  if (__pn == __nullptr) {
    __pn = __p1_.first().__ptr();
    __nd->__next_ = __pn->__next_;
    __pn->__next_ = __nd->__ptr();

    __bucket_list_[__chash] = __pn;
    if (__nd->__next_ != __nullptr)
      __bucket_list_[std::__constrain_hash(__nd->__next_->__hash(), __bc)] = __nd->__ptr();
  } else {
    __nd->__next_ = __pn->__next_;
    __pn->__next_ = __nd->__ptr();
  }
  ++size();
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique(__node_pointer __nd) {
  __nd->__hash_ = hash_function()(__nd->__get_value());
  __next_pointer __existing_node = __node_insert_unique_prepare(__nd->__hash(), __nd->__get_value());


  bool __inserted = false;
  if (__existing_node == __nullptr) {
    __node_insert_unique_perform(__nd);
    __existing_node = __nd->__ptr();
    __inserted = true;
  }
  return pair<iterator, bool>(iterator(__existing_node), __inserted);
}
# 1377 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__next_pointer
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi_prepare(size_t __cp_hash, value_type& __cp_val) {
  size_type __bc = bucket_count();
  if (size() + 1 > __bc * max_load_factor() || __bc == 0) {
    __rehash_multi(std::max<size_type>(
        2 * __bc + !std::__is_hash_power2(__bc), size_type(std::ceil(float(size() + 1) / max_load_factor()))));
    __bc = bucket_count();
  }
  size_t __chash = std::__constrain_hash(__cp_hash, __bc);
  __next_pointer __pn = __bucket_list_[__chash];
  if (__pn != __nullptr) {
    for (bool __found = false;
         __pn->__next_ != __nullptr && std::__constrain_hash(__pn->__next_->__hash(), __bc) == __chash;
         __pn = __pn->__next_) {





      if (__found !=
          (__pn->__next_->__hash() == __cp_hash && key_eq()(__pn->__next_->__upcast()->__get_value(), __cp_val))) {
        if (!__found)
          __found = true;
        else
          break;
      }
    }
  }
  return __pn;
}






template <class _Tp, class _Hash, class _Equal, class _Alloc>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi_perform(
    __node_pointer __cp, __next_pointer __pn) throw() {
  size_type __bc = bucket_count();
  size_t __chash = std::__constrain_hash(__cp->__hash_, __bc);
  if (__pn == __nullptr) {
    __pn = __p1_.first().__ptr();
    __cp->__next_ = __pn->__next_;
    __pn->__next_ = __cp->__ptr();

    __bucket_list_[__chash] = __pn;
    if (__cp->__next_ != __nullptr)
      __bucket_list_[std::__constrain_hash(__cp->__next_->__hash(), __bc)] = __cp->__ptr();
  } else {
    __cp->__next_ = __pn->__next_;
    __pn->__next_ = __cp->__ptr();
    if (__cp->__next_ != __nullptr) {
      size_t __nhash = std::__constrain_hash(__cp->__next_->__hash(), __bc);
      if (__nhash != __chash)
        __bucket_list_[__nhash] = __cp->__ptr();
    }
  }
  ++size();
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(__node_pointer __cp) {
  __cp->__hash_ = hash_function()(__cp->__get_value());
  __next_pointer __pn = __node_insert_multi_prepare(__cp->__hash(), __cp->__get_value());
  __node_insert_multi_perform(__cp, __pn);

  return iterator(__cp->__ptr());
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(const_iterator __p, __node_pointer __cp) {
  if (__p != end() && key_eq()(*__p, __cp->__get_value())) {
    __next_pointer __np = __p.__node_;
    __cp->__hash_ = __np->__hash();
    size_type __bc = bucket_count();
    if (size() + 1 > __bc * max_load_factor() || __bc == 0) {
      __rehash_multi(std::max<size_type>(
          2 * __bc + !std::__is_hash_power2(__bc), size_type(std::ceil(float(size() + 1) / max_load_factor()))));
      __bc = bucket_count();
    }
    size_t __chash = std::__constrain_hash(__cp->__hash_, __bc);
    __next_pointer __pp = __bucket_list_[__chash];
    while (__pp->__next_ != __np)
      __pp = __pp->__next_;
    __cp->__next_ = __np;
    __pp->__next_ = static_cast<__next_pointer>(__cp);
    ++size();
    return iterator(static_cast<__next_pointer>(__cp));
  }
  return __node_insert_multi(__cp);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key, class... _Args>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args) {
  size_t __hash = hash_function()(__k);
  size_type __bc = bucket_count();
  bool __inserted = false;
  __next_pointer __nd;
  size_t __chash;
  if (__bc != 0) {
    __chash = std::__constrain_hash(__hash, __bc);
    __nd = __bucket_list_[__chash];
    if (__nd != __nullptr) {
      for (__nd = __nd->__next_;
           __nd != __nullptr && (__nd->__hash() == __hash || std::__constrain_hash(__nd->__hash(), __bc) == __chash);
           __nd = __nd->__next_) {
        if ((__nd->__hash() == __hash) && key_eq()(__nd->__upcast()->__get_value(), __k))
          goto __done;
      }
    }
  }
  {
    __node_holder __h = __construct_node_hash(__hash, std::forward<_Args>(__args)...);
    if (size() + 1 > __bc * max_load_factor() || __bc == 0) {
      __rehash_unique(std::max<size_type>(
          2 * __bc + !std::__is_hash_power2(__bc), size_type(std::ceil(float(size() + 1) / max_load_factor()))));
      __bc = bucket_count();
      __chash = std::__constrain_hash(__hash, __bc);
    }

    __next_pointer __pn = __bucket_list_[__chash];
    if (__pn == __nullptr) {
      __pn = __p1_.first().__ptr();
      __h->__next_ = __pn->__next_;
      __pn->__next_ = __h.get()->__ptr();

      __bucket_list_[__chash] = __pn;
      if (__h->__next_ != __nullptr)
        __bucket_list_[std::__constrain_hash(__h->__next_->__hash(), __bc)] = __h.get()->__ptr();
    } else {
      __h->__next_ = __pn->__next_;
      __pn->__next_ = static_cast<__next_pointer>(__h.get());
    }
    __nd = static_cast<__next_pointer>(__h.release());

    ++size();
    __inserted = true;
  }
__done:
  return pair<iterator, bool>(iterator(__nd), __inserted);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class... _Args>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique_impl(_Args&&... __args) {
  __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
  pair<iterator, bool> __r = __node_insert_unique(__h.get());
  if (__r.second)
    __h.release();
  return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class... _Args>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_multi(_Args&&... __args) {
  __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
  iterator __r = __node_insert_multi(__h.get());
  __h.release();
  return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class... _Args>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_hint_multi(const_iterator __p, _Args&&... __args) {
  __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
  iterator __r = __node_insert_multi(__p, __h.get());
  __h.release();
  return __r;
}
# 1654 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <bool _UniqueKeys>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__rehash(size_type __n) __attribute__((__no_sanitize__("unsigned-integer-overflow"))) {
  if (__n == 1)
    __n = 2;
  else if (__n & (__n - 1))
    __n = std::__next_prime(__n);
  size_type __bc = bucket_count();
  if (__n > __bc)
    __do_rehash<_UniqueKeys>(__n);
  else if (__n < __bc) {
    __n = std::max<size_type>(
        __n,
        std::__is_hash_power2(__bc) ? std::__next_hash_pow2(size_t(std::ceil(float(size()) / max_load_factor())))
                                    : std::__next_prime(size_t(std::ceil(float(size()) / max_load_factor()))));
    if (__n < __bc)
      __do_rehash<_UniqueKeys>(__n);
  }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <bool _UniqueKeys>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::__do_rehash(size_type __nbc) {
  __pointer_allocator& __npa = __bucket_list_.get_deleter().__alloc();
  __bucket_list_.reset(__nbc > 0 ? __pointer_alloc_traits::allocate(__npa, __nbc) : __nullptr);
  __bucket_list_.get_deleter().size() = __nbc;
  if (__nbc > 0) {
    for (size_type __i = 0; __i < __nbc; ++__i)
      __bucket_list_[__i] = __nullptr;
    __next_pointer __pp = __p1_.first().__ptr();
    __next_pointer __cp = __pp->__next_;
    if (__cp != __nullptr) {
      size_type __chash = std::__constrain_hash(__cp->__hash(), __nbc);
      __bucket_list_[__chash] = __pp;
      size_type __phash = __chash;
      for (__pp = __cp, void(), __cp = __cp->__next_; __cp != __nullptr; __cp = __pp->__next_) {
        __chash = std::__constrain_hash(__cp->__hash(), __nbc);
        if (__chash == __phash)
          __pp = __cp;
        else {
          if (__bucket_list_[__chash] == __nullptr) {
            __bucket_list_[__chash] = __pp;
            __pp = __cp;
            __phash = __chash;
          } else {
            __next_pointer __np = __cp;
            if (!_UniqueKeys) {
              for (; __np->__next_ != __nullptr &&
                     key_eq()(__cp->__upcast()->__get_value(), __np->__next_->__upcast()->__get_value());
                   __np = __np->__next_)
                ;
            }
            __pp->__next_ = __np->__next_;
            __np->__next_ = __bucket_list_[__chash]->__next_;
            __bucket_list_[__chash]->__next_ = __cp;
          }
        }
      }
    }
  }
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k) {
  size_t __hash = hash_function()(__k);
  size_type __bc = bucket_count();
  if (__bc != 0) {
    size_t __chash = std::__constrain_hash(__hash, __bc);
    __next_pointer __nd = __bucket_list_[__chash];
    if (__nd != __nullptr) {
      for (__nd = __nd->__next_;
           __nd != __nullptr && (__nd->__hash() == __hash || std::__constrain_hash(__nd->__hash(), __bc) == __chash);
           __nd = __nd->__next_) {
        if ((__nd->__hash() == __hash) && key_eq()(__nd->__upcast()->__get_value(), __k))
          return iterator(__nd);
      }
    }
  }
  return end();
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k) const {
  size_t __hash = hash_function()(__k);
  size_type __bc = bucket_count();
  if (__bc != 0) {
    size_t __chash = std::__constrain_hash(__hash, __bc);
    __next_pointer __nd = __bucket_list_[__chash];
    if (__nd != __nullptr) {
      for (__nd = __nd->__next_;
           __nd != __nullptr && (__hash == __nd->__hash() || std::__constrain_hash(__nd->__hash(), __bc) == __chash);
           __nd = __nd->__next_) {
        if ((__nd->__hash() == __hash) && key_eq()(__nd->__upcast()->__get_value(), __k))
          return const_iterator(__nd);
      }
    }
  }
  return end();
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class... _Args>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(_Args&&... __args) {
  _Static_assert(!__is_hash_value_type<_Args...>::value, "Construct cannot be called with a hash value type");
  __node_allocator& __na = __node_alloc();
  __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));







  std::__construct_at(std::addressof(*__h), __nullptr, 0);


  __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__get_value()), std::forward<_Args>(__args)...);
  __h.get_deleter().__value_constructed = true;

  __h->__hash_ = hash_function()(__h->__get_value());
  return __h;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _First, class... _Rest>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node_hash(size_t __hash, _First&& __f, _Rest&&... __rest) {
  _Static_assert(!__is_hash_value_type<_First, _Rest...>::value, "Construct cannot be called with a hash value type");
  __node_allocator& __na = __node_alloc();
  __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
  std::__construct_at(std::addressof(*__h), __nullptr, __hash);
  __node_traits::construct(
      __na, _NodeTypes::__get_ptr(__h->__get_value()), std::forward<_First>(__f), std::forward<_Rest>(__rest)...);
  __h.get_deleter().__value_constructed = true;
  return __h;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __p) {
  __next_pointer __np = __p.__node_;
  ((void)0);

  iterator __r(__np);
  ++__r;
  remove(__p);
  return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator
__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __first, const_iterator __last) {
  for (const_iterator __p = __first; __first != __last; __p = __first) {
    ++__first;
    erase(__p);
  }
  __next_pointer __np = __last.__node_;
  return iterator(__np);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_unique(const _Key& __k) {
  iterator __i = find(__k);
  if (__i == end())
    return 0;
  erase(__i);
  return 1;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_multi(const _Key& __k) {
  size_type __r = 0;
  iterator __i = find(__k);
  if (__i != end()) {
    iterator __e = end();
    do {
      erase(__i++);
      ++__r;
    } while (__i != __e && key_eq()(*__i, __k));
  }
  return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder
__hash_table<_Tp, _Hash, _Equal, _Alloc>::remove(const_iterator __p) throw() {

  __next_pointer __cn = __p.__node_;
  size_type __bc = bucket_count();
  size_t __chash = std::__constrain_hash(__cn->__hash(), __bc);

  __next_pointer __pn = __bucket_list_[__chash];
  for (; __pn->__next_ != __cn; __pn = __pn->__next_)
    ;



  if (__pn == __p1_.first().__ptr() || std::__constrain_hash(__pn->__hash(), __bc) != __chash) {
    if (__cn->__next_ == __nullptr || std::__constrain_hash(__cn->__next_->__hash(), __bc) != __chash)
      __bucket_list_[__chash] = __nullptr;
  }

  if (__cn->__next_ != __nullptr) {
    size_t __nhash = std::__constrain_hash(__cn->__next_->__hash(), __bc);
    if (__nhash != __chash)
      __bucket_list_[__nhash] = __pn;
  }

  __pn->__next_ = __cn->__next_;
  __cn->__next_ = __nullptr;
  --size();
  return __node_holder(__cn->__upcast(), _Dp(__node_alloc(), true));
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
inline typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_unique(const _Key& __k) const {
  return static_cast<size_type>(find(__k) != end());
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_multi(const _Key& __k) const {
  size_type __r = 0;
  const_iterator __i = find(__k);
  if (__i != end()) {
    const_iterator __e = end();
    do {
      ++__i;
      ++__r;
    } while (__i != __e && key_eq()(*__i, __k));
  }
  return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(const _Key& __k) {
  iterator __i = find(__k);
  iterator __j = __i;
  if (__i != end())
    ++__j;
  return pair<iterator, iterator>(__i, __j);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(const _Key& __k) const {
  const_iterator __i = find(__k);
  const_iterator __j = __i;
  if (__i != end())
    ++__j;
  return pair<const_iterator, const_iterator>(__i, __j);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(const _Key& __k) {
  iterator __i = find(__k);
  iterator __j = __i;
  if (__i != end()) {
    iterator __e = end();
    do {
      ++__j;
    } while (__j != __e && key_eq()(*__j, __k));
  }
  return pair<iterator, iterator>(__i, __j);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
template <class _Key>
pair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,
     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>
__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(const _Key& __k) const {
  const_iterator __i = find(__k);
  const_iterator __j = __i;
  if (__i != end()) {
    const_iterator __e = end();
    do {
      ++__j;
    } while (__j != __e && key_eq()(*__j, __k));
  }
  return pair<const_iterator, const_iterator>(__i, __j);
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
void __hash_table<_Tp, _Hash, _Equal, _Alloc>::swap(__hash_table& __u)
# 1966 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__hash_table" 3
{
  ((void)0);



  {
    __node_pointer_pointer __npp = __bucket_list_.release();
    __bucket_list_.reset(__u.__bucket_list_.release());
    __u.__bucket_list_.reset(__npp);
  }
  std::swap(__bucket_list_.get_deleter().size(), __u.__bucket_list_.get_deleter().size());
  std::__swap_allocator(__bucket_list_.get_deleter().__alloc(), __u.__bucket_list_.get_deleter().__alloc());
  std::__swap_allocator(__node_alloc(), __u.__node_alloc());
  std::swap(__p1_.first().__next_, __u.__p1_.first().__next_);
  __p2_.swap(__u.__p2_);
  __p3_.swap(__u.__p3_);
  if (size() > 0)
    __bucket_list_[std::__constrain_hash(__p1_.first().__next_->__hash(), bucket_count())] = __p1_.first().__ptr();
  if (__u.size() > 0)
    __u.__bucket_list_[std::__constrain_hash(__u.__p1_.first().__next_->__hash(), __u.bucket_count())] =
        __u.__p1_.first().__ptr();
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type
__hash_table<_Tp, _Hash, _Equal, _Alloc>::bucket_size(size_type __n) const {
  ((void)0);

  __next_pointer __np = __bucket_list_[__n];
  size_type __bc = bucket_count();
  size_type __r = 0;
  if (__np != __nullptr) {
    for (__np = __np->__next_; __np != __nullptr && std::__constrain_hash(__np->__hash(), __bc) == __n;
         __np = __np->__next_, (void)++__r)
      ;
  }
  return __r;
}

template <class _Tp, class _Hash, class _Equal, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
swap(__hash_table<_Tp, _Hash, _Equal, _Alloc>& __x, __hash_table<_Tp, _Hash, _Equal, _Alloc>& __y)
                                          {
  __x.swap(__y);
}

}}
# 593 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ranges_iterator_traits.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ranges_iterator_traits.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__iterator/ranges_iterator_traits.h" 3
}}
# 597 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__node_handle" 1 3
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__node_handle" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__node_handle" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 205 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__node_handle" 3
}}
# 601 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 2 3
# 626 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 630 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Key,
          class _Cp,
          class _Hash,
          class _Pred,
          bool = is_empty<_Hash>::value && !__libcpp_is_final<_Hash>::value>
class __unordered_map_hasher : private _Hash {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __unordered_map_hasher() : _Hash() {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __unordered_map_hasher(const _Hash& __h)
      : _Hash(__h) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _Hash& hash_function() const throw() { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(const _Cp& __x) const {
    return static_cast<const _Hash&>(*this)(__x.__get_value().first);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(const _Key& __x) const { return static_cast<const _Hash&>(*this)(__x); }






  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(__unordered_map_hasher& __y) {
    using std::swap;
    swap(static_cast<_Hash&>(*this), static_cast<_Hash&>(__y));
  }
};

template <class _Key, class _Cp, class _Hash, class _Pred>
class __unordered_map_hasher<_Key, _Cp, _Hash, _Pred, false> {
  _Hash __hash_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __unordered_map_hasher()
      : __hash_() {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __unordered_map_hasher(const _Hash& __h)
      : __hash_(__h) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _Hash& hash_function() const throw() { return __hash_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(const _Cp& __x) const { return __hash_(__x.__get_value().first); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_t operator()(const _Key& __x) const { return __hash_(__x); }






  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(__unordered_map_hasher& __y) {
    using std::swap;
    swap(__hash_, __y.__hash_);
  }
};

template <class _Key, class _Cp, class _Hash, class _Pred, bool __b>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
swap(__unordered_map_hasher<_Key, _Cp, _Hash, _Pred, __b>& __x,
     __unordered_map_hasher<_Key, _Cp, _Hash, _Pred, __b>& __y) {
  __x.swap(__y);
}

template <class _Key,
          class _Cp,
          class _Pred,
          class _Hash,
          bool = is_empty<_Pred>::value && !__libcpp_is_final<_Pred>::value>
class __unordered_map_equal : private _Pred {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __unordered_map_equal() : _Pred() {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __unordered_map_equal(const _Pred& __p)
      : _Pred(__p) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _Pred& key_eq() const throw() { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _Cp& __x, const _Cp& __y) const {
    return static_cast<const _Pred&>(*this)(__x.__get_value().first, __y.__get_value().first);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _Cp& __x, const _Key& __y) const {
    return static_cast<const _Pred&>(*this)(__x.__get_value().first, __y);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _Key& __x, const _Cp& __y) const {
    return static_cast<const _Pred&>(*this)(__x, __y.__get_value().first);
  }
# 729 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(__unordered_map_equal& __y) {
    using std::swap;
    swap(static_cast<_Pred&>(*this), static_cast<_Pred&>(__y));
  }
};

template <class _Key, class _Cp, class _Pred, class _Hash>
class __unordered_map_equal<_Key, _Cp, _Pred, _Hash, false> {
  _Pred __pred_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __unordered_map_equal()
      : __pred_() {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __unordered_map_equal(const _Pred& __p)
      : __pred_(__p) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _Pred& key_eq() const throw() { return __pred_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _Cp& __x, const _Cp& __y) const {
    return __pred_(__x.__get_value().first, __y.__get_value().first);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _Cp& __x, const _Key& __y) const {
    return __pred_(__x.__get_value().first, __y);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator()(const _Key& __x, const _Cp& __y) const {
    return __pred_(__x, __y.__get_value().first);
  }
# 772 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(__unordered_map_equal& __y) {
    using std::swap;
    swap(__pred_, __y.__pred_);
  }
};

template <class _Key, class _Cp, class _Pred, class _Hash, bool __b>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
swap(__unordered_map_equal<_Key, _Cp, _Pred, _Hash, __b>& __x, __unordered_map_equal<_Key, _Cp, _Pred, _Hash, __b>& __y)
                                          {
  __x.swap(__y);
}

template <class _Alloc>
class __hash_map_node_destructor {
  typedef _Alloc allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;

public:
  typedef typename __alloc_traits::pointer pointer;

private:
  allocator_type& __na_;

  __hash_map_node_destructor& operator=(const __hash_map_node_destructor&);

public:
  bool __first_constructed;
  bool __second_constructed;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __hash_map_node_destructor(allocator_type& __na) throw()
      : __na_(__na),
        __first_constructed(false),
        __second_constructed(false) {}
# 815 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_map_node_destructor(const __hash_node_destructor<allocator_type>& __x)
      : __na_(__x.__na_), __first_constructed(__x.__value_constructed), __second_constructed(__x.__value_constructed) {
    const_cast<bool&>(__x.__value_constructed) = false;
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator()(pointer __p) throw() {
    if (__second_constructed)
      __alloc_traits::destroy(__na_, std::addressof(__p->__get_value().__get_value().second));
    if (__first_constructed)
      __alloc_traits::destroy(__na_, std::addressof(__p->__get_value().__get_value().first));
    if (__p)
      __alloc_traits::deallocate(__na_, __p, 1);
  }
};
# 897 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
template <class _Key, class _Tp>
struct __hash_value_type {
  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef pair<const key_type, mapped_type> value_type;

private:
  value_type __cc_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) value_type& __get_value() { return __cc_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const value_type& __get_value() const { return __cc_; }

private:
  ~__hash_value_type();
};



template <class _HashIterator>
class __hash_map_iterator {
  _HashIterator __i_;

  typedef __hash_node_types_from_iterator<_HashIterator> _NodeTypes;

public:
  typedef forward_iterator_tag iterator_category;
  typedef typename _NodeTypes::__map_value_type value_type;
  typedef typename _NodeTypes::difference_type difference_type;
  typedef value_type& reference;
  typedef typename _NodeTypes::__map_value_type_pointer pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_map_iterator() throw() {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_map_iterator(_HashIterator __i) throw() : __i_(__i) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator*() const { return __i_->__get_value(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer operator->() const { return pointer_traits<pointer>::pointer_to(__i_->__get_value()); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_map_iterator& operator++() {
    ++__i_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_map_iterator operator++(int) {
    __hash_map_iterator __t(*this);
    ++(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const __hash_map_iterator& __x, const __hash_map_iterator& __y) {
    return __x.__i_ == __y.__i_;
  }

  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const __hash_map_iterator& __x, const __hash_map_iterator& __y) {
    return __x.__i_ != __y.__i_;
  }


  template <class, class, class, class, class>
  friend class unordered_map;
  template <class, class, class, class, class>
  friend class unordered_multimap;
  template <class>
  friend class __hash_const_iterator;
  template <class>
  friend class __hash_const_local_iterator;
  template <class>
  friend class __hash_map_const_iterator;
};

template <class _HashIterator>
class __hash_map_const_iterator {
  _HashIterator __i_;

  typedef __hash_node_types_from_iterator<_HashIterator> _NodeTypes;

public:
  typedef forward_iterator_tag iterator_category;
  typedef typename _NodeTypes::__map_value_type value_type;
  typedef typename _NodeTypes::difference_type difference_type;
  typedef const value_type& reference;
  typedef typename _NodeTypes::__const_map_value_type_pointer pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_map_const_iterator() throw() {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_map_const_iterator(_HashIterator __i) throw() : __i_(__i) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  __hash_map_const_iterator(__hash_map_iterator<typename _HashIterator::__non_const_iterator> __i) throw()
      : __i_(__i.__i_) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference operator*() const { return __i_->__get_value(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer operator->() const { return pointer_traits<pointer>::pointer_to(__i_->__get_value()); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_map_const_iterator& operator++() {
    ++__i_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __hash_map_const_iterator operator++(int) {
    __hash_map_const_iterator __t(*this);
    ++(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
  operator==(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y) {
    return __x.__i_ == __y.__i_;
  }

  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
  operator!=(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y) {
    return __x.__i_ != __y.__i_;
  }


  template <class, class, class, class, class>
  friend class unordered_map;
  template <class, class, class, class, class>
  friend class unordered_multimap;
  template <class>
  friend class __hash_const_iterator;
  template <class>
  friend class __hash_const_local_iterator;
};

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
class unordered_multimap;

template <class _Key,
          class _Tp,
          class _Hash = hash<_Key>,
          class _Pred = equal_to<_Key>,
          class _Alloc = allocator<pair<const _Key, _Tp> > >
class unordered_map {
public:

  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef __type_identity_t<_Hash> hasher;
  typedef __type_identity_t<_Pred> key_equal;
  typedef __type_identity_t<_Alloc> allocator_type;
  typedef pair<const key_type, mapped_type> value_type;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  _Static_assert((is_same<value_type, typename allocator_type::value_type>::value), "Allocator::value_type must be same type as value_type");


private:
  typedef __hash_value_type<key_type, mapped_type> __value_type;
  typedef __unordered_map_hasher<key_type, __value_type, hasher, key_equal> __hasher;
  typedef __unordered_map_equal<key_type, __value_type, key_equal, hasher> __key_equal;
  typedef __rebind_alloc<allocator_traits<allocator_type>, __value_type> __allocator_type;

  typedef __hash_table<__value_type, __hasher, __key_equal, __allocator_type> __table;

  __table __table_;

  typedef typename __table::_NodeTypes _NodeTypes;
  typedef typename __table::__node_pointer __node_pointer;
  typedef typename __table::__node_const_pointer __node_const_pointer;
  typedef typename __table::__node_traits __node_traits;
  typedef typename __table::__node_allocator __node_allocator;
  typedef typename __table::__node __node;
  typedef __hash_map_node_destructor<__node_allocator> _Dp;
  typedef unique_ptr<__node, _Dp> __node_holder;
  typedef allocator_traits<allocator_type> __alloc_traits;

  _Static_assert(is_same<allocator_type, __rebind_alloc<__alloc_traits, value_type> >::value, "[allocator.requirements] states that rebinding an allocator to the same type should result in the " "original allocator");



  _Static_assert((is_same<typename __table::__container_value_type, value_type>::value), "");
  _Static_assert((is_same<typename __table::__node_value_type, __value_type>::value), "");

public:
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;
  typedef typename __table::size_type size_type;
  typedef typename __table::difference_type difference_type;

  typedef __hash_map_iterator<typename __table::iterator> iterator;
  typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;
  typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;
  typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;






  template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>
  friend class unordered_map;
  template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>
  friend class unordered_multimap;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unordered_map() {}
  explicit __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  unordered_map(size_type __n, const hasher& __hf = hasher(), const key_equal& __eql = key_equal());
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  unordered_map(size_type __n, const hasher& __hf, const key_equal& __eql, const allocator_type& __a);
  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unordered_map(_InputIterator __first, _InputIterator __last);
  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  unordered_map(_InputIterator __first,
                _InputIterator __last,
                size_type __n,
                const hasher& __hf = hasher(),
                const key_equal& __eql = key_equal());
  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unordered_map(
      _InputIterator __first,
      _InputIterator __last,
      size_type __n,
      const hasher& __hf,
      const key_equal& __eql,
      const allocator_type& __a);
# 1131 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit unordered_map(const allocator_type& __a);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unordered_map(const unordered_map& __u);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unordered_map(const unordered_map& __u, const allocator_type& __a);
# 1181 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~unordered_map() {
    _Static_assert(sizeof(std::__diagnose_unordered_container_requirements<_Key, _Hash, _Pred>(0)), "");
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unordered_map& operator=(const unordered_map& __u) {



    if (this != std::addressof(__u)) {
      __table_.clear();
      __table_.hash_function() = __u.__table_.hash_function();
      __table_.key_eq() = __u.__table_.key_eq();
      __table_.max_load_factor() = __u.__table_.max_load_factor();
      __table_.__copy_assign_alloc(__u.__table_);
      insert(__u.begin(), __u.end());
    }

    return *this;
  }






  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) allocator_type get_allocator() const throw() {
    return allocator_type(__table_.__node_alloc());
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool empty() const throw() { return __table_.size() == 0; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type size() const throw() { return __table_.size(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type max_size() const throw() { return __table_.max_size(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator begin() throw() { return __table_.begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator end() throw() { return __table_.end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator begin() const throw() { return __table_.begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator end() const throw() { return __table_.end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator cbegin() const throw() { return __table_.begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator cend() const throw() { return __table_.end(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<iterator, bool> insert(const value_type& __x) { return __table_.__insert_unique(__x); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator insert(const_iterator, const value_type& __x) { return insert(__x).first; }

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void insert(_InputIterator __first, _InputIterator __last);
# 1325 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator erase(const_iterator __p) { return __table_.erase(__p.__i_); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator erase(iterator __p) { return __table_.erase(__p.__i_); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type erase(const key_type& __k) { return __table_.__erase_unique(__k); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator erase(const_iterator __first, const_iterator __last) {
    return __table_.erase(__first.__i_, __last.__i_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void clear() throw() { __table_.clear(); }
# 1377 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(unordered_map& __u) {
    __table_.swap(__u.__table_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) hasher hash_function() const { return __table_.hash_function().hash_function(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) key_equal key_eq() const { return __table_.key_eq().key_eq(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator find(const key_type& __k) { return __table_.find(__k); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator find(const key_type& __k) const { return __table_.find(__k); }
# 1399 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type count(const key_type& __k) const { return __table_.__count_unique(__k); }
# 1418 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<iterator, iterator> equal_range(const key_type& __k) {
    return __table_.__equal_range_unique(__k);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<const_iterator, const_iterator> equal_range(const key_type& __k) const {
    return __table_.__equal_range_unique(__k);
  }
# 1437 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) mapped_type& operator[](const key_type& __k);




  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) mapped_type& at(const key_type& __k);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const mapped_type& at(const key_type& __k) const;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type bucket_count() const throw() { return __table_.bucket_count(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type max_bucket_count() const throw() { return __table_.max_bucket_count(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type bucket_size(size_type __n) const { return __table_.bucket_size(__n); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type bucket(const key_type& __k) const { return __table_.bucket(__k); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) local_iterator begin(size_type __n) { return __table_.begin(__n); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) local_iterator end(size_type __n) { return __table_.end(__n); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_local_iterator begin(size_type __n) const { return __table_.cbegin(__n); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_local_iterator end(size_type __n) const { return __table_.cend(__n); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_local_iterator cbegin(size_type __n) const { return __table_.cbegin(__n); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_local_iterator cend(size_type __n) const { return __table_.cend(__n); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float load_factor() const throw() { return __table_.load_factor(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float max_load_factor() const throw() { return __table_.max_load_factor(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void max_load_factor(float __mlf) { __table_.max_load_factor(__mlf); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void rehash(size_type __n) { __table_.__rehash_unique(__n); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void reserve(size_type __n) { __table_.__reserve_unique(__n); }

private:

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __node_holder __construct_node_with_key(const key_type& __k);

};
# 1609 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql) {
  __table_.__rehash_unique(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
    size_type __n, const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a)) {
  __table_.__rehash_unique(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(const allocator_type& __a)
    : __table_(typename __table::allocator_type(__a)) {}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(_InputIterator __first, _InputIterator __last) {
  insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
    _InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql) {
  __table_.__rehash_unique(__n);
  insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(
    _InputIterator __first,
    _InputIterator __last,
    size_type __n,
    const hasher& __hf,
    const key_equal& __eql,
    const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a)) {
  __table_.__rehash_unique(__n);
  insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(const unordered_map& __u) : __table_(__u.__table_) {
  __table_.__rehash_unique(__u.bucket_count());
  insert(__u.begin(), __u.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(const unordered_map& __u, const allocator_type& __a)
    : __table_(__u.__table_, typename __table::allocator_type(__a)) {
  __table_.__rehash_unique(__u.bucket_count());
  insert(__u.begin(), __u.end());
}
# 1728 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
inline void unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first, _InputIterator __last) {
  for (; __first != __last; ++__first)
    __table_.__insert_unique(*__first);
}
# 1755 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder
unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node_with_key(const key_type& __k) {
  __node_allocator& __na = __table_.__node_alloc();
  __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
  __node_traits::construct(__na, std::addressof(__h->__get_value().__get_value().first), __k);
  __h.get_deleter().__first_constructed = true;
  __node_traits::construct(__na, std::addressof(__h->__get_value().__get_value().second));
  __h.get_deleter().__second_constructed = true;
  return __h;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
_Tp& unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type& __k) {
  iterator __i = find(__k);
  if (__i != end())
    return __i->second;
  __node_holder __h = __construct_node_with_key(__k);
  pair<iterator, bool> __r = __table_.__node_insert_unique(__h.get());
  __h.release();
  return __r.first->second;
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
_Tp& unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k) {
  iterator __i = find(__k);
  if (__i == end())
    __throw_out_of_range("unordered_map::at: key not found");
  return __i->second;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
const _Tp& unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k) const {
  const_iterator __i = find(__k);
  if (__i == end())
    __throw_out_of_range("unordered_map::at: key not found");
  return __i->second;
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x, unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
                                          {
  __x.swap(__y);
}
# 1811 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
                                      const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y) {
  if (__x.size() != __y.size())
    return false;
  typedef typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator const_iterator;
  for (const_iterator __i = __x.begin(), __ex = __x.end(), __ey = __y.end(); __i != __ex; ++__i) {
    const_iterator __j = __y.find(__i->first);
    if (__j == __ey || !(*__i == *__j))
      return false;
  }
  return true;
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
                                             const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y) {
  return !(__x == __y);
}



template <class _Key,
          class _Tp,
          class _Hash = hash<_Key>,
          class _Pred = equal_to<_Key>,
          class _Alloc = allocator<pair<const _Key, _Tp> > >
class unordered_multimap {
public:

  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef __type_identity_t<_Hash> hasher;
  typedef __type_identity_t<_Pred> key_equal;
  typedef __type_identity_t<_Alloc> allocator_type;
  typedef pair<const key_type, mapped_type> value_type;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  _Static_assert((is_same<value_type, typename allocator_type::value_type>::value), "Allocator::value_type must be same type as value_type");


private:
  typedef __hash_value_type<key_type, mapped_type> __value_type;
  typedef __unordered_map_hasher<key_type, __value_type, hasher, key_equal> __hasher;
  typedef __unordered_map_equal<key_type, __value_type, key_equal, hasher> __key_equal;
  typedef __rebind_alloc<allocator_traits<allocator_type>, __value_type> __allocator_type;

  typedef __hash_table<__value_type, __hasher, __key_equal, __allocator_type> __table;

  __table __table_;

  typedef typename __table::_NodeTypes _NodeTypes;
  typedef typename __table::__node_traits __node_traits;
  typedef typename __table::__node_allocator __node_allocator;
  typedef typename __table::__node __node;
  typedef __hash_map_node_destructor<__node_allocator> _Dp;
  typedef unique_ptr<__node, _Dp> __node_holder;
  typedef allocator_traits<allocator_type> __alloc_traits;
  _Static_assert((is_same<typename __node_traits::size_type, typename __alloc_traits::size_type>::value), "Allocator uses different size_type for different types");


  _Static_assert(is_same<allocator_type, __rebind_alloc<__alloc_traits, value_type> >::value, "[allocator.requirements] states that rebinding an allocator to the same type should result in the " "original allocator");



public:
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;
  typedef typename __table::size_type size_type;
  typedef typename __table::difference_type difference_type;

  typedef __hash_map_iterator<typename __table::iterator> iterator;
  typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;
  typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;
  typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;





  template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>
  friend class unordered_map;
  template <class _Key2, class _Tp2, class _Hash2, class _Pred2, class _Alloc2>
  friend class unordered_multimap;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unordered_multimap() {}
  explicit __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  unordered_multimap(size_type __n, const hasher& __hf = hasher(), const key_equal& __eql = key_equal());
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  unordered_multimap(size_type __n, const hasher& __hf, const key_equal& __eql, const allocator_type& __a);
  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unordered_multimap(_InputIterator __first, _InputIterator __last);
  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unordered_multimap(
      _InputIterator __first,
      _InputIterator __last,
      size_type __n,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal());
  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unordered_multimap(
      _InputIterator __first,
      _InputIterator __last,
      size_type __n,
      const hasher& __hf,
      const key_equal& __eql,
      const allocator_type& __a);
# 1938 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit unordered_multimap(const allocator_type& __a);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unordered_multimap(const unordered_multimap& __u);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unordered_multimap(const unordered_multimap& __u, const allocator_type& __a);
# 1989 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) ~unordered_multimap() {
    _Static_assert(sizeof(std::__diagnose_unordered_container_requirements<_Key, _Hash, _Pred>(0)), "");
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unordered_multimap& operator=(const unordered_multimap& __u) {



    if (this != std::addressof(__u)) {
      __table_.clear();
      __table_.hash_function() = __u.__table_.hash_function();
      __table_.key_eq() = __u.__table_.key_eq();
      __table_.max_load_factor() = __u.__table_.max_load_factor();
      __table_.__copy_assign_alloc(__u.__table_);
      insert(__u.begin(), __u.end());
    }

    return *this;
  }






  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) allocator_type get_allocator() const throw() {
    return allocator_type(__table_.__node_alloc());
  }

                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool empty() const throw() { return __table_.size() == 0; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type size() const throw() { return __table_.size(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type max_size() const throw() { return __table_.max_size(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator begin() throw() { return __table_.begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator end() throw() { return __table_.end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator begin() const throw() { return __table_.begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator end() const throw() { return __table_.end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator cbegin() const throw() { return __table_.begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator cend() const throw() { return __table_.end(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator insert(const value_type& __x) { return __table_.__insert_multi(__x); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator insert(const_iterator __p, const value_type& __x) {
    return __table_.__insert_multi(__p.__i_, __x);
  }

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void insert(_InputIterator __first, _InputIterator __last);
# 2076 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator erase(const_iterator __p) { return __table_.erase(__p.__i_); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator erase(iterator __p) { return __table_.erase(__p.__i_); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type erase(const key_type& __k) { return __table_.__erase_multi(__k); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator erase(const_iterator __first, const_iterator __last) {
    return __table_.erase(__first.__i_, __last.__i_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void clear() throw() { __table_.clear(); }
# 2128 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(unordered_multimap& __u) {
    __table_.swap(__u.__table_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) hasher hash_function() const { return __table_.hash_function().hash_function(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) key_equal key_eq() const { return __table_.key_eq().key_eq(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) iterator find(const key_type& __k) { return __table_.find(__k); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_iterator find(const key_type& __k) const { return __table_.find(__k); }
# 2150 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type count(const key_type& __k) const { return __table_.__count_multi(__k); }
# 2169 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<iterator, iterator> equal_range(const key_type& __k) {
    return __table_.__equal_range_multi(__k);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pair<const_iterator, const_iterator> equal_range(const key_type& __k) const {
    return __table_.__equal_range_multi(__k);
  }
# 2188 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type bucket_count() const throw() { return __table_.bucket_count(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type max_bucket_count() const throw() { return __table_.max_bucket_count(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type bucket_size(size_type __n) const { return __table_.bucket_size(__n); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type bucket(const key_type& __k) const { return __table_.bucket(__k); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) local_iterator begin(size_type __n) { return __table_.begin(__n); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) local_iterator end(size_type __n) { return __table_.end(__n); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_local_iterator begin(size_type __n) const { return __table_.cbegin(__n); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_local_iterator end(size_type __n) const { return __table_.cend(__n); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_local_iterator cbegin(size_type __n) const { return __table_.cbegin(__n); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_local_iterator cend(size_type __n) const { return __table_.cend(__n); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float load_factor() const throw() { return __table_.load_factor(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) float max_load_factor() const throw() { return __table_.max_load_factor(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void max_load_factor(float __mlf) { __table_.max_load_factor(__mlf); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void rehash(size_type __n) { __table_.__rehash_multi(__n); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void reserve(size_type __n) { __table_.__reserve_multi(__n); }
};
# 2361 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
    size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql) {
  __table_.__rehash_multi(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
    size_type __n, const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a)) {
  __table_.__rehash_multi(__n);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(_InputIterator __first, _InputIterator __last) {
  insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
    _InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql) {
  __table_.__rehash_multi(__n);
  insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
    _InputIterator __first,
    _InputIterator __last,
    size_type __n,
    const hasher& __hf,
    const key_equal& __eql,
    const allocator_type& __a)
    : __table_(__hf, __eql, typename __table::allocator_type(__a)) {
  __table_.__rehash_multi(__n);
  insert(__first, __last);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(const allocator_type& __a)
    : __table_(typename __table::allocator_type(__a)) {}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(const unordered_multimap& __u)
    : __table_(__u.__table_) {
  __table_.__rehash_multi(__u.bucket_count());
  insert(__u.begin(), __u.end());
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(
    const unordered_multimap& __u, const allocator_type& __a)
    : __table_(__u.__table_, typename __table::allocator_type(__a)) {
  __table_.__rehash_multi(__u.bucket_count());
  insert(__u.begin(), __u.end());
}
# 2484 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
inline void unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first, _InputIterator __last) {
  for (; __first != __last; ++__first)
    __table_.__insert_multi(*__first);
}

template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x, unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
                                          {
  __x.swap(__y);
}
# 2506 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/unordered_map" 3
template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
                                      const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y) {
  if (__x.size() != __y.size())
    return false;
  typedef typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator const_iterator;
  typedef pair<const_iterator, const_iterator> _EqRng;
  for (const_iterator __i = __x.begin(), __ex = __x.end(); __i != __ex;) {
    _EqRng __xeq = __x.equal_range(__i->first);
    _EqRng __yeq = __y.equal_range(__i->first);
    if (std::distance(__xeq.first, __xeq.second) != std::distance(__yeq.first, __yeq.second) ||
        !std::is_permutation(__xeq.first, __xeq.second, __yeq.first))
      return false;
    __i = __xeq.second;
  }
  return true;
}



template <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
                                             const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y) {
  return !(__x == __y);
}



}}
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/boyer_moore_searcher.h" 2 3
# 527 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/compose.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/compose.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 51 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/compose.h" 3
}}
# 528 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/default_searcher.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/default_searcher.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/default_searcher.h" 3
}}
# 529 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/builtin_new_allocator.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__memory/builtin_new_allocator.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {





struct __builtin_new_allocator {
  struct __builtin_new_deleter {
    typedef void* pointer_type;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit __builtin_new_deleter(size_t __size, size_t __align)
        : __size_(__size), __align_(__align) {}

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void operator()(void* __p) const throw() {
      std::__libcpp_deallocate(__p, __size_, __align_);
    }

  private:
    size_t __size_;
    size_t __align_;
  };

  typedef unique_ptr<void, __builtin_new_deleter> __holder_t;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static __holder_t __allocate_bytes(size_t __s, size_t __align) {
    return __holder_t(std::__libcpp_allocate(__s, __align), __builtin_new_deleter(__s, __align));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static void __deallocate_bytes(void* __p, size_t __s, size_t __align) throw() {
    std::__libcpp_deallocate(__p, __s, __align);
  }

  template <class _Tp>
  __attribute__((__nodebug__)) __attribute__((__always_inline__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static __holder_t __allocate_type(size_t __n) {
    return __allocate_bytes(__n * sizeof(_Tp), _Alignof(_Tp));
  }

  template <class _Tp>
  __attribute__((__nodebug__)) __attribute__((__always_inline__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) static void
  __deallocate_type(void* __p, size_t __n) throw() {
    __deallocate_bytes(__p, __n * sizeof(_Tp), _Alignof(_Tp));
  }
};

}}
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 2 3
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/strip_signature.h" 1 3
# 16 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/strip_signature.h" 3
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 2 3
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/function.h" 2 3
# 530 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/mem_fn.h" 1 3
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/mem_fn.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp>
class __mem_fn : public __weak_result_type<_Tp> {
public:

  typedef _Tp type;

private:
  type __f_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __mem_fn(type __f) throw() : __f_(__f) {}


  template <class... _ArgTypes>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))

      typename __invoke_return<type, _ArgTypes...>::type
      operator()(_ArgTypes&&... __args) const {
    return std::__invoke(__f_, std::forward<_ArgTypes>(__args)...);
  }
};

template <class _Rp, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) __mem_fn<_Rp _Tp::*> mem_fn(_Rp _Tp::*__pm) throw() {
  return __mem_fn<_Rp _Tp::*>(__pm);
}

}}
# 534 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/mem_fun_ref.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/mem_fun_ref.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Sp, class _Tp>
class mem_fun_t : public __unary_function<_Tp*, _Sp> {
  _Sp (_Tp::*__p_)();

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit mem_fun_t(_Sp (_Tp::*__p)()) : __p_(__p) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Sp operator()(_Tp* __p) const { return (__p->*__p_)(); }
};

template <class _Sp, class _Tp, class _Ap>
class mem_fun1_t : public __binary_function<_Tp*, _Ap, _Sp> {
  _Sp (_Tp::*__p_)(_Ap);

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap)) : __p_(__p) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Sp operator()(_Tp* __p, _Ap __x) const { return (__p->*__p_)(__x); }
};

template <class _Sp, class _Tp>
                            inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) mem_fun_t<_Sp, _Tp> mem_fun(_Sp (_Tp::*__f)()) {
  return mem_fun_t<_Sp, _Tp>(__f);
}

template <class _Sp, class _Tp, class _Ap>
                            inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) mem_fun1_t<_Sp, _Tp, _Ap> mem_fun(_Sp (_Tp::*__f)(_Ap)) {
  return mem_fun1_t<_Sp, _Tp, _Ap>(__f);
}

template <class _Sp, class _Tp>
class mem_fun_ref_t : public __unary_function<_Tp, _Sp> {
  _Sp (_Tp::*__p_)();

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit mem_fun_ref_t(_Sp (_Tp::*__p)()) : __p_(__p) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Sp operator()(_Tp& __p) const { return (__p.*__p_)(); }
};

template <class _Sp, class _Tp, class _Ap>
class mem_fun1_ref_t : public __binary_function<_Tp, _Ap, _Sp> {
  _Sp (_Tp::*__p_)(_Ap);

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap)) : __p_(__p) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Sp operator()(_Tp& __p, _Ap __x) const { return (__p.*__p_)(__x); }
};

template <class _Sp, class _Tp>
                            inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) mem_fun_ref_t<_Sp, _Tp> mem_fun_ref(_Sp (_Tp::*__f)()) {
  return mem_fun_ref_t<_Sp, _Tp>(__f);
}

template <class _Sp, class _Tp, class _Ap>
                            inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) mem_fun1_ref_t<_Sp, _Tp, _Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap)) {
  return mem_fun1_ref_t<_Sp, _Tp, _Ap>(__f);
}

template <class _Sp, class _Tp>
class const_mem_fun_t : public __unary_function<const _Tp*, _Sp> {
  _Sp (_Tp::*__p_)() const;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit const_mem_fun_t(_Sp (_Tp::*__p)() const) : __p_(__p) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Sp operator()(const _Tp* __p) const { return (__p->*__p_)(); }
};

template <class _Sp, class _Tp, class _Ap>
class const_mem_fun1_t
    : public __binary_function<const _Tp*, _Ap, _Sp> {
  _Sp (_Tp::*__p_)(_Ap) const;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const) : __p_(__p) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Sp operator()(const _Tp* __p, _Ap __x) const { return (__p->*__p_)(__x); }
};

template <class _Sp, class _Tp>
                            inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_mem_fun_t<_Sp, _Tp> mem_fun(_Sp (_Tp::*__f)() const) {
  return const_mem_fun_t<_Sp, _Tp>(__f);
}

template <class _Sp, class _Tp, class _Ap>
                            inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_mem_fun1_t<_Sp, _Tp, _Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap) const) {
  return const_mem_fun1_t<_Sp, _Tp, _Ap>(__f);
}

template <class _Sp, class _Tp>
class const_mem_fun_ref_t : public __unary_function<_Tp, _Sp> {
  _Sp (_Tp::*__p_)() const;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const) : __p_(__p) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Sp operator()(const _Tp& __p) const { return (__p.*__p_)(); }
};

template <class _Sp, class _Tp, class _Ap>
class const_mem_fun1_ref_t : public __binary_function<_Tp, _Ap, _Sp> {
  _Sp (_Tp::*__p_)(_Ap) const;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const) : __p_(__p) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Sp operator()(const _Tp& __p, _Ap __x) const { return (__p.*__p_)(__x); }
};

template <class _Sp, class _Tp>
                            inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_mem_fun_ref_t<_Sp, _Tp>
mem_fun_ref(_Sp (_Tp::*__f)() const) {
  return const_mem_fun_ref_t<_Sp, _Tp>(__f);
}

template <class _Sp, class _Tp, class _Ap>
                            inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_mem_fun1_ref_t<_Sp, _Tp, _Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap) const) {
  return const_mem_fun1_ref_t<_Sp, _Tp, _Ap>(__f);
}



}}
# 535 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/not_fn.h" 1 3
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/not_fn.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/not_fn.h" 3
}}
# 536 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/pointer_to_binary_function.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/pointer_to_binary_function.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Arg1, class _Arg2, class _Result>
class pointer_to_binary_function
    : public __binary_function<_Arg1, _Arg2, _Result> {
  _Result (*__f_)(_Arg1, _Arg2);

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2)) : __f_(__f) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Result operator()(_Arg1 __x, _Arg2 __y) const { return __f_(__x, __y); }
};

template <class _Arg1, class _Arg2, class _Result>
                            inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer_to_binary_function<_Arg1, _Arg2, _Result>
ptr_fun(_Result (*__f)(_Arg1, _Arg2)) {
  return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__f);
}



}}
# 538 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/pointer_to_unary_function.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/pointer_to_unary_function.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Arg, class _Result>
class pointer_to_unary_function
    : public __unary_function<_Arg, _Result> {
  _Result (*__f_)(_Arg);

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit pointer_to_unary_function(_Result (*__f)(_Arg)) : __f_(__f) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Result operator()(_Arg __x) const { return __f_(__x); }
};

template <class _Arg, class _Result>
                            inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pointer_to_unary_function<_Arg, _Result>
ptr_fun(_Result (*__f)(_Arg)) {
  return pointer_to_unary_function<_Arg, _Result>(__f);
}



}}
# 539 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/unary_negate.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/unary_negate.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {



template <class _Predicate>
class unary_negate
    : public __unary_function<typename _Predicate::argument_type, bool> {
  _Predicate __pred_;

public:
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit unary_negate(const _Predicate& __pred)
      : __pred_(__pred) {}
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
  operator()(const typename _Predicate::argument_type& __x) const {
    return !__pred_(__x);
  }
};

template <class _Predicate>
                            inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) unary_negate<_Predicate>
not1(const _Predicate& __pred) {
  return unary_negate<_Predicate>(__pred);
}



}}
# 543 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 2 3
# 549 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/functional" 3
# 2603 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/deque" 2 3
# 273 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 2 3
# 284 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 288 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Container = deque<_Tp> >
class queue;

template <class _Tp, class _Container>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const queue<_Tp, _Container>& __x, const queue<_Tp, _Container>& __y);

template <class _Tp, class _Container>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<(const queue<_Tp, _Container>& __x, const queue<_Tp, _Container>& __y);

template <class _Tp, class _Container >
class queue {
public:
  typedef _Container container_type;
  typedef typename container_type::value_type value_type;
  typedef typename container_type::reference reference;
  typedef typename container_type::const_reference const_reference;
  typedef typename container_type::size_type size_type;
  _Static_assert((is_same<_Tp, value_type>::value), "");

protected:
  container_type c;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) queue() : c() {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) queue(const queue& __q) : c(__q.c) {}
# 340 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) queue& operator=(const queue& __q) {
    c = __q.c;
    return *this;
  }
# 355 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit queue(const container_type& __c) : c(__c) {}



  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit queue(const _Alloc& __a,
                                       __enable_if_t<uses_allocator<container_type, _Alloc>::value>* = 0)
      : c(__a) {}
  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  queue(const queue& __q, const _Alloc& __a, __enable_if_t<uses_allocator<container_type, _Alloc>::value>* = 0)
      : c(__q.c, __a) {}
  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  queue(const container_type& __c, const _Alloc& __a, __enable_if_t<uses_allocator<container_type, _Alloc>::value>* = 0)
      : c(__c, __a) {}
# 383 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool empty() const { return c.empty(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type size() const { return c.size(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference front() { return c.front(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference front() const { return c.front(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference back() { return c.back(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference back() const { return c.back(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void push(const value_type& __v) { c.push_back(__v); }
# 420 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void pop() { c.pop_front(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(queue& __q) {
    using std::swap;
    swap(c, __q.c);
  }

                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _Container& __get_container() const { return c; }

  template <class _T1, class _OtherContainer>
  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
  operator==(const queue<_T1, _OtherContainer>& __x, const queue<_T1, _OtherContainer>& __y);

  template <class _T1, class _OtherContainer>
  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool
  operator<(const queue<_T1, _OtherContainer>& __x, const queue<_T1, _OtherContainer>& __y);
};
# 468 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3
template <class _Tp, class _Container>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const queue<_Tp, _Container>& __x, const queue<_Tp, _Container>& __y) {
  return __x.c == __y.c;
}

template <class _Tp, class _Container>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<(const queue<_Tp, _Container>& __x, const queue<_Tp, _Container>& __y) {
  return __x.c < __y.c;
}

template <class _Tp, class _Container>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const queue<_Tp, _Container>& __x, const queue<_Tp, _Container>& __y) {
  return !(__x == __y);
}

template <class _Tp, class _Container>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>(const queue<_Tp, _Container>& __x, const queue<_Tp, _Container>& __y) {
  return __y < __x;
}

template <class _Tp, class _Container>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>=(const queue<_Tp, _Container>& __x, const queue<_Tp, _Container>& __y) {
  return !(__x < __y);
}

template <class _Tp, class _Container>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<=(const queue<_Tp, _Container>& __x, const queue<_Tp, _Container>& __y) {
  return !(__y < __x);
}
# 509 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3
template <class _Tp, class _Container, __enable_if_t<__is_swappable<_Container>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(queue<_Tp, _Container>& __x, queue<_Tp, _Container>& __y)
                                          {
  __x.swap(__y);
}

template <class _Tp, class _Container, class _Alloc>
struct uses_allocator<queue<_Tp, _Container>, _Alloc> : public uses_allocator<_Container, _Alloc> {
};

template <class _Tp, class _Container = vector<_Tp>, class _Compare = less<typename _Container::value_type> >
class priority_queue {
public:
  typedef _Container container_type;
  typedef _Compare value_compare;
  typedef typename container_type::value_type value_type;
  typedef typename container_type::reference reference;
  typedef typename container_type::const_reference const_reference;
  typedef typename container_type::size_type size_type;
  _Static_assert((is_same<_Tp, value_type>::value), "");

protected:
  container_type c;
  value_compare comp;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) priority_queue()

      : c(), comp() {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) priority_queue(const priority_queue& __q) : c(__q.c), comp(__q.comp) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) priority_queue& operator=(const priority_queue& __q) {
    c = __q.c;
    comp = __q.comp;
    return *this;
  }
# 560 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit priority_queue(const value_compare& __comp) : c(), comp(__comp) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) priority_queue(const value_compare& __comp, const container_type& __c);



  template <class _InputIter, class = __enable_if_t<__has_input_iterator_category<_InputIter>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) priority_queue(_InputIter __f, _InputIter __l, const value_compare& __comp = value_compare());
  template <class _InputIter, class = __enable_if_t<__has_input_iterator_category<_InputIter>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  priority_queue(_InputIter __f, _InputIter __l, const value_compare& __comp, const container_type& __c);
# 584 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3
  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit priority_queue(const _Alloc& __a,
                                                __enable_if_t<uses_allocator<container_type, _Alloc>::value>* = 0);
  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  priority_queue(const value_compare& __comp,
                 const _Alloc& __a,
                 __enable_if_t<uses_allocator<container_type, _Alloc>::value>* = 0);
  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  priority_queue(const value_compare& __comp,
                 const container_type& __c,
                 const _Alloc& __a,
                 __enable_if_t<uses_allocator<container_type, _Alloc>::value>* = 0);
  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) priority_queue(
      const priority_queue& __q, const _Alloc& __a, __enable_if_t<uses_allocator<container_type, _Alloc>::value>* = 0);
# 613 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3
  template <class _InputIter, class _Alloc, class = __enable_if_t<__has_input_iterator_category<_InputIter>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  priority_queue(_InputIter __f,
                 _InputIter __l,
                 const _Alloc& __a,
                 __enable_if_t<uses_allocator<container_type, _Alloc>::value>* = 0);

  template <class _InputIter, class _Alloc, class = __enable_if_t<__has_input_iterator_category<_InputIter>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) priority_queue(
      _InputIter __f,
      _InputIter __l,
      const value_compare& __comp,
      const _Alloc& __a,
      __enable_if_t<uses_allocator<container_type, _Alloc>::value>* = 0);

  template <class _InputIter, class _Alloc, class = __enable_if_t<__has_input_iterator_category<_InputIter>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) priority_queue(
      _InputIter __f,
      _InputIter __l,
      const value_compare& __comp,
      const container_type& __c,
      const _Alloc& __a,
      __enable_if_t<uses_allocator<container_type, _Alloc>::value>* = 0);
# 668 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool empty() const { return c.empty(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type size() const { return c.size(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference top() const { return c.front(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void push(const value_type& __v);
# 692 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void pop();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(priority_queue& __q)
                                                                                                              ;

                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _Container& __get_container() const { return c; }
};
# 778 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3
template <class _Tp, class _Container, class _Compare>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(const _Compare& __comp, const container_type& __c)
    : c(__c), comp(__comp) {
  std::make_heap(c.begin(), c.end(), comp);
}
# 794 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3
template <class _Tp, class _Container, class _Compare>
template <class _InputIter, class>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(
    _InputIter __f, _InputIter __l, const value_compare& __comp)
    : c(__f, __l), comp(__comp) {
  std::make_heap(c.begin(), c.end(), comp);
}

template <class _Tp, class _Container, class _Compare>
template <class _InputIter, class>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(
    _InputIter __f, _InputIter __l, const value_compare& __comp, const container_type& __c)
    : c(__c), comp(__comp) {
  c.insert(c.end(), __f, __l);
  std::make_heap(c.begin(), c.end(), comp);
}
# 824 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3
template <class _Tp, class _Container, class _Compare>
template <class _Alloc>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(
    const _Alloc& __a, __enable_if_t<uses_allocator<container_type, _Alloc>::value>*)
    : c(__a) {}

template <class _Tp, class _Container, class _Compare>
template <class _Alloc>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(
    const value_compare& __comp, const _Alloc& __a, __enable_if_t<uses_allocator<container_type, _Alloc>::value>*)
    : c(__a), comp(__comp) {}

template <class _Tp, class _Container, class _Compare>
template <class _Alloc>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(
    const value_compare& __comp,
    const container_type& __c,
    const _Alloc& __a,
    __enable_if_t<uses_allocator<container_type, _Alloc>::value>*)
    : c(__c, __a), comp(__comp) {
  std::make_heap(c.begin(), c.end(), comp);
}

template <class _Tp, class _Container, class _Compare>
template <class _Alloc>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(
    const priority_queue& __q, const _Alloc& __a, __enable_if_t<uses_allocator<container_type, _Alloc>::value>*)
    : c(__q.c, __a), comp(__q.comp) {}
# 874 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3
template <class _Tp, class _Container, class _Compare>
template <class _InputIter, class _Alloc, class>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(
    _InputIter __f, _InputIter __l, const _Alloc& __a, __enable_if_t<uses_allocator<container_type, _Alloc>::value>*)
    : c(__f, __l, __a), comp() {
  std::make_heap(c.begin(), c.end(), comp);
}

template <class _Tp, class _Container, class _Compare>
template <class _InputIter, class _Alloc, class>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(
    _InputIter __f,
    _InputIter __l,
    const value_compare& __comp,
    const _Alloc& __a,
    __enable_if_t<uses_allocator<container_type, _Alloc>::value>*)
    : c(__f, __l, __a), comp(__comp) {
  std::make_heap(c.begin(), c.end(), comp);
}

template <class _Tp, class _Container, class _Compare>
template <class _InputIter, class _Alloc, class>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(
    _InputIter __f,
    _InputIter __l,
    const value_compare& __comp,
    const container_type& __c,
    const _Alloc& __a,
    __enable_if_t<uses_allocator<container_type, _Alloc>::value>*)
    : c(__c, __a), comp(__comp) {
  c.insert(c.end(), __f, __l);
  std::make_heap(c.begin(), c.end(), comp);
}
# 924 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3
template <class _Tp, class _Container, class _Compare>
inline void priority_queue<_Tp, _Container, _Compare>::push(const value_type& __v) {
  c.push_back(__v);
  std::push_heap(c.begin(), c.end(), comp);
}
# 947 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/queue" 3
template <class _Tp, class _Container, class _Compare>
inline void priority_queue<_Tp, _Container, _Compare>::pop() {
  std::pop_heap(c.begin(), c.end(), comp);
  c.pop_back();
}

template <class _Tp, class _Container, class _Compare>
inline void priority_queue<_Tp, _Container, _Compare>::swap(priority_queue& __q)
                                                                                                             {
  using std::swap;
  swap(c, __q.c);
  swap(comp, __q.comp);
}

template <class _Tp,
          class _Container,
          class _Compare,
          __enable_if_t<__is_swappable<_Container>::value && __is_swappable<_Compare>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void
swap(priority_queue<_Tp, _Container, _Compare>& __x, priority_queue<_Tp, _Container, _Compare>& __y)
                                          {
  __x.swap(__y);
}

template <class _Tp, class _Container, class _Compare, class _Alloc>
struct uses_allocator<priority_queue<_Tp, _Container, _Compare>, _Alloc>
    : public uses_allocator<_Container, _Alloc> {};

}}
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/container_adaptor.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stack" 1 3
# 139 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stack" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 143 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stack" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _Container = deque<_Tp> >
class stack;

template <class _Tp, class _Container>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y);

template <class _Tp, class _Container>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y);

template <class _Tp, class _Container >
class stack {
public:
  typedef _Container container_type;
  typedef typename container_type::value_type value_type;
  typedef typename container_type::reference reference;
  typedef typename container_type::const_reference const_reference;
  typedef typename container_type::size_type size_type;
  _Static_assert((is_same<_Tp, value_type>::value), "");

protected:
  container_type c;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) stack() : c() {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) stack(const stack& __q) : c(__q.c) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) stack& operator=(const stack& __q) {
    c = __q.c;
    return *this;
  }
# 190 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stack" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit stack(const container_type& __c) : c(__c) {}

  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit stack(const _Alloc& __a,
                                       __enable_if_t<uses_allocator<container_type, _Alloc>::value>* = 0)
      : c(__a) {}
  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  stack(const container_type& __c, const _Alloc& __a, __enable_if_t<uses_allocator<container_type, _Alloc>::value>* = 0)
      : c(__c, __a) {}
  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100")))
  stack(const stack& __s, const _Alloc& __a, __enable_if_t<uses_allocator<container_type, _Alloc>::value>* = 0)
      : c(__s.c, __a) {}
# 237 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stack" 3
                                __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool empty() const { return c.empty(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) size_type size() const { return c.size(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) reference top() { return c.back(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const_reference top() const { return c.back(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void push(const value_type& __v) { c.push_back(__v); }
# 272 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stack" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void pop() { c.pop_back(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(stack& __s) {
    using std::swap;
    swap(c, __s.c);
  }

                    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) const _Container& __get_container() const { return c; }

  template <class _T1, class _OtherContainer>
  friend bool operator==(const stack<_T1, _OtherContainer>& __x, const stack<_T1, _OtherContainer>& __y);

  template <class _T1, class _OtherContainer>
  friend bool operator<(const stack<_T1, _OtherContainer>& __x, const stack<_T1, _OtherContainer>& __y);
};
# 319 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stack" 3
template <class _Tp, class _Container>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator==(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y) {
  return __x.c == __y.c;
}

template <class _Tp, class _Container>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y) {
  return __x.c < __y.c;
}

template <class _Tp, class _Container>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator!=(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y) {
  return !(__x == __y);
}

template <class _Tp, class _Container>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y) {
  return __y < __x;
}

template <class _Tp, class _Container>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator>=(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y) {
  return !(__x < __y);
}

template <class _Tp, class _Container>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) bool operator<=(const stack<_Tp, _Container>& __x, const stack<_Tp, _Container>& __y) {
  return !(__y < __x);
}
# 360 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stack" 3
template <class _Tp, class _Container, __enable_if_t<__is_swappable<_Container>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(stack<_Tp, _Container>& __x, stack<_Tp, _Container>& __y)
                                          {
  __x.swap(__y);
}

template <class _Tp, class _Container, class _Alloc>
struct uses_allocator<stack<_Tp, _Container>, _Alloc> : public uses_allocator<_Container, _Alloc> {
};

}}
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/container_adaptor.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/container_adaptor.h" 3
}}
# 196 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/format" 2 3






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_functions.h" 1 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_functions.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_char.h" 1 3
# 22 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_char.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/write_escaped.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/write_escaped.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/escaped_output_table.h" 1 3
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/escaped_output_table.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 1038 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/escaped_output_table.h" 3
}}
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/write_escaped.h" 2 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/write_escaped.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/write_escaped.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

namespace __formatter {
# 220 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/write_escaped.h" 3
}

}}
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_char.h" 2 3
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_char.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 92 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_char.h" 3
}}
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_functions.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_floating_point.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_floating_point.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/chars_format.h" 1 3
# 18 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/chars_format.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/chars_format.h" 3
}}
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_floating_point.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_floating_point.h" 1 3
# 20 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_floating_point.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 54 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__charconv/to_chars_floating_point.h" 3
}}
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_floating_point.h" 2 3
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_floating_point.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_floating_point.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 778 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_floating_point.h" 3
}}
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_functions.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_integer.h" 1 3
# 27 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_integer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 94 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_integer.h" 3
}}
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_functions.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_pointer.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_pointer.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_pointer.h" 3
}}
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_functions.h" 2 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_string.h" 1 3
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_string.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 149 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_string.h" 3
}}
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_functions.h" 2 3
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_functions.h" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 53 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_functions.h" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 678 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/format_functions.h" 3
}}
# 203 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/format" 2 3
# 214 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/format" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_tuple.h" 1 3
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_tuple.h" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 148 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__format/formatter_tuple.h" 3
}}
# 215 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/format" 2 3
# 223 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/format" 3
# 190 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ostream" 2 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/print" 1 3
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/print" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/print" 3
__attribute__((__visibility__("default"))) bool __is_posix_terminal(FILE* __stream);
# 391 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/print" 3
}}
# 194 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ostream" 2 3
# 200 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ostream" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 204 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ostream" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT, class _Traits>
class basic_ostream : virtual public basic_ios<_CharT, _Traits> {
public:

  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::pos_type pos_type;
  typedef typename traits_type::off_type off_type;


  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb) {
    this->init(__sb);
  }
  ~basic_ostream() override;

protected:
  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream(basic_ostream&& __rhs);


  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream& operator=(basic_ostream&& __rhs);

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(basic_ostream& __rhs) {
    basic_ios<char_type, traits_type>::swap(__rhs);
  }

  basic_ostream(const basic_ostream& __rhs) = delete;
  basic_ostream& operator=(const basic_ostream& __rhs) = delete;

public:

  class sentry;


  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&)) {
    return __pf(*this);
  }

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream&
  operator<<(basic_ios<char_type, traits_type>& (*__pf)(basic_ios<char_type, traits_type>&)) {
    __pf(*this);
    return *this;
  }

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream& operator<<(ios_base& (*__pf)(ios_base&)) {
    __pf(*this);
    return *this;
  }

  basic_ostream& operator<<(bool __n);
  basic_ostream& operator<<(short __n);
  basic_ostream& operator<<(unsigned short __n);
  basic_ostream& operator<<(int __n);
  basic_ostream& operator<<(unsigned int __n);
  basic_ostream& operator<<(long __n);
  basic_ostream& operator<<(unsigned long __n);
  basic_ostream& operator<<(long long __n);
  basic_ostream& operator<<(unsigned long long __n);
  basic_ostream& operator<<(float __f);
  basic_ostream& operator<<(double __f);
  basic_ostream& operator<<(long double __f);
  basic_ostream& operator<<(const void* __p);







  basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);
# 285 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ostream" 3
  basic_ostream& put(char_type __c);
  basic_ostream& write(const char_type* __s, streamsize __n);
  basic_ostream& flush();


  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) pos_type tellp();
  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream& seekp(pos_type __pos);
  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream() {}
};

template <class _CharT, class _Traits>
class basic_ostream<_CharT, _Traits>::sentry {
  bool __ok_;
  basic_ostream<_CharT, _Traits>& __os_;

public:
  explicit sentry(basic_ostream<_CharT, _Traits>& __os);
  ~sentry();
  sentry(const sentry&) = delete;
  sentry& operator=(const sentry&) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit operator bool() const { return __ok_; }
};

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os) : __ok_(false), __os_(__os) {
  if (__os.good()) {
    if (__os.tie())
      __os.tie()->flush();
    __ok_ = true;
  }
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::~sentry() {
  if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf) && !uncaught_exception()) {

    try {

      if (__os_.rdbuf()->pubsync() == -1)
        __os_.setstate(ios_base::badbit);

    } catch (...) {
    }

  }
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream&& __rhs) {
  this->move(__rhs);
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator=(basic_ostream&& __rhs) {
  swap(__rhs);
  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::~basic_ostream() {}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb) {

  try {

    sentry __s(*this);
    if (__s) {
      if (__sb) {

        try {

          typedef istreambuf_iterator<_CharT, _Traits> _Ip;
          typedef ostreambuf_iterator<_CharT, _Traits> _Op;
          _Ip __i(__sb);
          _Ip __eof;
          _Op __o(*this);
          size_t __c = 0;
          for (; __i != __eof; ++__i, ++__o, ++__c) {
            *__o = *__i;
            if (__o.failed())
              break;
          }
          if (__c == 0)
            this->setstate(ios_base::failbit);

        } catch (...) {
          this->__set_failbit_and_consider_rethrow();
        }

      } else
        this->setstate(ios_base::badbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(bool __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
      const _Fp& __f = std::use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), __n).failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(short __n) {

  try {

    sentry __s(*this);
    if (__s) {
      ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
      const _Fp& __f = std::use_facet<_Fp>(this->getloc());
      if (__f.put(*this,
                  *this,
                  this->fill(),
                  __flags == ios_base::oct || __flags == ios_base::hex
                      ? static_cast<long>(static_cast<unsigned short>(__n))
                      : static_cast<long>(__n))
              .failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(unsigned short __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
      const _Fp& __f = std::use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(int __n) {

  try {

    sentry __s(*this);
    if (__s) {
      ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
      const _Fp& __f = std::use_facet<_Fp>(this->getloc());
      if (__f.put(*this,
                  *this,
                  this->fill(),
                  __flags == ios_base::oct || __flags == ios_base::hex
                      ? static_cast<long>(static_cast<unsigned int>(__n))
                      : static_cast<long>(__n))
              .failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(unsigned int __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
      const _Fp& __f = std::use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(long __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
      const _Fp& __f = std::use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), __n).failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(unsigned long __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
      const _Fp& __f = std::use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), __n).failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(long long __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
      const _Fp& __f = std::use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), __n).failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
      const _Fp& __f = std::use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), __n).failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(float __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
      const _Fp& __f = std::use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(double __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
      const _Fp& __f = std::use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), __n).failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(long double __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
      const _Fp& __f = std::use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), __n).failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(const void* __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;
      const _Fp& __f = std::use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), __n).failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<_CharT, _Traits>&
__put_character_sequence(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str, size_t __len) {

  try {

    typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
    if (__s) {
      typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
      if (std::__pad_and_output(
              _Ip(__os),
              __str,
              (__os.flags() & ios_base::adjustfield) == ios_base::left ? __str + __len : __str,
              __str + __len,
              __os,
              __os.fill())
              .failed())
        __os.setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    __os.__set_badbit_and_consider_rethrow();
  }

  return __os;
}

template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c) {
  return std::__put_character_sequence(__os, &__c, 1);
}

template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __os, char __cn) {

  try {

    typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
    if (__s) {
      _CharT __c = __os.widen(__cn);
      typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
      if (std::__pad_and_output(
              _Ip(__os),
              &__c,
              (__os.flags() & ios_base::adjustfield) == ios_base::left ? &__c + 1 : &__c,
              &__c + 1,
              __os,
              __os.fill())
              .failed())
        __os.setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    __os.__set_badbit_and_consider_rethrow();
  }

  return __os;
}

template <class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& __os, char __c) {
  return std::__put_character_sequence(__os, &__c, 1);
}

template <class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& __os, signed char __c) {
  return std::__put_character_sequence(__os, (char*)&__c, 1);
}

template <class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& __os, unsigned char __c) {
  return std::__put_character_sequence(__os, (char*)&__c, 1);
}

template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str) {
  return std::__put_character_sequence(__os, __str, _Traits::length(__str));
}

template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn) {

  try {

    typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
    if (__s) {
      typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
      size_t __len = char_traits<char>::length(__strn);
      const int __bs = 100;
      _CharT __wbb[__bs];
      _CharT* __wb = __wbb;
      unique_ptr<_CharT, void (*)(void*)> __h(0, free);
      if (__len > __bs) {
        __wb = (_CharT*)malloc(__len * sizeof(_CharT));
        if (__wb == 0)
          __throw_bad_alloc();
        __h.reset(__wb);
      }
      for (_CharT* __p = __wb; *__strn != '\0'; ++__strn, ++__p)
        *__p = __os.widen(*__strn);
      if (std::__pad_and_output(
              _Ip(__os),
              __wb,
              (__os.flags() & ios_base::adjustfield) == ios_base::left ? __wb + __len : __wb,
              __wb + __len,
              __os,
              __os.fill())
              .failed())
        __os.setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    __os.__set_badbit_and_consider_rethrow();
  }

  return __os;
}

template <class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& __os, const char* __str) {
  return std::__put_character_sequence(__os, __str, _Traits::length(__str));
}

template <class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const signed char* __str) {
  const char* __s = (const char*)__str;
  return std::__put_character_sequence(__os, __s, _Traits::length(__s));
}

template <class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str) {
  const char* __s = (const char*)__str;
  return std::__put_character_sequence(__os, __s, _Traits::length(__s));
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::put(char_type __c) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef ostreambuf_iterator<_CharT, _Traits> _Op;
      _Op __o(*this);
      *__o = __c;
      if (__o.failed())
        this->setstate(ios_base::badbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n) {

  try {

    sentry __sen(*this);
    if (__sen && __n) {
      if (this->rdbuf()->sputn(__s, __n) != __n)
        this->setstate(ios_base::badbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::flush() {

  try {

    if (this->rdbuf()) {
      sentry __s(*this);
      if (__s) {
        if (this->rdbuf()->pubsync() == -1)
          this->setstate(ios_base::badbit);
      }
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
typename basic_ostream<_CharT, _Traits>::pos_type basic_ostream<_CharT, _Traits>::tellp() {
  if (this->fail())
    return pos_type(-1);
  return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::seekp(pos_type __pos) {
  sentry __s(*this);
  if (!this->fail()) {
    if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))
      this->setstate(ios_base::failbit);
  }
  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir) {
  sentry __s(*this);
  if (!this->fail()) {
    if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))
      this->setstate(ios_base::failbit);
  }
  return *this;
}

template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline basic_ostream<_CharT, _Traits>& endl(basic_ostream<_CharT, _Traits>& __os) {
  __os.put(__os.widen('\n'));
  __os.flush();
  return __os;
}

template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline basic_ostream<_CharT, _Traits>& ends(basic_ostream<_CharT, _Traits>& __os) {
  __os.put(_CharT());
  return __os;
}

template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) inline basic_ostream<_CharT, _Traits>& flush(basic_ostream<_CharT, _Traits>& __os) {
  __os.flush();
  return __os;
}

template <class _Stream, class _Tp, class = void>
struct __is_ostreamable : false_type {};

template <class _Stream, class _Tp>
struct __is_ostreamable<_Stream, _Tp, __decltype(std::declval<_Stream>() << std::declval<_Tp>(), void())> : true_type {};

template <class _Stream,
          class _Tp,
          __enable_if_t<_And<is_base_of<ios_base, _Stream>, __is_ostreamable<_Stream&, const _Tp&> >::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Stream&& operator<<(_Stream&& __os, const _Tp& __x) {
  __os << __x;
  return std::move(__os);
}

template <class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const basic_string<_CharT, _Traits, _Allocator>& __str) {
  return std::__put_character_sequence(__os, __str.data(), __str.size());
}

template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, basic_string_view<_CharT, _Traits> __sv) {
  return std::__put_character_sequence(__os, __sv.data(), __sv.size());
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec) {
  return __os << __ec.category().name() << ':' << __ec.value();
}

template <class _CharT, class _Traits, class _Yp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p) {
  return __os << __p.get();
}

template <
    class _CharT,
    class _Traits,
    class _Yp,
    class _Dp,
    __enable_if_t<is_same<void,
                          __void_t<__decltype((std::declval<basic_ostream<_CharT, _Traits>&>() << std::declval<typename unique_ptr<_Yp, _Dp>::pointer>()))> >::value,

                  int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, unique_ptr<_Yp, _Dp> const& __p) {
  return __os << __p.get();
}

template <class _CharT, class _Traits, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x) {
  return __os << __x.template to_string<_CharT, _Traits>(std::use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),
                                                         std::use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));
}
# 1019 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ostream" 3
extern template class __attribute__((__visibility__("default"))) basic_ostream<char>;

extern template class __attribute__((__visibility__("default"))) basic_ostream<wchar_t>;
# 1173 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/ostream" 3
}}
# 171 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/istream" 2 3
# 175 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/istream" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 179 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/istream" 2 3

namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT, class _Traits>
class basic_istream : virtual public basic_ios<_CharT, _Traits> {
  streamsize __gc_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void __inc_gcount() {
    if (__gc_ < numeric_limits<streamsize>::max())
      ++__gc_;
  }

public:

  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::pos_type pos_type;
  typedef typename traits_type::off_type off_type;


  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit basic_istream(basic_streambuf<char_type, traits_type>* __sb)
      : __gc_(0) {
    this->init(__sb);
  }
  ~basic_istream() override;

protected:
  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream(basic_istream&& __rhs);


  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream& operator=(basic_istream&& __rhs);

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(basic_istream& __rhs) {
    std::swap(__gc_, __rhs.__gc_);
    basic_ios<char_type, traits_type>::swap(__rhs);
  }

  basic_istream(const basic_istream& __rhs) = delete;
  basic_istream& operator=(const basic_istream& __rhs) = delete;

public:

  class sentry;


  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream& operator>>(basic_istream& (*__pf)(basic_istream&)) {
    return __pf(*this);
  }

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream&
  operator>>(basic_ios<char_type, traits_type>& (*__pf)(basic_ios<char_type, traits_type>&)) {
    __pf(*this);
    return *this;
  }

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream& operator>>(ios_base& (*__pf)(ios_base&)) {
    __pf(*this);
    return *this;
  }

  basic_istream& operator>>(basic_streambuf<char_type, traits_type>* __sb);
  basic_istream& operator>>(bool& __n);
  basic_istream& operator>>(short& __n);
  basic_istream& operator>>(unsigned short& __n);
  basic_istream& operator>>(int& __n);
  basic_istream& operator>>(unsigned int& __n);
  basic_istream& operator>>(long& __n);
  basic_istream& operator>>(unsigned long& __n);
  basic_istream& operator>>(long long& __n);
  basic_istream& operator>>(unsigned long long& __n);
  basic_istream& operator>>(float& __f);
  basic_istream& operator>>(double& __f);
  basic_istream& operator>>(long double& __f);
  basic_istream& operator>>(void*& __p);


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) streamsize gcount() const { return __gc_; }
  int_type get();

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream& get(char_type& __c) {
    int_type __ch = get();
    if (__ch != traits_type::eof())
      __c = traits_type::to_char_type(__ch);
    return *this;
  }

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream& get(char_type* __s, streamsize __n) {
    return get(__s, __n, this->widen('\n'));
  }

  basic_istream& get(char_type* __s, streamsize __n, char_type __dlm);

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream& get(basic_streambuf<char_type, traits_type>& __sb) {
    return get(__sb, this->widen('\n'));
  }

  basic_istream& get(basic_streambuf<char_type, traits_type>& __sb, char_type __dlm);

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream& getline(char_type* __s, streamsize __n) {
    return getline(__s, __n, this->widen('\n'));
  }

  basic_istream& getline(char_type* __s, streamsize __n, char_type __dlm);

  basic_istream& ignore(streamsize __n = 1, int_type __dlm = traits_type::eof());
  int_type peek();
  basic_istream& read(char_type* __s, streamsize __n);
  streamsize readsome(char_type* __s, streamsize __n);

  basic_istream& putback(char_type __c);
  basic_istream& unget();
  int sync();

  pos_type tellg();
  basic_istream& seekg(pos_type __pos);
  basic_istream& seekg(off_type __off, ios_base::seekdir __dir);
};

template <class _CharT, class _Traits>
class basic_istream<_CharT, _Traits>::sentry {
  bool __ok_;

public:
  explicit sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit operator bool() const { return __ok_; }

  sentry(const sentry&) = delete;
  sentry& operator=(const sentry&) = delete;
};

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws) : __ok_(false) {
  if (__is.good()) {
    if (__is.tie())
      __is.tie()->flush();
    if (!__noskipws && (__is.flags() & ios_base::skipws)) {
      typedef istreambuf_iterator<_CharT, _Traits> _Ip;
      const ctype<_CharT>& __ct = std::use_facet<ctype<_CharT> >(__is.getloc());
      _Ip __i(__is);
      _Ip __eof;
      for (; __i != __eof; ++__i)
        if (!__ct.is(__ct.space, *__i))
          break;
      if (__i == __eof)
        __is.setstate(ios_base::failbit | ios_base::eofbit);
    }
    __ok_ = __is.good();
  } else
    __is.setstate(ios_base::failbit);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::basic_istream(basic_istream&& __rhs) : __gc_(__rhs.__gc_) {
  __rhs.__gc_ = 0;
  this->move(__rhs);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator=(basic_istream&& __rhs) {
  swap(__rhs);
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::~basic_istream() {}

template <class _Tp, class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<_CharT, _Traits>&
__input_arithmetic(basic_istream<_CharT, _Traits>& __is, _Tp& __n) {
  ios_base::iostate __state = ios_base::goodbit;
  typename basic_istream<_CharT, _Traits>::sentry __s(__is);
  if (__s) {

    try {

      typedef istreambuf_iterator<_CharT, _Traits> _Ip;
      typedef num_get<_CharT, _Ip> _Fp;
      std::use_facet<_Fp>(__is.getloc()).get(_Ip(__is), _Ip(), __is, __state, __n);

    } catch (...) {
      __state |= ios_base::badbit;
      __is.__setstate_nothrow(__state);
      if (__is.exceptions() & ios_base::badbit) {
        throw;
      }
    }

    __is.setstate(__state);
  }
  return __is;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(unsigned short& __n) {
  return std::__input_arithmetic<unsigned short>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(unsigned int& __n) {
  return std::__input_arithmetic<unsigned int>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(long& __n) {
  return std::__input_arithmetic<long>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(unsigned long& __n) {
  return std::__input_arithmetic<unsigned long>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(long long& __n) {
  return std::__input_arithmetic<long long>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(unsigned long long& __n) {
  return std::__input_arithmetic<unsigned long long>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(float& __n) {
  return std::__input_arithmetic<float>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(double& __n) {
  return std::__input_arithmetic<double>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(long double& __n) {
  return std::__input_arithmetic<long double>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(bool& __n) {
  return std::__input_arithmetic<bool>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(void*& __n) {
  return std::__input_arithmetic<void*>(*this, __n);
}

template <class _Tp, class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<_CharT, _Traits>&
__input_arithmetic_with_numeric_limits(basic_istream<_CharT, _Traits>& __is, _Tp& __n) {
  ios_base::iostate __state = ios_base::goodbit;
  typename basic_istream<_CharT, _Traits>::sentry __s(__is);
  if (__s) {

    try {

      typedef istreambuf_iterator<_CharT, _Traits> _Ip;
      typedef num_get<_CharT, _Ip> _Fp;
      long __temp;
      std::use_facet<_Fp>(__is.getloc()).get(_Ip(__is), _Ip(), __is, __state, __temp);
      if (__temp < numeric_limits<_Tp>::min()) {
        __state |= ios_base::failbit;
        __n = numeric_limits<_Tp>::min();
      } else if (__temp > numeric_limits<_Tp>::max()) {
        __state |= ios_base::failbit;
        __n = numeric_limits<_Tp>::max();
      } else {
        __n = static_cast<_Tp>(__temp);
      }

    } catch (...) {
      __state |= ios_base::badbit;
      __is.__setstate_nothrow(__state);
      if (__is.exceptions() & ios_base::badbit) {
        throw;
      }
    }

    __is.setstate(__state);
  }
  return __is;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(short& __n) {
  return std::__input_arithmetic_with_numeric_limits<short>(*this, __n);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>>(int& __n) {
  return std::__input_arithmetic_with_numeric_limits<int>(*this, __n);
}

template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<_CharT, _Traits>&
__input_c_string(basic_istream<_CharT, _Traits>& __is, _CharT* __p, size_t __n) {
  ios_base::iostate __state = ios_base::goodbit;
  typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
  if (__sen) {

    try {

      _CharT* __s = __p;
      const ctype<_CharT>& __ct = std::use_facet<ctype<_CharT> >(__is.getloc());
      while (__s != __p + (__n - 1)) {
        typename _Traits::int_type __i = __is.rdbuf()->sgetc();
        if (_Traits::eq_int_type(__i, _Traits::eof())) {
          __state |= ios_base::eofbit;
          break;
        }
        _CharT __ch = _Traits::to_char_type(__i);
        if (__ct.is(__ct.space, __ch))
          break;
        *__s++ = __ch;
        __is.rdbuf()->sbumpc();
      }
      *__s = _CharT();
      __is.width(0);
      if (__s == __p)
        __state |= ios_base::failbit;

    } catch (...) {
      __state |= ios_base::badbit;
      __is.__setstate_nothrow(__state);
      if (__is.exceptions() & ios_base::badbit) {
        throw;
      }
    }

    __is.setstate(__state);
  }
  return __is;
}
# 541 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/istream" 3
template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, _CharT* __s) {
  streamsize __n = __is.width();
  if (__n <= 0)
    __n = numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;
  return std::__input_c_string(__is, __s, size_t(__n));
}

template <class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, unsigned char* __s) {
  return __is >> (char*)__s;
}

template <class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, signed char* __s) {
  return __is >> (char*)__s;
}



template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<_CharT, _Traits>& operator>>(basic_istream<_CharT, _Traits>& __is, _CharT& __c) {
  ios_base::iostate __state = ios_base::goodbit;
  typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
  if (__sen) {

    try {

      typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
      if (_Traits::eq_int_type(__i, _Traits::eof()))
        __state |= ios_base::eofbit | ios_base::failbit;
      else
        __c = _Traits::to_char_type(__i);

    } catch (...) {
      __state |= ios_base::badbit;
      __is.__setstate_nothrow(__state);
      if (__is.exceptions() & ios_base::badbit) {
        throw;
      }
    }

    __is.setstate(__state);
  }
  return __is;
}

template <class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, unsigned char& __c) {
  return __is >> (char&)__c;
}

template <class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __is, signed char& __c) {
  return __is >> (char&)__c;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::operator>>(basic_streambuf<char_type, traits_type>* __sb) {
  ios_base::iostate __state = ios_base::goodbit;
  __gc_ = 0;
  sentry __s(*this, true);
  if (__s) {
    if (__sb) {

      try {

        while (true) {
          typename traits_type::int_type __i = this->rdbuf()->sgetc();
          if (traits_type::eq_int_type(__i, _Traits::eof())) {
            __state |= ios_base::eofbit;
            break;
          }
          if (traits_type::eq_int_type(__sb->sputc(traits_type::to_char_type(__i)), traits_type::eof()))
            break;
          __inc_gcount();
          this->rdbuf()->sbumpc();
        }
        if (__gc_ == 0)
          __state |= ios_base::failbit;

      } catch (...) {
        __state |= ios_base::badbit;
        if (__gc_ == 0)
          __state |= ios_base::failbit;

        this->__setstate_nothrow(__state);
        if (this->exceptions() & ios_base::failbit || this->exceptions() & ios_base::badbit) {
          throw;
        }
      }

    } else {
      __state |= ios_base::failbit;
    }
    this->setstate(__state);
  }
  return *this;
}

template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::get() {
  ios_base::iostate __state = ios_base::goodbit;
  __gc_ = 0;
  int_type __r = traits_type::eof();
  sentry __s(*this, true);
  if (__s) {

    try {

      __r = this->rdbuf()->sbumpc();
      if (traits_type::eq_int_type(__r, traits_type::eof()))
        __state |= ios_base::failbit | ios_base::eofbit;
      else
        __gc_ = 1;

    } catch (...) {
      this->__setstate_nothrow(this->rdstate() | ios_base::badbit);
      if (this->exceptions() & ios_base::badbit) {
        throw;
      }
    }

    this->setstate(__state);
  }
  return __r;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n, char_type __dlm) {
  ios_base::iostate __state = ios_base::goodbit;
  __gc_ = 0;
  sentry __sen(*this, true);
  if (__sen) {
    if (__n > 0) {

      try {

        while (__gc_ < __n - 1) {
          int_type __i = this->rdbuf()->sgetc();
          if (traits_type::eq_int_type(__i, traits_type::eof())) {
            __state |= ios_base::eofbit;
            break;
          }
          char_type __ch = traits_type::to_char_type(__i);
          if (traits_type::eq(__ch, __dlm))
            break;
          *__s++ = __ch;
          __inc_gcount();
          this->rdbuf()->sbumpc();
        }
        if (__gc_ == 0)
          __state |= ios_base::failbit;

      } catch (...) {
        __state |= ios_base::badbit;
        this->__setstate_nothrow(__state);
        if (this->exceptions() & ios_base::badbit) {
          if (__n > 0)
            *__s = char_type();
          throw;
        }
      }

    } else {
      __state |= ios_base::failbit;
    }

    if (__n > 0)
      *__s = char_type();
    this->setstate(__state);
  }
  if (__n > 0)
    *__s = char_type();
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb, char_type __dlm) {
  ios_base::iostate __state = ios_base::goodbit;
  __gc_ = 0;
  sentry __sen(*this, true);
  if (__sen) {

    try {

      while (true) {
        typename traits_type::int_type __i = this->rdbuf()->sgetc();
        if (traits_type::eq_int_type(__i, traits_type::eof())) {
          __state |= ios_base::eofbit;
          break;
        }
        char_type __ch = traits_type::to_char_type(__i);
        if (traits_type::eq(__ch, __dlm))
          break;
        if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))
          break;
        __inc_gcount();
        this->rdbuf()->sbumpc();
      }

    } catch (...) {
      __state |= ios_base::badbit;

    }

    if (__gc_ == 0)
      __state |= ios_base::failbit;
    this->setstate(__state);
  }
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n, char_type __dlm) {
  ios_base::iostate __state = ios_base::goodbit;
  __gc_ = 0;
  sentry __sen(*this, true);
  if (__sen) {

    try {

      while (true) {
        typename traits_type::int_type __i = this->rdbuf()->sgetc();
        if (traits_type::eq_int_type(__i, traits_type::eof())) {
          __state |= ios_base::eofbit;
          break;
        }
        char_type __ch = traits_type::to_char_type(__i);
        if (traits_type::eq(__ch, __dlm)) {
          this->rdbuf()->sbumpc();
          __inc_gcount();
          break;
        }
        if (__gc_ >= __n - 1) {
          __state |= ios_base::failbit;
          break;
        }
        *__s++ = __ch;
        this->rdbuf()->sbumpc();
        __inc_gcount();
      }

    } catch (...) {
      __state |= ios_base::badbit;
      this->__setstate_nothrow(__state);
      if (this->exceptions() & ios_base::badbit) {
        if (__n > 0)
          *__s = char_type();
        if (__gc_ == 0)
          __state |= ios_base::failbit;
        throw;
      }
    }

  }
  if (__n > 0)
    *__s = char_type();
  if (__gc_ == 0)
    __state |= ios_base::failbit;
  this->setstate(__state);
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __dlm) {
  ios_base::iostate __state = ios_base::goodbit;
  __gc_ = 0;
  sentry __sen(*this, true);
  if (__sen) {

    try {

      if (__n == numeric_limits<streamsize>::max()) {
        while (true) {
          typename traits_type::int_type __i = this->rdbuf()->sbumpc();
          if (traits_type::eq_int_type(__i, traits_type::eof())) {
            __state |= ios_base::eofbit;
            break;
          }
          __inc_gcount();
          if (traits_type::eq_int_type(__i, __dlm))
            break;
        }
      } else {
        while (__gc_ < __n) {
          typename traits_type::int_type __i = this->rdbuf()->sbumpc();
          if (traits_type::eq_int_type(__i, traits_type::eof())) {
            __state |= ios_base::eofbit;
            break;
          }
          __inc_gcount();
          if (traits_type::eq_int_type(__i, __dlm))
            break;
        }
      }

    } catch (...) {
      __state |= ios_base::badbit;
      this->__setstate_nothrow(__state);
      if (this->exceptions() & ios_base::badbit) {
        throw;
      }
    }

    this->setstate(__state);
  }
  return *this;
}

template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::peek() {
  ios_base::iostate __state = ios_base::goodbit;
  __gc_ = 0;
  int_type __r = traits_type::eof();
  sentry __sen(*this, true);
  if (__sen) {

    try {

      __r = this->rdbuf()->sgetc();
      if (traits_type::eq_int_type(__r, traits_type::eof()))
        __state |= ios_base::eofbit;

    } catch (...) {
      __state |= ios_base::badbit;
      this->__setstate_nothrow(__state);
      if (this->exceptions() & ios_base::badbit) {
        throw;
      }
    }

    this->setstate(__state);
  }
  return __r;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n) {
  ios_base::iostate __state = ios_base::goodbit;
  __gc_ = 0;
  sentry __sen(*this, true);
  if (__sen) {

    try {

      __gc_ = this->rdbuf()->sgetn(__s, __n);
      if (__gc_ != __n)
        __state |= ios_base::failbit | ios_base::eofbit;

    } catch (...) {
      __state |= ios_base::badbit;
      this->__setstate_nothrow(__state);
      if (this->exceptions() & ios_base::badbit) {
        throw;
      }
    }

  } else {
    __state |= ios_base::failbit;
  }
  this->setstate(__state);
  return *this;
}

template <class _CharT, class _Traits>
streamsize basic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __n) {
  ios_base::iostate __state = ios_base::goodbit;
  __gc_ = 0;
  sentry __sen(*this, true);
  if (__sen) {

    try {

      streamsize __c = this->rdbuf()->in_avail();
      switch (__c) {
      case -1:
        __state |= ios_base::eofbit;
        break;
      case 0:
        break;
      default:
        __n = std::min(__c, __n);
        __gc_ = this->rdbuf()->sgetn(__s, __n);
        if (__gc_ != __n)
          __state |= ios_base::failbit | ios_base::eofbit;
        break;
      }

    } catch (...) {
      __state |= ios_base::badbit;
      this->__setstate_nothrow(__state);
      if (this->exceptions() & ios_base::badbit) {
        throw;
      }
    }

  } else {
    __state |= ios_base::failbit;
  }
  this->setstate(__state);
  return __gc_;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::putback(char_type __c) {
  ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
  __gc_ = 0;
  this->clear(__state);
  sentry __sen(*this, true);
  if (__sen) {

    try {

      if (this->rdbuf() == __nullptr || this->rdbuf()->sputbackc(__c) == traits_type::eof())
        __state |= ios_base::badbit;

    } catch (...) {
      __state |= ios_base::badbit;
      this->__setstate_nothrow(__state);
      if (this->exceptions() & ios_base::badbit) {
        throw;
      }
    }

  } else {
    __state |= ios_base::failbit;
  }
  this->setstate(__state);
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::unget() {
  ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
  __gc_ = 0;
  this->clear(__state);
  sentry __sen(*this, true);
  if (__sen) {

    try {

      if (this->rdbuf() == __nullptr || this->rdbuf()->sungetc() == traits_type::eof())
        __state |= ios_base::badbit;

    } catch (...) {
      __state |= ios_base::badbit;
      this->__setstate_nothrow(__state);
      if (this->exceptions() & ios_base::badbit) {
        throw;
      }
    }

  } else {
    __state |= ios_base::failbit;
  }
  this->setstate(__state);
  return *this;
}

template <class _CharT, class _Traits>
int basic_istream<_CharT, _Traits>::sync() {
  ios_base::iostate __state = ios_base::goodbit;
  int __r = 0;
  sentry __sen(*this, true);
  if (__sen) {

    try {

      if (this->rdbuf() == __nullptr)
        return -1;
      if (this->rdbuf()->pubsync() == -1) {
        __state |= ios_base::badbit;
        return -1;
      }

    } catch (...) {
      __state |= ios_base::badbit;
      this->__setstate_nothrow(__state);
      if (this->exceptions() & ios_base::badbit) {
        throw;
      }
    }

    this->setstate(__state);
  }
  return __r;
}

template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::pos_type basic_istream<_CharT, _Traits>::tellg() {
  ios_base::iostate __state = ios_base::goodbit;
  pos_type __r(-1);
  sentry __sen(*this, true);
  if (__sen) {

    try {

      __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);

    } catch (...) {
      __state |= ios_base::badbit;
      this->__setstate_nothrow(__state);
      if (this->exceptions() & ios_base::badbit) {
        throw;
      }
    }

    this->setstate(__state);
  }
  return __r;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::seekg(pos_type __pos) {
  ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
  this->clear(__state);
  sentry __sen(*this, true);
  if (__sen) {

    try {

      if (this->rdbuf()->pubseekpos(__pos, ios_base::in) == pos_type(-1))
        __state |= ios_base::failbit;

    } catch (...) {
      __state |= ios_base::badbit;
      this->__setstate_nothrow(__state);
      if (this->exceptions() & ios_base::badbit) {
        throw;
      }
    }

    this->setstate(__state);
  }
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir) {
  ios_base::iostate __state = this->rdstate() & ~ios_base::eofbit;
  this->clear(__state);
  sentry __sen(*this, true);
  if (__sen) {

    try {

      if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::in) == pos_type(-1))
        __state |= ios_base::failbit;

    } catch (...) {
      __state |= ios_base::badbit;
      this->__setstate_nothrow(__state);
      if (this->exceptions() & ios_base::badbit) {
        throw;
      }
    }

    this->setstate(__state);
  }
  return *this;
}

template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<_CharT, _Traits>& ws(basic_istream<_CharT, _Traits>& __is) {
  ios_base::iostate __state = ios_base::goodbit;
  typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
  if (__sen) {

    try {

      const ctype<_CharT>& __ct = std::use_facet<ctype<_CharT> >(__is.getloc());
      while (true) {
        typename _Traits::int_type __i = __is.rdbuf()->sgetc();
        if (_Traits::eq_int_type(__i, _Traits::eof())) {
          __state |= ios_base::eofbit;
          break;
        }
        if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))
          break;
        __is.rdbuf()->sbumpc();
      }

    } catch (...) {
      __state |= ios_base::badbit;
      __is.__setstate_nothrow(__state);
      if (__is.exceptions() & ios_base::badbit) {
        throw;
      }
    }

    __is.setstate(__state);
  }
  return __is;
}

template <class _Stream, class _Tp, class = void>
struct __is_istreamable : false_type {};

template <class _Stream, class _Tp>
struct __is_istreamable<_Stream, _Tp, __decltype(std::declval<_Stream>() >> std::declval<_Tp>(), void())> : true_type {};

template <class _Stream,
          class _Tp,
          __enable_if_t< _And<is_base_of<ios_base, _Stream>, __is_istreamable<_Stream&, _Tp&&> >::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) _Stream&& operator>>(_Stream&& __is, _Tp&& __x) {
  __is >> std::forward<_Tp>(__x);
  return std::move(__is);
}

template <class _CharT, class _Traits>
class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits> {
public:

  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::pos_type pos_type;
  typedef typename traits_type::off_type off_type;


  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) explicit basic_iostream(basic_streambuf<char_type, traits_type>* __sb)
      : basic_istream<_CharT, _Traits>(__sb) {}

  ~basic_iostream() override;

protected:
  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_iostream(basic_iostream&& __rhs);


  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_iostream& operator=(basic_iostream&& __rhs);

  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) void swap(basic_iostream& __rhs) {
    basic_istream<char_type, traits_type>::swap(__rhs);
  }
};

template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::basic_iostream(basic_iostream&& __rhs)
    : basic_istream<_CharT, _Traits>(std::move(__rhs)) {}

template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>& basic_iostream<_CharT, _Traits>::operator=(basic_iostream&& __rhs) {
  swap(__rhs);
  return *this;
}

template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::~basic_iostream() {}

template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, basic_string<_CharT, _Traits, _Allocator>& __str) {
  ios_base::iostate __state = ios_base::goodbit;
  typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
  if (__sen) {

    try {

      __str.clear();
      streamsize __n = __is.width();
      if (__n <= 0)
        __n = __str.max_size();
      if (__n <= 0)
        __n = numeric_limits<streamsize>::max();
      streamsize __c = 0;
      const ctype<_CharT>& __ct = std::use_facet<ctype<_CharT> >(__is.getloc());
      while (__c < __n) {
        typename _Traits::int_type __i = __is.rdbuf()->sgetc();
        if (_Traits::eq_int_type(__i, _Traits::eof())) {
          __state |= ios_base::eofbit;
          break;
        }
        _CharT __ch = _Traits::to_char_type(__i);
        if (__ct.is(__ct.space, __ch))
          break;
        __str.push_back(__ch);
        ++__c;
        __is.rdbuf()->sbumpc();
      }
      __is.width(0);
      if (__c == 0)
        __state |= ios_base::failbit;

    } catch (...) {
      __state |= ios_base::badbit;
      __is.__setstate_nothrow(__state);
      if (__is.exceptions() & ios_base::badbit) {
        throw;
      }
    }

    __is.setstate(__state);
  }
  return __is;
}

template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is, basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm) {
  ios_base::iostate __state = ios_base::goodbit;
  typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
  if (__sen) {

    try {

      __str.clear();
      streamsize __extr = 0;
      while (true) {
        typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
        if (_Traits::eq_int_type(__i, _Traits::eof())) {
          __state |= ios_base::eofbit;
          break;
        }
        ++__extr;
        _CharT __ch = _Traits::to_char_type(__i);
        if (_Traits::eq(__ch, __dlm))
          break;
        __str.push_back(__ch);
        if (__str.size() == __str.max_size()) {
          __state |= ios_base::failbit;
          break;
        }
      }
      if (__extr == 0)
        __state |= ios_base::failbit;

    } catch (...) {
      __state |= ios_base::badbit;
      __is.__setstate_nothrow(__state);
      if (__is.exceptions() & ios_base::badbit) {
        throw;
      }
    }

    __is.setstate(__state);
  }
  return __is;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is, basic_string<_CharT, _Traits, _Allocator>& __str) {
  return std::getline(__is, __str, __is.widen('\n'));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is, basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm) {
  return std::getline(__is, __str, __dlm);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>&& __is, basic_string<_CharT, _Traits, _Allocator>& __str) {
  return std::getline(__is, __str, __is.widen('\n'));
}

template <class _CharT, class _Traits, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne180100"))) basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x) {
  ios_base::iostate __state = ios_base::goodbit;
  typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
  if (__sen) {

    try {

      basic_string<_CharT, _Traits> __str;
      const ctype<_CharT>& __ct = std::use_facet<ctype<_CharT> >(__is.getloc());
      size_t __c = 0;
      _CharT __zero = __ct.widen('0');
      _CharT __one = __ct.widen('1');
      while (__c != _Size) {
        typename _Traits::int_type __i = __is.rdbuf()->sgetc();
        if (_Traits::eq_int_type(__i, _Traits::eof())) {
          __state |= ios_base::eofbit;
          break;
        }
        _CharT __ch = _Traits::to_char_type(__i);
        if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))
          break;
        __str.push_back(__ch);
        ++__c;
        __is.rdbuf()->sbumpc();
      }
      __x = bitset<_Size>(__str);
      if (_Size > 0 && __c == 0)
        __state |= ios_base::failbit;

    } catch (...) {
      __state |= ios_base::badbit;
      __is.__setstate_nothrow(__state);
      if (__is.exceptions() & ios_base::badbit) {
        throw;
      }
    }

    __is.setstate(__state);
  }
  return __is;
}

extern template class __attribute__((__visibility__("default"))) basic_istream<char>;

extern template class __attribute__((__visibility__("default"))) basic_istream<wchar_t>;

extern template class __attribute__((__visibility__("default"))) basic_iostream<char>;

}}
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iostream" 2 3
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/iostream" 3


namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

extern __attribute__((__visibility__("default"))) istream cin;
extern __attribute__((__visibility__("default"))) ostream cout;
extern __attribute__((__visibility__("default"))) ostream cerr;
extern __attribute__((__visibility__("default"))) ostream clog;


extern __attribute__((__visibility__("default"))) wistream wcin;
extern __attribute__((__visibility__("default"))) wostream wcout;
extern __attribute__((__visibility__("default"))) wostream wcerr;
extern __attribute__((__visibility__("default"))) wostream wclog;


}}
# 3 "src/core/Application.cpp" 2

# 1 "src/core/InputManager.h" 1





class InputManager {
public:
    static void processKeyboard(GLFWwindow* window, class Player& player);
};
# 5 "src/core/Application.cpp" 2

Application::Application()
    : camera(glm::vec3(0.0f, 0.5f, 3.0f)), player(&camera) {
    window = WindowManager::createWindow(800, 600, "16BitCraft");
    if (!window) {
        std::cerr << "ERROR: Failed to create window!" << std::endl;
        exit(1);
    }
}

Application::~Application() {
    glfwTerminate();
}

void Application::run() {
    renderer.initialize();

    while (!glfwWindowShouldClose(window)) {
        InputManager::processKeyboard(window, player);
        player.update();
        renderer.render();

        glfwSwapBuffers(window);
        glfwPollEvents();
    }
}
